using Quokka.TCL.Tools;
namespace Quokka.TCL.Vivado
{
	public partial class VivadoTCLBuilder
	{
		/// <summary>
		/// Add breakpoint at a line of a HDL source
		///
		///
		/// TCL Syntax: add_bp [-quiet] [-verbose] <file_name> <line_number>
		///
		/// The add_bp command lets you add breakpoints to an HDL source file to pause the current
		/// simulation.
		/// A breakpoint is a user-determined stopping point in the source code used for debugging the
		/// design. When simulating a design with breakpoints, simulation of the design stops at each
		/// breakpoint to let you examine values and verify the design behavior.
		/// You can report breakpoints in the current simulation using the report_bps command, and
		/// remove existing breakpoints using the remove_bps command.
		/// This command returns a new breakpoint object if there is not already a breakpoint set at the
		/// specified file line, or returns an existing breakpoint object if there is already a breakpoint defined
		/// for the specified file and line number.
		/// TIP: You can capture the returned breakpoint object in a Tcl variable if needed.
		/// The add_bp command returns an error if the command fails.
		///
		/// The following example adds a the breakpoint to the HDL source file at the specified line number:
		/// add_bp C:/Data/ug937/sources/sinegen.vhd 137
		///
		/// See ug835-vivado-tcl-commands.pdf, page 31
		/// </summary>
		/// <param name="file_name">(Required) Filename to add the breakpoint</param>
		/// <param name="line_number">(Required) Line number of the given file to set the breakpoint</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>
		/// </returns>
		public virtual SimpleTCLCommand add_bp(string file_name, string line_number, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: add_bp [-quiet] [-verbose] <file_name> <line_number>
			return
				new SimpleTCLCommand("add_bp")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file_name)
					.RequiredString(line_number)
			;
		}
		/// <summary>
		/// Add cells to a Pblock
		///
		///
		/// TCL Syntax: add_cells_to_pblock [-top] [-add_primitives] [-clear_locs] [-quiet] [-verbose] <pblock> [<cells>...]
		///
		/// Adds specified logic instances to a Pblock in an open implemented design. Once cells have been
		/// added to a Pblock, you can place the Pblocks onto the fabric of the FPGA using the
		/// resize_pblock command. The resize_pblock command can also be used to manually
		/// move and resize Pblocks.
		/// You can remove instances from the Pblock using the remove_cells_from_pblock command.
		///
		/// The following example creates a Pblock called pb_cpuEngine, and then adds only the leaf-cells
		/// found in the cpuEngine module, clearing placement constraints for placed instances:
		/// create_pblock pb_cpuEngine
		/// add_cells_to_pblock pb_cpuEngine [get_cells cpuEngine/*] \
		/// -add_primitives -clear_locs
		///
		/// See ug835-vivado-tcl-commands.pdf, page 33
		/// </summary>
		/// <param name="pblock">(Required) Pblock to add cells to</param>
		/// <param name="top">
		/// (Optional)
		/// Add the top level instance; This option can't be used with -
		/// cells, or -add_primitives options. You must specify either -
		/// cells or -top option.
		/// </param>
		/// <param name="add_primitives">
		/// (Optional)
		/// Assign to the pblock only primitive cells from the specified
		/// list of cells.
		/// </param>
		/// <param name="clear_locs">(Optional) Clear instance location constraints</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="cells">
		/// (Optional)
		/// Cells to add. You can't use this option with -top option. You
		/// must specify either -cells or -top option.
		/// </param>
		public virtual SimpleTCLCommand add_cells_to_pblock(string pblock, bool? top = null, bool? add_primitives = null, bool? clear_locs = null, bool? quiet = null, bool? verbose = null, string cells = null)
		{
			// TCL Syntax: add_cells_to_pblock [-top] [-add_primitives] [-clear_locs] [-quiet] [-verbose] <pblock> [<cells>...]
			return
				new SimpleTCLCommand("add_cells_to_pblock")
					.Flag("top", top)
					.Flag("add_primitives", add_primitives)
					.Flag("clear_locs", clear_locs)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(pblock)
					.OptionalString(cells)
			;
		}
		/// <summary>
		/// Conditionally execute Tcl commands
		///
		///
		/// TCL Syntax: add_condition [-name <arg>] [-radix <arg>] [-notrace] [-quiet] [-verbose] <condition_expression> <commands>
		///
		/// Add a condition that is evaluated by a specified condition, <condition_expression>, and runs a
		/// series of simulation Tcl commands when the condition is TRUE.
		/// Conditions can be defined prior to starting the simulation. When a condition is added, the
		/// simulator evaluates the condition expression anytime a signal change is detected. When a
		/// specified condition expression becomes TRUE, the condition commands are run.
		/// The add_condition command returns a condition identifier for the added condition, or returns
		/// an error if the command fails.
		///
		/// The following example defines a condition named resetLow, that becomes true when the reset
		/// signal is low, and then puts a message to the standard output, and stops the current simulation:
		/// add_condition -name resetLow {/testbench/reset == 0 } {
		/// puts "Condition Reset was encountered at [current_time]. Stopping
		/// simulation."
		/// stop }
		/// This next example defines a Tcl procedure, called myProc, that uses the add_force command to
		/// define clk and reset signal values, and print a standard message when it completes. A
		/// condition is then added that calls myProc when reset is low:
		/// proc myProc {} {
		/// add_force clk {0 1} { 1 2} -repeat_every 4 -cancel_after 500
		/// add_force reset 1
		/// run 10 ns
		/// remove_force force2
		/// puts "Reached end of myProc"
		/// }
		/// add_condition -radix unsigned /top/reset==0 myproc
		///
		/// See ug835-vivado-tcl-commands.pdf, page 35
		/// </summary>
		/// <param name="condition_expression">(Required) The condition expression when true executes the given commands</param>
		/// <param name="commands">(Required) Commands to execute upon condition</param>
		/// <param name="name">
		/// (Optional)
		/// Assign a unique name (label) to a condition. Multiple
		/// conditions cannot be assigned the same name. If no name
		/// is specified, then a default label named as condition<id> is
		/// automatically created
		/// </param>
		/// <param name="radix">
		/// (Optional)
		/// Specifies which radix to use. Allowed values are: default,
		/// dec, bin, oct, hex, unsigned, ascii, smag.
		/// </param>
		/// <param name="notrace">(Optional) Turn off the logging of condition commands</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The condition object created</returns>
		public virtual SimpleTCLCommand add_condition(string condition_expression, string commands, string name = null, string radix = null, bool? notrace = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: add_condition [-name <arg>] [-radix <arg>] [-notrace] [-quiet] [-verbose] <condition_expression> <commands>
			return
				new SimpleTCLCommand("add_condition")
					.OptionalNamedString("name", name)
					.OptionalNamedString("radix", radix)
					.Flag("notrace", notrace)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(condition_expression)
					.RequiredString(commands)
			;
		}
		/// <summary>
		/// Add DRC rule check objects to a rule deck
		///
		///
		/// TCL Syntax: add_drc_checks [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] -ruledeck <arg> [-quiet] [-verbose] [<patterns>]
		///
		/// Add design rule checks to the specified drc_ruledeck object.
		/// A rule deck is a collection of design rule checks grouped for convenience, to be run with the
		/// report_drc command at different stages of the Xilinx design flow, such as during I/O planning
		/// or placement. The tool comes with a set of factory defined rule decks, but you can also create
		/// new user-defined rule decks with the create_drc_ruledeck command.
		/// Use the get_drc_ruledecks command to return a list of the currently defined rule decks
		/// available for use in the report_drc command.
		/// You can add standard factory defined rule checks to the rule deck, or add user-defined rule
		/// checks that were created using the create_drc_check command. Use the get_drc_checks
		/// command to get a list of checks that can be added to a rule deck.
		/// Checks can also be removed from a rule deck using the remove_drc_checks command.
		/// Note: To temporarily disable a specific DRC rule, use the set_property command to set the
		/// IS_ENABLED property for the rule to false. This will disable the rule from being run in report_drc,
		/// without having to remove the rule from the rule deck. Use reset_drc_check to restore the rule to its
		/// default setting.
		/// This command returns the list of design rule checks that were added to the rule deck.
		///
		/// The following example adds the rule checks matching the specified search pattern to the
		/// project_rules rule deck:
		/// add_drc_checks -ruledeck project_rules {*DCI* *BUF*}
		/// The following example creates a new rule deck called placer+, copies all of the rule checks from
		/// the placer_checks rule deck into the placer+ rule deck, then adds some additional checks:
		/// create_drc_ruledeck placer+
		/// add_drc_checks -of_objects [get_drc_ruledecks placer_checks] \
		/// -ruledeck placer+
		/// add_drc_checks -ruledeck placer+ *IO*
		/// The following example adds only the rule checks with a severity of Warning to the rule deck:
		/// add_drc_checks -filter {SEVERITY == Warning} -ruledeck warn_only
		///
		/// See ug835-vivado-tcl-commands.pdf, page 38
		/// </summary>
		/// <param name="ruledeck">(Required) DRC rule deck to modify</param>
		/// <param name="of_objects">(Optional) Get 'rule_check' objects of these types: 'drc_ruledeck'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'rule_check' objects against patterns. Default: *</param>
		/// <returns>drc_check</returns>
		public virtual SimpleTCLCommand add_drc_checks(string ruledeck, string of_objects = null, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: add_drc_checks [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] -ruledeck <arg> [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("add_drc_checks")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.RequiredNamedString("ruledeck", ruledeck)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Add sources to the active fileset
		///
		///
		/// TCL Syntax: add_files [-fileset <arg>] [-of_objects <args>] [-norecurse] [-copy_to <arg>] [-force] [-scan_for_includes] [-quiet] [-verbose] [<files>...]
		///
		/// Adds one or more source files, or the source file contents of one or more directories, to the
		/// specified fileset in the current project. Valid source files include HDL sources (VHDL, Verilog,
		/// SystemVerilog, and related header files), netlist sources (DCP, EDIF, and NGC), and memory
		/// interface files (BMM, MIF, MEM, ELF).
		/// IP and Block Design sources are not added through the add_files command. These are
		/// compound files that are supported by separate commands such as import_ip, read_bd, and
		/// read_ip.
		/// For every file added to a project the Vivado Design Suite attempts to store and maintain both a
		/// relative path and an absolute path to the file or directory. When a project is opened, these paths
		/// are used to locate the files and directories. By default the Vivado Design Suite applies a Relative
		/// First approach to resolving paths, searching the relative path first, then the absolute path. You
		/// can use the PATH_MODE property to change how the Vivado tool resolves file paths or
		/// properties for specific objects. For more information, see the Vivado Design Suite Properties
		/// Reference Guide (UG912).
		/// IMPORTANT! Adding multiple files one at a time can cause noticeable performance degradation. It is more
		/// efficient to use a single add_files command to import a list of files:
		/// add_files {file1 file2 file3 ... fileN}
		/// The Vivado tool does not read the contents of a file automatically when the file is added to the
		/// project with add_files, but rather reads the file contents when they are needed. For instance,
		/// a constraints file is not read when added to the design until needed by synthesis, timing, or
		/// implementation. To read the file at the time of adding it to the design, use the read_xxx
		/// command instead.
		/// TIP: When running the Vivado tool in Non-Project mode, in which there is no project file to maintain and
		/// manage the various project source files, you should use the read_xxx commands to read the contents of
		/// source files into the in-memory design. Refer to the Vivado Design Suite User Guide: Design Flows Overview
		/// (UG892) for more information on Non-Project mode.
		/// The add_files command adds them by reference to the specified fileset. This is different from
		/// the import_files command, which copies the file into the local project folders as well as
		/// adding them to the specified fileset.
		/// This command returns the files that were added, or returns an error if it fails.
		///
		/// The following example adds a file called rtl.v to the current project:
		/// add_files rtl.v
		/// In the preceding example the tool looks for the rtl.v file in the current working directory since no
		/// file path is specified, and the file is added to the source fileset as a default since no fileset is
		/// specified.
		/// The following example adds a file called top.xdc to the constrs_1 constraint fileset, as well
		/// as any appropriate source files found in the project_1 directory, and its subdirectories:
		/// add_files -fileset constrs_1 -quiet c:/Design/top.xdc c:/Design/project_1
		/// In addition, the tool ignores any command line errors because the -quiet argument was
		/// specified.
		/// If the -norecurse option had been specified then only constraint files found in the
		/// project_1 directory would have been added, but subdirectories would not be searched.
		/// The following example adds an existing IP core file to the current project:
		/// add_files -norecurse C:/Data/ip/c_addsub_v11_0_0.xci
		/// Note: Use the import_ip command to import the IP file into the local project folders.
		/// The following example reads a top-level design netlist, and the char_fifo IP in a Non-Project
		/// Mode design:
		/// # Read top-level EDIF and IP DCP
		/// read_edif ./sources/wave_gen.edif
		/// add_files ./my_IP/char_fifo/char_fifo.xci
		/// Note: Either add_files or read_ip can be used reading in an IP core. All output products of the IP,
		/// including a design checkpoint ( DCP), will be read as needed.
		/// The following example adds an existing DSP module, created in System Generator, into the
		/// current project:
		/// add_files C:/Data/model1.mdl
		/// Note: Use the create_sysgen command to use System Generator to create a new DSP module.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 42
		/// </summary>
		/// <param name="fileset">(Optional) Fileset name</param>
		/// <param name="of_objects">(Optional) Filesets or sub-designs or RMs to add the files to</param>
		/// <param name="norecurse">(Optional) Do not recursively search in specified directories</param>
		/// <param name="copy_to">(Optional) Copy the file to the specified directory before adding it to project</param>
		/// <param name="force">(Optional) Overwrite the existing file when -copy_to is used</param>
		/// <param name="scan_for_includes">(Optional) Scan and add any included files found in the fileset's RTL sources</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="files">
		/// (Optional)
		/// Name of the files and/or directories to add. Must be
		/// specified if -scan_for_includes is not used.
		/// </param>
		/// <returns>list of file objects that were added</returns>
		public virtual SimpleTCLCommand add_files(string fileset = null, string of_objects = null, bool? norecurse = null, string copy_to = null, bool? force = null, bool? scan_for_includes = null, bool? quiet = null, bool? verbose = null, string files = null)
		{
			// TCL Syntax: add_files [-fileset <arg>] [-of_objects <args>] [-norecurse] [-copy_to <arg>] [-force] [-scan_for_includes] [-quiet] [-verbose] [<files>...]
			return
				new SimpleTCLCommand("add_files")
					.OptionalNamedString("fileset", fileset)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("norecurse", norecurse)
					.OptionalNamedString("copy_to", copy_to)
					.Flag("force", force)
					.Flag("scan_for_includes", scan_for_includes)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(files)
			;
		}
		/// <summary>
		/// Force value of signal, wire, or reg to a specified value
		///
		///
		/// TCL Syntax: add_force [-radix <arg>] [-repeat_every <arg>] [-cancel_after <arg>] [-quiet] [-verbose] <hdl_object> <values>...
		///
		/// Force the value of a signal, wire, or reg to a certain value during simulation.
		/// The add_force command has the same effect as the Verilog force/release commands in
		/// the test bench or the module definition. It forces an HDL object to hold the specified value for
		/// the specified time, or until released by the -cancel_after option, or the remove_forces
		/// command.
		/// IMPORTANT! If there are Verilog force/release statements on an HDL object in the test bench or
		/// module, these commands are overridden by the Tcl add_force command. When the Tcl force expires or is
		/// released, the HDL object resumes normal operation in the simulation, including the application of any Verilog
		/// forces.
		/// This command returns the name of the force object created, or returns an error if the command
		/// failed. The name of the returned force object is important when using the remove_forces
		/// command, and should be captured in a Tcl variable for later recall, as shown in the examples.
		///
		/// The following example forces the reset signal high at 300 nanoseconds, using the default radix,
		/// and captures the name of the returned force object in a Tcl variable which can be used to later
		/// remove the force:
		/// set for10 [ add_force reset 1 300 ]
		/// The following example shows the use of {<value> <time>} pairs, repeated periodically, and
		/// canceled after a specified time.
		/// add_force mySig {0} {1 50} {0 100} {1 150} -repeat_every 200
		/// -cancel_after 10000
		/// Note: In the preceding example, the first {<value> <time>} pair does not include a time. This indicates that
		/// the specified value, 0, is applied at time 0 (the current_time).
		///
		/// See ug835-vivado-tcl-commands.pdf, page 46
		/// </summary>
		/// <param name="hdl_object">(Required) Specifies the object upon which to add a force</param>
		/// <param name="values">(Required) Adds a value and time offset to the force: {value [ time_offset ] }</param>
		/// <param name="radix">
		/// (Optional)
		/// Specifies which radix to use. Allowed values are: default,
		/// dec, bin, oct, hex, unsigned, ascii, smag
		/// </param>
		/// <param name="repeat_every">(Optional) Repeat every time duration</param>
		/// <param name="cancel_after">(Optional) Cancel after time offset</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The force objects added</returns>
		public virtual SimpleTCLCommand add_force(string hdl_object, string values, string radix = null, string repeat_every = null, string cancel_after = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: add_force [-radix <arg>] [-repeat_every <arg>] [-cancel_after <arg>] [-quiet] [-verbose] <hdl_object> <values>...
			return
				new SimpleTCLCommand("add_force")
					.OptionalNamedString("radix", radix)
					.OptionalNamedString("repeat_every", repeat_every)
					.OptionalNamedString("cancel_after", cancel_after)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hdl_object)
					.RequiredString(values)
			;
		}
		/// <summary>
		/// Select Pseudo Channel to add to Activity Monitor on the specified hardware HBM(s). Must
		/// specify the Memory Controller number first, follow by Pseudo Channel number.
		///
		///
		/// TCL Syntax: add_hw_hbm_pc [-quiet] [-verbose] <mc_num> <pc_num> <hw_objects>
		///
		/// The HBM activity monitor (amon) can be used to gain real-time access to performance
		/// monitoring and temperature sensors certain Xilinx® UltraScale+ devices that include an
		/// integrated High-Bandwidth Memory (HBM) controller. Refer to the LogiCore IP Product Guide:
		/// AXI High Bandwidth Memory Controller (PG276) for more information on this core. The HBM
		/// controller and memory stacks contain both performance counters and temperature sensors that
		/// can be accessed through the HBM activity monitor from within the Xilinx Vivado hardware
		/// manager. Each HBM stack is split into eight independent memory channels, each of which is
		/// further divided into two 64-bit pseudo channels (pc).
		/// After configuring an HBM enabled device with a design that contains instances of the AXI High
		/// Bandwidth Memory Controller, the HBM cores will be visible in the Vivado hardware manager.
		/// The add_hw_hbm_pc command lets you specify a memory channel (mc)/psuedo channel (pc) to
		/// monitor in the HBM activity monitor prior to using the run_hw_hbm_amon command.
		/// TIP: The HBM activity monitor must not be running when adding or removing psuedo channels.
		/// This command returns nothing if successful, or returns an error if it fails.
		///
		/// The following example adds the specified memory channels/psuedo channels on the defined
		/// HBM controller (hw_hbm) object, and then runs the HBM activity monitor in the Vivado
		/// hardware manager:
		/// set hbm_mon [get_hw_hbms *HBM_2]
		/// add_hw_hbm_pc 0 0 $hbm_mon
		/// add_hw_hbm_pc 0 1 $hbm_mon
		/// add_hw_hbm_pc 1 0 $hbm_mon
		/// add_hw_hbm_pc 1 1 $hbm_mon
		/// add_hw_hbm_pc 2 0 $hbm_mon
		/// add_hw_hbm_pc 2 1 $hbm_mon
		/// add_hw_hbm_pc 3 0 $hbm_mon
		/// add_hw_hbm_pc 3 1 $hbm_mon
		/// run_hw_hbm_amon $hbm_mon
		///
		/// See ug835-vivado-tcl-commands.pdf, page 50
		/// </summary>
		/// <param name="mc_num">(Required) Memory Controller number to select: 0 to 7</param>
		/// <param name="pc_num">(Required) Pseudo Channel number to select: 0 or 1</param>
		/// <param name="hw_objects">(Required) hardware objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand add_hw_hbm_pc(string mc_num, string pc_num, string hw_objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: add_hw_hbm_pc [-quiet] [-verbose] <mc_num> <pc_num> <hw_objects>
			return
				new SimpleTCLCommand("add_hw_hbm_pc")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(mc_num)
					.RequiredString(pc_num)
					.RequiredString(hw_objects)
			;
		}
		/// <summary>
		/// Add an enumerated name-value pair to a hw_probe enumeration.
		///
		///
		/// TCL Syntax: add_hw_probe_enum [-no_gui_update] [-dict <args>] [-quiet] [-verbose] <name> <value> <hw_probe>
		///
		/// Assign enumerated name/value pairs to specified hardware probe objects.
		/// This command is intended to make it easier to monitor the states of signals in the Vivado logic
		/// analyzer. The command lets you define a set of states, or enumerated names to be associated
		/// with specific values that may be found on a hw_probe object. This lets you monitor state
		/// machine probes and some other types of probes, by comparing symbolic names with trigger
		/// values and waveform data values.
		/// The enumerated name is added as an ENUM.NAME property on the specified hw_probe object,
		/// and associated with the specified bit value on the probe. Enumerated names can be used to
		/// specify trigger/capture compare values for hw_probes.
		/// TIP: Enumerated names are displayed in the waveform viewer of the Vivado logic analyzer. Display of the
		/// enumerated names can be disabled on a per probe basis. Refer to the Vivado Design Suite User Guide:
		/// Programming and Debugging (UG908) for more information on the waveform viewer.
		/// This command returns the enumerated name property, or returns an error if it fails.
		///
		/// The following example uses the -dict option to define the enumerated name/value pairs for
		/// the specified hw_probe object:
		/// add_hw_probe_enum -dict {ZERO eq5'h00 RED eq5'h12 GREEN eq5'h13 \
		/// BLUE eq5'h14 WHITE eq5'h15 YELLOW eq5'h16 GREY eq5'h17} \
		/// [get_hw_probes op1 -of_objects [current_hw_ila]]
		/// The following example defines the enumerated name/value pairs for the specified hw_probe
		/// object:
		/// add_hw_probe_enum ZERO eq5'h00 [get_hw_probes op1 \
		/// -of_objects [current_hw_ila]]
		/// add_hw_probe_enum RED eq5'h12 [get_hw_probes op1 \
		/// -of_objects [current_hw_ila]]
		/// add_hw_probe_enum GREEN eq5'h13 [get_hw_probes op1 \
		/// -of_objects [current_hw_ila]]
		/// add_hw_probe_enum BLUE eq5'h14 [get_hw_probes op1 \
		/// -of_objects [current_hw_ila]]
		/// add_hw_probe_enum WHITE eq5'h15 [get_hw_probes op1 \
		/// -of_objects [current_hw_ila]]
		/// add_hw_probe_enum YELLOW eq5'h16 [get_hw_probes op1 \
		/// -of_objects [current_hw_ila]]
		/// add_hw_probe_enum GREY eq5'h17 [get_hw_probes op1 \
		/// -of_objects [current_hw_ila]]
		/// The following example returns the ENUM property assigned to the specified hw_probe object:
		/// report_property [get_hw_probes op1 -of_objects [current_hw_ila]] ENUM*
		/// Property Type Read-only Visible Value
		/// ENUM.ZERO string true true eq5'h00
		/// ENUM.RED string true true eq5'h12
		/// ENUM.GREEN string true true eq5'h13
		/// ENUM.BLUE string true true eq5'h14
		/// ENUM.WHITE string true true eq5'h15
		/// ENUM.YELLOW string true true eq5'h16
		/// ENUM.GREY string true true eq5'h17
		///
		/// See ug835-vivado-tcl-commands.pdf, page 52
		/// </summary>
		/// <param name="name">(Required) Enumerated name.</param>
		/// <param name="value">(Required) Explicit value.</param>
		/// <param name="hw_probe">(Required) hw_probe object.</param>
		/// <param name="no_gui_update">(Optional) Defer GUI update.</param>
		/// <param name="dict">(Optional) List of parameter name-value pairs.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand add_hw_probe_enum(string name, string value, string hw_probe, bool? no_gui_update = null, string dict = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: add_hw_probe_enum [-no_gui_update] [-dict <args>] [-quiet] [-verbose] <name> <value> <hw_probe>
			return
				new SimpleTCLCommand("add_hw_probe_enum")
					.Flag("no_gui_update", no_gui_update)
					.OptionalNamedString("dict", dict)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
					.RequiredString(value)
					.RequiredString(hw_probe)
			;
		}
		/// <summary>
		/// Add a new bus interface to a peripheral.
		///
		///
		/// TCL Syntax: add_peripheral_interface -interface_mode <arg> -axi_type <arg> [-quiet] [-verbose] <name> <peripheral>
		///
		/// Add an AXI bus interface to a peripheral created with the create_peripheral command.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 55
		/// </summary>
		/// <param name="interface_mode">(Required) Mode of an interface, supported option - master,slave.</param>
		/// <param name="axi_type">(Required) Type of a axi interface, supported option - lite,full,stream.</param>
		/// <param name="name">(Required) Name to initialize the newly added element e.g S1_AXI, M1_AXI</param>
		/// <param name="peripheral">(Required) Peripheral object</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand add_peripheral_interface(string interface_mode, string axi_type, string name, string peripheral, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: add_peripheral_interface -interface_mode <arg> -axi_type <arg> [-quiet] [-verbose] <name> <peripheral>
			return
				new SimpleTCLCommand("add_peripheral_interface")
					.RequiredNamedString("interface_mode", interface_mode)
					.RequiredNamedString("axi_type", axi_type)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
					.RequiredString(peripheral)
			;
		}
		/// <summary>
		/// Add new waves
		///
		///
		/// TCL Syntax: add_wave [-into <args>] [-at_wave <args>] [-after_wave <args>] [-before_wave <args>] [-reverse] [-radix <arg>] [-color <arg>] [-name <arg>] [-recursive] [-r] [-regexp] [-nocase] [-quiet] [-verbose] <items>...
		///
		/// The add_wave command creates one or more new design-based wave objects.
		/// This command returns the name of the newly-created wave object(s).
		/// Note: This command can only be used when running a simulation. At a minimum, you must specify an
		/// item, which is an HDL object (signal) within the simulation project. In the Vivado interface, the object
		/// would display in the Objects Window.
		///
		/// The following example defines a wave group, defines a color for that group, and adds all signals
		/// that begin with the letter 's', and has at least one character following it followed by 0 or more
		/// characters, to the wave window in the wave group:
		/// set groupColor YELLOW
		/// set AXIS_ID [add_wave_group "Streaming Data"]
		/// add_wave -into $AXIS_ID -color $groupColor -regexp s.*
		/// Add the dout_tvalid signal from the rsb_design_testbench to the existing simulation waveform
		/// configuration:
		/// add_wave dout_tvalid /rsb_design_testbench/dout_tvalid
		///
		/// See ug835-vivado-tcl-commands.pdf, page 57
		/// </summary>
		/// <param name="items">(Required) the design objects from which to create wave objects</param>
		/// <param name="into">
		/// (Optional)
		/// the wave configuration, group, or virtual bus into which the
		/// new wave object(s) will be inserted.
		/// </param>
		/// <param name="at_wave">
		/// (Optional)
		/// inserts the new wave object(s) into the specified wave
		/// object, or after the specified wave object if not a group or
		/// virtual bus
		/// </param>
		/// <param name="after_wave">(Optional) inserts the new wave objects(s) after the specified wave object</param>
		/// <param name="before_wave">(Optional) inserts the new wave objects(s) before the specified wave object</param>
		/// <param name="reverse">(Optional) reverses the displayed bit order of the new wave objects(s)</param>
		/// <param name="radix">
		/// (Optional)
		/// sets the displayed radix of the new wave object(s) to the
		/// specified radix. Allowed values are: default, dec, bin, oct,
		/// hex, unsigned, ascii, smag
		/// </param>
		/// <param name="color">
		/// (Optional)
		/// sets the displayed color of the new wave object(s) to the
		/// specified color, which can be a standard color name or a
		/// string of the form #RRGGBB
		/// </param>
		/// <param name="name">
		/// (Optional)
		/// sets the displayed name of the single new wave object to
		/// the specified string
		/// </param>
		/// <param name="recursive">
		/// (Optional)
		/// if the design object is a scope, this option specifies that
		/// wave objects for all design objects under that scope should
		/// be created
		/// </param>
		/// <param name="r">
		/// (Optional)
		/// if the design object is a scope, this option specifies that
		/// wave objects for all design objects under that scope should
		/// be created
		/// </param>
		/// <param name="regexp">(Optional) interprets <items> using regular expressions</param>
		/// <param name="nocase">(Optional) only when regexp is used, performs a case insensitive match</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The new waves</returns>
		public virtual SimpleTCLCommand add_wave(string items, string into = null, string at_wave = null, string after_wave = null, string before_wave = null, bool? reverse = null, string radix = null, string color = null, string name = null, bool? recursive = null, bool? r = null, bool? regexp = null, bool? nocase = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: add_wave [-into <args>] [-at_wave <args>] [-after_wave <args>] [-before_wave <args>] [-reverse] [-radix <arg>] [-color <arg>] [-name <arg>] [-recursive] [-r] [-regexp] [-nocase] [-quiet] [-verbose] <items>...
			return
				new SimpleTCLCommand("add_wave")
					.OptionalNamedString("into", into)
					.OptionalNamedString("at_wave", at_wave)
					.OptionalNamedString("after_wave", after_wave)
					.OptionalNamedString("before_wave", before_wave)
					.Flag("reverse", reverse)
					.OptionalNamedString("radix", radix)
					.OptionalNamedString("color", color)
					.OptionalNamedString("name", name)
					.Flag("recursive", recursive)
					.Flag("r", r)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(items)
			;
		}
		/// <summary>
		/// Add a new divider
		///
		///
		/// TCL Syntax: add_wave_divider [-into <args>] [-at_wave <args>] [-after_wave <args>] [-before_wave <args>] [-color <arg>] [-quiet] [-verbose] [<name>]
		///
		/// Creates a wave divider in the wave form viewer. The wave divider can be used to separate
		/// groups of related objects, for easier viewing.
		/// The wave divider can be added into a specified or current waveform configuration (WCFG) at the
		/// specified location. If no location is specified the wave divider is inserted at the end of the
		/// waveform configuration.
		/// This command returns the name of the newly-created wave divider.
		/// Note: This command can only be used when running a simulation.
		///
		/// The following example inserts a wave divider named Div1, after the CLK wave object:
		/// add_wave_divider -after_wave CLK Div1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 60
		/// </summary>
		/// <param name="into">
		/// (Optional)
		/// the wave configuration or group into which the new divider
		/// will be inserted.
		/// </param>
		/// <param name="at_wave">
		/// (Optional)
		/// inserts the new divider into the specified wave object, or
		/// after the specified wave object if not a group
		/// </param>
		/// <param name="after_wave">(Optional) inserts the new divider after the specified wave object</param>
		/// <param name="before_wave">(Optional) inserts the new divider before the specified wave object</param>
		/// <param name="color">
		/// (Optional)
		/// sets the displayed color of the new divider to the specified
		/// color, which can be a standard color name or a string of the
		/// form #RRGGBB Default: default
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="name">
		/// (Optional)
		/// the displayed name of the new divider to the specified
		/// string Default: new_divider
		/// </param>
		/// <returns>The new divider</returns>
		public virtual SimpleTCLCommand add_wave_divider(string into = null, string at_wave = null, string after_wave = null, string before_wave = null, string color = null, bool? quiet = null, bool? verbose = null, string name = null)
		{
			// TCL Syntax: add_wave_divider [-into <args>] [-at_wave <args>] [-after_wave <args>] [-before_wave <args>] [-color <arg>] [-quiet] [-verbose] [<name>]
			return
				new SimpleTCLCommand("add_wave_divider")
					.OptionalNamedString("into", into)
					.OptionalNamedString("at_wave", at_wave)
					.OptionalNamedString("after_wave", after_wave)
					.OptionalNamedString("before_wave", before_wave)
					.OptionalNamedString("color", color)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(name)
			;
		}
		/// <summary>
		/// Add a new group
		///
		///
		/// TCL Syntax: add_wave_group [-into <args>] [-at_wave <args>] [-after_wave <args>] [-before_wave <args>] [-quiet] [-verbose] [<name>]
		///
		/// Creates a wave group into a specified or current waveform configuration. New wave objects and
		/// wave_dividers can be added into the wave group to build up the waveform display.
		/// The wave group can be inserted at a specified location. If no location is specified the group is
		/// inserted at the end of the specified waveform configuration.
		/// The command returns the name of the newly created wave group object.
		/// Note: This command can only be used when running a simulation.
		///
		/// Add a clk to the existing waveform configuration:
		/// add_wave_group clk
		/// group10
		///
		/// See ug835-vivado-tcl-commands.pdf, page 62
		/// </summary>
		/// <param name="into">
		/// (Optional)
		/// the wave configuration or group into which the new group
		/// will be inserted.
		/// </param>
		/// <param name="at_wave">
		/// (Optional)
		/// inserts the new group into the specified wave object, or
		/// after the specified wave object if not a group
		/// </param>
		/// <param name="after_wave">(Optional) inserts the new group after the specified wave object</param>
		/// <param name="before_wave">(Optional) inserts the new group before the specified wave object</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="name">
		/// (Optional)
		/// the displayed name of the new group to the specified string
		/// Default: new_group
		/// </param>
		/// <returns>The new group</returns>
		public virtual SimpleTCLCommand add_wave_group(string into = null, string at_wave = null, string after_wave = null, string before_wave = null, bool? quiet = null, bool? verbose = null, string name = null)
		{
			// TCL Syntax: add_wave_group [-into <args>] [-at_wave <args>] [-after_wave <args>] [-before_wave <args>] [-quiet] [-verbose] [<name>]
			return
				new SimpleTCLCommand("add_wave_group")
					.OptionalNamedString("into", into)
					.OptionalNamedString("at_wave", at_wave)
					.OptionalNamedString("after_wave", after_wave)
					.OptionalNamedString("before_wave", before_wave)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(name)
			;
		}
		/// <summary>
		/// Create a new wave marker
		///
		///
		/// TCL Syntax: add_wave_marker [-into <arg>] [-name <arg>] [-quiet] [-verbose] [<time>] [<unit>]
		///
		/// Creates a wave marker at the specified time and of the specified name in the current waveform
		/// configuration.
		/// This command returns nothing.
		/// Note: This command can only be used when running a simulation.
		///
		/// Add a marker to the existing waveform configuration at 500ns:
		/// add_wave_marker 500 ns
		///
		/// See ug835-vivado-tcl-commands.pdf, page 64
		/// </summary>
		/// <param name="into">(Optional) the wave configuration in which to create the marker</param>
		/// <param name="name">(Optional) sets the name of the new marker to the specified string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="time">(Optional) the numerical portion of the new marker's time Default: 0</param>
		/// <param name="unit">
		/// (Optional)
		/// the time unit portion of the new marker's time. Allowed
		/// values are fs, ps, ns, us, ms, and s.
		/// </param>
		/// <returns>The new created marker</returns>
		public virtual SimpleTCLCommand add_wave_marker(string into = null, string name = null, bool? quiet = null, bool? verbose = null, string time = null, string unit = null)
		{
			// TCL Syntax: add_wave_marker [-into <arg>] [-name <arg>] [-quiet] [-verbose] [<time>] [<unit>]
			return
				new SimpleTCLCommand("add_wave_marker")
					.OptionalNamedString("into", into)
					.OptionalNamedString("name", name)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(time)
					.OptionalString(unit)
			;
		}
		/// <summary>
		/// Add a new virtual bus
		///
		///
		/// TCL Syntax: add_wave_virtual_bus [-into <args>] [-at_wave <args>] [-after_wave <args>] [-before_wave <args>] [-reverse] [-radix <arg>] [-color <arg>] [-quiet] [-verbose] [<name>]
		///
		/// The add_wave_virtual_bus command creates a new virtual bus of the specified <name>.
		/// The command inserts the virtual bus into the wave configuration (WCFG) where specified, or by
		/// default at the bottom of the existing WCFG. It returns a vb### for the newly-created virtual bus.
		/// Note: This command can only be used when running a simulation. At a minimum, you must specify a name,
		/// which is the name of the new virtual bus
		///
		/// Add a virtual bus of the name dout_tvalid to the end of the current waveform configuration:
		/// add_wave_virtual_bus dout_tvalid
		///
		/// See ug835-vivado-tcl-commands.pdf, page 66
		/// </summary>
		/// <param name="into">
		/// (Optional)
		/// the wave configuration, group, or virtual bus into which the
		/// new virtual bus will be inserted.
		/// </param>
		/// <param name="at_wave">
		/// (Optional)
		/// inserts the new virtual bus into the specified wave object, or
		/// after the specified wave object if not a group or virtual bus
		/// </param>
		/// <param name="after_wave">(Optional) inserts the new virtual bus after the specified wave object</param>
		/// <param name="before_wave">(Optional) inserts the new virtual bus before the specified wave object</param>
		/// <param name="reverse">(Optional) reverses the displayed bit order of the new virtual bus</param>
		/// <param name="radix">
		/// (Optional)
		/// sets the displayed radix of the new virtual bus to the
		/// specified radix. Allowed values are: default, dec, bin, oct,
		/// hex, unsigned, ascii, smag
		/// </param>
		/// <param name="color">
		/// (Optional)
		/// sets the displayed color of the new virtual bus to the
		/// specified color, which can be a standard color name or a
		/// string of the form #RRGGBB Default: default
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="name">
		/// (Optional)
		/// the displayed name of the new virtual bus to the specified
		/// string Default: new_virtual_bus
		/// </param>
		/// <returns>The new virtual bus</returns>
		public virtual SimpleTCLCommand add_wave_virtual_bus(string into = null, string at_wave = null, string after_wave = null, string before_wave = null, bool? reverse = null, string radix = null, string color = null, bool? quiet = null, bool? verbose = null, string name = null)
		{
			// TCL Syntax: add_wave_virtual_bus [-into <args>] [-at_wave <args>] [-after_wave <args>] [-before_wave <args>] [-reverse] [-radix <arg>] [-color <arg>] [-quiet] [-verbose] [<name>]
			return
				new SimpleTCLCommand("add_wave_virtual_bus")
					.OptionalNamedString("into", into)
					.OptionalNamedString("at_wave", at_wave)
					.OptionalNamedString("after_wave", after_wave)
					.OptionalNamedString("before_wave", before_wave)
					.Flag("reverse", reverse)
					.OptionalNamedString("radix", radix)
					.OptionalNamedString("color", color)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(name)
			;
		}
		/// <summary>
		/// Get a list of all clocks in the current design
		///
		///
		/// TCL Syntax: all_clocks [-quiet] [-verbose]
		///
		/// Returns a list of all clocks that have been declared in the current design.
		/// To get a list of specific clocks in the design, use the get_clocks command, or use the filter
		/// command to filter the results returned by all_clocks.
		/// Clocks can be defined by using the create_clock or create_generated_clock
		/// commands.
		///
		/// The following example shows all clocks in the sample CPU netlist project:
		/// % all_clocks
		/// cpuClk wbClk usbClk phy_clk_pad_0_i phy_clk_pad_1_i fftClk
		/// The following example applies the set_propagated_clock command to all clocks, and also
		/// demonstrates how the returned list (all_clocks) can be passed to another command:
		/// % set_propagated_clock [all_clocks]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 69
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of clock objects</returns>
		public virtual SimpleTCLCommand all_clocks(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: all_clocks [-quiet] [-verbose]
			return
				new SimpleTCLCommand("all_clocks")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Get a list of cpu cells in the current design
		///
		///
		/// TCL Syntax: all_cpus [-quiet] [-verbose]
		///
		/// Returns a list of all CPU cell objects in the current design. Creates a list of all the CPU cell objects
		/// that have been declared in the current design.
		/// The list of CPUs returned by all_cpus can also be limited or reduced by the filter command
		/// to filter according to properties assigned to the CPU cell objects. Properties of an object can be
		/// returned by the list_property or report_property commands.
		/// The all_cpus command is scoped to return the objects hierarchically, from the top-level of the
		/// design or from the level of the current instance. By default the current instance is defined as the
		/// top level of the design, but can be changed by using the current_instance command.
		/// Note: This command returns a list of CPU cell objects
		///
		/// The following example returns all CPU objects in the current design:
		/// all_cpus
		/// The following example shows how the list returned can be passed to another command:
		/// set_false_path -from [all_cpus] -to [all_registers]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 71
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of cpu cell objects</returns>
		public virtual SimpleTCLCommand all_cpus(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: all_cpus [-quiet] [-verbose]
			return
				new SimpleTCLCommand("all_cpus")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Get a list of dsp cells in the current design
		///
		///
		/// TCL Syntax: all_dsps [-quiet] [-verbose]
		///
		/// Returns a list of all DSP cell objects that have been declared in the current design.
		/// The list of DSPs returned by all_dsps can also be limited or reduced by the filter command
		/// to filter according to properties assigned to the DSP objects. Properties of an object can be
		/// returned by the list_property or report_property commands.
		/// The all_dsps command is scoped to return the objects hierarchically, from the top-level of the
		/// design or from the level of the current instance. By default the current instance is defined as the
		/// top level of the design, but can be changed by using the current_instance command.
		///
		/// The following example returns a list of all DSPs defined in the current design, and filters that list
		/// to return a single DSP assigned to the specified SITE:
		/// filter [all_dsps] {SITE == DSP48_X1Y6}
		/// The following example shows how the list returned can be passed to another command:
		/// set_false_path -from [all_dsps] -to [all_registers]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 73
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of dsp cell objects</returns>
		public virtual SimpleTCLCommand all_dsps(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: all_dsps [-quiet] [-verbose]
			return
				new SimpleTCLCommand("all_dsps")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Get a list of pins or cells in fanin of specified sinks
		///
		///
		/// TCL Syntax: all_fanin [-startpoints_only] [-flat] [-only_cells] [-levels <arg>] [-pin_levels <arg>] [-trace_arcs <arg>] [-quiet] [-verbose] <to>
		///
		/// Returns a list of port, pin or cell objects in the fan-in of the specified sinks.
		/// The all_fanin command is scoped to return objects from current level of the hierarchy of the
		/// design, either from the top-level or from the level of the current instance. By default the current
		/// instance is defined as the top level of the design, but can be changed by using the
		/// current_instance command. To return the fan-in across all levels of the hierarchy, use the -
		/// flat option.
		///
		/// The following example lists the timing fan-in of the led_pins output port:
		/// all_fanin [get_ports led_pins[*] ]
		/// The following example traces back from the clock pin of the specified flip- flop to the clock
		/// source (an MMCM output pin in this example):
		/// all_fanin -flat -startpoints_only [get_pins cmd_parse_i0/prescale_reg[7]/C]
		/// The following examples returns the ports connected to the input pins of IDELAYs, ignoring the
		/// hierarchy of the design:
		/// all_fanin -flat -startpoints_only [get_pins IDELAY*/IDATAIN]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 75
		/// </summary>
		/// <param name="to">(Required) List of sink pins, ports, or nets</param>
		/// <param name="startpoints_only">(Optional) Find only the timing startpoints</param>
		/// <param name="flat">(Optional) Hierarchy is ignored</param>
		/// <param name="only_cells">(Optional) Only cells</param>
		/// <param name="levels">(Optional) Maximum number of cell levels to traverse:Value >= 0 Default: 0</param>
		/// <param name="pin_levels">(Optional) Maximum number of pin levels to traverse:Value >= 0 Default: 0</param>
		/// <param name="trace_arcs">(Optional) Type of network arcs to trace: Values: timing, enabled, all</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of cell or pin objects</returns>
		public virtual SimpleTCLCommand all_fanin(string to, bool? startpoints_only = null, bool? flat = null, bool? only_cells = null, string levels = null, string pin_levels = null, string trace_arcs = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: all_fanin [-startpoints_only] [-flat] [-only_cells] [-levels <arg>] [-pin_levels <arg>] [-trace_arcs <arg>] [-quiet] [-verbose] <to>
			return
				new SimpleTCLCommand("all_fanin")
					.Flag("startpoints_only", startpoints_only)
					.Flag("flat", flat)
					.Flag("only_cells", only_cells)
					.OptionalNamedString("levels", levels)
					.OptionalNamedString("pin_levels", pin_levels)
					.OptionalNamedString("trace_arcs", trace_arcs)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(to)
			;
		}
		/// <summary>
		/// Get a list of pins or cells in fanout of specified sources
		///
		///
		/// TCL Syntax: all_fanout [-endpoints_only] [-flat] [-only_cells] [-levels <arg>] [-pin_levels <arg>] [-trace_arcs <arg>] [-quiet] [-verbose] <from>
		///
		/// Returns a list of port, pin, or cell objects in the fanout of the specified sources.
		/// The all_fanout command is scoped to return objects from current level of the hierarchy of the
		/// design, either from the top-level or from the level of the current instance. By default the current
		/// instance is defined as the top level of the design, but can be changed by using the
		/// current_instance command. To return the fanout across all levels of the hierarchy, use the -
		/// flat option.
		///
		/// The following example gets the fanout for all input ports in the design:
		/// all_fanout [all_inputs]
		/// This example gets the fanout for all inputs assigned to I/O Bank 15 in the current design:
		/// all_fanout [filter [all_inputs] {IOBANK == 15}]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 78
		/// </summary>
		/// <param name="from">(Required) List of source pins, ports, or nets</param>
		/// <param name="endpoints_only">(Optional) Find only the timing endpoints</param>
		/// <param name="flat">(Optional) Hierarchy is ignored</param>
		/// <param name="only_cells">(Optional) Only cells</param>
		/// <param name="levels">(Optional) Maximum number of cell levels to traverse:Value >= 0 Default: 0</param>
		/// <param name="pin_levels">(Optional) Maximum number of pin levels to traverse:Value >= 0 Default: 0</param>
		/// <param name="trace_arcs">(Optional) Type of network arcs to trace: Values: timing, enabled, all</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of cell or pin objects</returns>
		public virtual SimpleTCLCommand all_fanout(string from, bool? endpoints_only = null, bool? flat = null, bool? only_cells = null, string levels = null, string pin_levels = null, string trace_arcs = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: all_fanout [-endpoints_only] [-flat] [-only_cells] [-levels <arg>] [-pin_levels <arg>] [-trace_arcs <arg>] [-quiet] [-verbose] <from>
			return
				new SimpleTCLCommand("all_fanout")
					.Flag("endpoints_only", endpoints_only)
					.Flag("flat", flat)
					.Flag("only_cells", only_cells)
					.OptionalNamedString("levels", levels)
					.OptionalNamedString("pin_levels", pin_levels)
					.OptionalNamedString("trace_arcs", trace_arcs)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(from)
			;
		}
		/// <summary>
		/// Get a list of flip flop cells in the current design
		///
		///
		/// TCL Syntax: all_ffs [-quiet] [-verbose]
		///
		/// Returns a list of all flip flop instances in the current design.
		/// You can use the get_cells command, or use the filter command to limit the results from
		/// the all_ffs command to return a list of flip-flop cells matching the specified properties.
		/// The all_ffs command is scoped to return the objects hierarchically, from the top-level of the
		/// design or from the level of the current instance. By default the current instance is defined as the
		/// top level of the design, but can be changed by using the current_instance command.
		///
		/// The following example returns the count of all flops in the design, then returns the count of all
		/// flops in the fftEngine module:
		/// current_instance
		/// INFO: [Vivado 12-618] Current instance is the top level of design
		/// 'netlist_1'.
		/// top
		/// llength [all_ffs]
		/// 15741
		/// current_instance fftEngine
		/// fftEngine
		/// llength [all_ffs]
		/// 1519
		/// This example filters the results of all_ffs to return only the FDRE flops:
		/// filter [all_ffs] {REF_NAME == FDRE}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 81
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of flip flop cell objects</returns>
		public virtual SimpleTCLCommand all_ffs(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: all_ffs [-quiet] [-verbose]
			return
				new SimpleTCLCommand("all_ffs")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Get a list of hsio cells in the current design
		///
		///
		/// TCL Syntax: all_hsios [-quiet] [-verbose]
		///
		/// Returns a list of all High Speed IO (HSIO) cell objects that have been declared in the current
		/// design. These HSIO cell objects can be assigned to a variable or passed into another command.
		/// The list of high-speed IOs returned by all_hsios can also be limited or reduced by the
		/// filter command to filter according to properties assigned to the HSIO objects. Properties of
		/// an object can be returned by the list_property or report_property commands.
		/// The all_hsios command is scoped to return the objects hierarchically, from the top-level of
		/// the design or from the level of the current instance. By default the current instance is defined as
		/// the top level of the design, but can be changed by using the current_instance command.
		///
		/// The following example returns all HSIO objects in the current design:
		/// all_hsios
		/// The following example shows how the list returned can be directly passed to another command:
		/// set_false_path -from [all_hsios] -to [all_registers]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 83
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of hsio cell objects</returns>
		public virtual SimpleTCLCommand all_hsios(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: all_hsios [-quiet] [-verbose]
			return
				new SimpleTCLCommand("all_hsios")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Get a list of all input ports in the current design
		///
		///
		/// TCL Syntax: all_inputs [-quiet] [-verbose]
		///
		/// Returns a list of all input port objects in the current design.
		/// To get a list of specific inputs in the design, use the get_ports command, or use the filter
		/// command to filter the results returned by all_inputs.
		/// The all_inputs command is scoped to return the objects hierarchically, from the top-level of
		/// the design or from the level of the current instance. By default the current instance is defined as
		/// the top level of the design, but can be changed by using the current_instance command.
		///
		/// The following example returns all input port objects in the current design:
		/// all_inputs
		/// This example gets all input port objects, filters out the GT ports, and sets the IOSTANDARD
		/// property for the non-GT ports:
		/// set non_gt_ports [filter [all_inputs] {!is_gt_term}]
		/// set_property IOSTANDARD LVCMOS18 $non_gt_ports
		/// The following example shows how the list returned can be passed to another command:
		/// set_input_delay 5 -clock REFCLK [all_inputs]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 85
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of port objects</returns>
		public virtual SimpleTCLCommand all_inputs(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: all_inputs [-quiet] [-verbose]
			return
				new SimpleTCLCommand("all_inputs")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Get a list of all latch cells in the current design
		///
		///
		/// TCL Syntax: all_latches [-quiet] [-verbose]
		///
		/// Returns a list of all latches that have been declared in the current design.
		/// The list of latches returned by all_latches can also be limited or reduced by the filter
		/// command to filter according to properties assigned to the latches. Properties of an object can be
		/// returned by the list_property or report_property commands.
		/// The all_latches command is scoped to return the objects hierarchically, from the top-level of
		/// the design or from the level of the current instance. By default the current instance is defined as
		/// the top level of the design, but can be changed by using the current_instance command.
		///
		/// The following example returns a list of all latches in the current design:
		/// all_latches
		/// The following example shows how the list returned can be passed to another command:
		/// set_false_path -from [all_mults] -to [all_latches]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 87
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of latch cell objects</returns>
		public virtual SimpleTCLCommand all_latches(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: all_latches [-quiet] [-verbose]
			return
				new SimpleTCLCommand("all_latches")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Get a list of all output ports in the current design
		///
		///
		/// TCL Syntax: all_outputs [-quiet] [-verbose]
		///
		/// Returns a list of all output port objects that have been declared in the current design.
		/// To get a list of specific outputs in the design, use the get_ports command, or use the filter
		/// command to filter the results returned by all_outputs.
		/// The all_outputs command is scoped to return the objects hierarchically, from the top-level of
		/// the design or from the level of the current instance. By default the current instance is defined as
		/// the top level of the design, but can be changed by using the current_instance command.
		///
		/// The following example returns all the output ports in the current design:
		/// all_outputs
		/// The following example sets the output delay for all outputs in the design:
		/// set_output_delay 5 -clock REFCLK [all_outputs]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 89
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of port objects</returns>
		public virtual SimpleTCLCommand all_outputs(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: all_outputs [-quiet] [-verbose]
			return
				new SimpleTCLCommand("all_outputs")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Get a list of ram cells in the current design
		///
		///
		/// TCL Syntax: all_rams [-quiet] [-verbose]
		///
		/// Returns a list of all the RAM cell objects present in the current instance, including Block RAMS,
		/// Block RAM FIFOs, and Distributed RAMS. These RAM cell objects can be assigned to a variable
		/// or passed into another command.
		/// To get a list of specific RAM cells in the design, use the filter command to filter the results
		/// returned by all_rams based on properties assigned to the RAM cells. Properties of an object
		/// can be returned by the list_property or report_property commands.
		/// The all_rams command is scoped to return the objects hierarchically, from the top-level of the
		/// design or from the level of the current instance. By default the current instance is defined as the
		/// top level of the design, but can be changed by using the current_instance command.
		///
		/// The following example returns all RAM cells in the design:
		/// all_rams
		/// This example returns all RAM cells in the design, and filters the results to return only the FIFO
		/// block memories:
		/// filter [all_rams] {PRIMITIVE_SUBGROUP == fifo}
		/// The following example sets the current instance, and returns all RAM objects hierarchically from
		/// the level of the current instance:
		/// current_instance usbEngine0
		/// all_rams
		///
		/// See ug835-vivado-tcl-commands.pdf, page 91
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of ram cell objects</returns>
		public virtual SimpleTCLCommand all_rams(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: all_rams [-quiet] [-verbose]
			return
				new SimpleTCLCommand("all_rams")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Get a list of register cells or pins in the current design
		///
		///
		/// TCL Syntax: all_registers [-clock <args>] [-rise_clock <args>] [-fall_clock <args>] [-cells] [-data_pins] [-clock_pins] [-async_pins] [-output_pins] [-level_sensitive] [-edge_triggered] [-no_hierarchy] [-quiet] [-verbose]
		///
		/// Returns a list of sequential register cells or register pins in the current design.
		/// TIP: Returned objects includes DSPs and BRAMs as they contain internal registers.
		/// The list of returned objects can be limited by the use of the arguments described below. You can
		/// limit the list of registers returned to a specific clock or clocks, or to registers triggered by the
		/// rising or falling edge of a specified clock.
		/// The list of registers returned by all_registers can also be limited or reduced by the filter
		/// command to filter according to properties assigned to the registers. Properties of an object can
		/// be returned by the list_property or report_property commands.
		/// You can also get a list of the pins of collected registers instead of the register objects by
		/// specifying one or more of the pin arguments.
		///
		/// The following example returns a list of registers that are triggered by the falling edge of any clock
		/// in the design:
		/// all_registers -fall_clock [all_clocks]
		/// The following example sets the minimum delay:
		/// set_min_delay 2.0 -to [all_registers -clock CCLK -data_pins]
		/// The following example extracts all registers on clk_A with *meta* in the name:
		/// filter [all_registers -clock clk_A] {name =~ *meta*}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 93
		/// </summary>
		/// <param name="clock">(Optional) Consider registers of this clock</param>
		/// <param name="rise_clock">(Optional) Consider registers triggered by clock rising edge</param>
		/// <param name="fall_clock">(Optional) Consider registers triggered by clock falling edge</param>
		/// <param name="cells">(Optional) Return list of cells (default)</param>
		/// <param name="data_pins">(Optional) Return list of register data pins</param>
		/// <param name="clock_pins">(Optional) Return list of register clock pins</param>
		/// <param name="async_pins">(Optional) Return list of async preset/clear pins</param>
		/// <param name="output_pins">(Optional) Return list of register output pins</param>
		/// <param name="level_sensitive">(Optional) Only consider level-sensitive latches</param>
		/// <param name="edge_triggered">(Optional) Only consider edge-triggered flip-flops</param>
		/// <param name="no_hierarchy">(Optional) Only search the current instance</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of cell or pin objects</returns>
		public virtual SimpleTCLCommand all_registers(string clock = null, string rise_clock = null, string fall_clock = null, bool? cells = null, bool? data_pins = null, bool? clock_pins = null, bool? async_pins = null, bool? output_pins = null, bool? level_sensitive = null, bool? edge_triggered = null, bool? no_hierarchy = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: all_registers [-clock <args>] [-rise_clock <args>] [-fall_clock <args>] [-cells] [-data_pins] [-clock_pins] [-async_pins] [-output_pins] [-level_sensitive] [-edge_triggered] [-no_hierarchy] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("all_registers")
					.OptionalNamedString("clock", clock)
					.OptionalNamedString("rise_clock", rise_clock)
					.OptionalNamedString("fall_clock", fall_clock)
					.Flag("cells", cells)
					.Flag("data_pins", data_pins)
					.Flag("clock_pins", clock_pins)
					.Flag("async_pins", async_pins)
					.Flag("output_pins", output_pins)
					.Flag("level_sensitive", level_sensitive)
					.Flag("edge_triggered", edge_triggered)
					.Flag("no_hierarchy", no_hierarchy)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Runs an automation rule on an IPI object.
		///
		///
		/// TCL Syntax: apply_bd_automation -rule <arg> [-config <args>] -dict <arg> -opts <arg> [-quiet] [-verbose] <objects>...
		///
		/// IP integrator provides the Designer Assistance feature, using the apply_bd_automation
		/// command, to automatically configure and/or add other relevant IP integrator cells around a
		/// selected IP integrator object. For more information on the Designer Assistance features refer to
		/// the Vivado Design Suite User Guide: Designing with IP (UG896) or the Vivado Design Suite User
		/// Guide: Designing IP Subsystems Using IP Integrator (UG994).
		/// Currently block and connection automation exists for cells, interfaces, pins and ports. The Block
		/// Automation feature is provided for certain complex blocks such as the Zynq device, MicroBlaze
		/// processor, AXI Ethernet and memory IP.
		/// The Connection Automation feature helps automate different types of connections. For instance
		/// when connecting Slave AXI-MM interfaces, the automation will also connect up the relevant
		/// clock and reset pins and also create an interconnect if one is required. Connection Automation
		/// may also help with board-level connections; connecting pins and interfaces from relevant cells, to
		/// external ports and interfaces, and applying appropriate board constraints on these external I/Os.
		/// Note: This IP integrator command is issued from within the Vivado IDE via the Designer Assistance GUI
		/// feature. It is recommended that you make use of this command in IP integrator through the Vivado IDE,
		/// rather than directly from Tcl scripts. Use the write_bd_tcl command to output Tcl for use within a user
		/// script.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 96
		/// </summary>
		/// <param name="rule">(Required) Rule ID string</param>
		/// <param name="dict">(Required) List of objects and corresponding parameter name-value pairs.</param>
		/// <param name="opts">(Required) List of settings that apply to all objects in this rule.</param>
		/// <param name="objects">(Required) The objects to run the automation rule on</param>
		/// <param name="config">(Optional) List of parameter value pairs</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Returns success or failure</returns>
		public virtual SimpleTCLCommand apply_bd_automation(string rule, string dict, string opts, string objects, string config = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: apply_bd_automation -rule <arg> [-config <args>] -dict <arg> -opts <arg> [-quiet] [-verbose] <objects>...
			return
				new SimpleTCLCommand("apply_bd_automation")
					.RequiredNamedString("rule", rule)
					.OptionalNamedString("config", config)
					.RequiredNamedString("dict", dict)
					.RequiredNamedString("opts", opts)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Applies board connections to given designs
		///
		///
		/// TCL Syntax: apply_board_connection [-board_interface <arg>] -ip_intf <arg> -diagram <arg> [-quiet] [-verbose]
		///
		/// Connects the interface pin of an IP core in the specified block design to the interface of the
		/// current board part in the current project or design.
		/// The board part provides a representation of the Xilinx device in the context of the board-level
		/// system, and can help define key aspects of the design, such as clock constraints, I/O port
		/// assignments, and supported interfaces. The board part file stores information regarding board
		/// attributes. The file, called board_part.xml, is located in the data/boards/board_parts
		/// folder of the Vivado Design Suite installation area.
		/// The command lets you quickly connect compatible interface pins of an IP integrator block design
		/// to the appropriate interface definition on the current board part. To make the connection
		/// between the IP core to the board part, the IP integrator of the Vivado Design Suite adds an
		/// external interface port and interface connection to the block design. The added external
		/// interface port is named for the specified board part interface.
		/// The apply_board_connection commands uses the available interfaces of the current board
		/// part defined in the project. An error is returned if the project uses a target part rather than a
		/// target board. You can use the current_board_part command to identify the target board
		/// used by the project, or get_board_parts to list the boards available for use by the project.
		/// Use the get_board_part_interfaces command to determine the list of available interfaces
		/// on the current board.
		/// To remove an existing IP interface connection, specify the -ip_intf option, but do not specify
		/// the -board_interface. If no board part interface is specified, the IP interface pin is
		/// disconnected.
		/// This command returns a transcript of it actions, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 99
		/// </summary>
		/// <param name="ip_intf">
		/// (Required)
		/// Full path of IP interface name to which board automation
		/// need to be applied.
		/// </param>
		/// <param name="diagram">(Required) The IP Integrator design name.</param>
		/// <param name="board_interface">(Optional) Board interface name to which connection need to be applied.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>sucess/failure status of applied action.</returns>
		public virtual SimpleTCLCommand apply_board_connection(string ip_intf, string diagram, string board_interface = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: apply_board_connection [-board_interface <arg>] -ip_intf <arg> -diagram <arg> [-quiet] [-verbose]
			return
				new SimpleTCLCommand("apply_board_connection")
					.OptionalNamedString("board_interface", board_interface)
					.RequiredNamedString("ip_intf", ip_intf)
					.RequiredNamedString("diagram", diagram)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Apply trigger at startup init values to an ILA core in the design
		///
		///
		/// TCL Syntax: apply_hw_ila_trigger [-ila_cell <arg>] [-quiet] [-verbose] [<file>]
		///
		/// Apply a trigger configuration file to the bitstream of a design, to support ILA trigger at startup.
		/// This command is used to configure the trigger settings of an ILA core in a design bitstream (.bit)
		/// file, so that the ILA debug core is armed to trigger on events immediately after device
		/// configuration and startup. This allows data to be captured from the earliest stages of device
		/// activity, which would not be possible through the use of the Hardware Manager feature of the
		/// Vivado Design Suite, and the run_hw_ila command.
		/// The apply_hw_ila_trigger command reads a trigger configuration file written by
		/// run_hw_ila -file and applies the various trigger settings to the ILA core in the implemented
		/// design. The trigger configuration for the ILA core then become part of the bitstream written by
		/// write_bitstream, that is used to program the Xilinx FPGA device.
		/// The process for using the trigger at startup feature includes the following steps:
		/// 1. From the Hardware Manager, use run_hw_ila -file to export the trigger register map
		/// file for the ILA core.
		/// 2. Open the implemented design, or the implemented design checkpoint.
		/// 3. Use the apply_hw_ila_trigger command to apply the trigger settings to the in-memory
		/// design.
		/// 4. Use the write_bitstream command to write the bitstream with the applied trigger
		/// configuration file.
		/// Note: Be sure to use the write_bitstream command, and not the Flow Navigator commands in the
		/// Vivado IDE.
		/// 5. Return to the Hardware Manager, and use program_hw_device to program the hw_device
		/// using the new bitstream file.
		/// Once programmed, the new ILA core should immediately arm at startup. In the Vivado logic
		/// analyzer feature, you should see the "Trigger Capture Status" for the ILA core is now populated
		/// with captured data samples if trigger events or capture conditions have occurred. Refer to the
		/// Vivado Design Suite User Guide: Vivado Programming and Debugging (UG908) for more information.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 102
		/// </summary>
		/// <param name="ila_cell">(Optional) Apply trigger settings to this ila cell</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="file">(Optional) ILA startup trigger settings file</param>
		public virtual SimpleTCLCommand apply_hw_ila_trigger(string ila_cell = null, bool? quiet = null, bool? verbose = null, string file = null)
		{
			// TCL Syntax: apply_hw_ila_trigger [-ila_cell <arg>] [-quiet] [-verbose] [<file>]
			return
				new SimpleTCLCommand("apply_hw_ila_trigger")
					.OptionalNamedString("ila_cell", ila_cell)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(file)
			;
		}
		/// <summary>
		/// Archive the current project
		///
		///
		/// TCL Syntax: archive_project [-temp_dir <arg>] [-force] [-exclude_run_results] [-include_config_settings] [-include_runs_in_progress] [-include_local_ip_cache] [-quiet] [-verbose] [<file>]
		///
		/// Archives a project to store as backup, or to encapsulate the design and send it to a remote site.
		/// The tool parses the hierarchy of the design, copies the required source files, include files, and
		/// remote files from the library directories, copies the constraint files, copies the results of the
		/// various synthesis, simulation, and implementation runs, and then creates a ZIP file of the project.
		/// TIP: In order to archive the tcl.pre and tcl.post scripts, associated with the synthesis and implementation steps
		/// in the Design Run Settings dialog box, you must add these script files to the project as design sources.
		/// An alternative method of archiving the project is using write_project_tcl to create a Tcl
		/// script that will recreate the project in its current form.
		///
		/// The following command archives the current project:
		/// archive_project
		/// Note: The project archive is named <project_name>.zip because no file name is specified.
		/// The following example specifies project_3 as the current project, and then archives that
		/// project into a file called proj3.zip:
		/// current_project project_3
		/// archive_project -force -exclude_run_results proj3.zip
		/// Note: The use of the -force argument causes the tool to overwrite the proj3.zip file if one exists. The
		/// use of the -exclude_run_results argument causes the tool to leave any results from synthesis or
		/// implementation runs out of the archive. The various runs defined in the project are included in the archive,
		/// but not any of the results.
		/// The following command archives the current project in the specified file, overwrites an existing
		/// file if needed, excludes the run results, and includes any configuration settings used when
		/// launching the Vivado tool:
		/// archive_project -force mb1_archive.zip -temp_dir C:/Data/Temp \
		/// -exclude_run_results -include_config_settings
		///
		/// See ug835-vivado-tcl-commands.pdf, page 105
		/// </summary>
		/// <param name="temp_dir">(Optional) specify temporary location to save project copy to archive Default: .</param>
		/// <param name="force">(Optional) Overwrite existing archived file</param>
		/// <param name="exclude_run_results">(Optional) Exclude run results from the archive</param>
		/// <param name="include_config_settings">
		/// (Optional)
		/// Include current project environment configuration settings/
		/// files in archive
		/// </param>
		/// <param name="include_runs_in_progress">
		/// (Optional)
		/// Include run result even if the run is in progress, this switch
		/// will be ignored if -exclude_run_results is specified
		/// </param>
		/// <param name="include_local_ip_cache">(Optional) Include IP cache results in the archive</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="file">(Optional) Name of the archive file</param>
		/// <returns>true</returns>
		public virtual SimpleTCLCommand archive_project(string temp_dir = null, bool? force = null, bool? exclude_run_results = null, bool? include_config_settings = null, bool? include_runs_in_progress = null, bool? include_local_ip_cache = null, bool? quiet = null, bool? verbose = null, string file = null)
		{
			// TCL Syntax: archive_project [-temp_dir <arg>] [-force] [-exclude_run_results] [-include_config_settings] [-include_runs_in_progress] [-include_local_ip_cache] [-quiet] [-verbose] [<file>]
			return
				new SimpleTCLCommand("archive_project")
					.OptionalNamedString("temp_dir", temp_dir)
					.Flag("force", force)
					.Flag("exclude_run_results", exclude_run_results)
					.Flag("include_config_settings", include_config_settings)
					.Flag("include_runs_in_progress", include_runs_in_progress)
					.Flag("include_local_ip_cache", include_local_ip_cache)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(file)
			;
		}
		/// <summary>
		/// Automatically assign addresses to unmapped IP
		///
		///
		/// TCL Syntax: assign_bd_address [-target_address_space <arg>] [-boundary] [-master_boundary] [-external] -dict <arg> [-import_from_file <arg>] [-export_to_file <arg>] [-export_gui_to_file <arg>] [-offset <arg>] [-range <arg>] [-base_high <arg>] [-force] [-quiet] [-verbose] [<objects>...]
		///
		/// Assign unmapped IP address segments to address spaces in the IP integrator subsystem design.
		/// If the target address space is not specified, the IP integrator will automatically assign the address
		/// segment to an available address space on a connected AXI master.
		/// If no bd_addr_seg objects are specified the assign_bd_address command will assign all
		/// unmapped address segments to any connected AXI master address spaces.
		/// This command returns the newly mapped address segments, or returns an error if it failed.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 108
		/// </summary>
		/// <param name="dict">
		/// (Required)
		/// dictionary of offset range address pairs, e.g. {offset
		/// 0x00000000 range 32K offset 0x20000000 range 32K} used to
		/// map an external interface to more than one address
		/// </param>
		/// <param name="target_address_space">(Optional) Target address space to place segment into</param>
		/// <param name="boundary">
		/// (Optional)
		/// assign peripherals to the exported slave hierarchical
		/// boundary of the design
		/// </param>
		/// <param name="master_boundary">
		/// (Optional)
		/// set hierarchical master boundary by assigning exported
		/// master interface segments to internal masters
		/// </param>
		/// <param name="external">
		/// (Optional)
		/// allow an external master interface to be mapped to more
		/// than one address
		/// </param>
		/// <param name="import_from_file">
		/// (Optional)
		/// import the addressing from file. When extension is csv,
		/// format = <address space name>,<slave
		/// segment>,<offset>,<range>
		/// </param>
		/// <param name="export_to_file">
		/// (Optional)
		/// export the address map to a file in csv format. format =
		/// <address space name>,<slave segment>,<offset>,<range>
		/// </param>
		/// <param name="export_gui_to_file">
		/// (Optional)
		/// export the address map to a file in csv format. Structure is
		/// same as Address Editor GUI
		/// </param>
		/// <param name="offset">(Optional) Offset of assignment. e.g. 0x00000000</param>
		/// <param name="range">(Optional) Range of assignment. e.g. 4096, 4K, 16M, 1G</param>
		/// <param name="base_high">
		/// (Optional)
		/// colon separated base:high offsets of a range assignment.
		/// e.g. 0x0000:0xFFFF
		/// </param>
		/// <param name="force">(Optional) force the assignment, do not run any validity checks</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">(Optional) The objects to assign</param>
		/// <returns>The newly mapped segments, "" if failed.</returns>
		public virtual SimpleTCLCommand assign_bd_address(string dict, string target_address_space = null, bool? boundary = null, bool? master_boundary = null, bool? external = null, string import_from_file = null, string export_to_file = null, string export_gui_to_file = null, string offset = null, string range = null, string base_high = null, bool? force = null, bool? quiet = null, bool? verbose = null, string objects = null)
		{
			// TCL Syntax: assign_bd_address [-target_address_space <arg>] [-boundary] [-master_boundary] [-external] -dict <arg> [-import_from_file <arg>] [-export_to_file <arg>] [-export_gui_to_file <arg>] [-offset <arg>] [-range <arg>] [-base_high <arg>] [-force] [-quiet] [-verbose] [<objects>...]
			return
				new SimpleTCLCommand("assign_bd_address")
					.OptionalNamedString("target_address_space", target_address_space)
					.Flag("boundary", boundary)
					.Flag("master_boundary", master_boundary)
					.Flag("external", external)
					.RequiredNamedString("dict", dict)
					.OptionalNamedString("import_from_file", import_from_file)
					.OptionalNamedString("export_to_file", export_to_file)
					.OptionalNamedString("export_gui_to_file", export_gui_to_file)
					.OptionalNamedString("offset", offset)
					.OptionalNamedString("range", range)
					.OptionalNamedString("base_high", base_high)
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(objects)
			;
		}
		/// <summary>
		/// Auto detect the XPM Libraries that are used in the design and set the XPM_LIBRARIES project
		/// property.
		///
		///
		/// TCL Syntax: auto_detect_xpm [-quiet] [-verbose]
		///
		/// This command collects the list of Xilinx Parameterized Macros (XPM) used in RTL design files and
		/// sets the XPM_LIBRARIES property. Because it identifies XPM used in the RTL source files, it
		/// must be used after the RTL files are read or added to the design as shown in the example.
		/// TIP: This command is intended for use in non-project mode, and is not needed for project-based flows.
		/// This command will find all the XPMs used in the user RTL and update the XPM_LIBRARIES
		/// property on the current project. Synthesis and simulation will use the XPM_LIBRARIES property
		/// to properly support these macros.
		/// This command returns nothing, or returns an error if it fails.
		///
		/// The following example reads the specified RTL file, and then uses auto_detect_xpm to define
		/// the XPM_LIBRARIES used in the files:
		/// read_verilog ../top_bgRAM_173_0.v
		/// read_xdc ../top_bgRAM_173_0.xdc
		/// auto_detect_xpm
		///
		/// See ug835-vivado-tcl-commands.pdf, page 112
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand auto_detect_xpm(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: auto_detect_xpm [-quiet] [-verbose]
			return
				new SimpleTCLCommand("auto_detect_xpm")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Issue JTAG Program command to hw_device
		///
		///
		/// TCL Syntax: boot_hw_device [-disable_done_check] [-timeout <arg>] [-quiet] [-verbose] <hw_device>
		///
		/// Issue JTAG PROGRAM command to the hw_device (FPGA).
		/// The boot_hw_device command triggers the FPGA boot and board startup sequence. The boot
		/// sequence starts the FPGA configuration process to clear the device of any prior programming,
		/// and then to load a new program, depending on the mode pin settings.
		/// The hw_device will boot based on its mode pin settings. If the FPGA's mode pins on the device
		/// are set to JTAG mode, or the interface is not active (e.g. the PROM is not configured) the net
		/// effect of the boot_hw_device command is to clear the prior programming.
		/// This command returns a 1 if it detects that the DONE pin has gone HIGH, or when the device
		/// has been cleared, otherwise it returns 0.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 114
		/// </summary>
		/// <param name="hw_device">(Required) Target hw_device connection</param>
		/// <param name="disable_done_check">(Optional) Disable done check for boot device</param>
		/// <param name="timeout">(Optional) Time out for boot (seconds) Default: default</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand boot_hw_device(string hw_device, bool? disable_done_check = null, string timeout = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: boot_hw_device [-disable_done_check] [-timeout <arg>] [-quiet] [-verbose] <hw_device>
			return
				new SimpleTCLCommand("boot_hw_device")
					.Flag("disable_done_check", disable_done_check)
					.OptionalNamedString("timeout", timeout)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_device)
			;
		}
		/// <summary>
		/// Calculate device configuration time (ms)
		///
		///
		/// TCL Syntax: calc_config_time [-verbose] [-max] [-min] [-typical] [-por_used] [-por_ramp <arg>] [-clk_freq <arg>] [-bitstream_size <arg>] [-quiet]
		///
		/// Estimates the time in milliseconds (ms) to configure a Xilinx device for the current design.
		/// TIP: The Device Configuration Mode must be defined for this command to work.
		/// Some applications require that the Xilinx device be configured and operational within a short
		/// time. This command lets you estimate the configuration time for the device and design in
		/// question. The configuration time includes the device initialization time plus the configuration
		/// time. Configuration time depends on the size of the device and speed of the configuration logic.
		/// For more information on the configuration time refer to UltraFast Design Methodology Guide for
		/// the Vivado Design Suite (UG949), the UltraScale Architecture Configuration User Guide (UG570), or
		/// the 7 Series FPGAs Configuration User Guide (UG470).
		/// Some of the settings needed to calculate the configuration time are stored as properties on the
		/// current design, such as the BITSTREAM.CONFIG.CONFIGRATE or
		/// BITSTREAM.CONFIG.EXTMASTERCCLK_EN properties. In some master modes, the FPGA
		/// provides the configuration clock to control configuration, with the nominal configuration clock
		/// frequency specified by BITSTREAM.CONFIG.CONFIGRATE. The property can be defined in the
		/// Edit Device Properties dialog box of the Vivado Design Suite IDE, or by using set_property to
		/// directly set the value of the specified property.
		/// For a slave configuration mode, or for configuration modes using an external master clock, the
		/// needed clock frequency is specified by the -clk_freq option.
		/// This command returns a value in milliseconds if successful, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 117
		/// </summary>
		/// <param name="verbose">(Optional) Print out calculation parameters</param>
		/// <param name="max">(Optional) Calculate Maximum Configuration Time</param>
		/// <param name="min">(Optional) Calculate Minimum Configuration Time</param>
		/// <param name="typical">(Optional) Calculate Typical Configuration Time</param>
		/// <param name="por_used">
		/// (Optional)
		/// (Deprecated) Specify if Power On Reset (POR) is used by
		/// using a non-zero por_ramp
		/// </param>
		/// <param name="por_ramp">
		/// (Optional)
		/// Specify a Power On Reset (POR) ramp rate as 1 ms to 50 ms
		/// Default: 0 ms
		/// </param>
		/// <param name="clk_freq">
		/// (Optional)
		/// Specify a clock frequency for Slave mode, or for Master
		/// mode if using external master clock (MHz) Default: 0 MHz
		/// </param>
		/// <param name="bitstream_size">(Optional) Specify a bitstream size to override the default Default: 0</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <returns>Report</returns>
		public virtual SimpleTCLCommand calc_config_time(bool? verbose = null, bool? max = null, bool? min = null, bool? typical = null, bool? por_used = null, string por_ramp = null, string clk_freq = null, string bitstream_size = null, bool? quiet = null)
		{
			// TCL Syntax: calc_config_time [-verbose] [-max] [-min] [-typical] [-por_used] [-por_ramp <arg>] [-clk_freq <arg>] [-bitstream_size <arg>] [-quiet]
			return
				new SimpleTCLCommand("calc_config_time")
					.Flag("verbose", verbose)
					.Flag("max", max)
					.Flag("min", min)
					.Flag("typical", typical)
					.Flag("por_used", por_used)
					.OptionalNamedString("por_ramp", por_ramp)
					.OptionalNamedString("clk_freq", clk_freq)
					.OptionalNamedString("bitstream_size", bitstream_size)
					.Flag("quiet", quiet)
			;
		}
		/// <summary>
		/// Check if a module can be referenced
		///
		///
		/// TCL Syntax: can_resolve_reference [-quiet] [-verbose] <module>...
		///
		/// This command is used to validate reference to modules prior to trying to import them into the
		/// design. Its primary use is in scripts like the script produced by the write_bd_tcl command,
		/// though you can use it in your own scripts as well.
		/// This command returns 0 if the reference cannot be resolved, or returns 1 if it can be resolved.
		///
		/// This example determines if the reference to the specified module can be resolved:
		/// can_resolve_reference clk_div
		///
		/// See ug835-vivado-tcl-commands.pdf, page 120
		/// </summary>
		/// <param name="module">(Required) module name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand can_resolve_reference(string module, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: can_resolve_reference [-quiet] [-verbose] <module>...
			return
				new SimpleTCLCommand("can_resolve_reference")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(module)
			;
		}
		/// <summary>
		/// Check HDL syntax in the supplied fileset or active fileset.
		///
		///
		/// TCL Syntax: check_syntax [-fileset <arg>] [-return_string] [-quiet] [-verbose]
		///
		/// Parses Verilog, SystemVerilog, and VHDL source files and generates syntax warnings and error
		/// messages for the design.
		/// TIP: The syntax is also checked automatically as the file is edited in the Vivado text editor, or when the file is
		/// saved.
		/// This command returns warnings or errors related to the files it examines, or returns nothing if no
		/// problems are found.
		///
		/// The following example checks the syntax of files in the simulation fileset:
		/// check_syntax -fileset sim_1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 122
		/// </summary>
		/// <param name="fileset">(Optional) Fileset to check for syntax</param>
		/// <param name="return_string">(Optional) Return the syntax check messages as a string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand check_syntax(string fileset = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: check_syntax [-fileset <arg>] [-return_string] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("check_syntax")
					.OptionalNamedString("fileset", fileset)
					.Flag("return_string", return_string)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Check the design for possible timing problems
		///
		///
		/// TCL Syntax: check_timing [-file <arg>] [-no_header] [-loop_limit <arg>] [-append] [-name <arg>] [-override_defaults <args>] [-include <args>] [-exclude <args>] [-return_string] [-rpx <arg>] [-cells <args>] [-verbose] [-quiet]
		///
		/// Checks the design elements of ports, pins, and paths, against the current timing constraints. Use
		/// this command to identify possible problems with design data and timing constraints before
		/// running the report_timing command. The check_timing command runs a series of default
		/// timing checks, and reports a summary of any violations found. To get detailed information about
		/// violations, use the -verbose option.
		/// Note: By default the report is written to the Tcl console or STD output. However, the results can also be
		/// written to the GUI with the -name option, or to a file with -file.
		/// Default Timing Checks:
		/// • constant_clock - Checks for clock signals connected to a constant signal (gnd/vss/data).
		/// • generated_clocks - Checks for loops, or circular definitions within the generated clock
		/// network. This check will return an error if a generated clock uses a second generated clock as
		/// its source, when the second generated clock uses the first clock as its source.
		/// • latch_loops - Checks for and warns of combinational latch loops in the design.
		/// • loops - Checks for and warns of combinational feedback loops in the design.
		/// • multiple_clock - Warns if multiple clocks reach a register clock pin. If more than one clock
		/// signal reaches a register clock pin it is unclear which clock will be used for analysis. In this
		/// case, use the set_case_analysis command so that only one clock will propagate to the
		/// register clock pin.
		/// • no_clock - Reports unclocked registers. In this case, no setup or hold checks are performed
		/// on data pins related to the register clock pin.
		/// • no_input_delay - Reports the input ports without an input delay constraint. Input delays
		/// can be assigned using the set_input_delay command. Input ports that are unclocked will
		/// not be checked for input delays.
		/// • no_output_delay - Reports the output ports without an output delay constraint. Output
		/// delays can be assigned using the set_output_delay command. Output ports that are
		/// unclocked will not be checked for output delays.
		/// • partial_input_delay - Reports the input ports having partially defined input delay
		/// constraints. Assigning set_input_delay -max or set_input_delay -min to an input
		/// port, without assigning the other, creates a partially defined input delay. In such cases, paths
		/// starting from the input port may become unconstrained and no timing checks will be done
		/// against the port. Assigning set_input_delay without specifying either -min or -max
		/// allows the tool to assume both min and max delays, and so does not result in a partial input
		/// delay.
		/// Note: Unclocked input ports are not checked for partial input delays.
		/// • partial_output_delay - Reports the output ports having partially defined output delay
		/// constraints. Assigning set_output_delay -max or set_output_delay -min to an
		/// output port, without assigning the other, creates a partially defined output delay. In such
		/// cases, paths reaching the port may become unconstrained and no timing checks will be done
		/// against the port. Assigning set_output_delay without specifying either -min or -max
		/// allows the tool to assume both min and max delays, and so does not result in a partial output
		/// delay.
		/// Note: Unclocked output ports are not checked for partial output delays.
		/// • pulse_width_clock - Reports clock pins that have only a pulse width check associated
		/// with the pin, and no setup or hold check, no recovery, removal, or clk->Q check.
		/// • unconstrained_internal_endpoints - This warning identifies timing path endpoints at
		/// register data pins that are not constrained. Endpoints at register data pins are constrained by
		/// clock assignment using the create_clock command. Endpoints at output ports are checked
		/// and reported by the no_output_delay check.
		/// • unexpandable_clocks - Reports clock sets in which the period is not expandable with
		/// respect to each other, when there is at least 1 path between the clock sets. A clock is
		/// unexpandable if no common multiples are found within 1000 cycles between the source and
		/// destination clocks.
		///
		/// The following example runs check_timing, but excludes the specified checks from the default
		/// timing checks:
		/// check_timing -exclude {loops generated_clocks}
		/// The following example uses the -verbose argument to obtain detailed results running just the
		/// multiple_clocks check, and then uses get_clocks to look further into the issue:
		/// check_timing -verbose -override_defaults {multiple_clock}
		/// Checking multiple_clock.
		/// There are 2 register/latch pins with multiple clocks.
		/// procEngine/mode_du/set_reg[0]/C
		/// provEngine/mode_du/set_reg[1]/C
		/// get_clocks -of_objects [get_pin procEngine/mode_du/set_reg[0]/C]
		/// sysClk coreClk
		///
		/// See ug835-vivado-tcl-commands.pdf, page 124
		/// </summary>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="no_header">(Optional) do not generate a report header</param>
		/// <param name="loop_limit">(Optional) Limit the number of loops reported for loops check Default: 100</param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="override_defaults">(Optional) Overrides the checks in the default timing checks listed below</param>
		/// <param name="include">
		/// (Optional)
		/// Add this list of checks to be performed along with default
		/// timing checks listed below
		/// </param>
		/// <param name="exclude">
		/// (Optional)
		/// Exclude this list of checks to be performed from the default
		/// timing checks listed below
		/// </param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="rpx">(Optional) Filename to output interactive results to.</param>
		/// <param name="cells">(Optional) run check_timing on the specified cell(s)</param>
		/// <param name="verbose">(Optional) Return a detailed list of all timing problems found</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		public virtual SimpleTCLCommand check_timing(string file = null, bool? no_header = null, string loop_limit = null, bool? append = null, string name = null, string override_defaults = null, string include = null, string exclude = null, bool? return_string = null, string rpx = null, string cells = null, bool? verbose = null, bool? quiet = null)
		{
			// TCL Syntax: check_timing [-file <arg>] [-no_header] [-loop_limit <arg>] [-append] [-name <arg>] [-override_defaults <args>] [-include <args>] [-exclude <args>] [-return_string] [-rpx <arg>] [-cells <args>] [-verbose] [-quiet]
			return
				new SimpleTCLCommand("check_timing")
					.OptionalNamedString("file", file)
					.Flag("no_header", no_header)
					.OptionalNamedString("loop_limit", loop_limit)
					.Flag("append", append)
					.OptionalNamedString("name", name)
					.OptionalNamedString("override_defaults", override_defaults)
					.OptionalNamedString("include", include)
					.OptionalNamedString("exclude", exclude)
					.Flag("return_string", return_string)
					.OptionalNamedString("rpx", rpx)
					.OptionalNamedString("cells", cells)
					.Flag("verbose", verbose)
					.Flag("quiet", quiet)
			;
		}
		/// <summary>
		/// Create a VCD checkpoint (equivalent of Verilog $dumpall system task)
		///
		///
		/// TCL Syntax: checkpoint_vcd [-quiet] [-verbose]
		///
		/// The checkpoint_vcd command inserts current HDL object signal values into the Value Change
		/// Dump (VCD) file. Nothing is returned. This Tcl command is the equivalent of the Verilog
		/// $dumpall system task, providing the initial values of the specified signals.
		/// VCD is an ASCII file containing header information, variable definitions, and value change details
		/// of a set of HDL signals. The VCD file can be used to view simulation result in a VCD viewer or to
		/// estimate the power consumption of the design. See the IEEE Standard for Verilog Hardware
		/// Description Language (IEEE Std 1364-2005) for a description of the VCD file format.
		/// You must execute the open_vcd and log_vcd commands before using the checkpoint_vcd
		/// command. After you execute the checkpoint_vcd command, run or rerun the simulation to
		/// capture the signal values.
		///
		/// The following is an example of the checkpoint_vcd command where the command dumps
		/// signal values of specified HDL objects into the open VCD file:
		/// checkpoint_vcd
		///
		/// See ug835-vivado-tcl-commands.pdf, page 129
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand checkpoint_vcd(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: checkpoint_vcd [-quiet] [-verbose]
			return
				new SimpleTCLCommand("checkpoint_vcd")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Close a design.
		///
		///
		/// TCL Syntax: close_bd_design [-quiet] [-verbose] <name>
		///
		/// Closes the specified IP subsystem design in the IP integrator of the Vivado Design Suite.
		/// If the design has been modified, you will not be prompted to save the design prior to closing. You
		/// will need to run save_bd_design to save any changes made to the design before using the
		/// close_bd_design command.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 131
		/// </summary>
		/// <param name="name">(Required) Name of design to close</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The design object, "" if failed.</returns>
		public virtual SimpleTCLCommand close_bd_design(string name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: close_bd_design [-quiet] [-verbose] <name>
			return
				new SimpleTCLCommand("close_bd_design")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
			;
		}
		/// <summary>
		/// Close the current design
		///
		///
		/// TCL Syntax: close_design [-quiet] [-verbose]
		///
		/// Closes the currently active design. If the design has been modified, you will not be prompted to
		/// save the design prior to closing. You will need to run save_design or save_design_as to
		/// save any changes made to the design before using the close_design command.
		///
		/// The following example closes the current design:
		/// close_design
		/// Note: If multiple designs are open, you can specify the current design with the current_design
		/// command prior to using close_design.
		/// The following example sets the current design, then closes it:
		/// current_design rtl_1
		/// close_design
		/// current_design sets rtl_1 as the active design, then the close_design command closes
		/// it.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 133
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand close_design(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: close_design [-quiet] [-verbose]
			return
				new SimpleTCLCommand("close_design")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Close the hardware tool
		///
		///
		/// TCL Syntax: close_hw_manager [-quiet] [-verbose]
		///
		/// Close the Hardware Manager tool in the Vivado Design Suite.
		/// Opening the Hardware Manager using the open_hw_manager command, is the first step in
		/// programming and/or debugging your design in Xilinx FPGA hardware. For more information refer
		/// to the Vivado Design Suite User Guide: Programming and Debugging (UG908).
		///
		/// See ug835-vivado-tcl-commands.pdf, page 135
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand close_hw_manager(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: close_hw_manager [-quiet] [-verbose]
			return
				new SimpleTCLCommand("close_hw_manager")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Close a hardware target
		///
		///
		/// TCL Syntax: close_hw_target [-quiet] [-verbose] [<hw_target>]
		///
		/// Close the connection to the current or specified hardware target that was previously opened
		/// using the open_hw_target command.
		/// The hardware target is a system board containing a JTAG chain of one or more Xilinx devices that
		/// you can program with a bitstream file, or use to debug your design. Connections between
		/// hardware targets on the system board and the Vivado Design Suite are managed by the
		/// hw_server application. Refer to Vivado Design Suite User Guide: Programming and Debugging
		/// (UG908) for a list of supported JTAG download cables and devices.
		/// This command returns connection messages from the hardware server, or returns an error if it
		/// fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 137
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_target">(Optional) hardware target Default: current hardware target</param>
		public virtual SimpleTCLCommand close_hw_target(bool? quiet = null, bool? verbose = null, string hw_target = null)
		{
			// TCL Syntax: close_hw_target [-quiet] [-verbose] [<hw_target>]
			return
				new SimpleTCLCommand("close_hw_target")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(hw_target)
			;
		}
		/// <summary>
		/// Close current opened project
		///
		///
		/// TCL Syntax: close_project [-delete] [-quiet] [-verbose]
		///
		/// Closes the current open project.
		/// TIP: Any user-defined Tcl variables that are in the global namespace (i.e. not in a project-specific namespace)
		/// are not reset or cleared by this command. Global variables are persistent with the invocation of Vivado and are
		/// only cleared when the Vivado Design Suite is closed. You can also use the unset command to expressly clear a
		/// specific Tcl variable.
		///
		/// The following command closes the active project:
		/// close_project
		/// This example closes the current project. If you have multiple projects open, the
		/// close_project command applies to the current project which can be defined with the
		/// current_project command.
		/// The following example sets project_1 as the current project, and then closes the project and
		/// deletes it from the computer hard disk:
		/// current_project project_1
		/// close_project -delete
		/// Note: Use the -delete argument with caution. You will not be prompted to confirm the deletion of
		/// project data.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 139
		/// </summary>
		/// <param name="delete">(Optional) Delete the project from disk also</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand close_project(bool? delete = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: close_project [-delete] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("close_project")
					.Flag("delete", delete)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Flush SAIF toggle information to the SAIF output file and close the file
		///
		///
		/// TCL Syntax: close_saif [-quiet] [-verbose]
		///
		/// Closes the open SAIF file.
		/// Only one SAIF file can be open in the Vivado simulator at one time, using open_saif. You must
		/// close the currently opened SAIF file before opening another file.
		/// This command returns nothing if it is successful, or an error if it fails.
		///
		/// The following is an example:
		/// close_saif
		///
		/// See ug835-vivado-tcl-commands.pdf, page 141
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand close_saif(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: close_saif [-quiet] [-verbose]
			return
				new SimpleTCLCommand("close_saif")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Unload the current simulation without exiting Vivado
		///
		///
		/// TCL Syntax: close_sim [-force] [-quiet] [-verbose]
		///
		/// Close the current Vivado simulation.
		/// Note: This command does not support third party simulators.
		///
		/// The following example closes the current simulation, forcing the close even if changes would be
		/// lost:
		/// close_sim -force
		///
		/// See ug835-vivado-tcl-commands.pdf, page 143
		/// </summary>
		/// <param name="force">
		/// (Optional)
		/// Forces the closing of the simulation, even if changes would
		/// be lost. Default behavior is to reject the closing with an error
		/// if changes would be lost.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand close_sim(bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: close_sim [-force] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("close_sim")
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Flush VCD information to the VCD output file and close the file
		///
		///
		/// TCL Syntax: close_vcd [-quiet] [-verbose]
		///
		/// Closes the open Value Change Dump (VCD) file.
		/// Only one VCD file can be open in the Vivado simulator at one time. You must close the currently
		/// opened VCD file before opening another file.
		///
		/// The following example closes the current VCD object:
		/// close_vcd
		///
		/// See ug835-vivado-tcl-commands.pdf, page 145
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand close_vcd(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: close_vcd [-quiet] [-verbose]
			return
				new SimpleTCLCommand("close_vcd")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Closes the wave config
		///
		///
		/// TCL Syntax: close_wave_config [-force] [-quiet] [-verbose] [<wcfgobj>]
		///
		/// Close the current, or specified wave configuration.
		/// In the Vivado® simulator GUI, you can work with a waveform to analyze your design and debug
		/// your code. A wave configuration object displays with top-level HDL objects, and can be further
		/// populated using commands like add_wave and add_wave_divider. A new wave
		/// configuration object can be created in the current simulation with the create_wave_config
		/// command.
		/// Any changes made to a wave configuration object can be saved to a Wave Config file with the
		/// save_wave_config command. You can open a saved Wave Config file with the
		/// open_wave_config command.
		///
		/// The following example closes all Wave Config files associated with the current simulation:
		/// close_wave_config [get_wave_configs]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 147
		/// </summary>
		/// <param name="force">
		/// (Optional)
		/// Forces the closing of the wave configuration, even if
		/// changes would be lost. Default behavior is to reject the
		/// closing with an error if changes would be lost.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="wcfgobj">
		/// (Optional)
		/// Closes and destroys the specified wave configuration object,
		/// or the current wave configuration if none specified Default:
		/// NULL
		/// </param>
		public virtual SimpleTCLCommand close_wave_config(bool? force = null, bool? quiet = null, bool? verbose = null, string wcfgobj = null)
		{
			// TCL Syntax: close_wave_config [-force] [-quiet] [-verbose] [<wcfgobj>]
			return
				new SimpleTCLCommand("close_wave_config")
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(wcfgobj)
			;
		}
		/// <summary>
		/// Commit the property changes of the current hardware object. Inputs can be HBM or device
		/// hardware object. At least one object is required.
		///
		///
		/// TCL Syntax: commit_hw_hbm [-quiet] [-verbose] <hw_objects>
		///
		/// Commit the current values of properties defined on the specified HBM controller in the Vivado
		/// hardware manager to the current hardware device.
		/// The commit_hw_hbm command takes the current property values defined on a hw_hbm object
		/// and commits them to the current hardware device connected to the hardware server.
		/// When you change the property values on the hw_hbm object, they are not written to the
		/// hardware device until you use the commit_hw_hbm command.
		/// This command returns nothing if successful, or returns an error if it fails.
		///
		/// The following example changes a property of the specified HBM controller object, and then
		/// commits the change to the device:
		/// set_property MC2.INIT.AM_REPEAT_EN 1 [get_hw_hbms *HBM_2]
		/// commit_hw_hbm [get_hw_hbm *HBM_2]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 149
		/// </summary>
		/// <param name="hw_objects">(Required) hardware objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand commit_hw_hbm(string hw_objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: commit_hw_hbm [-quiet] [-verbose] <hw_objects>
			return
				new SimpleTCLCommand("commit_hw_hbm")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_objects)
			;
		}
		/// <summary>
		/// Commit the property changes of the current hardware object. Inputs can be any mig, device,
		/// target, or server hardware object. At least one object is required.
		///
		///
		/// TCL Syntax: commit_hw_mig [-quiet] [-verbose] <hw_objects>
		///
		/// Commit the current values of properties defined on the specified memory IP debug core
		/// hardware objects in the Hardware Manager feature of the Vivado Design Suite to the current
		/// hardware device.
		/// The commit_hw_mig command takes the current property values defined on a hw_mig object in
		/// the Vivado logic analyzer, and commits them to the current hardware device connected to the
		/// hardware server.
		/// When you change the property values on the hw_mig object, like the CONFIG.* properties, they
		/// are not written to the hardware device until you use the commit_hw_mig command.
		/// This command returns nothing if successful, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 151
		/// </summary>
		/// <param name="hw_objects">(Required) hardware objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand commit_hw_mig(string hw_objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: commit_hw_mig [-quiet] [-verbose] <hw_objects>
			return
				new SimpleTCLCommand("commit_hw_mig")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_objects)
			;
		}
		/// <summary>
		/// Commit the property changes of the current hardware object. Inputs can be any serial I/O
		/// (except scan and sweep), device, target, or server hardware object. At least one object is required.
		///
		///
		/// TCL Syntax: commit_hw_sio [-quiet] [-verbose] <hw_objects>
		///
		/// Commit the current values of properties defined on the specified serial I/O hardware objects in
		/// the Hardware Manager feature of the Vivado Design Suite to the current hardware device.
		/// Specified objects can include any serial I/O object such as GTs, RXs, TXs, PLLs, or Commons,
		/// excluding hw_sio_scan and hw_sio_sweep objects. SIO objects also include device, target, or
		/// server hardware objects.
		/// The SIO IBERT core operates on an object property-based set/commit use model. You can set
		/// the property values on the hardware objects using the set_property command. You can then
		/// drive those values onto the current hardware device using the commit_hw_sio command.
		/// TIP: To update the properties on the hardware object with the actual value on the device use the
		/// refresh_hw_sio command.
		/// This command returns nothing if successful, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 153
		/// </summary>
		/// <param name="hw_objects">(Required) hardware objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand commit_hw_sio(string hw_objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: commit_hw_sio [-quiet] [-verbose] <hw_objects>
			return
				new SimpleTCLCommand("commit_hw_sio")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_objects)
			;
		}
		/// <summary>
		/// Commit the property changes of the current hardware object. Inputs can be hw_server,
		/// hw_target, hw_device or hw_sysmon objects. At least one object is required.
		///
		///
		/// TCL Syntax: commit_hw_sysmon [-quiet] [-verbose] <hw_objects>
		///
		/// The commit_hw_sysmon command takes the current property values defined on a hw_sysmon
		/// object, and commits them to the system monitor registers on the hardware device.
		/// When you change the property values on the hw_sysmon object, like the CONFIG.* properties,
		/// they are not written to the hardware device until you use the commit_hw_sysmon command.
		/// This command returns nothing if successful, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 155
		/// </summary>
		/// <param name="hw_objects">(Required) hardware objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand commit_hw_sysmon(string hw_objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: commit_hw_sysmon [-quiet] [-verbose] <hw_objects>
			return
				new SimpleTCLCommand("commit_hw_sysmon")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_objects)
			;
		}
		/// <summary>
		/// Write hardware VIO probe OUTPUT_VALUE properties values to VIO core(s).
		///
		///
		/// TCL Syntax: commit_hw_vio [-quiet] [-verbose] <hw_objects>...
		///
		/// Commit the current values defined on the probes of the VIO Debug core to the current hardware
		/// device.
		/// The Virtual Input/Output (VIO) debug core can both monitor and drive internal signals on a
		/// programmed Xilinx FPGA in real time. The VIO core uses hardware probes, hw_probe objects, to
		/// monitor and drive signals on the device. Input probes monitor signals as inputs to the VIO core.
		/// Output probes drive signals to specified values from the VIO core.
		/// The VIO core operates on an object property-based set/commit use model. You can set the
		/// OUTPUT_VALUE property on the output probes of the VIO core using the set_property
		/// command. You can then drive those values onto probed signals on the hardware device using the
		/// commit_hw_vio command.
		/// This command returns nothing if successful, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 157
		/// </summary>
		/// <param name="hw_objects">(Required) List of hardware VIO and hardware probe objects.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand commit_hw_vio(string hw_objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: commit_hw_vio [-quiet] [-verbose] <hw_objects>...
			return
				new SimpleTCLCommand("commit_hw_vio")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_objects)
			;
		}
		/// <summary>
		/// Compile C code into RTL
		///
		///
		/// TCL Syntax: compile_c [-force] [-quiet] [-verbose] <objects>
		///
		/// In IP cores that are imported from Vivado HLS, the compile_c command detects C, C++, and
		/// SystemC files and converts those files to RTL for synthesis by the Vivado Design Suite.
		/// This lets you use Vivado HLS to describe IP cores in a high-level language, like C or C++ rather
		/// than RTL.
		/// When HLS-based IP cores are generated, they only deliver the C source. When the HLS-based IP
		/// is synthesized, either in the out-of-context flow, or with the top-level design, the compile_c
		/// command launches Vivado HLS to convert the C source files into RTL, and import the resulting
		/// RTL sources back into the design prior to synthesis.
		/// RECOMMENDED: The compile_c command is automatically called by the Vivado Design Suite when it
		/// encounters IP with C code from the Vivado HLS system. You should not need to manually call this command.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 159
		/// </summary>
		/// <param name="objects">(Required) The objects which need C to RTL conversion</param>
		/// <param name="force">(Optional) Force generate product state regeneration</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand compile_c(string objects, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: compile_c [-force] [-quiet] [-verbose] <objects>
			return
				new SimpleTCLCommand("compile_c")
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Compile simulation libraries
		///
		///
		/// TCL Syntax: compile_simlib [-directory <arg>] [-family <arg>] [-force] [-language <arg>] [-library <arg>] [-print_library_info <arg>] -simulator <arg> [-simulator_exec_path <arg>] [-source_library_path <arg>] [-no_ip_compile] [-32bit] [-quiet] [-verbose]
		///
		/// Compile Xilinx® simulation libraries for the cells and IP used in the current project, or from a
		/// specified directory for use in multiple design projects.
		/// The Vivado Design Suite provides simulation models as a set of files and libraries that contain the
		/// behavioral and timing models for use by the Vivado simulator. The compile_simlib command
		/// compiles these libraries for use by third-party simulators prior to design simulation. Libraries
		/// must generally be compiled or recompiled with a new software release to update simulation
		/// models and to support a new version of a simulator.
		/// IMPORTANT! You should rerun the compile_simlib command any time a new third party simulator will be
		/// used, or a new Vivado Design Suite version or update is installed.
		/// When this command is run from a current project, the tool will use the device family, target
		/// language, and library settings specified by the project as the default values, rather than the
		/// default settings of the command defined below. The default settings can be overridden by
		/// specifying the necessary options when the command is run.
		/// The compile_simlib command uses simulator compilation directives when compiling the
		/// simulation libraries. You can edit the default configuration settings using the
		/// config_compile_simlib command.
		/// The command returns information related to the compiled libraries, or an error if it fails.
		///
		/// The following example shows how to compile UNISIM and SIMPRIM libraries for ModelSim
		/// (VHDL) for a design using a Virtex-7 device:
		/// compile_simlib -simulator modelsim -family virtex7 -library unisim \
		/// -library simprim -language vhdl
		///
		/// See ug835-vivado-tcl-commands.pdf, page 161
		/// </summary>
		/// <param name="simulator">(Required) Compile libraries for this simulator</param>
		/// <param name="directory">(Optional) Directory path for saving the compiled results Default: .</param>
		/// <param name="family">(Optional) Select device architecture Default: all</param>
		/// <param name="force">(Optional) Overwrite the pre-compiled libraries</param>
		/// <param name="language">(Optional) Compile libraries for this language Default: all</param>
		/// <param name="library">(Optional) Select library to compile Default: all</param>
		/// <param name="print_library_info">(Optional) Print Pre-Compiled library information</param>
		/// <param name="simulator_exec_path">(Optional) Use simulator executables from this directory</param>
		/// <param name="source_library_path">
		/// (Optional)
		/// If specified, this directory will be searched for the library
		/// source files before searching the default path(s) found in
		/// environment variable XILINX_VIVADO for Vivado
		/// </param>
		/// <param name="no_ip_compile">(Optional) Do not compile IP static files from repository</param>
		/// <param name="_32bit">(Optional) Perform the 32-bit compilation</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand compile_simlib(string simulator, string directory = null, string family = null, bool? force = null, string language = null, string library = null, string print_library_info = null, string simulator_exec_path = null, string source_library_path = null, bool? no_ip_compile = null, bool? _32bit = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: compile_simlib [-directory <arg>] [-family <arg>] [-force] [-language <arg>] [-library <arg>] [-print_library_info <arg>] -simulator <arg> [-simulator_exec_path <arg>] [-source_library_path <arg>] [-no_ip_compile] [-32bit] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("compile_simlib")
					.OptionalNamedString("directory", directory)
					.OptionalNamedString("family", family)
					.Flag("force", force)
					.OptionalNamedString("language", language)
					.OptionalNamedString("library", library)
					.OptionalNamedString("print_library_info", print_library_info)
					.RequiredNamedString("simulator", simulator)
					.OptionalNamedString("simulator_exec_path", simulator_exec_path)
					.OptionalNamedString("source_library_path", source_library_path)
					.Flag("no_ip_compile", no_ip_compile)
					.Flag("32bit", _32bit)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Configure settings for compile_simlib
		///
		///
		/// TCL Syntax: config_compile_simlib [-cfgopt <arg>] [-simulator <arg>] [-reset] [-quiet] [-verbose]
		///
		/// Configure third party simulator options for use by the compile_simlib command.
		/// The Vivado Design Suite has a pre-defined configuration file for the compile_simlib
		/// command, with compilation options defined for supported third-party simulators, languages, and
		/// libraries. The config_compile_simlib command is provided to let you change the
		/// configuration options for specific combinations of simulator, language, and library.
		/// Use the config_compile_simlib command without any arguments to return all current
		/// configuration options.
		///
		/// The following example configures the compilation options for the Modelsim simulator, Verilog
		/// language, and Unisim library:
		/// config_compile_simlib -cfgopt {modelsim.verilog.unisim: -quiet}
		/// The following example configures the compilation options for multiple simulation libraries:
		/// config_compile_simlib -cfgopt {modelsim.verilog.synopsys: -quiet} \
		/// -cfgopt {modelsim.verilog.simprim:-source +define+XIL_TIMING}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 166
		/// </summary>
		/// <param name="cfgopt">(Optional) Configuration option in form of simulator.language.library.options</param>
		/// <param name="simulator">(Optional) Display the configurations for specified simulator</param>
		/// <param name="reset">(Optional) Reset all configurations</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand config_compile_simlib(string cfgopt = null, string simulator = null, bool? reset = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: config_compile_simlib [-cfgopt <arg>] [-simulator <arg>] [-reset] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("config_compile_simlib")
					.OptionalNamedString("cfgopt", cfgopt)
					.OptionalNamedString("simulator", simulator)
					.Flag("reset", reset)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// This command configures general features of design analysis.
		///
		///
		/// TCL Syntax: config_design_analysis [-max_common_paths <arg>] [-quiet] [-verbose]
		///
		/// This command configures features of the report_design_analysis command.
		/// The design analysis report analyzes timing paths at various stages in the Vivado tool flow,
		/// including synthesis, optimization, placement, routing. The -max_common_paths option
		/// specifies how many setup timing paths to capture at each stage in the flow.
		/// Note: This command returns nothing if successful, or returns an error if it fails.
		///
		/// The following example ignores the package delays during timing analysis:
		/// config_design_analysis 500
		///
		/// See ug835-vivado-tcl-commands.pdf, page 169
		/// </summary>
		/// <param name="max_common_paths">
		/// (Optional)
		/// Number of paths to consider for finding common paths
		/// across phases (< 20000) Default: 1000
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand config_design_analysis(string max_common_paths = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: config_design_analysis [-max_common_paths <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("config_design_analysis")
					.OptionalNamedString("max_common_paths", max_common_paths)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Configure the device GTs for the specified device.
		///
		///
		/// TCL Syntax: config_hw_sio_gts [-dict <args>] [-quiet] [-verbose] <hw_device>
		///
		/// See ug835-vivado-tcl-commands.pdf, page 171
		/// </summary>
		/// <param name="hw_device">(Required) hardware device object</param>
		/// <param name="dict">
		/// (Optional)
		/// list of name/value pairs of GT settings and values to use to
		/// configure GTs
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand config_hw_sio_gts(string hw_device, string dict = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: config_hw_sio_gts [-dict <args>] [-quiet] [-verbose] <hw_device>
			return
				new SimpleTCLCommand("config_hw_sio_gts")
					.OptionalNamedString("dict", dict)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_device)
			;
		}
		/// <summary>
		/// Configure Implementation
		///
		///
		/// TCL Syntax: config_implementation [-quiet] [-verbose] [<list>]
		///
		/// This command lets you configure implementation parameters to control the behavior of the
		/// implementation process.
		/// The list of properties that can be configured, or have been configured by this command can be
		/// reported by the report_config_implementation command.
		///
		/// The following example configures implementation parameters:
		/// config_implementation { {incr.ignore_user_clock_uncertainty True}
		/// {<other_param> <other_value>} }
		///
		/// See ug835-vivado-tcl-commands.pdf, page 172
		/// </summary>
		/// <param name="list">(Required) list of config params which need to be configured</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand config_implementation(string list, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: config_implementation [-quiet] [-verbose] [<list>]
			return
				new SimpleTCLCommand("config_implementation")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(list)
			;
		}
		/// <summary>
		/// Manage the IP instance Synthesis cache. Lists out the IP Cache entries if no options are specified.
		///
		///
		/// TCL Syntax: config_ip_cache [-use_cache_location <arg>] [-use_project_cache] [-disable_cache] [-clear_output_repo] [-clear_local_cache] [-cache_has_match] [-cache_was_used] [-get_id] [-remove] [-vlnv <arg>] [-old_swvers] [-unused] [-swver <arg>] [-num_days_old <arg>] [-num_days_unused <arg>] [-obs_synth_crc] [-disk_usage_output_repo] [-report] [-rptfile <arg>] [-csvfile <arg>] [-import_from_project] [-filter <arg>] [-regexp] [-nocase] [-purge] [-quiet] [-verbose] [<ip>]
		///
		/// This command lets you manage the Vivado Design Suite out-of-context (OOC) IP cache. The
		/// Vivado Design Suite caches the synthesis results for customized OOC IP in an IP repository, so
		/// multiple IP that use the same customization profile can share OOC synthesis results to decrease
		/// run time. The cached synthesis results can be reused in a single project from the project cache, or
		/// across multiple projects using a remote cache location.
		/// When generating the synthesis output products for an OOC IP, if a matching IP customization is
		/// found in the IP repository, the cached synthesis results will be used. If no suitable match is found
		/// in the IP repository, the synthesis output products will be generated as usual and the results,
		/// including the design checkpoint (DCP), will be copied into the IP synthesis cache for future use.
		/// TIP: When cached results are used, an information message is displayed in the Tcl console indicating the IP
		/// cache location used.
		/// You can specify a repository of cached IP synthesis results either within the current project, or at
		/// an external location. The location of the IP cache is defined by the IP_OUTPUT_REPO property
		/// on a project, with the value of a string defining a valid file system directory. You can set this
		/// property using the check_ip_cache command with either the -use_cache_location or
		/// the -use_project_cache options. The default IP synthesis cache location is in the current
		/// project folders.
		/// The use of the IP synthesis cache is controlled by the IP_CACHE_PERMISSIONS property that
		/// can be set with the set_property command. The current values are:
		/// • disabled - Do not use the IP synthesis cache. This is the default setting.
		/// • read - Use the IP synthesis cache to read OOC synthesis results from and apply as appropriate
		/// in the current project.
		/// • write - Use the IP synthesis cache to write OOC synthesis results into, but do not use them to
		/// read IP into the current project.
		/// • read write - Use the IP synthesis cache for both writing results to, and using those results in
		/// the current project.
		/// The config_ip_cache command should be followed by the update_ip_catalog command
		/// to read the specified IP cache repository into the Vivado tool.
		/// TIP: The IP synthesis cache can be enabled, and the cache repository specified, in the Vivado Design Suite IDE
		/// using the Settings dialog box. Refer to the Vivado Design Suite User Guide: Designing with IP (UG896) for more
		/// information on using the cache.
		/// By default, without any of the arguments specified below, the config_ip_cache command
		/// returns a list of entries in the IP synthesis cache, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 174
		/// </summary>
		/// <param name="use_cache_location">(Optional) Set current project properties to use the specified cache location</param>
		/// <param name="use_project_cache">
		/// (Optional)
		/// Set current project properties to use the default project IP
		/// cache location
		/// </param>
		/// <param name="disable_cache">(Optional) Disable cache use.</param>
		/// <param name="clear_output_repo">
		/// (Optional)
		/// Delete from disk and in memory all cache entries that exist
		/// in the current project's designated cache (local or remote).
		/// </param>
		/// <param name="clear_local_cache">
		/// (Optional)
		/// Delete from disk and in memory all local cache entries for
		/// this project.
		/// </param>
		/// <param name="cache_has_match">
		/// (Optional)
		/// Returns the cache-ID of the cache entry that would work for
		/// this IP instance; else ''.
		/// </param>
		/// <param name="cache_was_used">
		/// (Optional)
		/// Returns '1' if the cache was used to obtain the IP's current
		/// synthesis results; else '0'.
		/// </param>
		/// <param name="get_id">(Optional) Calculate and return IP cache ID string for specified <ip></param>
		/// <param name="remove">
		/// (Optional)
		/// Remove the corresponding cache entry for the specified IP
		/// instance or specified cachedInst; return cache ID string if
		/// successful, otherwise blank.
		/// </param>
		/// <param name="vlnv">
		/// (Optional)
		/// Used with -purge or -get_resource_data, specifies the VLNV
		/// of the cache entries to delete or find. May use a wildcard
		/// ('*') in one or more fields in the VLNV.
		/// </param>
		/// <param name="old_swvers">
		/// (Optional)
		/// Used with -purge to delete cache entries created with old
		/// Vivado SW Versions.
		/// </param>
		/// <param name="unused">(Optional) Used with -purge to delete cache entries that have never been used.</param>
		/// <param name="swver">
		/// (Optional)
		/// Used with -purge to delete any cache entries created from
		/// this specific Vivado SW Version (i.e., '2017.1').
		/// </param>
		/// <param name="num_days_old">
		/// (Optional)
		/// Used with -purge to delete any cache entries that are this
		/// number of days old or older.
		/// </param>
		/// <param name="num_days_unused">
		/// (Optional)
		/// Used with -purge to delete any cache entries that have not
		/// been used for this number of days or longer.
		/// </param>
		/// <param name="obs_synth_crc">
		/// (Optional)
		/// Used with -purge to delete cache entries whose component
		/// synth checksum is not the same as the IP Catalog's current
		/// component synthesis checksum.
		/// Name Description
		/// </param>
		/// <param name="disk_usage_output_repo">
		/// (Optional)
		/// Return total disk usage in MB for all cache entries in the
		/// current project's ip_output_repo.
		/// </param>
		/// <param name="report">
		/// (Optional)
		/// Report cache statistics for the specified IP or cache object,
		/// or for the current cache location if none specified. If -rptfile
		/// is specified, write statistics to that file. If -dir is specified,
		/// write statistics for cache entries found under that directory.
		/// </param>
		/// <param name="rptfile">
		/// (Optional)
		/// Used with -report, specifies the text file to write the cache
		/// statistics to.
		/// </param>
		/// <param name="csvfile">
		/// (Optional)
		/// Used with -report, specifies the csv file to write the cache
		/// statistics to, in csv format.
		/// </param>
		/// <param name="import_from_project">(Optional) Import existing synthesized IP from the project into the cache.</param>
		/// <param name="filter">(Optional) Filter result of '-list'</param>
		/// <param name="regexp">(Optional) Use regular expressions instead of globs in '-filter' argument(s)</param>
		/// <param name="nocase">(Optional) Use case insensitive matching in '-filter' argument(s)</param>
		/// <param name="purge">
		/// (Optional)
		/// Delete all cache entries that match the specified type(s): -
		/// vlnv, -obs_swvers, -obs_synth_crc, and/or -swver. Returns
		/// the number of entries deleted.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="ip">(Optional) IP instance object, IP file, or IP name pattern</param>
		public virtual SimpleTCLCommand config_ip_cache(string use_cache_location = null, bool? use_project_cache = null, bool? disable_cache = null, bool? clear_output_repo = null, bool? clear_local_cache = null, bool? cache_has_match = null, bool? cache_was_used = null, bool? get_id = null, bool? remove = null, string vlnv = null, bool? old_swvers = null, bool? unused = null, string swver = null, string num_days_old = null, string num_days_unused = null, bool? obs_synth_crc = null, bool? disk_usage_output_repo = null, bool? report = null, string rptfile = null, string csvfile = null, bool? import_from_project = null, string filter = null, bool? regexp = null, bool? nocase = null, bool? purge = null, bool? quiet = null, bool? verbose = null, string ip = null)
		{
			// TCL Syntax: config_ip_cache [-use_cache_location <arg>] [-use_project_cache] [-disable_cache] [-clear_output_repo] [-clear_local_cache] [-cache_has_match] [-cache_was_used] [-get_id] [-remove] [-vlnv <arg>] [-old_swvers] [-unused] [-swver <arg>] [-num_days_old <arg>] [-num_days_unused <arg>] [-obs_synth_crc] [-disk_usage_output_repo] [-report] [-rptfile <arg>] [-csvfile <arg>] [-import_from_project] [-filter <arg>] [-regexp] [-nocase] [-purge] [-quiet] [-verbose] [<ip>]
			return
				new SimpleTCLCommand("config_ip_cache")
					.OptionalNamedString("use_cache_location", use_cache_location)
					.Flag("use_project_cache", use_project_cache)
					.Flag("disable_cache", disable_cache)
					.Flag("clear_output_repo", clear_output_repo)
					.Flag("clear_local_cache", clear_local_cache)
					.Flag("cache_has_match", cache_has_match)
					.Flag("cache_was_used", cache_was_used)
					.Flag("get_id", get_id)
					.Flag("remove", remove)
					.OptionalNamedString("vlnv", vlnv)
					.Flag("old_swvers", old_swvers)
					.Flag("unused", unused)
					.OptionalNamedString("swver", swver)
					.OptionalNamedString("num_days_old", num_days_old)
					.OptionalNamedString("num_days_unused", num_days_unused)
					.Flag("obs_synth_crc", obs_synth_crc)
					.Flag("disk_usage_output_repo", disk_usage_output_repo)
					.Flag("report", report)
					.OptionalNamedString("rptfile", rptfile)
					.OptionalNamedString("csvfile", csvfile)
					.Flag("import_from_project", import_from_project)
					.OptionalNamedString("filter", filter)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.Flag("purge", purge)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(ip)
			;
		}
		/// <summary>
		/// Configure timing analysis general settings
		///
		///
		/// TCL Syntax: config_timing_analysis [-enable_input_delay_default_clock <arg>] [-enable_preset_clear_arcs <arg>] [-ignore_io_paths <arg>] [-disable_flight_delays <arg>] [-merge_exceptions <arg>] [-timing_early_launch_at_borrowing_latches <arg>] [-enable_time_borrowing_for_max_delay_exceptions <arg>] [-quiet] [-verbose]
		///
		/// This command configures general features of timing analysis.
		/// Note: This command returns nothing if successful, or returns an error if it fails.
		///
		/// The following example ignores the package delays during timing analysis:
		/// config_timing_analysis -disable_flight_delays true
		///
		/// See ug835-vivado-tcl-commands.pdf, page 181
		/// </summary>
		/// <param name="enable_input_delay_default_clock">
		/// (Optional)
		/// Launch SDC unclocked input delays from an internally
		/// defined clock: Values: true, false; This option is not
		/// supported for UCF constraints
		/// </param>
		/// <param name="enable_preset_clear_arcs">
		/// (Optional)
		/// Time paths through asynchronous preset or clear timing
		/// arcs: true, false;
		/// </param>
		/// <param name="ignore_io_paths">
		/// (Optional)
		/// Ignore paths from primary inputs and paths to primary
		/// outputs: Values: true, false
		/// </param>
		/// <param name="disable_flight_delays">(Optional) Disable adding package times to IO Calculations : Values: true, false;</param>
		/// <param name="merge_exceptions">
		/// (Optional)
		/// Allow/Prevent the timing engine from merging timing
		/// exceptions : Values: true, false;
		/// </param>
		/// <param name="timing_early_launch_at_borrowing_latches">
		/// (Optional)
		/// Remove clock latency pessimism from the launching enable
		/// of paths through transparent latches. Values: auto, true,
		/// false Default: auto
		/// [-
		/// enable_time_borrowing_for_max_delay_exceptions
		/// ]
		/// Allow timing paths covered by set_max_delay timing
		/// exceptions to borrow time. Values: true, false
		/// </param>
		/// <param name="enable_time_borrowing_for_max_delay_exceptions">(Optional)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand config_timing_analysis(string enable_input_delay_default_clock = null, string enable_preset_clear_arcs = null, string ignore_io_paths = null, string disable_flight_delays = null, string merge_exceptions = null, string timing_early_launch_at_borrowing_latches = null, string enable_time_borrowing_for_max_delay_exceptions = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: config_timing_analysis [-enable_input_delay_default_clock <arg>] [-enable_preset_clear_arcs <arg>] [-ignore_io_paths <arg>] [-disable_flight_delays <arg>] [-merge_exceptions <arg>] [-timing_early_launch_at_borrowing_latches <arg>] [-enable_time_borrowing_for_max_delay_exceptions <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("config_timing_analysis")
					.OptionalNamedString("enable_input_delay_default_clock", enable_input_delay_default_clock)
					.OptionalNamedString("enable_preset_clear_arcs", enable_preset_clear_arcs)
					.OptionalNamedString("ignore_io_paths", ignore_io_paths)
					.OptionalNamedString("disable_flight_delays", disable_flight_delays)
					.OptionalNamedString("merge_exceptions", merge_exceptions)
					.OptionalNamedString("timing_early_launch_at_borrowing_latches", timing_early_launch_at_borrowing_latches)
					.OptionalNamedString("enable_time_borrowing_for_max_delay_exceptions", enable_time_borrowing_for_max_delay_exceptions)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Configure single / multi corner timing analysis settings
		///
		///
		/// TCL Syntax: config_timing_corners [-corner <arg>] [-delay_type <arg>] [-setup] [-hold] [-quiet] [-verbose]
		///
		/// This command configures the Slow and Fast timing corners in the current design for single or
		/// multi-corner timing analysis. A synthesized or implemented design must be opened when
		/// running this command.
		/// The variation in the manufacturing process of the physical device, and the voltage and
		/// temperature at which the device is operating, combine to create a timing corner. These three
		/// variables (PVT) determine the delay across the device. The fast corner represents a device
		/// operating with the smallest manufacturing process tolerances, the highest voltage, and the
		/// lowest temperature. The slow corner represents a device operating with the greatest
		/// manufacturing tolerances, the lowest voltage, and the highest temperature. By default the
		/// Vivado Design Suite performs both a setup and hold analysis for both slow and fast process
		/// corners, also known as quad analysis:
		/// config_timing_corners -corner Slow -setup -hold
		/// config_timing_corners -corner Fast -setup -hold
		/// The config_timing_corners command can be used to limit the default four corner analysis
		/// performed by the Vivado timing engine as appropriate to the design, to improve timing
		/// performance. To change or disable the default analysis for both corners, you must configure both
		/// the Fast and Slow corners:
		/// config_timing_corners -corner Slow -delay_type max
		/// config_timing_corners -corner Fast -delay_type none
		/// Note: This command returns nothing if successful, or returns an error if it fails.
		///
		/// The following example configures the Slow timing corner for both setup and hold analysis:
		/// config_timing_corners -corner slow -setup -hold
		/// config_timing_corners -corner slow -delay_type min_max
		/// Note: The two preceding examples have the same effect.
		/// The following example configures the Fast corner for min delay analysis, and disables the Slow
		/// corner analysis:
		/// config_timing_corners -corner fast -delay_type min
		/// config_timing_corners -corner slow -delay_type none
		///
		/// See ug835-vivado-tcl-commands.pdf, page 184
		/// </summary>
		/// <param name="corner">(Optional) Name of the timing corner to be modified : Values: Slow, Fast</param>
		/// <param name="delay_type">
		/// (Optional)
		/// Type of path delays to be analyzed for specified timing
		/// corner: Values: none, max, min, min_max
		/// </param>
		/// <param name="setup">
		/// (Optional)
		/// Enable timing corner for setup analysis (equivalent to -
		/// delay_type max)
		/// </param>
		/// <param name="hold">
		/// (Optional)
		/// Enable timing corner for hold analysis (equivalent to -
		/// delay_type min)
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand config_timing_corners(string corner = null, string delay_type = null, bool? setup = null, bool? hold = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: config_timing_corners [-corner <arg>] [-delay_type <arg>] [-setup] [-hold] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("config_timing_corners")
					.OptionalNamedString("corner", corner)
					.OptionalNamedString("delay_type", delay_type)
					.Flag("setup", setup)
					.Flag("hold", hold)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Enable/disable WebTalk to send software, IP and device usage statistics to Xilinx. Note: WebTalk
		/// is always enabled for WebPACK users. WebTalk ignores user and install preference when a
		/// bitstream is generated using the WebPACK license. If a design is using a device contained in
		/// WebPACK and a WebPACK license is available, the WebPACK license will be used. To change
		/// this, please see answer record 34746.
		///
		///
		/// TCL Syntax: config_webtalk [-info] [-user <arg>] [-install <arg>] [-quiet] [-verbose]
		///
		/// WebTalk is a secure design data collection feature of Xilinx software that helps Xilinx understand
		/// how you are using Xilinx devices, software, and Intellectual Property (IP).
		/// This command returns the current state of the WebTalk feature for the current user and software
		/// installation. You can also enable or disable WebTalk to send software, IP and device usage
		/// statistics to Xilinx. No data is sent if you disable WebTalk, except for the use of the WebPACK
		/// license to generate a bitstream.
		/// Participation in WebTalk is voluntary, except for the use of the WebPACK license. WebTalk data
		/// transmission is mandatory, and is always enabled for WebPACK users. WebTalk ignores user and
		/// install preference when a bitstream is generated using the WebPACK license.
		/// Note: If a design is using a device contained in WebPACK and a WebPACK license is available, the
		/// WebPACK license will be used. To change this, please see answer record 34746.
		///
		/// The following example returns the current state of the WebTalk configuration:
		/// config_webtalk -info
		/// INFO: [Coretcl-120] Webtalk has been disabled by the current user.
		/// INFO: [Coretcl-123] Webtalk has been enabled for the current installation.
		/// INFO: [Coretcl-110] This combination of user/install settings means that
		/// WebTalk is currently disabled.
		/// The following example enables WebTalk for the current user:
		/// config_webtalk -user on
		///
		/// See ug835-vivado-tcl-commands.pdf, page 187
		/// </summary>
		/// <param name="info">(Optional) Show whether WebTalk is currently enabled or disabled</param>
		/// <param name="user">
		/// (Optional)
		/// Enable/disable WebTalk for the current user. Specify either
		/// 'on' to enable or 'off' to disable. Default: empty
		/// </param>
		/// <param name="install">
		/// (Optional)
		/// Enable/disable WebTalk for all users of the current
		/// installation. Specify either 'on' to enable or 'off' to disable.
		/// If you specify 'off', individual users will not be able to enable
		/// WebTalk using the -user option. You may need
		/// administrator rights to use this option. Default: empty
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand config_webtalk(bool? info = null, string user = null, string install = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: config_webtalk [-info] [-user <arg>] [-install <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("config_webtalk")
					.Flag("info", info)
					.OptionalNamedString("user", user)
					.OptionalNamedString("install", install)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Connect intf_port and intf_pin list.
		///
		///
		/// TCL Syntax: connect_bd_intf_net [-intf_net <arg>] [-boundary_type <arg>] [-quiet] [-verbose] <object1> <object2> [<auto>]
		///
		/// Connect the interface pins on an IP integrator cell to other interface pins, or to external interface
		/// ports. An interface is a grouping of signals that share a common function in the IP integrator
		/// subsystem design.
		/// This command will create an interface net of the name specified by the -intf_net option, will
		/// connect to an existing interface net of the specified name, or will assign a name if none is
		/// specified.
		/// Returns the connected interface net object, or returns an error.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 189
		/// </summary>
		/// <param name="object1">(Required) Name of intf_port or intf_pin to connect</param>
		/// <param name="object2">(Required) Name of intf_port or intf_pin to connect</param>
		/// <param name="intf_net">(Optional) The single intf_net that all objects connect to</param>
		/// <param name="boundary_type">
		/// (Optional)
		/// Used when source object is on a hierarchical block's
		/// interface pin. Valid values are 'upper', 'lower', or 'both'. If
		/// 'lower' boundary, searches from the lower level of hierarchy
		/// onwards. Default: both
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="auto">(Optional) Automatically connect associated pins</param>
		/// <returns>TCL_OK, TCL_ERROR if failed.</returns>
		public virtual SimpleTCLCommand connect_bd_intf_net(string object1, string object2, string intf_net = null, string boundary_type = null, bool? quiet = null, bool? verbose = null, string auto = null)
		{
			// TCL Syntax: connect_bd_intf_net [-intf_net <arg>] [-boundary_type <arg>] [-quiet] [-verbose] <object1> <object2> [<auto>]
			return
				new SimpleTCLCommand("connect_bd_intf_net")
					.OptionalNamedString("intf_net", intf_net)
					.OptionalNamedString("boundary_type", boundary_type)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(object1)
					.RequiredString(object2)
					.OptionalString(auto)
			;
		}
		/// <summary>
		/// Connect port and pin object list.
		///
		///
		/// TCL Syntax: connect_bd_net [-net <arg>] [-boundary_type <arg>] [-quiet] [-verbose] <objects>...
		///
		/// Create a new net in the current IP integrator subsystem design connecting the specified list of
		/// block diagram port and pin objects, or connect an existing net to the specified pins and ports.
		/// If the -net option is not specified, a new net is created connecting the listed objects. If -net is
		/// used, the specified net is either connected or created as needed.
		/// Use the get_bd_ports and get_bd_pins commands to specify the port and pin objects to
		/// connect.
		/// You can use this command to connect pins or ports at different levels of the subsystem design
		/// hierarchy. However, in this case, you cannot specify the -net option because the connection,
		/// when complete, will result in multiple nets rather than a single net.
		/// The command returns the connected IP integrator subsystem design net object, or returns an
		/// error.
		///
		/// The following example connects two pins on different levels of the IP subsystem design
		/// hierarchy:
		/// connect_bd_net [get_bd_pins /vidOut_1/locked] \
		/// [get_bd_pins /newMod1/bridge_1/fid]
		/// Note: Because /vidOut_1/locked and /newMod1/bridge_1/fid are in different levels of the
		/// subsystem design hierarchy, the -net option is not specified. In this case, multiple nets are created for
		/// connection across the hierarchy.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 191
		/// </summary>
		/// <param name="objects">(Required) The objects connect to the net</param>
		/// <param name="net">(Optional) The single net that all objects connect to</param>
		/// <param name="boundary_type">
		/// (Optional)
		/// Used when source object is on a hierarchical block's pin.
		/// Valid values are 'upper', 'lower', or 'both'. If 'lower'
		/// boundary, searches from the lower level of hierarchy
		/// onwards. Default: both
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>TCL_OK, TCL_ERROR if failed.</returns>
		public virtual SimpleTCLCommand connect_bd_net(string objects, string net = null, string boundary_type = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: connect_bd_net [-net <arg>] [-boundary_type <arg>] [-quiet] [-verbose] <objects>...
			return
				new SimpleTCLCommand("connect_bd_net")
					.OptionalNamedString("net", net)
					.OptionalNamedString("boundary_type", boundary_type)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Connect debug slave instances to the master instance. A valid master is a debug bridge or debug
		/// hub instance configured in "From BSCAN To DebugHUB" mode. A valid slave could be any of the
		/// following debug cores (Ex: ILA, VIO, JTAG_to_AXI). connect_debug_cores can only connect
		/// master and slave instances that exist in the same region (either in Reconfigurable Partition or
		/// static)
		///
		///
		/// TCL Syntax: connect_debug_cores -master <args> -slaves <args> [-quiet] [-verbose]
		///
		/// Connect debug slave instances to the specified master instance. The command can add the
		/// specified slaves into an existing debug chain, where the specified slaves will be connected to the
		/// debug hub or bridge, without affecting debug slaves that are already in the connection chain.
		/// Debug masters include both the Debug Hub and Debug Bridge. The Vivado Debug Hub core
		/// provides an interface between the JTAG Boundary Scan (BSCAN) interface of the Xilinx device
		/// and the Vivado Debug cores, including the Integrated Logic Analyzer (ILA), Virtual Input/Output
		/// (VIO), and the JTAG-to-AXI. The Vivado Debug Bridge is a debug controller that provides
		/// multiple options to communicate with the debug cores in both flat designs, or Partial
		/// Reconfiguration (PR) designs. The Debug Bridge can be configured to debug designs using a
		/// JTAG cable, or remotely through Ethernet, PCIe, or other interfaces using a Xilinx Virtual Cable
		/// (XVC), without the need for a JTAG cable. Refer to the Vivado Design Suite User Guide: Vivado
		/// Programming and Debugging (UG908) for more information.
		/// IMPORTANT! For Partial Reconfiguration (PR) designs, the connect_debug_cores command can only
		/// connect master and slave instances that occur in the Static Region, or in the same Reconfigurable Partition.
		///
		/// The following example connects the specified ILA cores to the debug bridge:
		/// connect_debug_cores -master [get_cells inst_count/debug_bridge_0] \
		/// -slaves [list [get_cells inst_count/ila_0] [get_cells inst_count/ila_1] ]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 193
		/// </summary>
		/// <param name="master">
		/// (Required)
		/// A valid debug bridge or debug hub instance configured in
		/// "From BSCAN To DebugHUB" mode. Only one master
		/// instance is allowed.
		/// </param>
		/// <param name="slaves">
		/// (Required)
		/// List of valid slave instances. A valid slave instance is any of
		/// the following debug cores (Ex: ILA, VIO, JTAG_to_AXI)
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>debug master and slave instances</returns>
		public virtual SimpleTCLCommand connect_debug_cores(string master, string slaves, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: connect_debug_cores -master <args> -slaves <args> [-quiet] [-verbose]
			return
				new SimpleTCLCommand("connect_debug_cores")
					.RequiredNamedString("master", master)
					.RequiredNamedString("slaves", slaves)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Connect nets and pins to debug port channels
		///
		///
		/// TCL Syntax: connect_debug_port [-channel_start_index <arg>] [-quiet] [-verbose] <port> <nets>...
		///
		/// Connects a signal from the netlist design to a port on an ILA debug core that was added to the
		/// design using the create_debug_core command. The signal can either be connected to a
		/// specific channel index on the port, or simply connected to an available channel on the port.
		/// If you try to connect too many signals to a port, or there are not enough channels to support the
		/// connection, the tool will return an error.
		/// Additional ports can be added to a debug core through the use of the create_debug_port
		/// command, and you can increase the available channels on an existing port with the
		/// set_property port_width command. See the examples below.
		/// You can disconnect signals from ports using the disconnect_debug_port command.
		/// When the debug core has been defined and connected, you can implement the debug core as a
		/// block for inclusion in the netlist design. Use the implement_debug_core command to
		/// implement the core.
		///
		/// The following example creates a new PROBE port on the myCore debug core, increases the
		/// PORT_WIDTH property of the port in order to prepare it to receive the number of signals to be
		/// connected, and connects signals to the port starting at the third channel position (index 2).
		/// create_debug_port myCore PROBE
		/// set_property PORT_WIDTH 8 [get_debug_ports myCore/PROBE1]
		/// connect_debug_port myCore/PROBE1 [get_nets [list m0_ack_o m0_cyc_i \
		/// m0_err_o m0_rty_o m0_stb_i m0_we_i ]] -channel_start_index 2
		/// Note: If you specify too many nets to connect to the available channels on the port, the tool will return an
		/// error and will not connect the ports.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 196
		/// </summary>
		/// <param name="port">(Required) Debug port name</param>
		/// <param name="nets">(Required) List of nets or pins</param>
		/// <param name="channel_start_index">(Optional) Connect nets starting at channel index</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand connect_debug_port(string port, string nets, string channel_start_index = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: connect_debug_port [-channel_start_index <arg>] [-quiet] [-verbose] <port> <nets>...
			return
				new SimpleTCLCommand("connect_debug_port")
					.OptionalNamedString("channel_start_index", channel_start_index)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(port)
					.RequiredString(nets)
			;
		}
		/// <summary>
		/// Open a connection to a hardware server
		///
		///
		/// TCL Syntax: connect_hw_server [-url <arg>] [-cs_url <arg>] [-quiet] [-verbose]
		///
		/// IMPORTANT! You must use the open_hw command to open the Hardware Manager in the Vivado Design
		/// Suite before using this command.
		/// To open a hardware target containing a JTAG chain of one or more Xilinx devices, for
		/// programming and/or debugging your design, you must first connect to a Vivado tools hardware
		/// server (hw_server) to manage the connection to the hardware target (hw_target).
		/// The hw_server manages the connection to the physical programming target. It should be running
		/// on the machine connected to the hardware programmer, or test board, connected either locally
		/// or remotely. The hw_server command must be launched as a separate application, and can be
		/// found in the /bin folder of your Vivado Design Suite installation directory.
		/// To connect to a hardware server, the hw_server application must be running, and the host
		/// name and port number noted for the -url argument of the connect_hw_server command.
		/// The default URL for the hw_server process is localhost:3121. For more information on
		/// setting up and running the Vivado hardware server, refer to the Vivado Design Suite User Guide:
		/// Programming and Debugging (UG908).
		/// You can connect a single instance of the Vivado Design Suite to multiple hardware servers, to
		/// support programming and debugging different device configurations. However, you can only
		/// have one connection to a specific hardware server as identified by the host name/port number
		/// combination. An error is returned if you attempt to open a connection to a server that is already
		/// connected.
		/// The last connected hardware server is the current hardware server, unless changed by the
		/// current_hw_server command. Any connected server can be disconnected with the
		/// disconnect_hw_server command.
		/// This command returns the host name of the hardware server that has been connected.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 198
		/// </summary>
		/// <param name="url">(Optional) hw_server url Default: localhost:3121</param>
		/// <param name="cs_url">
		/// (Optional)
		/// Url to use for cs_server. If default url is used and no server is
		/// running there, cs_server will be automatically launched on
		/// the default url. Default: TCP:localhost:3042
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>hardware server</returns>
		public virtual SimpleTCLCommand connect_hw_server(string url = null, string cs_url = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: connect_hw_server [-url <arg>] [-cs_url <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("connect_hw_server")
					.OptionalNamedString("url", url)
					.OptionalNamedString("cs_url", cs_url)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Connect a net to pins or ports
		///
		///
		/// TCL Syntax: connect_net [-hierarchical] [-basename <arg>] [-net <args>] [-objects <args>] [-net_object_list <args>] [-dict <args>] [-quiet] [-verbose]
		///
		/// This command allows the user to connect a specified net to one or more pins or ports in the
		/// netlist of an open Synthesized or Implemented Design.
		/// The connect_net command will also connect nets across levels of hierarchy in the design, by
		/// adding pins and hierarchical nets as needed to complete the connection. Added nets and pins can
		/// be assigned a custom basename to make them easy to identify, or will be assigned a basename
		/// by the Vivado tool.
		/// TIP: You can specify multiple nets, and a list of pins and ports to connect those nets to, using a single
		/// connect_net command with the -net_object_list or -dict options, to significantly speed the
		/// addition of multiple nets to the current design.
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*
		/// command.
		/// Note: Netlist editing is not allowed on the elaborated RTL design.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 201
		/// </summary>
		/// <param name="objects">(Required) List of pin and port objects to connect</param>
		/// <param name="hierarchical">
		/// (Optional)
		/// Allow hierarchical connection, creating nets and pins as
		/// needed (see -basename).
		/// </param>
		/// <param name="basename">
		/// (Optional)
		/// base name to use for net / pin names needed when doing
		/// hierarchical connection (see -hier). Default value is inferred
		/// from the name of the net being connected (see -net).
		/// </param>
		/// <param name="net">(Optional) Net to connect to given objects.</param>
		/// <param name="net_object_list">
		/// (Optional)
		/// optional, a list of net and pin/port list pairs, each pin or port
		/// list element is connected to the corresponding net, e.g.
		/// { net_a { pin_b port_c } net_d pin_e }. Cannot be used with -
		/// net, -objects list is ignored when -net_object_list is used.
		/// </param>
		/// <param name="dict">
		/// (Optional)
		/// alternative to -net_object_list, faster, but requires a list of
		/// net and pin/port object pairs (must be a list of objects, not
		/// names or other TCL objects), each pin or port list element is
		/// connected to the corresponding net, e.g. { $net_1 $pin_1
		/// $net_2 $pin_2 }. Cannot be used with -net, -objects list is
		/// ignored when -dict is used.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand connect_net(string objects, bool? hierarchical = null, string basename = null, string net = null, string net_object_list = null, string dict = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: connect_net [-hierarchical] [-basename <arg>] [-net <args>] [-objects <args>] [-net_object_list <args>] [-dict <args>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("connect_net")
					.Flag("hierarchical", hierarchical)
					.OptionalNamedString("basename", basename)
					.OptionalNamedString("net", net)
					.RequiredNamedString("objects", objects)
					.OptionalNamedString("net_object_list", net_object_list)
					.OptionalNamedString("dict", dict)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Convert specified IP to or from core container format.
		///
		///
		/// TCL Syntax: convert_ips [-force] [-to_core_container] [-from_core_container] [-quiet] [-verbose] <objects>
		///
		/// This command converts existing IP into core container format, or reverts core container IP into
		/// the expanded non-core container format.
		/// The core container format for IP is a compressed zip file that reduces the file structure in the
		/// design, and increases tool performance.
		/// By default, the Vivado tool adds IP from the Xilinx IP catalog into a design using the core
		/// container format. However, the convert_ips command lets you convert IP in existing designs
		/// to take advantage of the core container format. In addition, the convert_ips command also
		/// lets you revert the compressed core container format into the expanded non-core container
		/// format.
		/// TIP: If neither -to_core_container or -from_core_container options are specified then the
		/// convert_ips command will convert the IP from its current format into the opposite form. Any core container
		/// IP will be converted to non-core container format, and any non-core container IP will be converted to core
		/// container format.
		/// IP that is user-managed, cannot be converted from its current format. IP that is locked requires
		/// the use of the -force option to convert. Refer to the Vivado Design Suite User Guide: Designing
		/// with IP (UG896) for more information on editing IP and the IS_LOCKED and IS_MANAGED
		/// properties.
		/// This command returns a transcript of its actions, or returns an error if it fails.
		///
		/// The following example converts all IP in the current project into core container format:
		/// convert_ips -to_core_container [get_ips]
		/// Note: Any IP already in the core container format will be skipped.
		/// The following example converts the specified IP file to core container format:
		/// convert_ips -to_core_container \
		/// [get_files C:/Data/wave1/wave1.srcs/sources_1/ip/char_fifo/char_fifo.xci]
		/// The following example toggles the current format of all IP in the design, switching from core
		/// container to non-core container, and from non-core container to core container:
		/// convert_ips [get_ips]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 205
		/// </summary>
		/// <param name="objects">(Required) Input objects for the IP. May IP or source file objects</param>
		/// <param name="force">(Optional) Force conversion even if the IP is locked.</param>
		/// <param name="to_core_container">(Optional) Convert IP to core container format.</param>
		/// <param name="from_core_container">(Optional) Convert IP to non core container format.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand convert_ips(string objects, bool? force = null, bool? to_core_container = null, bool? from_core_container = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: convert_ips [-force] [-to_core_container] [-from_core_container] [-quiet] [-verbose] <objects>
			return
				new SimpleTCLCommand("convert_ips")
					.Flag("force", force)
					.Flag("to_core_container", to_core_container)
					.Flag("from_core_container", from_core_container)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// (User-written application) Convert all provided NGC files to a supported format
		///
		///
		/// TCL Syntax: convert_ngc [-output_dir <arg>] [-format <arg>] [-add_to_project] [-force] [-quiet] [-verbose] <files>
		///
		/// Converts provided NGC files to a supported format.
		///
		/// The following example will convert test.ngc to test.edn, with verbose messaging. The
		/// test.edn file will be added to the current open project:
		/// convert_ngc ./test.ngc -add_to_project -verbose
		/// The following example will convert test.ngc to test.edn. The test.edn file will be placed
		/// in the ./output directory. If ./output/test.edn exists it will be replaced:
		/// convert_ngc ./test.ngc -output_dir output -force
		/// The following example converts all NGC files in the current directory and in all sub-directories:
		/// convert_ngc [ glob ./**/*.ngc ] [ glob ./*.ngc ]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 208
		/// </summary>
		/// <param name="files">(Required) A list of NGC files to convert</param>
		/// <param name="output_dir">
		/// (Optional)
		/// Directory to place all output, else the output is placed at
		/// location of NGC file Default: Script output directory path
		/// </param>
		/// <param name="format">
		/// (Optional)
		/// Accepts 'Verilog' or 'EDIF' (Default: EDIF), specifies the
		/// desired output format Default: EDIF
		/// </param>
		/// <param name="add_to_project">
		/// (Optional)
		/// Adds the output files to the current project, if no project is
		/// open, then this option does nothing
		/// </param>
		/// <param name="force">
		/// (Optional)
		/// Force overwriting of files that already exist on disk, replaces
		/// files in project if add_to_project switch was specified
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>None</returns>
		public virtual SimpleTCLCommand convert_ngc(string files, string output_dir = null, string format = null, bool? add_to_project = null, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: convert_ngc [-output_dir <arg>] [-format <arg>] [-add_to_project] [-force] [-quiet] [-verbose] <files>
			return
				new SimpleTCLCommand("convert_ngc")
					.OptionalNamedString("output_dir", output_dir)
					.OptionalNamedString("format", format)
					.Flag("add_to_project", add_to_project)
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(files)
			;
		}
		/// <summary>
		/// Make copies of the objects and add the copies to the given hierarchical cell.
		///
		///
		/// TCL Syntax: copy_bd_objs [-prefix <arg>] [-from_design <arg>] [-quiet] [-verbose] <parent_cell> <objects>...
		///
		/// Use this command to copy IP integrator objects from one open subsystem design to a second
		/// subsystem design. The selected objects can be copied into the top-level of the current subsystem
		/// design, or into an existing hierarchical module.
		/// Because get_bd_cells, and other commands like it, operate on the current subsystem design,
		/// you must store the objects to be copied in a Tcl variable, as shown in the example below. Set the
		/// current subsystem design to the source design, select the group of objects to be copied, and
		/// store them in a Tcl variable. Then change the current_bd_design to the target design, and
		/// copy the selected objects. In this case, the -from_design option must be used.
		/// You can also use this command to copy objects from one level of hierarchy in the current
		/// subsystem design to another. In this case, the -from_design argument does not need to be
		/// specified.
		/// This command returns 0 if successful, and returns an error if it failed.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 210
		/// </summary>
		/// <param name="parent_cell">(Required) Parent cell</param>
		/// <param name="objects">(Required) The objects to copy</param>
		/// <param name="prefix">(Optional) Prefix name to add to cells</param>
		/// <param name="from_design">(Optional) The design to own the original objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>0, "" if failed.</returns>
		public virtual SimpleTCLCommand copy_bd_objs(string parent_cell, string objects, string prefix = null, string from_design = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: copy_bd_objs [-prefix <arg>] [-from_design <arg>] [-quiet] [-verbose] <parent_cell> <objects>...
			return
				new SimpleTCLCommand("copy_bd_objs")
					.OptionalNamedString("prefix", prefix)
					.OptionalNamedString("from_design", from_design)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(parent_cell)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Copy an existing IP
		///
		///
		/// TCL Syntax: copy_ip -name <arg> [-dir <arg>] [-quiet] [-verbose] <objects>...
		///
		/// Create a copy of an IP core that has been previously instanced into the current project.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 213
		/// </summary>
		/// <param name="name">(Required) Name of copied IP</param>
		/// <param name="objects">(Required) IP to be copied</param>
		/// <param name="dir">
		/// (Optional)
		/// Directory path for remote IP to be created and managed
		/// outside the project
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>IP file object that was added to the project</returns>
		public virtual SimpleTCLCommand copy_ip(string name, string objects, string dir = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: copy_ip -name <arg> [-dir <arg>] [-quiet] [-verbose] <objects>...
			return
				new SimpleTCLCommand("copy_ip")
					.RequiredNamedString("name", name)
					.OptionalNamedString("dir", dir)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// (User-written application) Copy a run from an already existing run, source-run, to a new copy of
		/// that run, destination-run.
		///
		///
		/// TCL Syntax: copy_run [-parent_run <arg>] [-verbose] -name <arg> [-quiet] <run>
		///
		/// Copies an existing synthesis or implementation run.
		///
		/// The following example will copy synth_1 run into a new synth_2 run:
		/// copy_run -name synth_2 [get_runs synth_1]
		/// The following example will copy the impl_1 run into a new run called impl_2, and assign synth_2
		/// as the parent of the new run:
		/// copy_run -name impl_2 [get_runs impl_1] -parent_run synth_2
		///
		/// See ug835-vivado-tcl-commands.pdf, page 215
		/// </summary>
		/// <param name="name">(Required) Specify the name of the new run</param>
		/// <param name="run">(Required) The run to be copied, accepts name or run object</param>
		/// <param name="parent_run">
		/// (Optional)
		/// Specify the synthesis run for the new implementation run,
		/// accepts name or run object (Default: same as source run)
		/// Default: None
		/// </param>
		/// <param name="verbose">(Optional) Print detailed information as the copy progresses</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <returns>The new run object</returns>
		public virtual SimpleTCLCommand copy_run(string name, string run, string parent_run = null, bool? verbose = null, bool? quiet = null)
		{
			// TCL Syntax: copy_run [-parent_run <arg>] [-verbose] -name <arg> [-quiet] <run>
			return
				new SimpleTCLCommand("copy_run")
					.OptionalNamedString("parent_run", parent_run)
					.Flag("verbose", verbose)
					.RequiredNamedString("name", name)
					.Flag("quiet", quiet)
					.RequiredString(run)
			;
		}
		/// <summary>
		/// Create a new segment.
		///
		///
		/// TCL Syntax: create_bd_addr_seg -range <arg> -offset <arg> [-quiet] [-verbose] [<parent_addr_space>] [<slave_segment>] <name>
		///
		/// Create a new address segment object, bd_addr_seg, in the current IP integrator subsystem
		/// design.
		/// This command returns the newly created master address segment object, or returns nothing if it
		/// failed.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 217
		/// </summary>
		/// <param name="range">(Required) Range of segment. e.g. 4096, 4K, 16M, 1G</param>
		/// <param name="offset">(Required) Offset of segment. e.g. 0x00000000</param>
		/// <param name="parent_addr_space">(Required) Parent address space of segment</param>
		/// <param name="slave_segment">(Required) Slave segment of the created segment</param>
		/// <param name="name">(Required) Name of segment to create</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The newly created segment object, "" if failed.</returns>
		public virtual SimpleTCLCommand create_bd_addr_seg(string range, string offset, string parent_addr_space, string slave_segment, string name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_bd_addr_seg -range <arg> -offset <arg> [-quiet] [-verbose] [<parent_addr_space>] [<slave_segment>] <name>
			return
				new SimpleTCLCommand("create_bd_addr_seg")
					.RequiredNamedString("range", range)
					.RequiredNamedString("offset", offset)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(parent_addr_space)
					.RequiredString(slave_segment)
					.RequiredString(name)
			;
		}
		/// <summary>
		/// Add an IP cell from the IP catalog, or add a new hierarchical block.
		///
		///
		/// TCL Syntax: create_bd_cell [-vlnv <arg>] [-type <arg>] [-reference <arg>] [-revision <arg>] [-quiet] [-verbose] <name>
		///
		/// Add a cell from the Vivado catalog to the current subsystem design, create a new hierarchical
		/// module to add to the subsystem design, or create a new module by referencing the module
		/// definition from an HDL source file.
		/// When adding an IP core from the catalog, the -vlnv argument is required.
		/// When creating a new hierarchical block design module, the -type hier argument is required.
		/// When creating a block design module that references an RTL module or entity declaration the -
		/// type module argument is required, as well as -reference. The module reference feature lets
		/// you add a module definition from an RTL file (Verilog or VHDL) into the block design. The source
		/// file containing the module definition must be added to the project, or read into the design before
		/// creating a module reference. Refer to the Vivado Design Suite User Guide: Designing IP Subsystems
		/// Using IP Integrator (UG994) for more information on referencing modules.
		/// This command returns the name of the newly created cell object, or returns nothing if the
		/// command fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 219
		/// </summary>
		/// <param name="vlnv">(Required) Vendor:Library:Name:Version of the IP cell to add from the IP catalog.</param>
		/// <param name="name">(Required) Name of cell to create</param>
		/// <param name="type">
		/// (Optional)
		/// Type of cell to create. Valid values are IP, hier and module.
		/// Default: IP
		/// </param>
		/// <param name="reference">
		/// (Optional)
		/// Top module-name or file-path of the module which is
		/// referred to create the cell.
		/// </param>
		/// <param name="revision">(Optional) (Optional) Core revision Default: -1</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The newly created cell object. Returns nothing if the command fails.</returns>
		public virtual SimpleTCLCommand create_bd_cell(string vlnv, string name, string type = null, string reference = null, string revision = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_bd_cell [-vlnv <arg>] [-type <arg>] [-reference <arg>] [-revision <arg>] [-quiet] [-verbose] <name>
			return
				new SimpleTCLCommand("create_bd_cell")
					.RequiredNamedString("vlnv", vlnv)
					.OptionalNamedString("type", type)
					.OptionalNamedString("reference", reference)
					.OptionalNamedString("revision", revision)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
			;
		}
		/// <summary>
		/// Create a new design and its top level hierarchy cell with the same name.
		///
		///
		/// TCL Syntax: create_bd_design [-dir <arg>] [-cell <arg>] [-quiet] [-verbose] <name>
		///
		/// Create a new IP subsystem design module to add to the current project, and for use with the IP
		/// integrator of the Vivado Design Suite.
		/// An empty IP subsystem module is created and added to the source files of the current project.
		/// The subsystem module and file are created with the specified <name> in the current project at:
		/// <project_name>/<project_name>.srcs/sources_1/bd/<name>/<name>.bd
		/// This command returns the file path and name of the IP subsystem design created if the command
		/// is successful. An error is returned if the command fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 222
		/// </summary>
		/// <param name="name">(Required) Name of design to create</param>
		/// <param name="dir">
		/// (Optional)
		/// Directory path for remote BD to be created and managed
		/// outside the project
		/// </param>
		/// <param name="cell">(Optional) hierarchical cell name which sub design to be copied into new design</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The newly created design object, "" if failed.</returns>
		public virtual SimpleTCLCommand create_bd_design(string name, string dir = null, string cell = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_bd_design [-dir <arg>] [-cell <arg>] [-quiet] [-verbose] <name>
			return
				new SimpleTCLCommand("create_bd_design")
					.OptionalNamedString("dir", dir)
					.OptionalNamedString("cell", cell)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
			;
		}
		/// <summary>
		/// Create a new intf_net.
		///
		///
		/// TCL Syntax: create_bd_intf_net [-quiet] [-verbose] <name>
		///
		/// Create a new IP integrator interface net for the subsystem design.
		/// This command returns the newly created interface net object if successful, and returns noting if it
		/// failed.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 224
		/// </summary>
		/// <param name="name">(Required) Name of intf_net to create</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The newly created intf_net object, "" if failed.</returns>
		public virtual SimpleTCLCommand create_bd_intf_net(string name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_bd_intf_net [-quiet] [-verbose] <name>
			return
				new SimpleTCLCommand("create_bd_intf_net")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
			;
		}
		/// <summary>
		/// Create a new intf_pin.
		///
		///
		/// TCL Syntax: create_bd_intf_pin -vlnv <arg> -mode <arg> [-quiet] [-verbose] <name>
		///
		/// Create a new interface pin on an IP integrator hierarchical module. An IP integrator interface is a
		/// grouping of signals that share a common function, and can include both individual signals and
		/// buses that share a related function. An AXI4-Lite master, for example, is an interface that
		/// includes a large number of individual signals plus multiple buses.
		/// To create a single connection pin, or standard bus pin, use the create_bd_pin command.
		/// Interface pins connect with other compatible interface pins, or interface ports. The interface pin
		/// is added as a port inside the hierarchical module, to connect outside of the module, and as a pin
		/// on the hierarchical module.
		/// You must define the hierarchical module as the current instance in the IP integrator subsystem
		/// design, using the current_bd_instance command. The current instance is the target of the
		/// create_bd_intf_pin command.
		/// This command returns the name of the newly created interface pin object if successful, and
		/// returns an error if it failed.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 226
		/// </summary>
		/// <param name="vlnv">(Required) Bus vlnv</param>
		/// <param name="mode">(Required) Bus interface mode</param>
		/// <param name="name">(Required) Name of intf_pin to create</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The newly created intf_pin object, "" if failed.</returns>
		public virtual SimpleTCLCommand create_bd_intf_pin(string vlnv, string mode, string name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_bd_intf_pin -vlnv <arg> -mode <arg> [-quiet] [-verbose] <name>
			return
				new SimpleTCLCommand("create_bd_intf_pin")
					.RequiredNamedString("vlnv", vlnv)
					.RequiredNamedString("mode", mode)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
			;
		}
		/// <summary>
		/// Create a new interface port.
		///
		///
		/// TCL Syntax: create_bd_intf_port -vlnv <arg> -mode <arg> [-board_intf <arg>] [-quiet] [-verbose] <name>
		///
		/// Create a new IP integrator subsystem design interface port. An IP integrator interface is a
		/// grouping of signals that share a common function, and can include both individual signals and
		/// buses that share a related function. An AXI4-Lite master, for example, is an interface that
		/// includes a large number of individual signals plus multiple buses.
		/// To create a single connection port, or common bus port, use the create_bd_port command.
		/// This command returns the name of the newly created interface port object if successful, and
		/// returns nothing if it failed.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 228
		/// </summary>
		/// <param name="vlnv">(Required) Bus vlnv</param>
		/// <param name="mode">(Required) Bus interface mode</param>
		/// <param name="name">(Required) Name of port to create</param>
		/// <param name="board_intf">
		/// (Optional)
		/// Creates port-maps for this external bus-interface using the
		/// specified interface of current board.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The newly created interface port object, "" if failed.</returns>
		public virtual SimpleTCLCommand create_bd_intf_port(string vlnv, string mode, string name, string board_intf = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_bd_intf_port -vlnv <arg> -mode <arg> [-board_intf <arg>] [-quiet] [-verbose] <name>
			return
				new SimpleTCLCommand("create_bd_intf_port")
					.RequiredNamedString("vlnv", vlnv)
					.RequiredNamedString("mode", mode)
					.OptionalNamedString("board_intf", board_intf)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
			;
		}
		/// <summary>
		/// Create a new TLM interface port.
		///
		///
		/// TCL Syntax: create_bd_intf_tlm_port -vlnv <arg> -mode <arg> [-quiet] [-verbose] <name>
		///
		/// See ug835-vivado-tcl-commands.pdf, page 230
		/// </summary>
		/// <param name="vlnv">(Required) TLM interface vlnv</param>
		/// <param name="mode">(Required) TLM interface mode</param>
		/// <param name="name">(Required) TLM interface name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The newly created TLM interface port object, "" if failed.</returns>
		public virtual SimpleTCLCommand create_bd_intf_tlm_port(string vlnv, string mode, string name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_bd_intf_tlm_port -vlnv <arg> -mode <arg> [-quiet] [-verbose] <name>
			return
				new SimpleTCLCommand("create_bd_intf_tlm_port")
					.RequiredNamedString("vlnv", vlnv)
					.RequiredNamedString("mode", mode)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
			;
		}
		/// <summary>
		/// Create a new net.
		///
		///
		/// TCL Syntax: create_bd_net [-quiet] [-verbose] <name>
		///
		/// Create a new net in the current IP integrator subsystem design.
		/// This command returns the newly created net object, or returns an error if failed.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 231
		/// </summary>
		/// <param name="name">(Required) Name of net to create</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The newly created net object, "" if failed.</returns>
		public virtual SimpleTCLCommand create_bd_net(string name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_bd_net [-quiet] [-verbose] <name>
			return
				new SimpleTCLCommand("create_bd_net")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
			;
		}
		/// <summary>
		/// Create a new pin.
		///
		///
		/// TCL Syntax: create_bd_pin [-from <arg>] [-to <arg>] -dir <arg> [-type <arg>] [-quiet] [-verbose] <name>
		///
		/// Create a new pin to add to an IP integrator hierarchical module.
		/// This command returns the name of the newly created pin object, or returns an error message if it
		/// failed.
		///
		/// The following example creates a new input pin on the specified module in the current IP
		/// integrator subsystem design:
		/// create_bd_pin -dir I -type rst /newMod1/rst
		/// /newMod1/rst
		///
		/// See ug835-vivado-tcl-commands.pdf, page 233
		/// </summary>
		/// <param name="dir">(Required) Pin direction</param>
		/// <param name="name">(Required) Name of pin to create</param>
		/// <param name="from">(Optional) Begin index Default: Unspecified</param>
		/// <param name="to">(Optional) End index Default: Unspecified</param>
		/// <param name="type">(Optional) Pin type</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The newly created pin object, "" if failed.</returns>
		public virtual SimpleTCLCommand create_bd_pin(string dir, string name, string from = null, string to = null, string type = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_bd_pin [-from <arg>] [-to <arg>] -dir <arg> [-type <arg>] [-quiet] [-verbose] <name>
			return
				new SimpleTCLCommand("create_bd_pin")
					.OptionalNamedString("from", from)
					.OptionalNamedString("to", to)
					.RequiredNamedString("dir", dir)
					.OptionalNamedString("type", type)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
			;
		}
		/// <summary>
		/// Create a new port for an IP subsystem design.
		///
		///
		/// TCL Syntax: create_bd_port [-from <arg>] [-to <arg>] -dir <arg> [-type <arg>] [-freq_hz <arg>] [-quiet] [-verbose] <name>
		///
		/// Create a new port to add to an IP integrator subsystem design. The port is a connection to
		/// signals external to the subsystem design.
		/// This command returns the name of the newly created port object, or returns an error message if
		/// it failed.
		///
		/// The following example creates a new bidirectional bus port in the current IP integrator
		/// subsystem design:
		/// create_bd_port -from 0 -to 32 -dir IO -type data addr
		/// /addr
		/// The following example creates a new 125 MHz clock port:
		/// create_bd_port -dir I -type clk -freq_hz 125000000 my_clock
		///
		/// See ug835-vivado-tcl-commands.pdf, page 235
		/// </summary>
		/// <param name="dir">(Required) Port direction. Valid values are I, O, or IO.</param>
		/// <param name="name">(Required) Name of port to create</param>
		/// <param name="from">(Optional) Beginning index Default: Unspecified</param>
		/// <param name="to">(Optional) Ending index Default: Unspecified</param>
		/// <param name="type">(Optional) Port type. Valid values are clk, ce, rst, intr, data.</param>
		/// <param name="freq_hz">(Optional) Frequency in Hertz for clock ports Default: Unspecified</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The newly created port object. Returns nothing if the command fails.</returns>
		public virtual SimpleTCLCommand create_bd_port(string dir, string name, string from = null, string to = null, string type = null, string freq_hz = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_bd_port [-from <arg>] [-to <arg>] -dir <arg> [-type <arg>] [-freq_hz <arg>] [-quiet] [-verbose] <name>
			return
				new SimpleTCLCommand("create_bd_port")
					.OptionalNamedString("from", from)
					.OptionalNamedString("to", to)
					.RequiredNamedString("dir", dir)
					.OptionalNamedString("type", type)
					.OptionalNamedString("freq_hz", freq_hz)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
			;
		}
		/// <summary>
		/// Create a new TLM port for an IP subsystem design.
		///
		///
		/// TCL Syntax: create_bd_tlm_port [-quiet] [-verbose] <name>
		///
		/// See ug835-vivado-tcl-commands.pdf, page 237
		/// </summary>
		/// <param name="name">(Required) Name of port to create</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The newly created TLM port object. Returns nothing if the command fails.</returns>
		public virtual SimpleTCLCommand create_bd_tlm_port(string name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_bd_tlm_port [-quiet] [-verbose] <name>
			return
				new SimpleTCLCommand("create_bd_tlm_port")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
			;
		}
		/// <summary>
		/// Create cells in the current design
		///
		///
		/// TCL Syntax: create_cell -reference <arg> [-black_box] [-quiet] [-verbose] <cells>...
		///
		/// Add cells to the netlist of the current Synthesized or Implemented design.
		/// Note: You cannot add cells to library macros, or macro-primitives.
		/// New cell instances can be added to the top-level of the design, or hierarchically within any
		/// module of the design. Instances can reference an existing cell from the library or design source
		/// files, or a black box instance can be added that reference cells that have not yet been created.
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*
		/// command.
		/// Note: Netlist editing is not allowed on the elaborated RTL design.
		/// This command returns the name of the created cell instance or instances.
		///
		/// The following example creates three new cell instances of the or1200_cpu module with the
		/// specified instance names:
		/// create_cell -reference or1200_cpu myCell1 myCell2 myCell3
		/// The following example sets the hierarchy separator character, then creates a black box instance
		/// for the referenced cell, specifying a hierarchical instance name:
		/// set_hierarchy_separator |
		/// create_cell -reference dmaBlock -black_box usbEngine0|myDMA
		/// Note: The tool will return an error when -black_box is used, but the -reference cell already exists.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 238
		/// </summary>
		/// <param name="reference">(Required) Library cell or design which cells reference</param>
		/// <param name="cells">(Required) Names of cells to create</param>
		/// <param name="black_box">(Optional) Create black box instance</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand create_cell(string reference, string cells, bool? black_box = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_cell -reference <arg> [-black_box] [-quiet] [-verbose] <cells>...
			return
				new SimpleTCLCommand("create_cell")
					.RequiredNamedString("reference", reference)
					.Flag("black_box", black_box)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(cells)
			;
		}
		/// <summary>
		/// Create a clock object
		///
		///
		/// TCL Syntax: create_clock -period <arg> [-name <arg>] [-waveform <args>] [-add] [-quiet] [-verbose] [<objects>]
		///
		/// TIP: The XDC > Timing Constraints language templates and the Timing Constraints Wizard in the Vivado IDE
		/// offer timing diagrams and additional details around defining specific timing constraints. You can refer to these
		/// sources for additional information.
		/// Create a clock object with the specified period or waveform defined in nanoseconds (ns). This
		/// command defines primary clocks which are used by the timing engine as the delay propagation
		/// starting point of any clock edge. The defined clock can be added to the definition of an existing
		/// clock, or overwrite the existing clock.
		/// A virtual clock can be created that has no source in the design. A virtual clock can be used as a
		/// time reference for setting input and output delays but does not physically exist in the design.
		/// A clock can also be generated from an existing physical clock, and derive many of its properties
		/// from the master clock. Use the create_generated_clock command to derive a clock from
		/// an existing physical clock.
		/// IMPORTANT! If you use create_clock to create a generated clock, instead of
		/// create_generated_clock, the created clock does not inherit any of the properties of its source clock. The
		/// insertion delay and jitter of the parent clock will not be propagated to the generated clock, causing incorrect
		/// timing calculations.
		/// The create_clock command returns the name of the clock object that is created.
		///
		/// The following example creates a physical clock called bftClk and defines the clock period:
		/// create_clock -name bftClk -period 5.000 [get_ports bftClk]
		/// Note: If the get_ports command defining the objects is left off of this example, a virtual clock is created
		/// in the design rather than a physical clock.
		/// The following example creates a clock named clk on the input port, bftClk, with a period of 10ns,
		/// the rising edge at 2.4ns and the falling edge at 7.4ns:
		/// create_clock -name clk -period 10.000 -waveform {2.4 7.4} [get_ports
		/// bftClk]
		/// The following example creates a virtual clock since no clock source is specified:
		/// create_clock -name virtual_clock -period 5.000
		/// The following example creates a clock with the falling edge at 2ns and the rising edge at 7ns:
		/// create_clock -name clk -period 10.000 -waveform {7 2} [get_ports bftClk]
		/// Note: Because the falling edge is earlier than the rising edge in the -waveform definition, although it is
		/// specified as arg2, it occurs first in the waveform.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 241
		/// </summary>
		/// <param name="period">(Required) Clock period: Value > 0</param>
		/// <param name="name">(Optional) Clock name</param>
		/// <param name="waveform">(Optional) Clock edge specification</param>
		/// <param name="add">(Optional) Add to the existing clock in source_objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">(Optional) List of clock source ports, pins or nets</param>
		/// <returns>new clock object</returns>
		public virtual SimpleTCLCommand create_clock(string period, string name = null, string waveform = null, bool? add = null, bool? quiet = null, bool? verbose = null, string objects = null)
		{
			// TCL Syntax: create_clock -period <arg> [-name <arg>] [-waveform <args>] [-add] [-quiet] [-verbose] [<objects>]
			return
				new SimpleTCLCommand("create_clock")
					.RequiredNamedString("period", period)
					.OptionalNamedString("name", name)
					.OptionalNamedString("waveform", waveform)
					.Flag("add", add)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(objects)
			;
		}
		/// <summary>
		/// Create the Gadget for Project summary dashboard
		///
		///
		/// TCL Syntax: create_dashboard_gadget -name <arg> -type <arg> [-quiet] [-verbose]
		///
		/// IMPORTANT! This command is primarily intended to be used in the Vivado IDE, with the Project Summary,
		/// and the Add Gadget command.
		/// Create a new "gadget" for a dashboard, such as the Project Summary dashboard that lets you
		/// view different aspects of the synthesized or implemented design run. Aspects of the design
		/// include timing information, resource utilization, DRC and methodology violations, and power
		/// analysis.
		/// A dashboard gadget has a series of properties that define the information displayed, and the way
		/// it is displayed. These properties can be set using the set_property command. To determine
		/// the properties on a gadget, you can use the following command:
		/// report_property -all [get_dashboard_gadget <gadget_name>]
		/// Properties of a dashboard gadget can be set using the set_property command. Some of the
		/// properties of a gadget that can be set include:
		/// • TYPE: Indicates the type of information presented by the gadget as defined by the -type
		/// option.
		/// • ROW: Indicates the row placement in the dashboard.
		/// • COL: Indicates the column placement of the gadget in the dashboard.
		/// • REPORTS: specifies the reports associated with the gadget.
		/// • RUN.STEP and TYPE: specifies the synthesis or implementation run step that the gadget
		/// applies to.
		/// • VIEW.TYPE and ORIENTATION: Specifies the presentation of information as a graph or table,
		/// and indicates the orientation of the data.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 245
		/// </summary>
		/// <param name="name">(Required) Name of the gadget</param>
		/// <param name="type">(Required) Type of the gadget</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand create_dashboard_gadget(string name, string type, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_dashboard_gadget -name <arg> -type <arg> [-quiet] [-verbose]
			return
				new SimpleTCLCommand("create_dashboard_gadget")
					.RequiredNamedString("name", name)
					.RequiredNamedString("type", type)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Create a new Integrated Logic Analyzer debug core
		///
		///
		/// TCL Syntax: create_debug_core [-quiet] [-verbose] <name> <type>
		///
		/// Adds a new Integrated Logic Analyzer (ILA) debug core to an open netlist design in the current
		/// project. The ILA debug core defines ports for connecting nets to for debugging the design in the
		/// logic analyzer feature of the Vivado Design Suite available through the open_hw command.
		/// ILA debug cores can be added to the RTL source files of the design using debug cores from the
		/// Xilinx IP catalog, or added to the netlist design after synthesis using this command. Refer to the
		/// Vivado Design Suite User Guide: Vivado Programming and Debugging (UG908) for more information
		/// on using ILA debug cores.
		/// Note: A debug core can only be added to an open netlist design using this command.
		/// The ILA core is created with a CLK port and a PROBE port by default. The CLK port defines the
		/// clock domain for the ILA core, and allows you to probe signals that are common to that domain.
		/// The CLK port only supports one clock signal, and so you must create a separate debug core for
		/// each clock domain. The PROBE port provides a probe point for nets marked for debug with the
		/// MARK_DEBUG property. The PROBE port offers multiple channels to probe multiple nets from a
		/// single ILA core.
		/// You can add new ports to an existing ILA core with the create_debug_port command, and
		/// connect signals to the ports using the connect_debug_port command.
		///
		/// The following example opens the synthesis run, creating the specified netlist design name, and
		/// then creates a new ILA debug core in that design:
		/// open_run -name netlist_1 synth_1
		/// create_debug_core myCore ila
		/// The properties of the debug core can be customized by using the set_property command as
		/// in the following example:
		/// set_property C_DATA_DEPTH 2048 [get_debug_cores myCore]
		/// This example marks a sequence of nets for debugging using the MARK_DEBUG property, creates
		/// a new debug core, connects the CLK port to the appropriate clock domain, and assigns the debug
		/// nets to the PROBE ports on the core:
		/// set_property MARK_DEBUG true [get_nets [list {control_reg[0]}
		/// {control_reg[1]} \
		/// {control_reg[2]} {control_reg[3]} {control_reg[4]} {control_reg[5]} \
		/// {control_reg[6]} {control_reg[7]} {control_reg[8]} {control_reg[9]} \
		/// {control_reg[10]} {control_reg[11]} {control_reg[12]} {control_reg[13]}
		/// \
		/// {control_reg[14]} {control_reg[15]} {control_reg[16]} {control_reg[17]}
		/// \
		/// {control_reg[18]} {control_reg[19]} {control_reg[20]} {control_reg[21]}
		/// \
		/// {control_reg[22]} {control_reg[23]} {control_reg[24]} {control_reg[25]}
		/// \
		/// {control_reg[26]} {control_reg[27]} {control_reg[28]} {control_reg[29]}
		/// \
		/// {control_reg[30]} {control_reg[31]}]]
		/// create_debug_core u_ila_0 ila
		/// set_property port_width 1 [get_debug_ports u_ila_0/CLK]
		/// connect_debug_port u_ila_0/CLK [get_nets [list wbClk ]]
		/// set_property port_width 32 [get_debug_ports u_ila_0/PROBE0]
		/// connect_debug_port u_ila_0/PROBE0 [get_nets [list {control_reg[0]}
		/// {control_reg[1]} {control_reg[2]} {control_reg[3]} {control_reg[4]} \
		/// {control_reg[5]} {control_reg[6]} {control_reg[7]} {control_reg[8]} \
		/// {control_reg[9]} {control_reg[10]} {control_reg[11]} {control_reg[12]}
		/// \
		/// {control_reg[13]} {control_reg[14]} {control_reg[15]} {control_reg[16]}
		/// \
		/// {control_reg[17]} {control_reg[18]} {control_reg[19]} {control_reg[20]}
		/// \
		/// {control_reg[21]} {control_reg[22]} {control_reg[23]} {control_reg[24]}
		/// \
		/// {control_reg[25]} {control_reg[26]} {control_reg[27]} {control_reg[28]}
		/// \
		/// {control_reg[29]} {control_reg[30]} {control_reg[31]} ]]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 247
		/// </summary>
		/// <param name="name">(Required) Name of the new debug core instance</param>
		/// <param name="type">(Required) Type of the new debug core</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>new debug_core object</returns>
		public virtual SimpleTCLCommand create_debug_core(string name, string type, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_debug_core [-quiet] [-verbose] <name> <type>
			return
				new SimpleTCLCommand("create_debug_core")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
					.RequiredString(type)
			;
		}
		/// <summary>
		/// Create a new debug port
		///
		///
		/// TCL Syntax: create_debug_port [-quiet] [-verbose] <name> <type>
		///
		/// Defines a new port to be added to an existing Vivado ILA debug core that was added to the
		/// design using the create_debug_core command. The port provides connection points on an
		/// ILA core to attach nets from the design for debugging.
		/// When a new debug core is created using the create_debug_core command, it includes a clk
		/// and probe port by default. However, you can add trigger input/output port types as well. Refer
		/// to the Vivado Design Suite User Guide: Programming and Debugging (UG908) for more information
		/// on port types and purpose.
		/// A port can have one or more connection points to support one or more nets to debug. As a
		/// default new ports are defined as having a width of 1, allowing only one net to be attached. You
		/// can change the port width of probe ports to support multiple signals using the set_property
		/// port_width command (see Examples).
		/// Note: clk, trig_in, trig_in_ack, trig_out, and trig_out_ack ports can only have a width of 1.
		/// You can connect signals to ports using the connect_debug_port command, modify existing
		/// probe connections using modify_debug_ports, and disconnect signals with the
		/// disconnect_debug_port command.
		///
		/// The following example creates a new debug core, and then adds an additional probe port to the
		/// core, then sets the width of that new port to 8, and connects signals to the probe port:
		/// create_debug_core myCore ila
		/// create_debug_port myCore probe
		/// set_property PORT_WIDTH 8 myCore/probe1
		/// connect_debug_port -channel_start_index 1 myCore/probe1 \
		/// {m1_cyc_i m1_ack_o m1_err_o m1_rty_o}
		/// Note: Recall that the ILA core is created with a clk and probe port by default, so the new probe port is
		/// automatically numbered as probe1.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 250
		/// </summary>
		/// <param name="name">(Required) Name of the debug core instance</param>
		/// <param name="type">(Required) Type of the new debug port</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>new debug_port object</returns>
		public virtual SimpleTCLCommand create_debug_port(string name, string type, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_debug_port [-quiet] [-verbose] <name> <type>
			return
				new SimpleTCLCommand("create_debug_port")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
					.RequiredString(type)
			;
		}
		/// <summary>
		/// Create a user defined DRC rule
		///
		///
		/// TCL Syntax: create_drc_check [-hiername <arg>] -name <arg> [-desc <arg>] [-msg <arg>] -rule_body <arg> [-severity <arg>] [-quiet] [-verbose]
		///
		/// Create a new user-defined DRC rule check, drc_check, for use by the tool when running
		/// report_drc.
		/// This command allows you to define a unique name or abbreviation for the user-defined rule
		/// check, optionally group the rule into a special hierarchy and provide a description of the rule,
		/// define a general placeholder message for the check when violations are encountered, and refer
		/// to the Tcl code associated with the design rule check to be run during the report_drc
		/// command.
		/// The general placeholder message defined in this command is populated with specific information
		/// related to the design objects and violations found by the Tcl checker procedure, and by the
		/// create_drc_violation command.
		/// The process in brief is:
		/// • Write a Tcl checker procedure to define the method applied when checking the user-defined
		/// rule, and the objects to check against the rule. The Tcl checker procedure is defined in a
		/// separate Tcl script that must be loaded by the source command prior to running
		/// report_drc.
		/// • Use create_drc_violation in the Tcl checker to identify and flag violations found when
		/// checking the rule against a design.
		/// • Define a user-defined DRC rule check using the create_drc_check command that calls the
		/// Tcl checker proc from the -rule_body.
		/// • Create a rule deck using the create_drc_ruledeck command, and add the user-defined
		/// rule check to the rule deck using the add_drc_checks command.
		/// • Run report_drc, and specify either the rule deck, or the user-defined rule check to check
		/// for violations.
		/// If a drc_check of the specified name is already defined in the tool, an error is returned. In this
		/// case, to overwrite or redefine and existing drc_check, you must first delete the check using the
		/// delete_drc_check command.
		/// The DRC rule check object features the is_enabled property that can be set to TRUE or
		/// FALSE using the set_property command. When a new rule check is created, the
		/// is_enabled property is set to TRUE as a default. Set the is_enabled property to FALSE to
		/// disable the rule check from being used when report_drc is run. This lets you create new DRC
		/// checks, add them to rule decks using add_drc_checks, and then enable them or disable them
		/// as needed without having to remove them from the rule deck.
		/// Each user defined DRC rule check has the 'USER_DEFINED' property, which lets you quickly
		/// identify and select user-defined rule checks.
		///
		/// The following example defines a new design rule check named RAMW-1, with the hierarchy
		/// name and description defined, using the default severity of Warning, and calling the
		/// dataWidthCheck procedure when the check is run:
		/// create_drc_check -name {RAMW-1} -hiername {RAMB} \
		/// -desc {Data Width Check} -rule_body dataWidthCheck -severity Advisory
		/// The following Tcl script defines the dataWidthCheck procedure which is called by the -
		/// rule_body argument of the RAMW-1 check. This Tcl script file must be loaded into the tool
		/// using the source command, prior to running the report_drc command.
		/// # This is a simplistic check -- report BRAM cells with WRITE_WIDTH_B
		/// # wider than 36.
		/// proc dataWidthCheck {} {
		/// # list to hold violations
		/// set vios {}
		/// # iterate through the objects to be checked
		/// foreach bram [get_cells -hier -filter {PRIMITIVE_SUBGROUP == bram}] {
		/// set bwidth [get_property WRITE_WIDTH_B $bram]
		/// if { $bwidth > 36} {
		/// # define the message to report when violations are found
		/// set msg "On cell %ELG, WRITE_WIDTH_B is $bwidth"
		/// set vio [ create_drc_violation -name {RAMW-1} -msg $msg $bram ]
		/// lappend vios $vio
		/// }
		/// }
		/// if {[llength $vios] > 0} {
		/// return -code error $vios
		/// } else {
		/// return {}
		/// }
		/// }
		/// create_drc_check -name {RAMW-1} -hiername {RAMB Checks} \
		/// -desc {Data Width Check} -rule_body dataWidthCheck \
		/// -severity Advisory
		/// Note: The script file can contain both the Tcl checker procedure, and the create_drc_check command
		/// that defines it for use by report_drc command. In this case, when the Tcl script file is sourced, both the
		/// dataWidthCheck proc and the RAMW-1 design rule check are loaded into the tool.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 253
		/// </summary>
		/// <param name="name">
		/// (Required)
		/// Specify the name for this rule. This must be of the form
		/// PREFIX-id where XXXX is a 4-6 letter abbreviation and id is an
		/// integer identifying a particular rule. Similar checks should
		/// have the same abbreviation and each a unique id.
		/// </param>
		/// <param name="rule_body">
		/// (Required)
		/// The string representing the body of the rule. This can be a
		/// tcl proc name or any string of tcl code to be evaluated.
		/// </param>
		/// <param name="hiername">
		/// (Optional)
		/// Specify the hiername for this rule. When the DRC UI panel is
		/// created, this is used to place the new rule in the menu
		/// hierarchy. Use a dot (.) to separate layers in the menu
		/// hierarchy. It is optional and will default to User Defined.
		/// Default: User Defined
		/// </param>
		/// <param name="desc">
		/// (Optional)
		/// Specify the short description for this rule. It is optional and
		/// will default to <User rule - default description>. Default:
		/// User rule - default description
		/// </param>
		/// <param name="msg">
		/// (Optional)
		/// Specify the full description for this rule. Including the
		/// substitutions. Values are: %MSG_STRING
		/// %NETLIST_ELEMENT %SITE_GROUP %CLOCK_REGION
		/// %BANK %BEL_GROUP.
		/// </param>
		/// <param name="severity">
		/// (Optional)
		/// Specify severity level for a DRC rule. Default: Warning.
		/// Values: Error, Critical Warning, Warning, Advisory.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand create_drc_check(string name, string rule_body, string hiername = null, string desc = null, string msg = null, string severity = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_drc_check [-hiername <arg>] -name <arg> [-desc <arg>] [-msg <arg>] -rule_body <arg> [-severity <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("create_drc_check")
					.OptionalNamedString("hiername", hiername)
					.RequiredNamedString("name", name)
					.OptionalNamedString("desc", desc)
					.OptionalNamedString("msg", msg)
					.RequiredNamedString("rule_body", rule_body)
					.OptionalNamedString("severity", severity)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Create one or more user defined DRC rule deck objects
		///
		///
		/// TCL Syntax: create_drc_ruledeck [-quiet] [-verbose] <ruledecks>...
		///
		/// Create one or more user-defined rule decks for use when running report_drc.
		/// A drc_ruledeck object is a collection of design rule checks, grouped for convenience, to be run at
		/// different stages of the FPGA design flow, such as during I/O planning or placement. The tool
		/// comes with a set of factory predefined rule decks. Use the get_drc_ruledecks command to
		/// return a list of the currently defined rule decks.
		/// The rule decks created by this command are empty, without any checks. You must add design
		/// rule checks to the rule deck using the add_drc_checks command. Checks can be removed
		/// from a rule deck using the remove_drc_checks command. To see a list of design rule checks
		/// that are available to include in the ruledeck, use the get_drc_checks command.
		/// This command returns the list of drc_ruledecks created.
		///
		/// The following example creates two new drc_ruledeck objects:
		/// create_drc_ruledeck my_rules project_rules
		///
		/// See ug835-vivado-tcl-commands.pdf, page 258
		/// </summary>
		/// <param name="ruledecks">(Required) Names of DRC rule decks to create</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>drc_ruledeck</returns>
		public virtual SimpleTCLCommand create_drc_ruledeck(string ruledecks, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_drc_ruledeck [-quiet] [-verbose] <ruledecks>...
			return
				new SimpleTCLCommand("create_drc_ruledeck")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(ruledecks)
			;
		}
		/// <summary>
		/// Create a DRC violation
		///
		///
		/// TCL Syntax: create_drc_violation -name <arg> [-severity <arg>] [-msg <arg>] [-quiet] [-verbose] [<objects>...]
		///
		/// Create a DRC violation object and manage the list of design objects associated with the violation
		/// for reporting by the report_drc command.
		/// The create_drc_violation command is specified as part of the Tcl checker procedure that
		/// defines and implements the checking feature of a user-defined design rule check created by the
		/// create_drc_check command. A violation object is created by the Tcl checker each time a
		/// violation of the design rule is encountered.
		/// The process in brief is:
		/// • Write a Tcl checker procedure to define the method applied when checking the user-defined
		/// rule, and the objects to check against the rule. The Tcl checker procedure is defined in a
		/// separate Tcl script that must be loaded by the source command prior to running
		/// report_drc.
		/// • Use create_drc_violation in the Tcl checker to identify and flag violations found when
		/// checking the rule against a design.
		/// • Define a user-defined DRC rule check using the create_drc_check command that calls the
		/// Tcl checker proc from the -rule_body.
		/// • Create a rule deck using the create_drc_ruledeck command, and add the user-defined
		/// rule check to the rule deck using the add_drc_checks command.
		/// • Run report_drc, and specify either the rule deck, or the user-defined rule check to check
		/// for violations.
		/// Violations are reported by the report_drc command, and violation objects can be returned by
		/// the get_drc_violations command. The design objects associated with a DRC violation
		/// object can be obtained using the -of_objects option of the appropriate get_* command,
		/// such as get_cells, get_nets, or get_ports for instance:
		/// get_ports -of_objects [get_drc_violations -name drc_1 NSTD*]
		///
		/// The following Tcl script defines the dataWidthCheck procedure which is called by the -
		/// rule_body argument of the RAMW-1 check. This Tcl script file must be loaded into the tool
		/// using the source command, prior to running the report_drc command.
		/// Some features of the Tcl checker proc to notice are:
		/// • A list variable is created to store violations ($vios )
		/// • A violation object is created, and added to the list variable, each time a violation is found.
		/// • The placeholder key %ELG in the $msg string is dynamically substituted with the specific
		/// $bram cell associated with the violation.
		/// • The dataWidthCheck proc returns an error code when any violations are found ($vios >0)
		/// to inform the report_drc command of the results of the check.
		/// • The list of violations is passed along with the return code, and the violations are reported by
		/// report_drc.
		/// # This is a simplistic check -- report BRAM cells with WRITE_WIDTH_B
		/// # wider than 36.
		/// proc dataWidthCheck {} {
		/// # list to hold violations
		/// set vios {}
		/// # iterate through the objects to be checked
		/// foreach bram [get_cells -hier -filter {PRIMITIVE_SUBGROUP == bram}] {
		/// set bwidth [get_property WRITE_WIDTH_B $bram]
		/// if { $bwidth > 36} {
		/// # define the message to report when violations are found
		/// set msg "On cell %ELG, WRITE_WIDTH_B is $bwidth"
		/// set vio [ create_drc_violation -name {RAMW-1} -msg $msg $bram ]
		/// lappend vios $vio
		/// }
		/// }
		/// if {[llength $vios] > 0} {
		/// return -code error $vios
		/// } else {
		/// return {}
		/// }
		/// }
		/// create_drc_check -name {RAMW-1} -hiername {RAMB Checks} \
		/// -desc {Data Width Check} -rule_body dataWidthCheck \
		/// -severity Advisory
		/// Note: The script file can contain both the Tcl checker procedure, and the create_drc_check command
		/// that defines it for use by report_drc command. In this case, when the Tcl script file is sourced, both the
		/// dataWidthCheck proc and the RAMW-1 design rule check are loaded into the tool.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 260
		/// </summary>
		/// <param name="name">
		/// (Required)
		/// Specify the name for this rule. This is the typically a 4-6
		/// letter specification for your rule.
		/// </param>
		/// <param name="severity">
		/// (Optional)
		/// Specify severity level for a DRC rule. Default: WARNING.
		/// Values: FATAL, ERROR, CRITICAL WARNING, WARNING,
		/// ADVISORY.
		/// </param>
		/// <param name="msg">(Optional) Specify your message string for this DRC rule.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">
		/// (Optional)
		/// Cells, ports, pins, nets, clock regions, sites, package banks to
		/// query.
		/// </param>
		public virtual SimpleTCLCommand create_drc_violation(string name, string severity = null, string msg = null, bool? quiet = null, bool? verbose = null, string objects = null)
		{
			// TCL Syntax: create_drc_violation -name <arg> [-severity <arg>] [-msg <arg>] [-quiet] [-verbose] [<objects>...]
			return
				new SimpleTCLCommand("create_drc_violation")
					.RequiredNamedString("name", name)
					.OptionalNamedString("severity", severity)
					.OptionalNamedString("msg", msg)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(objects)
			;
		}
		/// <summary>
		/// Create a new fileset
		///
		///
		/// TCL Syntax: create_fileset [-constrset] [-simset] [-blockset] [-clone_properties <arg>] -define_from <arg> [-quiet] [-verbose] <name>
		///
		/// Defines a new fileset within a design project. Files can be added to a newly created fileset using
		/// the add_files command.
		/// A fileset is a list of files with a specific function within the project. One or more constraint files is
		/// a constraint set (-constrset); one or more simulation test benches is a simulation set (-
		/// simset). Only one fileset option can be specified when using the create_fileset command.
		/// As a default, the tool will create a constraint fileset if the type is not specified.
		/// You can also use the create_fileset -blockset command to configure an IP core, or
		/// hierarchical module of the design, as an out-of-context (OOC) block. The block fileset, or
		/// blockset, creates a hierarchical file collection for the IP or module specified with the -
		/// define_from option. The files related to the specified hierarchical module will be moved from
		/// their current fileset to the new blockset. When the blockset is created, the Vivado Design Suite
		/// also defines out-of-context synthesis and implementation runs for the block. The output
		/// products for the OOC module are stored in the blockset, including the synthesized design
		/// checkpoint (DCP) and any required structural simulation netlists. Stuctural simulation netlists are
		/// needed when a behavioral model for the block is not available, or is not available in the language
		/// supported by the target simulator. You can define an out-of-context constraint file for the IP or
		/// moduleif needed, and add the at to the block fileset as well.
		/// TIP: Refer to the Vivado Design Suite User Guide: Designing with IP (UG896) or the Vivado Design Suite User
		/// Guide: Hierarchical Design (UG905) for more information on out-of-context design.
		/// The create_fileset command returns the name of the newly created fileset, or will return an
		/// error message if it fails.
		///
		/// The following example creates a new constraint file set named constraints2:
		/// create_fileset -constrset -quiet constraints2
		/// Note: With -quiet specified, the tool will not return anything if it encounters an error in trying to create
		/// the specified fileset.
		/// The following example creates an out-of-context (OOC) blockset for the hierarchical module
		/// specified by the -define_from option:
		/// create_fileset -blockset -define_from dac_spi dac_spi
		/// The following example creates a new simulation fileset named sim_1:
		/// create_fileset -simset sim_1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 264
		/// </summary>
		/// <param name="define_from">(Required) Name of the module in the source fileset to be the top of the blockset</param>
		/// <param name="name">(Required) Name of the fileset to be create</param>
		/// <param name="constrset">(Optional) Create fileset as constraints fileset (default)</param>
		/// <param name="simset">(Optional) Create fileset as simulation source fileset</param>
		/// <param name="blockset">(Optional) Create fileset as block source fileset</param>
		/// <param name="clone_properties">(Optional) Fileset to initialize properties from</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>new fileset object</returns>
		public virtual SimpleTCLCommand create_fileset(string define_from, string name, bool? constrset = null, bool? simset = null, bool? blockset = null, string clone_properties = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_fileset [-constrset] [-simset] [-blockset] [-clone_properties <arg>] -define_from <arg> [-quiet] [-verbose] <name>
			return
				new SimpleTCLCommand("create_fileset")
					.Flag("constrset", constrset)
					.Flag("simset", simset)
					.Flag("blockset", blockset)
					.OptionalNamedString("clone_properties", clone_properties)
					.RequiredNamedString("define_from", define_from)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
			;
		}
		/// <summary>
		/// Create a generated clock object
		///
		///
		/// TCL Syntax: create_generated_clock [-name <arg>] [-source <args>] [-edges <args>] [-divide_by <arg>] [-multiply_by <arg>] [-combinational] [-duty_cycle <arg>] [-invert] [-edge_shift <args>] [-add] [-master_clock <args>] [-quiet] [-verbose] <objects>
		///
		/// TIP: The XDC > Timing Constraints language templates and the Timing Constraints Wizard in the Vivado IDE
		/// offer timing diagrams and additional details around defining specific timing constraints. You can refer to these
		/// sources for additional information.
		/// Generate a new clock object from an existing physical clock object in the design.
		/// Clocks can be added to a design in one of three ways:
		/// • Primary physical or virtual clocks defined with the create_clock command.
		/// • Derived clocks defined with the create_generated_clock command generated from a
		/// primary physical clock.
		/// • Derived clocks automatically generated by the Vivado Design Suite when a clock propagates
		/// through an MMCM/PLL/BUFR.
		/// You can also use the create_generated_clock command to change the name of clocks that
		/// the Vivado tool has auto-derived from an MMCM/PLL/BUFR. In this case, a new clock is not
		/// created, but an existing clock defined on the specified source object is renamed to the provided
		/// name. This requires -name and <object> to be specified, and supports the use of -source
		/// and/or -master_clock to further identify the clock to rename when multiple clocks exist on
		/// the source object. Refer to the Vivado Design Suite User Guide: Using Constraints (UG903) for more
		/// information on renaming auto-derived clocks.
		/// IMPORTANT! You cannot rename a clock that is already in use by other constraints at the time of renaming.
		/// You must rename the clock prior to any other appearance or use of the clock in an XDC file.
		/// This command returns the name of the clock object that is created, or returns an error if it fails.
		///
		/// The following example defines a generated clock that is divided from the master clock found on
		/// the specified CLK pin. Since -name is not specified, the generated clock is assigned the same
		/// name as the pin it is assigned to:
		/// create_generated_clock -divide_by 2 -source \
		/// [get_pins clkgen/cpuClk] [get_nets fftEngine/CLK]
		/// The following example defines a generated clock named CLK1 from the specified source clock,
		/// specifying the edges of the master clock to use as transition points for the generated clock, with
		/// edges shifted by the specified amount. In this example, the -edges option indicates that the
		/// second edge of the source clock is the first rising edge of the generated clock, the third edge of
		/// the source clock is the first falling edge of the generated clock, and the eighth edge of the source
		/// clock is the second rising edge of the generated clock. These values determine the period of the
		/// generated clock as the time from edge 2 to edge 8 of the source clock, and the duty cycle as the
		/// percentage of the period between edge 2 and edge 3 of the source clock. In addition, each edge
		/// of the generated clock is shifted by the specified amount:
		/// create_generated_clock -name CLK1 -source CMB/CLKIN -edges {2 3 8} \
		/// -edge_shift {0 -1.0 -2.0} CMB/CLKOUT
		/// Note: The waveform pattern of the generated clock is repeated based on the transitions defined by the -
		/// edges argument.
		/// This example creates two generated clocks from the output of a MUX, using -master_clock
		/// to identify which clock to use, using -add to assign the generated clocks to the Q pin of a flip
		/// flop, and using -name to define a name for the generated clock, since the object it is assigned to
		/// has multiple clocks assigned:
		/// create_generated_clock -source [get_pins muxOut] -master_clock M_CLKA \
		/// -divide_by 2 -add -name gen_CLKA [get_pins flop_Q]
		/// create_generated_clock -source [get_pins muxOut] -master_clock M_CLKB \
		/// -divide_by 2 -add -name gen_CLKB [get_pins flop_Q]
		/// The following example renames the automatically named clock that is derived by the Vivado
		/// Design Suite on the MMCM clock output:
		/// create_generated_clock -name CLK_DIV2 [get_pins mmcm/CLKOUT1]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 267
		/// </summary>
		/// <param name="objects">(Required) List of clock source ports, pins, or nets</param>
		/// <param name="name">(Optional) Generated clock name</param>
		/// <param name="source">(Optional) Master clock source object pin/port</param>
		/// <param name="edges">(Optional) Edge Specification</param>
		/// <param name="divide_by">(Optional) Period division factor: Value >= 1 Default: 1</param>
		/// <param name="multiply_by">(Optional) Period multiplication factor: Value >= 1 Default: 1</param>
		/// <param name="combinational">(Optional) Create a divide_by 1 clock through combinational logic</param>
		/// <param name="duty_cycle">(Optional) Duty cycle of clock period: Range: 0.0 to 100.0 Default: 50.0</param>
		/// <param name="invert">(Optional) Invert the signal</param>
		/// <param name="edge_shift">(Optional) Edge shift specification</param>
		/// <param name="add">(Optional) Add to the existing clock in source_objects</param>
		/// <param name="master_clock">(Optional) Use this clock if multiple clocks present at master pin</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>new clock object</returns>
		public virtual SimpleTCLCommand create_generated_clock(string objects, string name = null, string source = null, string edges = null, string divide_by = null, string multiply_by = null, bool? combinational = null, string duty_cycle = null, bool? invert = null, string edge_shift = null, bool? add = null, string master_clock = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_generated_clock [-name <arg>] [-source <args>] [-edges <args>] [-divide_by <arg>] [-multiply_by <arg>] [-combinational] [-duty_cycle <arg>] [-invert] [-edge_shift <args>] [-add] [-master_clock <args>] [-quiet] [-verbose] <objects>
			return
				new SimpleTCLCommand("create_generated_clock")
					.OptionalNamedString("name", name)
					.OptionalNamedString("source", source)
					.OptionalNamedString("edges", edges)
					.OptionalNamedString("divide_by", divide_by)
					.OptionalNamedString("multiply_by", multiply_by)
					.Flag("combinational", combinational)
					.OptionalNamedString("duty_cycle", duty_cycle)
					.Flag("invert", invert)
					.OptionalNamedString("edge_shift", edge_shift)
					.Flag("add", add)
					.OptionalNamedString("master_clock", master_clock)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Create a custom command in the GUI
		///
		///
		/// TCL Syntax: create_gui_custom_command -name <arg> [-menu_name <arg>] [-description <arg>] [-show_on_toolbar] [-run_proc <arg>] [-toolbar_icon <arg>] [-command <arg>] [-tcl_file <arg>] [-quiet] [-verbose]
		///
		/// This commands creates a GUI menu item for a user custom command. The menu command
		/// appears in the Tools → Custom Commands menu in the Vivado IDE.
		/// The custom GUI command can also be shown/hidden on the toolbar menu. When the GUI
		/// button is clicked the custom command is executed. A Tcl file can also be sourced when the GUI
		/// button is clicked.
		/// You can use the get_gui_custom_commands to determine the list of user-defined custom
		/// commands.
		///
		/// The following example creates a GUI custom command with name 'print_version', and adds it to
		/// the toolbar.
		/// create_gui_custom_command -name print_version -command "version" \
		/// -description "Gets tool version" -show_on_toolbar
		///
		/// See ug835-vivado-tcl-commands.pdf, page 272
		/// </summary>
		/// <param name="name">(Required) Unique name of the command to create.</param>
		/// <param name="menu_name">(Optional) Menu name for the custom command.</param>
		/// <param name="description">
		/// (Optional)
		/// Display this text for the description of the menu item and
		/// optionally the toolbar button
		/// </param>
		/// <param name="show_on_toolbar">(Optional) Add this command to the toolbar</param>
		/// <param name="run_proc">
		/// (Optional)
		/// Needed when '-command' and 'tcl_file' options are both
		/// specified. If true, gui button will run command mentioned in
		/// '-command' option otherwise source script mentioned in '-
		/// tcl_file' option
		/// </param>
		/// <param name="toolbar_icon">(Optional) The full path to the PNG or JPEG file to display on the toolbar button</param>
		/// <param name="command">(Optional) The command to execute</param>
		/// <param name="tcl_file">(Optional) The full path to the Tcl file to source</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand create_gui_custom_command(string name, string menu_name = null, string description = null, bool? show_on_toolbar = null, string run_proc = null, string toolbar_icon = null, string command = null, string tcl_file = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_gui_custom_command -name <arg> [-menu_name <arg>] [-description <arg>] [-show_on_toolbar] [-run_proc <arg>] [-toolbar_icon <arg>] [-command <arg>] [-tcl_file <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("create_gui_custom_command")
					.RequiredNamedString("name", name)
					.OptionalNamedString("menu_name", menu_name)
					.OptionalNamedString("description", description)
					.Flag("show_on_toolbar", show_on_toolbar)
					.OptionalNamedString("run_proc", run_proc)
					.OptionalNamedString("toolbar_icon", toolbar_icon)
					.OptionalNamedString("command", command)
					.OptionalNamedString("tcl_file", tcl_file)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Create a custom command argument for a custom command in the GUI
		///
		///
		/// TCL Syntax: create_gui_custom_command_arg -command_name <arg> -arg_name <arg> [-default <arg>] [-comment <arg>] [-optional] [-quiet] [-verbose]
		///
		/// This commands defines an argument for a specific custom GUI command.
		/// You can use the get_gui_custom_commands to determine the list of defined custom
		/// commands. You can use the get_gui_custom_command_args to determine the list of
		/// defined GUI custom command arguments of a particular GUI custom command.
		///
		/// This example creates an argument named 'quiet' for the custom GUI command
		/// print_version. The argument is defined as optional and its default value is -quiet.
		/// create_gui_custom_command_arg -command_name print_version -arg_name quiet \
		/// -default "-quiet" -comment "Ignore commands errors" -optional
		///
		/// See ug835-vivado-tcl-commands.pdf, page 274
		/// </summary>
		/// <param name="command_name">
		/// (Required)
		/// Unique name of the custom command for which an
		/// argument is being created.
		/// </param>
		/// <param name="arg_name">(Required) Unique name of the custom command argument to create.</param>
		/// <param name="@default">(Optional) Default value of the custom command argument.</param>
		/// <param name="comment">(Optional) Comment for the custom command argument.</param>
		/// <param name="optional">(Optional) Make the custom command argument optional.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand create_gui_custom_command_arg(string command_name, string arg_name, string @default = null, string comment = null, bool? optional = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_gui_custom_command_arg -command_name <arg> -arg_name <arg> [-default <arg>] [-comment <arg>] [-optional] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("create_gui_custom_command_arg")
					.RequiredNamedString("command_name", command_name)
					.RequiredNamedString("arg_name", arg_name)
					.OptionalNamedString("default", @default)
					.OptionalNamedString("comment", comment)
					.Flag("optional", optional)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Create hardware AXI transaction object
		///
		///
		/// TCL Syntax: create_hw_axi_txn [-address <arg>] [-data <arg>] [-size <arg>] -type <arg> [-len <arg>] [-burst <arg>] [-cache <arg>] [-id <arg>] [-force] [-quiet] [-verbose] <name> <hw_axi>
		///
		/// Define a read or write transaction for the JTAG to AXI Master core, hw_axi object, specified by
		/// the get_hw_axis command.
		/// The JTAG to AXI Master is a customizable IP core that works as an AXI Master to drive AXI
		/// transactions and drive AXI signals that are internal to the hardware device. The JTAG-AXI core
		/// supports all memory-mapped AXI interfaces, except AXI4-Stream, and supports the AXI-Lite
		/// protocol. Detailed documentation on the IP core can be found in the LogiCORE IP JTAG to AXI
		/// Master Product Guide (PG174).
		/// AXI transactions are read/write burst transactions from the JTAG to AXI Master core onto AXI
		/// signals connected to the core. The AXI transaction lets you configure aspects of the read or write
		/// transaction such as the data to send and the address to send it to. These defined transactions are
		/// stored as properties of the specified hw_axi object, waiting to be run and reported using the
		/// run_hw_axi and report_hw_axi_txn commands.
		/// The command returns the name of the hw_axi_txn object created, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 276
		/// </summary>
		/// <param name="type">(Required) READ or WRITE transaction.</param>
		/// <param name="name">(Required) Name of new object.</param>
		/// <param name="hw_axi">(Required) Associated hardware AXI core object.</param>
		/// <param name="address">(Optional) AXI read or write address. Default: Address zero</param>
		/// <param name="data">(Optional) Transaction data. Default: All zeroes</param>
		/// <param name="size">
		/// (Optional)
		/// Deprecated. Data word size in bits. This is now automatically
		/// set based on the IP core properties.
		/// </param>
		/// <param name="len">(Optional) Length of the transaction in data words. Default: 1</param>
		/// <param name="burst">(Optional) Burst type: INCR,FIXED or WRAP. Default: INCR</param>
		/// <param name="cache">(Optional) AXI cache type. Default: 3</param>
		/// <param name="id">(Optional) Address ID. Default: 0</param>
		/// <param name="force">
		/// (Optional)
		/// Overwrite an existing transaction with the specified name if
		/// it exists, otherwise create a new transaction. Default: 0
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>New hardware AXI transaction object.</returns>
		public virtual SimpleTCLCommand create_hw_axi_txn(string type, string name, string hw_axi, string address = null, string data = null, string size = null, string len = null, string burst = null, string cache = null, string id = null, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_hw_axi_txn [-address <arg>] [-data <arg>] [-size <arg>] -type <arg> [-len <arg>] [-burst <arg>] [-cache <arg>] [-id <arg>] [-force] [-quiet] [-verbose] <name> <hw_axi>
			return
				new SimpleTCLCommand("create_hw_axi_txn")
					.OptionalNamedString("address", address)
					.OptionalNamedString("data", data)
					.OptionalNamedString("size", size)
					.RequiredNamedString("type", type)
					.OptionalNamedString("len", len)
					.OptionalNamedString("burst", burst)
					.OptionalNamedString("cache", cache)
					.OptionalNamedString("id", id)
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
					.RequiredString(hw_axi)
			;
		}
		/// <summary>
		/// Read bitstream file into memory
		///
		///
		/// TCL Syntax: create_hw_bitstream -hw_device <arg> [-mask <arg>] [-nky <arg>] [-detect_partial] [-quiet] [-verbose] [<file>]
		///
		/// Read a bitstream file, created with the write_bitstream command, to create a hw_bitstream
		/// object, and associate that object with a hw_device object in the Hardware Manager feature of
		/// the Vivado Design Suite.
		/// The hw_bitstream object is associated with the specified hw_device through the
		/// PROGRAM.HW_BITSTREAM property on the device. This property is automatically set by the
		/// create_hw_bitstream command. The PROGRAM.FILE property is also set to reflect the file
		/// path of the specified bitstream file.
		/// Note: A hw_bitstream object is also automatically created and associated with a hw_device object when
		/// you use the program_hw_devices command.
		/// The mask file written with the bitstream file, using the write_bitstream -mask command, is
		/// associated through the MASK property on the hw_bitstream object. The encryption key file
		/// required for use with an encrypted bitstream is associated through the ENCRYPTION.FILE
		/// property on the hw_bitstream object. These files are associated with the hw_bitstream object
		/// using the -mask and -nky options.
		/// The created hw_bitstream object can be removed with the delete_hw_bitstream command.
		/// This command returns the name of the hw_bitstream object created, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 280
		/// </summary>
		/// <param name="hw_device">(Required) Target hw_device connection</param>
		/// <param name="file">(Required) Bitstream filename</param>
		/// <param name="mask">(Optional) Mask file for hw device</param>
		/// <param name="nky">(Optional) Encryption file for hw device</param>
		/// <param name="detect_partial">(Optional) detects partial bitstream</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand create_hw_bitstream(string hw_device, string file, string mask = null, string nky = null, bool? detect_partial = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_hw_bitstream -hw_device <arg> [-mask <arg>] [-nky <arg>] [-detect_partial] [-quiet] [-verbose] [<file>]
			return
				new SimpleTCLCommand("create_hw_bitstream")
					.RequiredNamedString("hw_device", hw_device)
					.OptionalNamedString("mask", mask)
					.OptionalNamedString("nky", nky)
					.Flag("detect_partial", detect_partial)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Read cfgmem file into memory
		///
		///
		/// TCL Syntax: create_hw_cfgmem -hw_device <arg> [-quiet] [-verbose] <mem_device>
		///
		/// Create a hw_cfgmem object associated with the specified hw_device.
		/// The process whereby the bitstream data is loaded or programmed into the Xilinx® FPGA is called
		/// configuration. Configuration is designed to be flexible to accommodate different application
		/// needs and, wherever possible, to leverage existing system resources to minimize system costs.
		/// Xilinx FPGAs are configured by loading design-specific configuration data, in the form of a
		/// bitstream file, into the internal memory of the hw_device. The hw_cfgmem defines a flash
		/// memory device used for configuring and booting the Xilinx FPGA device. Once the hw_cfgmem
		/// object is created, and associated with the hw_device, the configuration memory can be
		/// programmed with the bitstream and other data using the program_hw_cfgmem command.
		/// The hw_cfgmem object is associated with the specified hw_device object through the
		/// PROGRAM.HW_CFGMEM property on the device object. Use the get_hw_cfgmems command
		/// to work with the hw_cfgmem object, or use the get_property command to obtain the object
		/// from the hw_device:
		/// get_property PROGRAM.HW_CFGMEM [current_hw_device]
		/// TIP: When creating a new hw_cfgmem object, you can also associate the object with a Tcl variable as shown in
		/// the example below. By referring to the variable, you can set properties on the object, and use the object with
		/// other Tcl commands like program_hw_cfgmem or readback_hw_cfgmem.
		/// This command returns the created hw_cfgmem object, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 283
		/// </summary>
		/// <param name="hw_device">(Required) hw_device object with which to associate hw_cfgmem object</param>
		/// <param name="mem_device">(Required) name of flash memory device as returned by get_cfgmem_parts</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand create_hw_cfgmem(string hw_device, string mem_device, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_hw_cfgmem -hw_device <arg> [-quiet] [-verbose] <mem_device>
			return
				new SimpleTCLCommand("create_hw_cfgmem")
					.RequiredNamedString("hw_device", hw_device)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(mem_device)
			;
		}
		/// <summary>
		/// Create a hw_device (jtag chain) on an open target
		///
		///
		/// TCL Syntax: create_hw_device [-idcode <arg>] [-irlength <arg>] [-mask <arg>] [-part <arg>] [-quiet] [-verbose]
		///
		/// The Vivado hardware manager supports programming of hardware devices through the use of
		/// Serial Vector Format (SVF) files. SVF files are ASCII files that contain both programming
		/// instructions and configuration data. These files are used by ATE machines and embedded
		/// controllers to perform boundary-scan operations. The SVF file captures the JTAG commands
		/// needed to program the bitstream directly into a Xilinx device, or indirectly into a flash memory
		/// device. The SVF file can be written using the write_hw_svf command, or applied to an open
		/// hw_target through the execute_hw_svf command. Refer to the Vivado Design Suite User Guide:
		/// Programming and Debugging (UG908) for more information.
		/// The specific process for creating the hw_svf file is:
		/// 1. Create an SVF target using create_hw_target.
		/// 2. Open the SVF target.
		/// 3. Create one or more devices on the SVF target using create_hw_device.
		/// 4. Program the devices using commands like program_hw_devices.
		/// 5. Write the SVF file of operation commands using write_hw_svf.
		/// The create_hw_device command creates a hw_device object on an open SVF target, adding it
		/// to the JTAG chain. This device can be queried and programmed like other hw_targets using
		/// commands like get_hw_devices and program_hw_devices.
		/// You can create both Xilinx devices and user-defined parts to add to the JTAG chain on the open
		/// SVF hw_target. For Xilinx devices, simply specify a recognized part number and the Vivado tool
		/// will define it with the appropriate details. For user-defined parts you must specify the JTAG ID
		/// code, IR length, and mask details using the appropriate options. User-defined parts are added as
		/// space-holder devices to the JTAG chain as on the SVF hw_target. You can get the user-part with
		/// get_hw_devices command, and query the properties of the part with report_property,
		/// but you cannot program user-parts.
		/// IMPORTANT! You should create all the devices to define the JTAG chain for the SVF target, before performing
		/// any operations on the JTAG chain. If you mix create_hw_device commands with programming commands
		/// the JTAG chain referenced in the SVF file will be improperly defined and will not work during
		/// execute_hw_svf.
		/// After creating the hw_device on the SVF target, you can exercise the device with supported
		/// operations such as associating a bitstream file (.bit) and programming the device:
		/// set_property PROGRAM.FILE {C:/Data/design.bit} [current_hw_device]
		/// program_hw_devices [current_hw_device]
		/// The create_hw_device command returns nothing if successful, and returns an error if it fails.
		///
		/// The following example creates an SVF target, opens that target, and creates a new hw_device on
		/// the target:
		/// create_hw_target my_svf_target
		/// open_hw_target
		/// create_hw_device -part xc7k325t
		/// This example demonstrates the correct order of creating multiple devices on an SVF target. An
		/// SVF target is created and opened, then a Xilinx device, a user part, and a second Xilinx device are
		/// created on the current target. The bitstream properties are defined for the two Xilinx devices, the
		/// devices are programmed, and an SVF file is written:
		/// open_hw
		/// connect_hw_server
		/// create_hw_target my_svf_target
		/// open_hw_target
		/// create_hw_device -part xc7k325t
		/// create_hw_device -idcode 01234567 -irlength 8 -mask ffffffff -part
		/// userPart1
		/// create_hw_device -part xcku9p
		/// set_property PROGRAM.FILE {C:/Data/k7_design.bit} [lindex [get_hw_devices]
		/// 0]
		/// set_property PROGRAM.FILE {C:/Data/ku_design.bit} [lindex [get_hw_devices]
		/// 2]
		/// program_hw_devices [lindex [get_hw_devices] 0]
		/// program_hw_devices [lindex [get_hw_devices] 2]
		/// write_hw_svf C:/Data/myDesign.svf
		///
		/// See ug835-vivado-tcl-commands.pdf, page 286
		/// </summary>
		/// <param name="idcode">(Optional) hexadecimal device id code</param>
		/// <param name="irlength">(Optional) decimal device ir length</param>
		/// <param name="mask">(Optional) hexadecimal device mask value</param>
		/// <param name="part">(Optional) part type of device to create</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand create_hw_device(string idcode = null, string irlength = null, string mask = null, string part = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_hw_device [-idcode <arg>] [-irlength <arg>] [-mask <arg>] [-part <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("create_hw_device")
					.OptionalNamedString("idcode", idcode)
					.OptionalNamedString("irlength", irlength)
					.OptionalNamedString("mask", mask)
					.OptionalNamedString("part", part)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Create hardware probe object
		///
		///
		/// TCL Syntax: create_hw_probe [-no_gui_update] [-map <arg>] [-quiet] [-verbose] <name> <core>
		///
		/// This command creates a new user-defined probe on the specified ILA core to define triggers and
		/// view data in the Vivado Logic Analyzer. The new probe can combine specific bit values of existing
		/// probes to simplify or clarify the data presented in the waveform viewer. Captured data samples
		/// from the user-defined probe can be reported with the list_hw_samples command.
		/// User-defined probes can map bit values from a single physical probe on the ILA core, or can
		/// combine bit values from multiple physical probes onto a single user-defined probe. Probes that
		/// map bits from a single probe can be used to create triggers and view data. Probes that combine
		/// bits from multiple physical probes can only be used for viewing data in the Vivado Logic Analyzer.
		/// You can delete user-defined probes with the delete_hw_probe command.
		/// The create_hw_probe command returns the user-defined probe name when successful, or
		/// returns an error if it fails.
		///
		/// The following example maps bits from multiple physical probes onto a new user-defined probe
		/// on the specified ILA core:
		/// create_hw_probe -map {0011 probe5[3:0] probe8 probe9} myProbeAR[9:0]
		/// hw_ila_1
		/// TIP: The -map option combines 10 bits onto the new probe, so the probe name specifies a matching port
		/// width.
		/// The following example creates a hw_probe with copies of the most-significant bit to sign-extend
		/// a 30-bit signal to align it with other 32-bit signed signals:
		/// create_hw_probe -map {probe0[29] probe0[29] probe0[29:0]} \
		/// mySignExtendedProbe[31:0] [get_hw_ilas hw_ila_1]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 289
		/// </summary>
		/// <param name="name">(Required) Name of new object. Bus probes have range appended.</param>
		/// <param name="core">(Required) Associated hardware ILA core object.</param>
		/// <param name="no_gui_update">(Optional) Defer GUI update.</param>
		/// <param name="map">(Optional) Declaration of bits. Default: 0</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>New hardware probe object.</returns>
		public virtual SimpleTCLCommand create_hw_probe(string name, string core, bool? no_gui_update = null, string map = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_hw_probe [-no_gui_update] [-map <arg>] [-quiet] [-verbose] <name> <core>
			return
				new SimpleTCLCommand("create_hw_probe")
					.Flag("no_gui_update", no_gui_update)
					.OptionalNamedString("map", map)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
					.RequiredString(core)
			;
		}
		/// <summary>
		/// Create a new link between hardware RX and TX endpoints. There must be at least one hardware
		/// TX or RX endpoint specified. If one is missing, the endpoint will be treated as Unknown. The
		/// unknown endpoint can be renamed in a link property.
		///
		///
		/// TCL Syntax: create_hw_sio_link [-description <arg>] [-quiet] [-verbose] [<hw_sio_rx>] [<hw_sio_tx>]
		///
		/// Define a communication links between transmitter (TX) and receiver (RX) objects on the GTs of
		/// the IBERT debug core implemented on the current hardware device.
		/// Vivado Serial I/O analyzer is a link-based analyzer, which lets you link between any transmitter
		/// and receiver within the IBERT design. The links define the communication paths and protocols
		/// between transmitters and receivers of the GigaBit transceivers on the device. You can configure
		/// the links by using the set_property command to specify property values on the link object.
		/// Refer to the Vivado Design Suite User Guide: Programming and Debugging (UG908) for more
		/// information on configuring links.
		/// This command returns the created hw_sio_link object, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 292
		/// </summary>
		/// <param name="description">(Optional) Description of link. Default: Link object name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_sio_rx">(Optional) RX endpoint. Default: None</param>
		/// <param name="hw_sio_tx">(Optional) TX endpoint. Default: None</param>
		/// <returns>The new hardware SIO link</returns>
		public virtual SimpleTCLCommand create_hw_sio_link(string description = null, bool? quiet = null, bool? verbose = null, string hw_sio_rx = null, string hw_sio_tx = null)
		{
			// TCL Syntax: create_hw_sio_link [-description <arg>] [-quiet] [-verbose] [<hw_sio_rx>] [<hw_sio_tx>]
			return
				new SimpleTCLCommand("create_hw_sio_link")
					.OptionalNamedString("description", description)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(hw_sio_rx)
					.OptionalString(hw_sio_tx)
			;
		}
		/// <summary>
		/// Create a new hardware SIO link group.
		///
		///
		/// TCL Syntax: create_hw_sio_linkgroup [-description <arg>] [-quiet] [-verbose] <hw_sio_links>
		///
		/// Create a new group to associate the specified TX to RX communication links on the IBERT debug
		/// core implemented on the current device.
		/// Vivado Serial I/O analyzer is a link-based analyzer. The links define the communication paths and
		/// protocols between transmitters and receivers of the GigaBit transceivers on the device. Link
		/// groups, or hw_sio_linkgroup objects, let you associate links into related groups, to collectively
		/// configure properties and run scans.
		/// This command returns the name of the linkgroup created, or returns an error if the command
		/// fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 294
		/// </summary>
		/// <param name="hw_sio_links">(Required) hardware SIO links</param>
		/// <param name="description">(Optional) Description of link group. Default: Link group object name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The new hardware SIO link group</returns>
		public virtual SimpleTCLCommand create_hw_sio_linkgroup(string hw_sio_links, string description = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_hw_sio_linkgroup [-description <arg>] [-quiet] [-verbose] <hw_sio_links>
			return
				new SimpleTCLCommand("create_hw_sio_linkgroup")
					.OptionalNamedString("description", description)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_sio_links)
			;
		}
		/// <summary>
		/// Create a new hardware SIO scan. If a Link object is passed in, it must have a RX Endpoint object.
		///
		///
		/// TCL Syntax: create_hw_sio_scan [-description <arg>] [-link_settings <arg>] [-quiet] [-verbose] <scan_type> <hw_sio_object>
		///
		/// Create a serial I/O analyzer scan object for the specified communication link on the IBERT debug
		/// core.
		/// To analyze the margin of a given link, it is often helpful to run a scan of the link using the
		/// specialized Eye Scan hardware of Xilinx UltraScale devices or 7 series FPGAs. The Vivado serial
		/// I/O analyzer feature lets you to create, run, and save link scans.
		/// This command creates and returns a link scan object that you can use with the
		/// run_hw_sio_scan command to run analysis on the specified links, or GT receivers. You can
		/// also save the scan to disk using the write_hw_sio_scan command.
		/// You can remove the created scan object using remove_hw_sio_scan.
		/// This command returns the hw_sio_scan object, or returns an error if the command fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 296
		/// </summary>
		/// <param name="scan_type">(Required) Scan Type Options: 1d_bathtub, 2d_full_eye</param>
		/// <param name="hw_sio_object">(Required) RX endpoint or Link object to perform scan on.</param>
		/// <param name="description">(Optional) Description of scan Default: Scan object name</param>
		/// <param name="link_settings">
		/// (Optional)
		/// List of Link properties and values to set before running the
		/// scan. Default: None
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The new hardware SIO scan</returns>
		public virtual SimpleTCLCommand create_hw_sio_scan(string scan_type, string hw_sio_object, string description = null, string link_settings = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_hw_sio_scan [-description <arg>] [-link_settings <arg>] [-quiet] [-verbose] <scan_type> <hw_sio_object>
			return
				new SimpleTCLCommand("create_hw_sio_scan")
					.OptionalNamedString("description", description)
					.OptionalNamedString("link_settings", link_settings)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(scan_type)
					.RequiredString(hw_sio_object)
			;
		}
		/// <summary>
		/// Create a new hardware SIO sweep. If a Link object is passed in, it must have a RX Endpoint
		/// object.
		///
		///
		/// TCL Syntax: create_hw_sio_sweep [-description <arg>] [-iteration_settings <arg>] [-quiet] [-verbose] <scan_type> [<hw_sio_link>]
		///
		/// Create a serial I/O analyzer link sweep object to run multiple scans across a range of values.
		/// To analyze the margin of a given link, it is often helpful to run a scan of the link using the
		/// specialized features of Xilinx® UltraScale™ devices or 7 series FPGAs. It can also be helpful to run
		/// multiple scans on a the link with different configuration settings for the GTs. This can help you
		/// determine which settings are best for your design. The Vivado® serial I/O analyzer feature
		/// enables you to define, run, and save link sweeps, or collections of link scans run across a range of
		/// values.
		/// This command creates and returns a link sweep object that you can use with the
		/// run_hw_sio_sweep command to run analysis on the specified links, or GT receivers. You can
		/// also save the sweep scan to disk using the write_hw_sio_sweep command.
		/// You can remove the created sweep object using remove_hw_sio_sweep.
		/// This command returns the hw_sio_sweep object, or returns an error if the command fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 299
		/// </summary>
		/// <param name="scan_type">(Required) Sweep Type Options: 1d_bathtub, 2d_full_eye</param>
		/// <param name="description">(Optional) Description of sweep Default: Sweep object name</param>
		/// <param name="iteration_settings">
		/// (Optional)
		/// List of LINK_SETTINGS for each scan to set before running
		/// the sweep. Default: None
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_sio_link">(Optional) Link object to perform sweep on. Default: None</param>
		/// <returns>The new hardware SIO sweep</returns>
		public virtual SimpleTCLCommand create_hw_sio_sweep(string scan_type, string description = null, string iteration_settings = null, bool? quiet = null, bool? verbose = null, string hw_sio_link = null)
		{
			// TCL Syntax: create_hw_sio_sweep [-description <arg>] [-iteration_settings <arg>] [-quiet] [-verbose] <scan_type> [<hw_sio_link>]
			return
				new SimpleTCLCommand("create_hw_sio_sweep")
					.OptionalNamedString("description", description)
					.OptionalNamedString("iteration_settings", iteration_settings)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(scan_type)
					.OptionalString(hw_sio_link)
			;
		}
		/// <summary>
		/// Create a hw_target (jtag chain) and set its name
		///
		///
		/// TCL Syntax: create_hw_target [-copy <arg>] [-quiet] [-verbose] <target_name>
		///
		/// The Vivado hardware manager supports programming of hardware devices through the use of
		/// Serial Vector Format (SVF) files. SVF files are ASCII files that contain both programming
		/// instructions and configuration data. These files are used by ATE machines and embedded
		/// controllers to perform boundary-scan operations. The SVF file captures the JTAG commands
		/// needed to program the bitstream directly into a Xilinx device, or indirectly into a flash memory
		/// device. The SVF file can be written using the write_hw_svf command, or applied to an open
		/// hw_target through the execute_hw_svf command. Refer to the Vivado Design Suite User Guide:
		/// Programming and Debugging (UG908) for more information.
		/// The specific process for creating the hw_svf file is:
		/// 1. Create an SVF target using create_hw_target.
		/// 2. Open the SVF target.
		/// 3. Create one or more devices on the SVF target using create_hw_device.
		/// 4. Program the devices using commands like program_hw_devices.
		/// 5. Write the SVF file of operation commands using write_hw_svf.
		/// The create_hw_target command creates an SVF hw_target object on the current hw_server
		/// that can be used as a platform for programming devices, and exporting the programming
		/// commands in an SVF file. The SVF target, is a hw_target object that can be queried and managed
		/// like other hw_targets using commands like get_hw_targets and current_hw_target.
		/// Note: When using the SVF flow, Xilinx recommends that you connect to a local hw_server on your system,
		/// as the SVF target does not require connection to an actual hardware board or device.
		/// SVF hw_targets can be identified by the boolean IS_SVF property that can be returned by
		/// get_property or report_property commands. This property is TRUE for SVF targets.
		/// This command returns nothing if successful, or returns an error if it fails.
		///
		/// The following example creates a SVF hw_target object that is a copy of the specified hw_target:
		/// create_hw_target -copy [get_hw_targets *210203327996A] svfTarget
		/// The following example gets the currently defined SVF hw_target objects:
		/// get_hw_targets -filter {IS_SVF}
		/// The following example shows all of the steps needed for the SVF flow. First open the Vivado
		/// hardware manager and connect to a local hw_server; create and open an SVF hw_target; add a
		/// hw_device and program the bitstream into this device; and write the SVF file capturing the
		/// programming commands for the device:
		/// open_hw
		/// connect_hw_server
		/// create_hw_target my_svf_target
		/// open_hw_target
		/// create_hw_device -part xc7k325t
		/// set_property PROGRAM.FILE {C:/Data/k7_design.bit} [current_hw_device]
		/// program_hw_devices [current_hw_device]
		/// write_hw_svf my_xc7k325t.svf
		/// close_hw_target
		///
		/// See ug835-vivado-tcl-commands.pdf, page 302
		/// </summary>
		/// <param name="target_name">(Required) name of hardware target to create</param>
		/// <param name="copy">(Optional) hardware target copy Default: copy of existing target</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>hardware targets</returns>
		public virtual SimpleTCLCommand create_hw_target(string target_name, string copy = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_hw_target [-copy <arg>] [-quiet] [-verbose] <target_name>
			return
				new SimpleTCLCommand("create_hw_target")
					.OptionalNamedString("copy", copy)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(target_name)
			;
		}
		/// <summary>
		/// Create a new I/O port interface
		///
		///
		/// TCL Syntax: create_interface [-parent <arg>] [-quiet] [-verbose] <name>
		///
		/// Creates a new interface for grouping scalar or differential I/O ports.
		///
		/// Create a new USB interface:
		/// create_interface USB0
		/// Create an Ethernet interface within the specified parent interface:
		/// create_interface -parent Top_Int ENET0
		///
		/// See ug835-vivado-tcl-commands.pdf, page 305
		/// </summary>
		/// <param name="name">(Required) Name for new I/O port interface</param>
		/// <param name="parent">(Optional) Assign new interface to this parent interface</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>new interface object</returns>
		public virtual SimpleTCLCommand create_interface(string name, string parent = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_interface [-parent <arg>] [-quiet] [-verbose] <name>
			return
				new SimpleTCLCommand("create_interface")
					.OptionalNamedString("parent", parent)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
			;
		}
		/// <summary>
		/// Create an instance of a configurable IP and add it to the fileset
		///
		///
		/// TCL Syntax: create_ip [-vlnv <arg>] -module_name <arg> [-dir <arg>] [-force] [-allow_hidden] [-vendor <arg>] [-library <arg>] [-name <arg>] [-version <arg>] [-revision <arg>] [-quiet] [-verbose]
		///
		/// This command creates an XCI file for a configurable IP core from the IP catalog, and adds it to the
		/// source files of the current project. This creates an IP source object which must be instantiated
		/// into the HDL design to create an instance of the IP core in the netlist.
		/// For multiple instances of the same core, simply instantiate the core module into the HDL design
		/// as many times as needed. However, to use the same IP core with different customizations, use
		/// the create_ip command to create separate IP source objects.
		/// The create_ip command is used to import IP cores from the current IP catalog. Use the
		/// import_ip command to read existing XCI and XCO files directly, without having to add IP to a
		/// catalog.
		/// This command returns a transcript of the IP generation process, concluding with the file path and
		/// name of the imported IP core file.
		/// Note: IP cores are native to Vivado, and can be customized and regenerated within that tool. The
		/// convert_ip command lets you to convert legacy IP to native IP supported by Vivado.
		///
		/// The example below imports the IP core specified by the -vlnv string, and gives it the specified
		/// module name in the current project:
		/// create_ip -vlnv xilinx.com:ip:c_addsub:11.0 -module_name test_addr
		/// The following example, from Vivado, creates an IP block with the specified -vendor, -
		/// library, -name, -version values, and assigns it the specified module name. After the IP is
		/// created, attributes of the IP are customized using set_property commands. Then the
		/// instantiation template and the synthesis targets are generated for the IP:
		/// create_ip -name c_addsub -version 11.0 -vendor xilinx.com -library ip \
		/// -module_name c_addsub_v11_0_0
		/// set_property CONFIG.COMPONENT_NAME c_addsub_v11_0_0 \
		/// [get_ips c_addsub_v11_0_0]
		/// set_property CONFIG.A_WIDTH 32 [get_ips c_addsub_v11_0_0]
		/// set_property CONFIG.B_WIDTH 32 [get_ips c_addsub_v11_0_0]
		/// set_property CONFIG.ADD_MODE Add_Subtract [get_ips c_addsub_v11_0_0]
		/// set_property CONFIG.C_IN true [get_ips c_addsub_v11_0_0]
		/// generate_target {instantiation_template synthesis} \
		/// [get_files C:/Data/c_addsub_v11_0_0/c_addsub_v11_0_0.xci \
		/// -of_objects [get_filesets sources_1]]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 307
		/// </summary>
		/// <param name="module_name">(Required) Name for the new IP that will be added to the project</param>
		/// <param name="vlnv">
		/// (Optional)
		/// VLNV string for the Catalog IP from which the new IP will be
		/// created (colon delimited Vendor, Library, Name, Version)
		/// </param>
		/// <param name="dir">
		/// (Optional)
		/// Directory path for remote IP to be created and managed
		/// outside the project
		/// </param>
		/// <param name="force">(Optional) Overwrite existing IP instance; allowed only with -dir option</param>
		/// <param name="allow_hidden">(Optional) Allow hidden cores to be instantiated</param>
		/// <param name="vendor">(Optional) IP Vendor name</param>
		/// <param name="library">(Optional) IP Library name</param>
		/// <param name="name">(Optional) IP Name</param>
		/// <param name="version">(Optional) IP Version</param>
		/// <param name="revision">(Optional) (Optional) IP core revision</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of file objects that were added</returns>
		public virtual SimpleTCLCommand create_ip(string module_name, string vlnv = null, string dir = null, bool? force = null, bool? allow_hidden = null, string vendor = null, string library = null, string name = null, string version = null, string revision = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_ip [-vlnv <arg>] -module_name <arg> [-dir <arg>] [-force] [-allow_hidden] [-vendor <arg>] [-library <arg>] [-name <arg>] [-version <arg>] [-revision <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("create_ip")
					.OptionalNamedString("vlnv", vlnv)
					.RequiredNamedString("module_name", module_name)
					.OptionalNamedString("dir", dir)
					.Flag("force", force)
					.Flag("allow_hidden", allow_hidden)
					.OptionalNamedString("vendor", vendor)
					.OptionalNamedString("library", library)
					.OptionalNamedString("name", name)
					.OptionalNamedString("version", version)
					.OptionalNamedString("revision", revision)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Creates a run for the given IP.
		///
		///
		/// TCL Syntax: create_ip_run [-force] [-quiet] [-verbose] <objects>
		///
		/// Defines a synthesis and implementation run for a single IP object as specified by the get_ips
		/// command, or for the specified IP core file (XCI) as specified by the get_files command.
		/// The IP run is used to generate the synthesis design checkpoint file (DCP) to support the out-of￾context (OOC) IP flow, or to synthesize and implement an IP module in the OOC hierarchical
		/// design flow.
		/// Two runs are created: one for synthesis, and one for implementation. The runs are named after
		/// the IP core and the run type, <ip_name>_synth_1 and <ip_name>_impl_1.
		/// The IP source files required to synthesize the run are copied into the IP run directory. The
		/// attributes of the run can be configured with the use of the set_property command.
		/// This command returns the name of the synthesis run created for the IP module.
		///
		/// The following example creates synthesis and implementation runs for the specified IP module:
		/// create_ip_run [get_ips add1]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 310
		/// </summary>
		/// <param name="objects">
		/// (Required)
		/// All of the IP objects (from get_ips or get_files) for which a
		/// run needs to be generated for.
		/// </param>
		/// <param name="force">(Optional) Force regeneration of products of the given IP.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand create_ip_run(string objects, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_ip_run [-force] [-quiet] [-verbose] <objects>
			return
				new SimpleTCLCommand("create_ip_run")
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Create a Macro
		///
		///
		/// TCL Syntax: create_macro [-quiet] [-verbose] <name>
		///
		/// Create a macro for the relative placement of cells.
		/// Macros are primarily used to place small groups of associated cells together to improve resource
		/// efficiency and enable faster interconnections. The create_macro command lets you define
		/// macros in an open synthesized or implemented design for relative placement by place_design,
		/// like RPMs defined by the RLOC constraint in RTL source files. Refer to the Vivado Design Suite
		/// User Guide: Implementation (UG904) for more information on defining relatively placed macros.
		/// After creating the macro, specific cells can be assigned to the macro using the update_macro
		/// command. To change a currently defined macro, you must delete the macro with
		/// delete_macro, recreate the macro, and update the macro with the new contents. You cannot
		/// simply overwrite an existing macro.
		/// Use delete_macro to delete a defined macro. Use get_macros to return a list of currently
		/// defined macros in the design.
		/// This command operates silently and does not return anything.
		///
		/// The following example creates a macro called usbMacro1:
		/// create_macro usbMacro1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 312
		/// </summary>
		/// <param name="name">(Required) Macro to create.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand create_macro(string name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_macro [-quiet] [-verbose] <name>
			return
				new SimpleTCLCommand("create_macro")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
			;
		}
		/// <summary>
		/// Create nets in the current design
		///
		///
		/// TCL Syntax: create_net [-from <arg>] [-to <arg>] [-quiet] [-verbose] <nets>...
		///
		/// Create new nets in the current netlist of an open Synthesized or Implemented Design.
		/// Note: You cannot add nets to library macros, or macro-primitives.
		/// Nets can be created hierarchically from the top-level of the design, or within any level of the
		/// hierarchy by specifying the hierarchical net name.
		/// Bus nets can be created with increasing or decreasing bus indexes, using negative and positive
		/// index values.
		/// New nets are unconnected in the netlist at the time of creation. You must connect nets as
		/// desired using the connect_net command. Connected nets can be unconnected using the
		/// disconnect_net command, and can be removed from the netlist using the remove_net
		/// command.
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*
		/// command.
		/// Note: Netlist editing is not allowed on the elaborated RTL design.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 314
		/// </summary>
		/// <param name="nets">(Required) Names of nets to create</param>
		/// <param name="from">(Optional) Starting bus index</param>
		/// <param name="to">(Optional) Ending bus index</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand create_net(string nets, string from = null, string to = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_net [-from <arg>] [-to <arg>] [-quiet] [-verbose] <nets>...
			return
				new SimpleTCLCommand("create_net")
					.OptionalNamedString("from", from)
					.OptionalNamedString("to", to)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(nets)
			;
		}
		/// <summary>
		/// Create new PartitionDef
		///
		///
		/// TCL Syntax: create_partition_def -name <arg> -module <arg> [-library <arg>] [-quiet] [-verbose]
		///
		/// IMPORTANT! You must first define the project as a Partial Reconfiguration (PR) project by setting the
		/// PR_FLOW property on the project to TRUE, or by using the Tools > Enable Partial Reconfiguration command.
		/// The Partial Reconfiguration flow lets you create Partition Definitions (partitionDefs) from
		/// hierarchical cells in a design, and to specify reconfigurable modules (RMs) to be assigned to these
		/// partitionDefs to create a unique configurations of the design based on the combination of the
		/// core design and one or more RMs. The PR design flow requires the implementation of each PR
		/// configuration, resulting in partial bitstreams for the RMs, but complete bitstreams for each
		/// integrated configuration. Refer to the Vivado Design Suite User Guide: Dynamic Function eXchange
		/// (UG909) for more information.
		/// The create_partition_def command defines a partitionDef object in a PR project from a
		/// specified hierarchical cell. The partitionDef defines a partition hierarchy that RMs can be
		/// assigned to for a specific PR configuration.
		/// This command returns the name of the newly created partitionDef, or returns an error if the
		/// command fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 316
		/// </summary>
		/// <param name="name">(Required) Name of the PartitionDef</param>
		/// <param name="module">(Required) Module name of the PartitionDef</param>
		/// <param name="library">(Optional) Library name of the module of PartitionDef</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand create_partition_def(string name, string module, string library = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_partition_def -name <arg> -module <arg> [-library <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("create_partition_def")
					.RequiredNamedString("name", name)
					.RequiredNamedString("module", module)
					.OptionalNamedString("library", library)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Create a new Pblock
		///
		///
		/// TCL Syntax: create_pblock [-quiet] [-verbose] <name>
		///
		/// Defines a Pblock to allow you to add logic instances for floorplanning purposes.
		/// You can add logic elements to the Pblock using the add_cells_to_pblock command, and
		/// then place the Pblocks onto the fabric of the FPGA using the resize_pblocks command. The
		/// resize_pblock command can also be used to manually move and resize Pblocks.
		/// You can nest one Pblock inside another for hierarchical floorplanning using the set_property
		/// command to define the PARENT property as shown in the second example.
		///
		/// The following example creates a Pblock called pb_cpuEngine, and then adds only the leaf-cells
		/// found in the cpuEngine module, clearing placement constraints for placed instances:
		/// create_pblock pb_cpuEngine
		/// add_cells_to_pblock pb_cpuEngine [get_cells cpuEngine/*] \
		/// -add_primitives -clear_locs
		/// The following example shows nesting Pblocks, by creating Pblocks called pb_usbEngine0 and
		/// pb_usbEngine1, and a third Pblock called pb_usbTop. Then pb_usbEngine0 and pb_usbEngine1
		/// are nested inside pb_usbTop using the set_property command:
		/// create_pblock pb_usbEngine0
		/// create_pblock pb_usbEngine1
		/// create_pblock pb_usbTop
		/// set_property PARENT pb_usbTop [get_pblocks {pb_usbEngine?}]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 318
		/// </summary>
		/// <param name="name">(Required) Name of the new pblock</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>new pblock object</returns>
		public virtual SimpleTCLCommand create_pblock(string name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_pblock [-quiet] [-verbose] <name>
			return
				new SimpleTCLCommand("create_pblock")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
			;
		}
		/// <summary>
		/// Create a peripheral with a VLNV.
		///
		///
		/// TCL Syntax: create_peripheral [-dir <arg>] [-quiet] [-verbose] <vendor> <library> <name> <version>
		///
		/// Create an AXI peripheral to add to the IP repository with the specified VLNV attribute.
		/// The AXI peripheral that is created is just a framework until interfaces have been added to the
		/// peripheral using the add_peripheral_interface command, and the peripheral has been
		/// generated using the generate_peripheral command.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 320
		/// </summary>
		/// <param name="vendor">(Required) Vendor, for example xilinx.com</param>
		/// <param name="library">(Required) Library, for example ip</param>
		/// <param name="name">(Required) Name, for example myip</param>
		/// <param name="version">(Required) Version, for example 1.4</param>
		/// <param name="dir">
		/// (Optional)
		/// Directory path for remote Peripheral to be created and
		/// managed outside the project
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand create_peripheral(string vendor, string library, string name, string version, string dir = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_peripheral [-dir <arg>] [-quiet] [-verbose] <vendor> <library> <name> <version>
			return
				new SimpleTCLCommand("create_peripheral")
					.OptionalNamedString("dir", dir)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(vendor)
					.RequiredString(library)
					.RequiredString(name)
					.RequiredString(version)
			;
		}
		/// <summary>
		/// Create pins in the current design
		///
		///
		/// TCL Syntax: create_pin [-from <arg>] [-to <arg>] -direction <arg> [-quiet] [-verbose] <pins>...
		///
		/// Add single pins or bus pins to the current netlist of an open Synthesized or Implemented Design.
		/// You may define attributes of the pin such as direction and bus width, as well as the pin name.
		/// Bus pins can be created with increasing or decreasing bus indexes, using negative and positive
		/// index values.
		/// The pins must be created on an existing cell instance, or it is considered a top-level pin which
		/// should be created using the create_port command. If the instance name of a cell is not
		/// specified as part of the pin name, an error will be returned.
		/// Note: You cannot add pins to library macros, or macro-primitives.
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*
		/// command.
		/// Note: Netlist editing is not allowed on the elaborated RTL design.
		///
		/// The following example creates a new input pin on the cpuEngine module with the specified pin
		/// name:
		/// create_pin -direction IN cpuEngine/inPin
		/// The following example sets the hierarchy separator, creates a new black box instance of the
		/// reference cell, and creates a twenty-four bit bidirectional bus for that instance:
		/// set_hierarchy_separator |
		/// create_cell -reference dmaBlock -black_box usbEngine0|myDMA
		/// create_pin -direction INOUT -from 0 -to 23 usbEngine0|myDMA|dataBus
		///
		/// See ug835-vivado-tcl-commands.pdf, page 323
		/// </summary>
		/// <param name="direction">(Required) Pin direction Values: IN, OUT, INOUT</param>
		/// <param name="pins">(Required) Names of pins to create</param>
		/// <param name="from">(Optional) Starting bus index</param>
		/// <param name="to">(Optional) Ending bus index</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand create_pin(string direction, string pins, string from = null, string to = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_pin [-from <arg>] [-to <arg>] -direction <arg> [-quiet] [-verbose] <pins>...
			return
				new SimpleTCLCommand("create_pin")
					.OptionalNamedString("from", from)
					.OptionalNamedString("to", to)
					.RequiredNamedString("direction", direction)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(pins)
			;
		}
		/// <summary>
		/// Create scalar or bus port
		///
		///
		/// TCL Syntax: create_port -direction <arg> [-from <arg>] [-to <arg>] [-diff_pair] [-interface <arg>] [-quiet] [-verbose] <name> [<negative_name>]
		///
		/// Creates a port and specifies such parameters as direction, width, single-ended or differential, and
		/// optionally assigns it to an existing interface. New ports are added at the top-level of the design
		/// hierarchy.
		/// Bus ports can be created with increasing or decreasing bus indexes, using negative and positive
		/// index values.
		/// The create_port command can be used to create a new port in an I/O Planning project, or
		/// while editing the netlist of an open Synthesized or Implemented design.
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*
		/// command.
		/// Note: Netlist editing is not allowed on the elaborated RTL design.
		///
		/// The following example creates a new input port, named PORT0:
		/// create_port -direction IN PORT0
		/// The following example creates a new interface called Group1, and then creates a four-bit,
		/// differential pair output bus using the specified interface. Since the bus ports are defined as
		/// differential pairs, and only <name> is specified, the negative side ports are automatically named
		/// D_BUS_N:
		/// create_interface Group1
		/// create_port -direction OUT -from 0 -to 3 -diff_pair -interface Group1 D_BUS
		/// Note: This command results in the creation of eight ports: D_BUS[0] D_BUS_N[0] D_BUS[1] D_BUS_N[1]
		/// D_BUS[2] D_BUS_N[2] D_BUS[3] D_BUS_N[3]
		/// With only <name> specified, the following example creates differential pair output ports named
		/// data and data_N.
		/// create_port -direction OUT -diff_pair data
		/// With both <name> and <negative_name> specified, the following example creates differential
		/// pair output ports named data_P and data_N.
		/// create_port -direction OUT -diff_pair data_P data_N
		///
		/// See ug835-vivado-tcl-commands.pdf, page 326
		/// </summary>
		/// <param name="direction">(Required) Direction of port. Valid arguments are IN, OUT and INOUT</param>
		/// <param name="name">(Required) Name of the port</param>
		/// <param name="from">(Optional) Beginning index of new bus</param>
		/// <param name="to">(Optional) Ending index of new bus</param>
		/// <param name="diff_pair">(Optional) Create differential pair of ports</param>
		/// <param name="@interface">(Optional) Assign new port to this interface</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="negative_name">(Optional) Optional negative name of a diff-pair</param>
		/// <returns>list of port objects that were created</returns>
		public virtual SimpleTCLCommand create_port(string direction, string name, string from = null, string to = null, bool? diff_pair = null, string @interface = null, bool? quiet = null, bool? verbose = null, string negative_name = null)
		{
			// TCL Syntax: create_port -direction <arg> [-from <arg>] [-to <arg>] [-diff_pair] [-interface <arg>] [-quiet] [-verbose] <name> [<negative_name>]
			return
				new SimpleTCLCommand("create_port")
					.RequiredNamedString("direction", direction)
					.OptionalNamedString("from", from)
					.OptionalNamedString("to", to)
					.Flag("diff_pair", diff_pair)
					.OptionalNamedString("interface", @interface)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
					.OptionalString(negative_name)
			;
		}
		/// <summary>
		/// Generate a port on a given reconfigurable cell
		///
		///
		/// TCL Syntax: create_port_on_reconfigurable_module [-cell <arg>] [-port <arg>] [-direction <arg>] [-from <arg>] [-to <arg>] [-quiet] [-verbose]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 329
		/// </summary>
		/// <param name="cell">(Optional) (Required) specify the HD.RECONFIGURABLE cell name for port punching</param>
		/// <param name="port">
		/// (Optional)
		/// (Required) specify the newly added port name on given
		/// HD.RECONFIGURABLE cell
		/// </param>
		/// <param name="direction">
		/// (Optional)
		/// (Required) specify the direction of ports, it could be either
		/// INPUT, OUTPUT or INOUT
		/// </param>
		/// <param name="from">(Optional) (Optional) specify the lower boundary of port bus Default: -1</param>
		/// <param name="to">(Optional) (Optional) specify the higher boundary of port bus Default: -1</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand create_port_on_reconfigurable_module(string cell = null, string port = null, string direction = null, string from = null, string to = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_port_on_reconfigurable_module [-cell <arg>] [-port <arg>] [-direction <arg>] [-from <arg>] [-to <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("create_port_on_reconfigurable_module")
					.OptionalNamedString("cell", cell)
					.OptionalNamedString("port", port)
					.OptionalNamedString("direction", direction)
					.OptionalNamedString("from", from)
					.OptionalNamedString("to", to)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Create new Configuration
		///
		///
		/// TCL Syntax: create_pr_configuration -name <arg> [-partitions <args>] [-greyboxes <args>] [-use_netlist] [-quiet] [-verbose]
		///
		/// IMPORTANT! You must first define the project as a Partial Reconfiguration (PR) project by setting the
		/// PR_FLOW property on the project to TRUE, or by using the Tools > Enable Partial Reconfiguration command.
		/// The Partial Reconfiguration flow lets you create Partition Definitions (partitionDefs) from
		/// hierarchical cells in a design, and to specify reconfigurable modules (RMs) to be assigned to these
		/// partitionDefs to create unique configurations of the design based on the combination of the core
		/// design and one or more RMs. The PR design flow requires the implementation of each PR
		/// configuration, resulting in partial bitstreams for the RMs, but complete bitstreams for each
		/// integrated configuration. Refer to the Vivado Design Suite User Guide: Dynamic Function eXchange
		/// (UG909) for more information.
		/// The create_pr_configuration command defines the combination of the static logic and
		/// the RM to create a unique configuration of the design. The PR configuration is the design that is
		/// implemented and the bitstream is generated for.
		/// You will also need to create implementation runs for the PR configuration using the
		/// create_run -pr_config command.
		/// This command returns the name of the newly created PR configuration, or returns an error if the
		/// command fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 330
		/// </summary>
		/// <param name="name">(Required) Name of the Configuration</param>
		/// <param name="partitions">(Optional) List of partition instances and reconfig modules pairs</param>
		/// <param name="greyboxes">(Optional) List of instances to which buffers need to be inserted for all ports</param>
		/// <param name="use_netlist">
		/// (Optional)
		/// Use netlist for getting instances of partition_defs to creating
		/// configurations
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand create_pr_configuration(string name, string partitions = null, string greyboxes = null, bool? use_netlist = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_pr_configuration -name <arg> [-partitions <args>] [-greyboxes <args>] [-use_netlist] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("create_pr_configuration")
					.RequiredNamedString("name", name)
					.OptionalNamedString("partitions", partitions)
					.OptionalNamedString("greyboxes", greyboxes)
					.Flag("use_netlist", use_netlist)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Create a new project
		///
		///
		/// TCL Syntax: create_project [-part <arg>] [-force] [-in_memory] [-ip] [-rtl_kernel] [-quiet] [-verbose] [<name>] [<dir>]
		///
		/// Creates a Vivado Design Suite project file (.xpr), or a project file for the Vivado Lab Edition (.lpr),
		/// in the specified directory.
		/// For the Vivado Lab Edition: The create_project command has a different command syntax,
		/// with fewer options, in the Vivado Lab Edition. The options that are not supported in Vivado Lab
		/// Edition are:
		/// • -part - The Vivado Lab Edition project (.lpr) does not specify a target part because the
		/// current_hw_target and current_hw_device determine the target part.
		/// • -ip - The Vivado Lab Edition does not define projects for the Managed IP flow.
		/// For the Vivado Design Suite: The default project created for the Vivado Design Suite is an RTL
		/// project, which defines the project as holding and manage RTL source files in the source fileset.
		/// The type of project is determined by the DESIGN_MODE Property on the source fileset when the
		/// project is created. To change the project type, use the set_property command to set the
		/// DESIGN_MODE property on the current_fileset as follows:
		/// • RTL Project - set_property DESIGN_MODE RTL [current_fileset]
		/// • Netlist Project - set_property DESIGN_MODE GateLvl [current_fileset]
		/// • I/O Planning Project - set_property DESIGN_MODE PinPlanning
		/// [current_fileset]
		/// Refer to the Vivado Design Suite User Guide: System-Level Design Entry (UG895) for more
		/// information on the different types of projects.
		/// This command returns a transcript of its process and the name of the created project, or returns
		/// an error if it fails.
		///
		/// When run from the Vivado Design Suite, the following example creates a project called
		/// project1.xpr in a directory called myDesigns:
		/// create_project project1 myDesigns
		/// Note: Because the <dir> is specified as the folder name only, the tool will create the project in the current
		/// working directory, or the directory from which the tool was launched.
		/// When run from the Vivado Lab Edition, this example creates a project called project1.lpr in
		/// a directory called myDesigns:
		/// create_project project1 myDesigns
		/// The following example creates a project called Proj1 in a directory called FPGA in C:/Designs. In
		/// addition, the tool will overwrite an existing project if one is found to exist in the specified
		/// location. In the second and third lines, the location of -force is changed to show the flexibility
		/// of argument placement.
		/// create_project Proj1 C:/Designs/FPGA -force
		/// -or￾create_project Proj1 -force C:/Designs/FPGA
		/// -or￾create_project -force Proj1 C:/Designs/FPGA
		/// Note: In all cases the first argument without a preceding keyword is interpreted as the <name> variable,
		/// and the second argument without a preceding keyword is the <dir> variable.
		/// The following example creates a project for the Manage IP flow in the specified directory:
		/// create_project -ip manageIP C:/Data
		/// The following example creates a new project called pin_project, and then sets the
		/// DESIGN_MODE property as required for an I/O Pin Planning project, and finally opens an IO
		/// design:
		/// create_project pin_project C:/Designs/PinPlanning
		/// set_property design_mode PinPlanning [current_fileset]
		/// open_io_design -name io_1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 333
		/// </summary>
		/// <param name="name">(Required) Project name</param>
		/// <param name="part">(Optional) Target part</param>
		/// <param name="force">(Optional) Overwrite existing project directory</param>
		/// <param name="in_memory">(Optional) Create an in-memory project</param>
		/// <param name="ip">(Optional) Default GUI behavior is for a managed IP project</param>
		/// <param name="rtl_kernel">(Optional) Default GUI behavior is for a RTL Kernel project</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="dir">(Optional) Directory where the project file is saved Default: .</param>
		/// <returns>new project object</returns>
		public virtual SimpleTCLCommand create_project(string name, string part = null, bool? force = null, bool? in_memory = null, bool? ip = null, bool? rtl_kernel = null, bool? quiet = null, bool? verbose = null, string dir = null)
		{
			// TCL Syntax: create_project [-part <arg>] [-force] [-in_memory] [-ip] [-rtl_kernel] [-quiet] [-verbose] [<name>] [<dir>]
			return
				new SimpleTCLCommand("create_project")
					.OptionalNamedString("part", part)
					.Flag("force", force)
					.Flag("in_memory", in_memory)
					.Flag("ip", ip)
					.Flag("rtl_kernel", rtl_kernel)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
					.OptionalString(dir)
			;
		}
		/// <summary>
		/// Create property for class of objects(s)
		///
		///
		/// TCL Syntax: create_property [-description <arg>] [-type <arg>] [-enum_values <args>] [-default_value <arg>] [-file_types <args>] [-display_text <arg>] [-quiet] [-verbose] <name> <class>
		///
		/// Creates a new property of the <type> specified with the user-defined <name> for the specified
		/// <class> of objects. The property that is created can be assigned to an object of the specified class
		/// with the set_property command, but is not automatically associated with all objects of that
		/// class.
		/// The report_property -all command will not report the newly created property for an
		/// object of the specified class until the property has been assigned to that object.
		///
		/// The following example defines a property called PURPOSE for cell objects:
		/// create_property PURPOSE cell
		/// Note: Because the -type was not specified, the value will default to strings.
		/// The following example creates a pin property called COUNT which holds an Integer value:
		/// create_property -type int COUNT pin
		///
		/// See ug835-vivado-tcl-commands.pdf, page 337
		/// </summary>
		/// <param name="name">(Required) Name of property to create</param>
		/// <param name="@class">
		/// (Required)
		/// Object type to create property for; valid values are: design,
		/// net, cell, pin, port, pblock, interface, fileset
		/// </param>
		/// <param name="description">(Optional) Description of property</param>
		/// <param name="type">
		/// (Optional)
		/// Type of property to create; valid values are: string, int, long,
		/// double, bool, enum, file Default: string
		/// </param>
		/// <param name="enum_values">(Optional) Enumeration values</param>
		/// <param name="default_value">(Optional) Default value of type string</param>
		/// <param name="file_types">(Optional) File type extensions (without the dot)</param>
		/// <param name="display_text">(Optional) Text to display when selecting the file in file browser</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The property that was created if success, "" if failure</returns>
		public virtual SimpleTCLCommand create_property(string name, string @class, string description = null, string type = null, string enum_values = null, string default_value = null, string file_types = null, string display_text = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_property [-description <arg>] [-type <arg>] [-enum_values <args>] [-default_value <arg>] [-file_types <args>] [-display_text <arg>] [-quiet] [-verbose] <name> <class>
			return
				new SimpleTCLCommand("create_property")
					.OptionalNamedString("description", description)
					.OptionalNamedString("type", type)
					.OptionalNamedString("enum_values", enum_values)
					.OptionalNamedString("default_value", default_value)
					.OptionalNamedString("file_types", file_types)
					.OptionalNamedString("display_text", display_text)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
					.RequiredString(@class)
			;
		}
		/// <summary>
		/// Create new reconfig Module
		///
		///
		/// TCL Syntax: create_reconfig_module -name <arg> [-top <arg>] [-gate_level] -partition_def <arg> [-define_from <arg>] [-define_from_file <arg>] [-quiet] [-verbose]
		///
		/// IMPORTANT! You must first define the project as a Partial Reconfiguration (PR) project by setting the
		/// PR_FLOW property on the project to TRUE, or by using the Tools > Enable Partial Reconfiguration command.
		/// The create_reconfig_module command defines an reconfigurable module (RM) from a
		/// specified hierarchical cell, or design file, and assigns it to the specified Partition Definition
		/// (partitionDef) in the current project.
		/// The Partial Reconfiguration flow allows RMs to be swapped into and out of a partitionDef to
		/// create a unique configuration of the design based on the combination of the core design and an
		/// RM. A single partitionDef can have multiple RMs to contain different netlists, constraints, or
		/// implementations. Each instance of the partitionDef in the design can be assigned a different RM
		/// to support many different configurations. The PR design flow requires the implementation of
		/// each PR configuration, resulting in partial bitstreams for the RMs, but complete bitstreams for
		/// each integrated configuration. Refer to the Vivado Design Suite User Guide: Dynamic Function
		/// eXchange (UG909) for more information.
		/// This command returns the hierarchical name of the newly created RM, or returns an error if the
		/// command failed.
		///
		/// The example below creates a reconfigurable module with the specified name:
		/// create_reconfig_module -name fftBottom -partition_def \
		/// [get_partition_defs partDef1 ] -top fftTop
		///
		/// See ug835-vivado-tcl-commands.pdf, page 340
		/// </summary>
		/// <param name="name">(Required) Name of the Reconfig Module</param>
		/// <param name="partition_def">(Required) PartitionDef in which reconfig module will be created</param>
		/// <param name="top">(Optional) module name of the top module</param>
		/// <param name="gate_level">(Optional) Create Reconfig Module whcih alllows adding DCP/EDIF files only</param>
		/// <param name="define_from">(Optional) Name of the module in the source fileset to be the top of the blockset</param>
		/// <param name="define_from_file">
		/// (Optional)
		/// full path of the top source file in the source fileset for which
		/// reconfigurable module to be created.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand create_reconfig_module(string name, string partition_def, string top = null, bool? gate_level = null, string define_from = null, string define_from_file = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_reconfig_module -name <arg> [-top <arg>] [-gate_level] -partition_def <arg> [-define_from <arg>] [-define_from_file <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("create_reconfig_module")
					.RequiredNamedString("name", name)
					.OptionalNamedString("top", top)
					.Flag("gate_level", gate_level)
					.RequiredNamedString("partition_def", partition_def)
					.OptionalNamedString("define_from", define_from)
					.OptionalNamedString("define_from_file", define_from_file)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Create Configurable Report objects.
		///
		///
		/// TCL Syntax: create_report_config [-report_name <arg>] [-report_type <arg>] -steps <args> -runs <args> [-options <arg>] [-copy_of <args>] [-quiet] [-verbose]
		///
		/// This command lets you create configurable report objects to add to synthesis and
		/// implementation runs, or to add to Report Strategies. A report object defines the report type and
		/// options that are run every time a specified step of a synthesis or implementation design run is
		/// completed. A Report Strategy lets you define a collection of report objects to associate with
		/// many synthesis and implementation runs, and reuse at different stages of the design flow. See
		/// the Vivado Design Suite User Guide: Implementation (UG904) for more information.
		/// Each report object has the 'OPTIONS.MORE_OPTIONS' property, which lets you specify
		/// command line options of the Tcl report_* command associated with the report object. These
		/// command line options are used when the report is generated during the synthesis or
		/// implementation run. You can specify the command line options using the -options argument as
		/// described below, or by manually setting the 'OPTIONS.MORE_OPTIONS' property of an existing
		/// report object using the set_property command. Refer to the specific report_* command for
		/// information on the available command line options.
		///
		/// The following example defines a new report object with the specified name and type and
		/// associates it with the route_design step of the impl_1 run:
		/// create_report_config -report_name post_route_datasheet -report_type
		/// report_datasheet \
		/// -steps route_design -runs impl_1
		/// This example is the same as the prior example, except it does not specify the name, and so the
		/// report object is named automatically as shown in the return value:
		/// create_report_config -report_type report_datasheet -steps route_design -
		/// runs impl_1
		/// impl_1_route_report_datasheet_0
		/// The following example creates a new report object for the timing summary report, with the
		/// specified command-line options, and associates the object with multiple steps of an
		/// implementation run:
		/// create_report_config -report_type report_timing_summary \
		/// -steps {opt_design place_design route_design} -runs {impl_2}\
		/// -options {-no_detailed_paths -report_unconstrained}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 343
		/// </summary>
		/// <param name="steps">(Required) List of run step(s) for object(s) created</param>
		/// <param name="runs">(Required) List of run(s) for object(s) created</param>
		/// <param name="report_name">
		/// (Optional)
		/// Name of configurable report object created. Can not be
		/// used when creating multiple objects
		/// </param>
		/// <param name="report_type">
		/// (Optional)
		/// Type of configurable report object(s) created. Not required
		/// with '-copy_of'
		/// </param>
		/// <param name="options">
		/// (Optional)
		/// options for report command to be set at creation of
		/// configurable report object, except with '-copy_of'
		/// </param>
		/// <param name="copy_of">(Optional) configurable report object to be copied</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>List of configurable report objects</returns>
		public virtual SimpleTCLCommand create_report_config(string steps, string runs, string report_name = null, string report_type = null, string options = null, string copy_of = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_report_config [-report_name <arg>] [-report_type <arg>] -steps <args> -runs <args> [-options <arg>] [-copy_of <args>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("create_report_config")
					.OptionalNamedString("report_name", report_name)
					.OptionalNamedString("report_type", report_type)
					.RequiredNamedString("steps", steps)
					.RequiredNamedString("runs", runs)
					.OptionalNamedString("options", options)
					.OptionalNamedString("copy_of", copy_of)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// (User-written application) Creates and launches a new run based on the suggestions by
		/// report_qor_suggestions. This proc looks for 5 files in the directory specified by the user.
		/// 1.RQSPreSynth_<newProjName>.xdc 2.RQSImplCommon_<newProjName>.xdc
		/// 3.RQSPreImpl_<newProjName>.xdc 4.RQSPreImpl_<newProjName>.tcl
		/// 5.RQSImplCommon_<newProjName>.tcl. There are 2 flows. One is creating both synth and impl
		/// runs and the other is creating only impl run making user specified synth run as the parent for the
		/// newly created impl run. In the first flow, we create a new synth run based on the current impl
		/// run's parent run (i,e current synth run). We create a new constraint fileset and add the current
		/// synth run's constraint fileset's files to that. And we add RQSPreSynth_<>.xdc file to newly
		/// created constraint set. We create a impl run based on the current impl run. We create a impl run
		/// constraint (if it is not same as the one that has already been created), and add the current impl
		/// run's constraint fileset's files to that. We also add RQSImplCommon_<>.xdc to new impl
		/// constraint fileset. We set STEPS.OPT_DESIGN.TCL.PRE property of newly created impl run to
		/// RQSImplCommon_<>.tcl file. In this flow, we ignore RQSPreImpl_<>.xdc/tcl files. In the second
		/// flow, user specified synth run is used as parent for the newly created impl run. So there is no
		/// synth run creation. We create impl run based on current impl run and user specified synth run.
		/// We create a new impl constraint fileset and add fileset to that form the current impl run's
		/// constraint fileset. We also add RQSImplCommon_<>.xdc , RQSPreImpl_<>.xdc files. If
		/// RQSPreImpl_<>.tcl file is available, it is set as STEPS.OPT_DESIGN.TCL.PRE property for new
		/// impl run otherwise RQSImplCommon_<>.tcl is set. In both the flows adding or setting files is
		/// subject to availability of those files in the output directory.
		///
		///
		/// TCL Syntax: create_rqs_run -dir <arg> -new_name <arg> [-synth_name <arg>] [-opt_more_options <arg>] [-place_more_options <arg>] [-quiet] [-verbose]
		///
		/// Creates and launches a new implementation run based on the suggestions provided by
		/// report_qor_suggestions.
		///
		/// The following example will create and launch a new run, exp_1, using the constraints files from
		/// the specified directory:
		/// create_rqs_run -dir path_to_dir -new_name exp_1 -synth_name synth_1 \
		/// -opt_more_options optVal -place_more_options placeVal
		/// TIP: The constraints were previously created using the -output_dir option of the
		/// report_qor_suggestions command.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 346
		/// </summary>
		/// <param name="dir">
		/// (Required)
		/// Specify the directory from where the xdc files and tcl files
		/// need to fetched.
		/// </param>
		/// <param name="new_name">(Required) Specify the name of the new run</param>
		/// <param name="synth_name">
		/// (Optional)
		/// Specify the name of the already existing synth run. This run
		/// will be the parent run for the newly created impl run
		/// Default: None
		/// Name Description
		/// </param>
		/// <param name="opt_more_options">
		/// (Optional)
		/// optional argument. Specify the value for opt_design step's
		/// more option property which will be set on newly created
		/// run. Default: None
		/// </param>
		/// <param name="place_more_options">
		/// (Optional)
		/// Specify the value for place_design step's more option
		/// property which will be set on newly created run. Default:
		/// None
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>None</returns>
		public virtual SimpleTCLCommand create_rqs_run(string dir, string new_name, string synth_name = null, string opt_more_options = null, string place_more_options = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_rqs_run -dir <arg> -new_name <arg> [-synth_name <arg>] [-opt_more_options <arg>] [-place_more_options <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("create_rqs_run")
					.RequiredNamedString("dir", dir)
					.RequiredNamedString("new_name", new_name)
					.OptionalNamedString("synth_name", synth_name)
					.OptionalNamedString("opt_more_options", opt_more_options)
					.OptionalNamedString("place_more_options", place_more_options)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Define a synthesis or implementation run for the current project
		///
		///
		/// TCL Syntax: create_run [-constrset <arg>] [-parent_run <arg>] [-part <arg>] -flow <arg> [-strategy <arg>] [-report_strategy <arg>] [-pr_config <arg>] [-quiet] [-verbose] <name>
		///
		/// Defines a synthesis or implementation run. The attributes of the run can be configured with the
		/// use of the set_property command.
		///
		/// The following example creates a run named synth_1 referencing the Vivado synthesis tool flow:
		/// create_run -flow {Vivado Synthesis 2013} synth_1
		/// Note: The defaults of sources_1, constrs_1, and the default part for the project will be used in the synthesis
		/// run. In addition, since this is a synthesis run, the -parent_run argument is not required.
		/// The following example creates an implementation run based on the Vivado Implementation 2013
		/// tool flow, and attaches it to the synth_1 synthesis run previously created:
		/// create_run impl_2 -parent_run synth_1 -flow {Vivado Implementation 2013}
		/// Note: The -parent_run argument is required in this example because it is an implementation of
		/// synthesized RTL sources.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 349
		/// </summary>
		/// <param name="flow">(Required) Flow name</param>
		/// <param name="name">(Required) Name for new run</param>
		/// <param name="constrset">(Optional) Constraint fileset to use</param>
		/// <param name="parent_run">(Optional) Synthesis run to link to new implementation run</param>
		/// <param name="part">(Optional) Target part</param>
		/// <param name="strategy">(Optional) Strategy to apply to the run</param>
		/// <param name="report_strategy">(Optional) Report strategy to apply to the run</param>
		/// <param name="pr_config">(Optional) partition configuration to apply to the run</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>run object</returns>
		public virtual SimpleTCLCommand create_run(string flow, string name, string constrset = null, string parent_run = null, string part = null, string strategy = null, string report_strategy = null, string pr_config = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_run [-constrset <arg>] [-parent_run <arg>] [-part <arg>] -flow <arg> [-strategy <arg>] [-report_strategy <arg>] [-pr_config <arg>] [-quiet] [-verbose] <name>
			return
				new SimpleTCLCommand("create_run")
					.OptionalNamedString("constrset", constrset)
					.OptionalNamedString("parent_run", parent_run)
					.OptionalNamedString("part", part)
					.RequiredNamedString("flow", flow)
					.OptionalNamedString("strategy", strategy)
					.OptionalNamedString("report_strategy", report_strategy)
					.OptionalNamedString("pr_config", pr_config)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
			;
		}
		/// <summary>
		/// Create histogram
		///
		///
		/// TCL Syntax: create_slack_histogram [-to <args>] [-delay_type <arg>] [-num_bins <arg>] [-slack_less_than <arg>] [-slack_greater_than <arg>] [-group <args>] [-report_unconstrained] [-significant_digits <arg>] [-scale <arg>] [-name <arg>] [-cells <args>] [-quiet] [-verbose]
		///
		/// Create a slack histogram grouping paths into slack ranges, and displaying the results graphically.
		/// TIP: This command provides a graphical slack histogram that requires the tool to be running in GUI mode.
		///
		/// The following example creates a slack histogram of the current design, using the default values,
		/// and outputting the results to the named result set in the GUI:
		/// create_slack_histogram -name slack1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 352
		/// </summary>
		/// <param name="to">(Optional) To clock</param>
		/// <param name="delay_type">(Optional) Type of path delay: Values: max, min, min_max Default: max</param>
		/// <param name="num_bins">(Optional) Maximum number of bins: Valid Range (1-100) Default: 10</param>
		/// <param name="slack_less_than">(Optional) Display paths with slack less than this Default: 1e+30</param>
		/// <param name="slack_greater_than">(Optional) Display paths with slack greater than this Default: -1e+30</param>
		/// <param name="group">(Optional) Limit report to paths in this group(s)</param>
		/// <param name="report_unconstrained">(Optional) Report unconstrained end points</param>
		/// <param name="significant_digits">(Optional) Number of digits to display: Range: 0 to 3 Default: 3</param>
		/// <param name="scale">
		/// (Optional)
		/// Type of scale on which to draw the histogram; Values:
		/// linear, logarithmic Default: linear
		/// </param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="cells">(Optional) run create_slack_histogram on the specified cell(s)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand create_slack_histogram(string to = null, string delay_type = null, string num_bins = null, string slack_less_than = null, string slack_greater_than = null, string group = null, bool? report_unconstrained = null, string significant_digits = null, string scale = null, string name = null, string cells = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_slack_histogram [-to <args>] [-delay_type <arg>] [-num_bins <arg>] [-slack_less_than <arg>] [-slack_greater_than <arg>] [-group <args>] [-report_unconstrained] [-significant_digits <arg>] [-scale <arg>] [-name <arg>] [-cells <args>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("create_slack_histogram")
					.OptionalNamedString("to", to)
					.OptionalNamedString("delay_type", delay_type)
					.OptionalNamedString("num_bins", num_bins)
					.OptionalNamedString("slack_less_than", slack_less_than)
					.OptionalNamedString("slack_greater_than", slack_greater_than)
					.OptionalNamedString("group", group)
					.Flag("report_unconstrained", report_unconstrained)
					.OptionalNamedString("significant_digits", significant_digits)
					.OptionalNamedString("scale", scale)
					.OptionalNamedString("name", name)
					.OptionalNamedString("cells", cells)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Create DSP source for Xilinx System Generator and add to the source fileset
		///
		///
		/// TCL Syntax: create_sysgen [-quiet] [-verbose] <name>
		///
		/// Create a DSP sub-module for use in the current project, and add it to the source files.
		/// This command will launch System Generator for DSP to let you design the hardware portion of
		/// your system design. System Generator is a DSP design tool from Xilinx that allows the RTL
		/// source files, Simulink® and MATLAB® software models, and C/C++ components of a DSP system
		/// to come together in a single simulation and implementation environment.
		/// For more information on using specific features of the tool refer to System Generator for DSP
		/// Getting Started Guide (UG639).
		/// You can also add existing DSP model files (.mdl) from System Generator into the current project
		/// using the add_files command.
		/// The command returns the name of the DSP module created and added to the project.
		///
		/// The following example launches System Generator and allows you to define and configure the
		/// specified DSP module:
		/// create_sysgen DSP_mod1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 355
		/// </summary>
		/// <param name="name">(Required) Sub module name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Name for the new sub module</returns>
		public virtual SimpleTCLCommand create_sysgen(string name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_sysgen [-quiet] [-verbose] <name>
			return
				new SimpleTCLCommand("create_sysgen")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
			;
		}
		/// <summary>
		/// Create a DRC/METHODOLOGY/CDC message waiver
		///
		///
		/// TCL Syntax: create_waiver [-type <arg>] [-id <arg>] [-objects <args>] [-from <args>] [-to <args>] [-strings <args>] [-of_objects <args>] [-user <arg>] -description <arg> [-tags <arg>] [-timestamp <arg>] [-scoped] [-quiet] [-verbose]
		///
		/// After report_drc, report_methodology, or report_cdc commands are run, they return
		/// messages of specific violations or conditions found in the design. These violations can prevent
		/// the design from progressing until they have been resolved or addressed in some way. The
		/// create_waiver command lets you select individual violations or specific checks that can be
		/// waived for a design, letting you move forward in the design flow.
		/// IMPORTANT! Use caution when waiving violations. Waivers may let you proceed in the design flow, but also
		/// let you create a design that is fundamentally flawed.
		/// The user creating the waiver is required to provide a user ID and description in the
		/// create_waiver command in order to provide some history of the waiver.
		/// A waiver must be specified for an individual DRC or methodology violation, or for a specific DRC
		/// or methodology check, or for a CDC path. The waiver must be assigned to a specific object, or
		/// specific violation ID, or for paths using -from/-to arguments. The form of the
		/// create_waiver command varies depending on the check, violation, or object being waived, as
		/// shown in the examples below.
		/// TIP: Although many of the arguments are described as optional, some form of identifier is required to associate
		/// the waiver with its target.
		/// To save waivers from one design session to the next, you must use write_waivers to create
		/// an XDC file of the waiver commands, and read_xdc to read those waivers back into the design
		/// when it is reopened.
		/// After creating a waiver, you will need to rerun the DRC, methodology, or CDC report to have the
		/// waiver considered in the analysis. To see what waivers are in place in the current design you can
		/// use the report_waivers command. In addition, the report_drc, report_methodology,
		/// and report_cdc commands have options to run the reports on waived violations or checks.
		/// Use the delete_waivers command to remove waivers from the design.
		///
		/// This example creates a waiver for a methodology check based on the specified ID:
		/// create_waiver -id TIMING-18 -user samwise -description {waive rule check}
		/// The following example creates a DRC check waiver for the indicated ID on the specified list of
		/// port objects, and provides the timestamp in local time:
		/// create_waiver -type DRC -id UCIO-1 -user samwise -desc {waiving DRC
		/// violation} \
		/// -objects [get_ports {src_in* dest_out*}] \
		/// -timestamp [clock format [clock seconds] -gmt 0]
		/// The following example creates a waiver for specific CDC paths in the design, defined by the -
		/// from/-to arguments:
		/// create_waiver -type CDC -id CDC-6 -user samwise \
		/// -description {Paths to be re-tested later}\
		/// -from [list [get_pins {inst_xpm_grey/src_gray_ff_reg[3]/C \
		/// inst_xpm_grey/src_gray_ff_reg[16]/C \
		/// inst_xpm_grey/src_gray_ff_reg[22]/C \
		/// inst_xpm_grey/src_gray_ff_reg[25]/C}] ] \
		/// -to [list [get_pins {inst_xpm_grey/dest_graysync_ff_reg[0][1]/D \
		/// inst_xpm_grey/dest_graysync_ff_reg[0][6]/D \
		/// inst_xpm_grey/dest_graysync_ff_reg[0][9]/D \
		/// inst_xpm_grey/dest_graysync_ff_reg[0][24]/D}] ]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 357
		/// </summary>
		/// <param name="description">(Required) Description string of the cause for the waiver</param>
		/// <param name="type">(Optional) Type of waiver - DRC, METHODOLOGY, CDC</param>
		/// <param name="id">
		/// (Optional)
		/// ID of the DRC/METHODOLOGY/CDC message being waived,
		/// not needed for -of_objects use
		/// </param>
		/// <param name="objects">
		/// (Optional)
		/// List of inserted message objects for which a DRC/
		/// METHODOLOGY waiver will be set (i.e. %ELG, %SIG, etc. for
		/// cells or nets, etc., sites, etc., or '*CELL', '*NET', '*SITE', etc.
		/// as wildcards
		/// </param>
		/// <param name="from">
		/// (Optional)
		/// List of source (driver) pins or ports (or '*PORT', '*PIN' as
		/// wildcard) for which a CDC waiver will be set
		/// </param>
		/// <param name="to">
		/// (Optional)
		/// List of target (load) pins or ports (or '*PORT', '*PIN' as
		/// wildcard) for which a CDC waiver will be set
		/// </param>
		/// <param name="strings">
		/// (Optional)
		/// List of inserted message string values for which a DRC/
		/// METHODOLOGY waiver will be set (i.e. %STR for strings, or
		/// '*' as wildcard)
		/// </param>
		/// <param name="of_objects">
		/// (Optional)
		/// List of DRC/METHODOLOGY/CDC violation objects for which
		/// waiver(s) will be set
		/// </param>
		/// <param name="user">
		/// (Optional)
		/// Name of the user creating the waiver (required, but if not
		/// specified, the waivers will take the USER name from the
		/// environment if it is available)
		/// </param>
		/// <param name="tags">
		/// (Optional)
		/// Optional list of one or more tags to aid in subsequent
		/// waiver identification or categorization
		/// </param>
		/// <param name="timestamp">
		/// (Optional)
		/// Timestamp of waiver - for restaining the original time of a
		/// waiver being (re)created after being written
		/// </param>
		/// <param name="scoped">
		/// (Optional)
		/// Flag waiver to interpret object wildcards as scoped to the
		/// current_instance that is set
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>waiver</returns>
		public virtual SimpleTCLCommand create_waiver(string description, string type = null, string id = null, string objects = null, string from = null, string to = null, string strings = null, string of_objects = null, string user = null, string tags = null, string timestamp = null, bool? scoped = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_waiver [-type <arg>] [-id <arg>] [-objects <args>] [-from <args>] [-to <args>] [-strings <args>] [-of_objects <args>] [-user <arg>] -description <arg> [-tags <arg>] [-timestamp <arg>] [-scoped] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("create_waiver")
					.OptionalNamedString("type", type)
					.OptionalNamedString("id", id)
					.OptionalNamedString("objects", objects)
					.OptionalNamedString("from", from)
					.OptionalNamedString("to", to)
					.OptionalNamedString("strings", strings)
					.OptionalNamedString("of_objects", of_objects)
					.OptionalNamedString("user", user)
					.RequiredNamedString("description", description)
					.OptionalNamedString("tags", tags)
					.OptionalNamedString("timestamp", timestamp)
					.Flag("scoped", scoped)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Creates a new wave config
		///
		///
		/// TCL Syntax: create_wave_config [-quiet] [-verbose] [<name>]
		///
		/// Create a new wave configuration object in the current simulation, and open the waveform
		/// configuration in the Vivado IDE. This will make the new wave configuration object the current
		/// wave configuration.
		/// In the Vivado® simulator GUI, you can work with a waveform to analyze your design and debug
		/// your code. The Wave Config file contains the list of wave objects (signals, dividers, groups, virtual
		/// buses) to display, and their display properties, plus markers. A wave configuration displays with
		/// top-level HDL objects, and can be further populated using commands like add_wave and
		/// add_wave_divider. Any changes made to a wave configuration can be saved to a Wave
		/// Config file with the save_wave_config command.
		/// This command returns the name of the waveform configuration created, or an error if it fails.
		///
		/// The following example creates a new wave configuration object with the specified name:
		/// create_wave_config testbench1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 361
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="name">
		/// (Optional)
		/// Creates a new wave configuration of the specified name, or
		/// a default name if no name given. A new wave window
		/// showing that WCFG is also created and made the current
		/// wave window
		/// </param>
		/// <returns>The new wave config</returns>
		public virtual SimpleTCLCommand create_wave_config(bool? quiet = null, bool? verbose = null, string name = null)
		{
			// TCL Syntax: create_wave_config [-quiet] [-verbose] [<name>]
			return
				new SimpleTCLCommand("create_wave_config")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(name)
			;
		}
		/// <summary>
		/// Create embedded source for XPS and add to the source fileset (Not supported anymore. Please
		/// use Vivado IP integrator.)
		///
		///
		/// TCL Syntax: create_xps [-quiet] [-verbose] <name>
		///
		/// Create an Embedded Processor source for use in the current project, and add it to the source
		/// files.
		/// This command will launch the Xilinx Platform Studio (XPS) to let you design the hardware portion
		/// of the embedded processor system. In XPS you can define and configure the microprocessor,
		/// peripherals, and the interconnection of these components. After you exit XPS, the created files
		/// for the Embedded Processor sub-design will be written to the local project directory
		/// (<project_name>.srcs/sources_1/edk/<name> ), and added to the source files.
		/// For more information on using specific features of XPS refer to EDK Concepts, Tools, and
		/// Techniques (UG683).
		/// You can also add existing Xilinx Microprocessor Project (.xmp) files from XPS in the current
		/// project using the add_files command.
		/// The command returns the name of the Embedded Processor sub-design created.
		///
		/// The following example launches XPS to define and configure the specified Embedded Processor
		/// sub-design:
		/// create_xps xpsTest1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 363
		/// </summary>
		/// <param name="name">(Required) Source name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>source file name that was created</returns>
		public virtual SimpleTCLCommand create_xps(string name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_xps [-quiet] [-verbose] <name>
			return
				new SimpleTCLCommand("create_xps")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
			;
		}
		/// <summary>
		/// Set or get current design.
		///
		///
		/// TCL Syntax: current_bd_design [-quiet] [-verbose] [<design>]
		///
		/// Defines the current IP subsystem design for use with the IP integrator of the Vivado Design
		/// Suite, or returns the name of the current design in the active project.
		/// The current IP subsystem design and current IP subsystem instance are the target of most of the
		/// IP integrator Tcl commands and design changes made in the tool. The current IP subsystem
		/// instance can be defined using the current_bd_instance command.
		/// You can use the get_bd_designs command to get a list of open IP subsystem designs in the
		/// active project.
		/// A complete list of IP integrator Tcl commands can be returned using the following command from
		/// the Vivado Design Suite Tcl shell:
		/// load_features IPIntegrator
		/// help -category IPintegrator
		/// Note: The load_features command is only needed if the IP integrator is not currently loaded in the
		/// Vivado Design Suite.
		///
		/// The following example sets the IP subsystem design as the current design:
		/// current_bd_design design_1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 365
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="design">(Optional) Name of current design to be set</param>
		/// <returns>The current design object, "" if failed.</returns>
		public virtual SimpleTCLCommand current_bd_design(bool? quiet = null, bool? verbose = null, string design = null)
		{
			// TCL Syntax: current_bd_design [-quiet] [-verbose] [<design>]
			return
				new SimpleTCLCommand("current_bd_design")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(design)
			;
		}
		/// <summary>
		/// Set or get current cell instance.
		///
		///
		/// TCL Syntax: current_bd_instance [-quiet] [-verbose] [<instance>]
		///
		/// Set or get the current hierarchical cell instance in the current IP integrator subsystem design, as
		/// defined by current_bd_design. The current instance is referenced from the top-level of the
		/// subsystem design hierarchy, or "/".
		/// This command returns the current IP integrator cell instance object, or returns nothing if the
		/// command failed.
		///
		/// The following example sets the current instance in the subsystem design to the specified module:
		/// current_bd_instance module2
		/// The following example returns the current instance:
		/// current_bd_instance .
		/// This example resets the current instance of the subsystem design to the top level of the
		/// hierarchy:
		/// current_instance /
		///
		/// See ug835-vivado-tcl-commands.pdf, page 367
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="instance">(Optional) Name of current cell instance to be set</param>
		/// <returns>The current cell instance object, "" if failed.</returns>
		public virtual SimpleTCLCommand current_bd_instance(bool? quiet = null, bool? verbose = null, string instance = null)
		{
			// TCL Syntax: current_bd_instance [-quiet] [-verbose] [<instance>]
			return
				new SimpleTCLCommand("current_bd_instance")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(instance)
			;
		}
		/// <summary>
		/// Get the current board object
		///
		///
		/// TCL Syntax: current_board [-quiet] [-verbose]
		///
		/// Returns the board in use in the current project.
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite
		/// installation area, stores information regarding board attributes. The board provides a
		/// representation of the overall system that the Xilinx device is a part of, and can help define key
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.
		/// You can create custom boards by defining a custom Board Interface file, as described in the
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).
		/// The board can be specified:
		/// • When the project is created by selecting Boards from the Default Part dialog box.
		/// • By setting the BOARD_PART property on the current project as shown in the example.
		/// • By selecting the Project Device in the Settings dialog box in an open project in the Vivado IDE.
		/// Refer to the Vivado Design Suite User Guide: System-Level Design Entry (UG895) for information on
		/// creating projects, and on configuring project settings.
		/// IMPORTANT! When you specify the board with the set_property command, the target part is also
		/// changed to match the part required by the specified BOARD property.
		/// The current_board command returns the Vendor:Board_Name:File_Version attributes
		/// of the current board, as defined in the BOARD_PART property. The command returns nothing
		/// when the project targets a Xilinx FPGA instead of a TRD and board, or when the BOARD_PART
		/// property has not been defined. The command returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 369
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>current board object</returns>
		public virtual SimpleTCLCommand current_board(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: current_board [-quiet] [-verbose]
			return
				new SimpleTCLCommand("current_board")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Get the current board_part object
		///
		///
		/// TCL Syntax: current_board_part [-quiet] [-verbose]
		///
		/// Return the Xilinx device used in the current project or design.
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite
		/// installation area, stores information regarding board attributes. The board provides a
		/// representation of the overall system that the Xilinx device is a part of, and can help define key
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.
		/// You can create custom boards by defining a custom Board Interface file, as described in the
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).
		/// The board part provides a representation of the Xilinx device in the context of the board-level
		/// system, and is represented by the part0 component in the Board Interface file.
		/// The board can be specified:
		/// • When the project is created by selecting Boards from the Default Part dialog box.
		/// • By setting the BOARD_PART property on the current project as shown in the example.
		/// • By selecting the Project Device in the Settings dialog box in an open project in the Vivado IDE.
		/// Refer to the Vivado Design Suite User Guide: System-Level Design Entry (UG895) for information on
		/// creating projects, and on configuring project settings.
		/// IMPORTANT! When you specify the board with the set_property command, the target part is also
		/// changed to match the part required by the specified BOARD_PART property.
		/// The current_board_part command returns the NAME property of the current board part.
		/// The command returns a warning when the project targets a Xilinx FPGA instead of a board, or
		/// when the BOARD_PART property has not been defined. The command returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 372
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>current board_part object</returns>
		public virtual SimpleTCLCommand current_board_part(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: current_board_part [-quiet] [-verbose]
			return
				new SimpleTCLCommand("current_board_part")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Set or get the current design.
		///
		///
		/// TCL Syntax: current_design [-quiet] [-verbose] [<design>]
		///
		/// Defines the current design or returns the name of the current design in the active project.
		/// The current design and current instance are the target of most Tcl commands, design edits and
		/// constraint changes made in the tool. The current instance can be defined using the
		/// current_instance command.
		/// You can use the get_designs command to get a list of open designs in the active project, and
		/// use the get_projects command to get a list of open projects.
		///
		/// The following example sets the design rtl_1 as the current design:
		/// current_design rtl_1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 375
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="design">(Optional) Name of current design to be set</param>
		/// <returns>design object</returns>
		public virtual SimpleTCLCommand current_design(bool? quiet = null, bool? verbose = null, string design = null)
		{
			// TCL Syntax: current_design [-quiet] [-verbose] [<design>]
			return
				new SimpleTCLCommand("current_design")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(design)
			;
		}
		/// <summary>
		/// Get the current fileset (any type) or set the current fileset (applicable to simulation filesets only)
		///
		///
		/// TCL Syntax: current_fileset [-constrset] [-simset] [-quiet] [-verbose] [<fileset>...]
		///
		/// Get the active source, constraint, or simulation fileset within the current project.
		/// When used without any options, current_fileset sets and returns the sources_1 set as the active
		/// fileset.
		/// This command can also be used to set the current simulation fileset.
		/// Note: Use set_property CONSTRSET to define the active constraint set on a synthesis or
		/// implementation run.
		///
		/// The following example returns the name of the currently active constraint fileset:
		/// current_fileset -constrset
		/// The following example sets sim_2 as the active simulation set:
		/// current_fileset -simset sim_2
		///
		/// See ug835-vivado-tcl-commands.pdf, page 377
		/// </summary>
		/// <param name="constrset">(Optional) Get the current constraints fileset</param>
		/// <param name="simset">(Optional) Get the current active simulation fileset</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="fileset">(Optional) Specify the simulation fileset to set as current (active); optional</param>
		/// <returns>current fileset (the current srcset by default)</returns>
		public virtual SimpleTCLCommand current_fileset(bool? constrset = null, bool? simset = null, bool? quiet = null, bool? verbose = null, string fileset = null)
		{
			// TCL Syntax: current_fileset [-constrset] [-simset] [-quiet] [-verbose] [<fileset>...]
			return
				new SimpleTCLCommand("current_fileset")
					.Flag("constrset", constrset)
					.Flag("simset", simset)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(fileset)
			;
		}
		/// <summary>
		/// Get index of the selected subprogram frame (default, top i.e. most recent subprogram call) in the
		/// call-stack of the HDL process scope (current_scope). Sets current stack frame for the subprogram
		/// call-stack of the current_scope.
		///
		///
		/// TCL Syntax: current_frame [-up] [-down] [-set <arg>] [-quiet] [-verbose]
		///
		/// Returns the index of the frame which is selected as the "current" frame in sub-program call-stack
		/// of the current HDL process-scope, or current_scope. By default, the most recently called
		/// subprogram-frame is the current frame, i.e. with frame-index "0" (zero) and marked with (->).
		/// Switches like -up,-down, and -set let you select other frames in the call-stack, rather than the
		/// current frame.
		/// IMPORTANT! The current_frame strictly follows the current_scope. If current_scope is not an
		/// HDL process scope waiting inside a sub-program, the current_frame command reports that the current
		/// process does not have an associated sub-program stack.
		///
		/// Example design:
		/// module top;
		/// int i;
		/// function void f(input int in1);
		/// automatic int a;
		/// a = in1 + 7;
		/// $display($time, " in f :: a %d in1 %d ", a, in1);
		/// endfunction
		/// task automatic t(input int in2);
		/// int b;
		/// b = in2 + 10;
		/// $display($time, " in t :: in2 %d b %d ", in2, b);
		/// #5;
		/// f(b); // Case C
		/// $display($time, " Back in t : after wait and f(%d) ", b);
		/// endtask
		/// initial begin // "/top/Initial18_0"
		/// $display($time, " in initial 1 ");
		/// i = 200;
		/// t(i); // Case B
		/// $display($time, " Back in initial 1 after t(%d) ", i);
		/// end
		/// initial begin // "/top/Initial25_1"
		/// $display($time, " in initial 2 ");
		/// #2;
		/// f(50); // Case A
		/// $display($time, " Back in initial 2 after f(50) ");
		/// end
		/// endmodule
		/// When simulation is stopped inside function "f" for its call at 'Case C', function "f" is called from
		/// task "t" at 'Case C' which itself is called from process "/top/Initial18_0" at 'Case B'
		/// > current_scope
		/// /top/Initial18_0
		/// > report_frames
		/// -> 0 : f
		/// 1 : t
		/// 2: /top/Initial18_0
		/// 1. > current_frame
		/// 0
		/// 2. > current_frame -up
		/// 1
		/// > report_frames
		/// 0 : f
		/// -> 1 : t
		/// 2 : /top/Initial18_0
		/// 3. > current_frame -down
		/// 0
		/// > report_frames
		/// -> 0 : f
		/// 1 : t
		/// 2: /top/Initial18_0
		/// 4. > current_frame -set 1
		/// 1
		/// > report_frames
		/// 0 : f
		/// -> 1 : t
		/// 2 : /top/Initial18_0
		/// 5. > current_frame -verbose
		/// -> 0 : f @top.v:6
		/// 1 : t @top.v:15
		/// 2: /top/Initial18_0 @top.v:21
		///
		/// See ug835-vivado-tcl-commands.pdf, page 379
		/// </summary>
		/// <param name="up">
		/// (Optional)
		/// Selects stack frame of the caller subprogram/process as the
		/// current frame.
		/// </param>
		/// <param name="down">(Optional) Selects stack frame of the callee subprogram as the current frame.</param>
		/// <param name="set">
		/// (Optional)
		/// Selects stack frame with given index as the current frame of
		/// the call stack of current HDL process scope. Default: 0
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Returns index of the selected subprogram frame in the call stack of the current_scope.</returns>
		public virtual SimpleTCLCommand current_frame(bool? up = null, bool? down = null, string set = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: current_frame [-up] [-down] [-set <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("current_frame")
					.Flag("up", up)
					.Flag("down", down)
					.OptionalNamedString("set", set)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Get or set the current hardware cfgmem
		///
		///
		/// TCL Syntax: current_hw_cfgmem [-hw_device <args>] [-quiet] [-verbose] [<hw_cfgmem>]
		///
		/// Set or return the current hardware cfgmem object.
		/// The process whereby the design specific data is loaded or programmed into the Xilinx® FPGA is
		/// called configuration. The create_hw_cfgmem command defines a flash memory device used
		/// for configuring and booting the FPGA device.
		/// When a new hw_cfgmem object is created, it becomes the current hw_cfgmem object. You can
		/// use the current_hw_cfgmem to return the current hw_cfgmem object, or you can specify a
		/// hw_cfgmem object, as returned by get_hw_cfgmems, to change the current object.
		/// After the hw_cfgmem object is created, and associated with the hw_device, the configuration
		/// memory can be programmed with the bitstream and other data from a memory configuration file
		/// created with the write_cfgmem command.
		/// The hw_cfgmem object is programmed using the program_hw_cfgmem command.
		/// This command returns the current hardware cfgmem as an object, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 382
		/// </summary>
		/// <param name="hw_device">(Optional) list of hardware devices</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_cfgmem">(Optional) list of hardware cfgmems Default: current hardware cfgmem</param>
		/// <returns>hardware cfgmem</returns>
		public virtual SimpleTCLCommand current_hw_cfgmem(string hw_device = null, bool? quiet = null, bool? verbose = null, string hw_cfgmem = null)
		{
			// TCL Syntax: current_hw_cfgmem [-hw_device <args>] [-quiet] [-verbose] [<hw_cfgmem>]
			return
				new SimpleTCLCommand("current_hw_cfgmem")
					.OptionalNamedString("hw_device", hw_device)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(hw_cfgmem)
			;
		}
		/// <summary>
		/// Get or set the current hardware device
		///
		///
		/// TCL Syntax: current_hw_device [-quiet] [-verbose] [<hw_device>]
		///
		/// Set or return the current Xilinx FPGA targeted by the Hardware Manager in the Vivado Design
		/// Suite for programming and debug.
		/// The hardware target is a system board containing a JTAG chain of one or more Xilinx devices that
		/// you can program with a bitstream file, or use to debug your design. Connections between
		/// hardware targets on the system board and the Vivado Design Suite are managed by the
		/// hw_server application, and the connect_hw_server command. Refer to Vivado Design Suite
		/// User Guide: Programming and Debugging (UG908) for a list of supported JTAG download cables
		/// and devices.
		/// Each hardware target can have one or more Xilinx devices to program, or to use for debugging
		/// purposes. The current device is specified or returned by the current_hw_device command.
		/// To access a Xilinx FPGA through the Hardware Manager, you must use the following Tcl
		/// command sequence:
		/// 1. open_hw - Opens the Hardware Manager in the Vivado Design Suite.
		/// 2. connect_hw_server - Makes a connection to a local or remote Xilinx hardware server
		/// application.
		/// 3. current_hw_target - Defines the hardware target of the connected server.
		/// 4. open_hw_target - Opens a connection to the hardware target.
		/// 5. current_hw_device - Specifies the Xilinx FPGA to use for programming and debugging.
		/// After connecting to the appropriate hardware device, you can program the device with a
		/// bitstream file using the program_hw_device command, and debug the device using any of a
		/// number of Hardware Manager Tcl commands. To interactively debug the device open the
		/// Hardware Manager in the Vivado Design Suite IDE.
		/// IMPORTANT! You can use the current_hw_server, current_hw_target, and
		/// current_hw_device commands to set the hardware for programming and debugging the design. You
		/// should exercise care when using these commands to insure that the current server, target, and device are in
		/// sync. The current device should be found on the current target, which should be found on the current server.
		/// This command returns the current hardware device as an object, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 384
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_device">(Optional) hardware device to set as current; optional</param>
		/// <returns>hardware device</returns>
		public virtual SimpleTCLCommand current_hw_device(bool? quiet = null, bool? verbose = null, string hw_device = null)
		{
			// TCL Syntax: current_hw_device [-quiet] [-verbose] [<hw_device>]
			return
				new SimpleTCLCommand("current_hw_device")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(hw_device)
			;
		}
		/// <summary>
		/// Get or set the current hardware ILA
		///
		///
		/// TCL Syntax: current_hw_ila [-quiet] [-verbose] [<hw_ila>]
		///
		/// Set or return the current hardware ILA debug core targeted by the Hardware Manager in the
		/// Vivado Design Suite for programming and debug.
		/// The Integrated Logic Analyzer (ILA) debug core lets you perform in-system debug of
		/// implemented designs, or design bitstreams, on a programmed Xilinx FPGA. The ILA core includes
		/// many advanced features of modern logic analyzers, including boolean trigger equations, and edge
		/// transition triggers. You can use the ILA core to probe specific signals of the design, to trigger on
		/// programmed hardware events, and capture data from the Xilinx FPGA in real-time. Refer to
		/// LogiCORE IP Integrated Logic Analyzer (PG172) for details of the ILA core.
		/// ILA debug cores can be added to a design instantiating an ILA core from the IP catalog into the
		/// RTL design, or using the create_debug_core command to add the ILA core to the synthesized
		/// netlist. Refer to Vivado Design Suite User Guide: Programming and Debugging (UG908) for more
		/// information on adding ILA debug cores to the design.
		/// After generating a bitstream from the design, and programming the device with the
		/// program_hw_devices command, the ILA debug cores in the design are accessible from the
		/// Hardware Manager using the get_hw_ilas command. The debug probes assigned to the ILA
		/// debug cores in the design can be returned with the get_hw_probes command.
		/// This command returns the current hardware ILA core as an object, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 387
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_ila">(Optional) hardware ILA</param>
		/// <returns>hardware ILA</returns>
		public virtual SimpleTCLCommand current_hw_ila(bool? quiet = null, bool? verbose = null, string hw_ila = null)
		{
			// TCL Syntax: current_hw_ila [-quiet] [-verbose] [<hw_ila>]
			return
				new SimpleTCLCommand("current_hw_ila")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(hw_ila)
			;
		}
		/// <summary>
		/// Get or set the current hardware ILA data
		///
		///
		/// TCL Syntax: current_hw_ila_data [-quiet] [-verbose] [<hw_ila_data>]
		///
		/// Set or return the current ILA debug core data object.
		/// The ILA data object is created in the Vivado logic analyzer using the upload_hw_ila_data
		/// command, or the read_hw_ila_data command. By default, the current hw_ila_data object is
		/// the latest one created by the Vivado logic analyzer. The current_hw_ila_data command can
		/// be used to change that object.
		/// The ILA debug core captures sample data in real-time as the hardware device runs, based on the
		/// event triggers or capture conditions defined on the hw_ila object. The hw_ila object triggers on
		/// the hw_device are armed by the run_hw_ila command.
		/// The ILA data object can be displayed in the waveform window of the Vivado tools logic analyzer
		/// using the display_hw_ila_data command. You can also write the ILA data to disk with the
		/// write_hw_ila_data command to save the ILA debug information for later user and analysis.
		/// This command returns the captured hardware ILA debug core data as an object, or returns an
		/// error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 389
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_ila_data">(Optional) hardware ILA data</param>
		/// <returns>hardware ILA data</returns>
		public virtual SimpleTCLCommand current_hw_ila_data(bool? quiet = null, bool? verbose = null, string hw_ila_data = null)
		{
			// TCL Syntax: current_hw_ila_data [-quiet] [-verbose] [<hw_ila_data>]
			return
				new SimpleTCLCommand("current_hw_ila_data")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(hw_ila_data)
			;
		}
		/// <summary>
		/// Get or set the current hardware server
		///
		///
		/// TCL Syntax: current_hw_server [-quiet] [-verbose] [<hw_server>]
		///
		/// Defines the current hardware server from the list of hardware servers that are connected to the
		/// Vivado Design Suite, or returns the currently connected hardware server object.
		/// Hardware servers are instances of the Xilinx hardware server (hw_server) application running
		/// remotely, or on the local machine. The hardware server manages connections to a hardware
		/// target, such as a hardware board containing a JTAG chain of one or more Xilinx devices to be
		/// used for programming and debugging your FPGA design.
		/// Hardware servers are connected to the Vivado Design Suite with the connect_hw_server
		/// command. The current hardware server, and the current hardware target and device are the
		/// focus of most Hardware Manager Tcl commands. The current target and device can be defined
		/// using the current_hw_target and current_hw_device commands.
		/// Note: There is usually a current hw_server defined, either the last connected hardware server, or one you
		/// have defined with this command. However, if you disconnect the current hardware server, you will need to
		/// define a new current hw_server object.
		/// You can get a list of connected hardware servers using the get_hw_servers command. You
		/// can get a list of available hardware targets and devices using the get_hw_targets and
		/// get_hw_devices commands respectively.
		/// This command returns a hw_server object. If the <hw_server> is specified as part of the
		/// current_hw_server command, the specified server is defined as the current hardware server
		/// and that object is returned. If no server is specified, the current_hw_server command
		/// returns the current hardware server object.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 391
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_server">(Optional) hardware server</param>
		/// <returns>hardware server</returns>
		public virtual SimpleTCLCommand current_hw_server(bool? quiet = null, bool? verbose = null, string hw_server = null)
		{
			// TCL Syntax: current_hw_server [-quiet] [-verbose] [<hw_server>]
			return
				new SimpleTCLCommand("current_hw_server")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(hw_server)
			;
		}
		/// <summary>
		/// Get or set the current hardware target
		///
		///
		/// TCL Syntax: current_hw_target [-quiet] [-verbose] [<hw_target>]
		///
		/// After opening the Hardware Manager in the Vivado Design Suite, and connecting to the Xilinx
		/// hardware server (hw_server) using the connect_hw_server command, you will need to set
		/// the hardware target. This command sets or returns the current hardware target.
		/// The hardware target is a system board containing a JTAG chain of one or more Xilinx devices that
		/// you can program with a bitstream file, or use to debug your design. Connections between
		/// hardware targets on the system board and the Vivado Design Suite are managed by the
		/// hw_server object. Refer to Vivado Design Suite User Guide: Programming and Debugging (UG908)
		/// for a list of supported JTAG download cables and devices.
		/// The available hardware targets are defined when the Vivado tools Hardware Manager is
		/// connected to a hw_server. You can return a list of the available hardware targets using the
		/// get_hw_targets command, and define the current hardware target using the
		/// current_hw_target command.
		/// If the <hw_target> is specified as part of the current_hw_target command, the specified
		/// target is defined as the current hardware target and that object is returned. If no hardware target
		/// is specified, the current_hw_target command returns the current hardware target object.
		/// Each hardware target can have one or more Xilinx devices to program, or to use for debugging
		/// purposes. The current device is specified or returned by the current_hw_device command.
		/// After specifying the current hardware target, you can open the connection through the hardware
		/// target, to the Xilinx device using the open _hw_target command.
		/// IMPORTANT! You can use the current_hw_server, current_hw_target, and
		/// current_hw_device commands to set the hardware for programming and debugging the design. You
		/// should exercise care when using these commands to insure that the current server, target, and device are in
		/// sync. The current device should be found on the current target, which should be found on the current server.
		/// This command returns the current hardware target as an object, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 393
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_target">(Optional) hardware target</param>
		/// <returns>hardware target</returns>
		public virtual SimpleTCLCommand current_hw_target(bool? quiet = null, bool? verbose = null, string hw_target = null)
		{
			// TCL Syntax: current_hw_target [-quiet] [-verbose] [<hw_target>]
			return
				new SimpleTCLCommand("current_hw_target")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(hw_target)
			;
		}
		/// <summary>
		/// Set or get the current instance
		///
		///
		/// TCL Syntax: current_instance [-quiet] [-verbose] [<instance>]
		///
		/// Set the current instance in the design hierarchy to the specified instance cell or to the top of the
		/// current design. By default, current_instance points to the top module of the
		/// current_design, which is not an instantiated cell object. You can also set
		/// current_instance to reference an instantiated hierarchical cell in the design.
		/// IMPORTANT! Since the top module is not an instantiated object, current_instance returns an empty
		/// string rather than a design object, when set to the top-level of the current design.
		/// The current design and current instance are the target of most of the commands and design
		/// changes you will make. The current design can be defined using the current_design
		/// command.
		/// You must specify the <instance> name relative to the currently defined instance, and use the
		/// established hierarchy separator to define instance paths. You can determine the current hierarchy
		/// separator with the get_hierarchy_separator command.
		/// Use '..' to traverse up the hierarchical instance path when specifying the current instance.
		/// This command returns the name of the design object of the current_instance, or returns nothing
		/// when set to the top of current design.
		///
		/// The following example sets the current instance to the top module of the current design:
		/// current_instance
		/// INFO: [Vivado 12-618] Current instance is the top level of design
		/// 'netlist_1'.
		/// In this example you have selected an object in the Vivado IDE, and you want to set that selected
		/// object as the current instance:
		/// current_instance [lindex [get_selected_objects] 0]
		/// Note: get_selected_objects returns a list, even of one object, so you must use lindex to specify an
		/// object from that list.
		/// The following example first sets the hierarchy separator character, and then sets the current
		/// instance relative to the presently defined current instance:
		/// set_hierarchy_separator |
		/// current_instance ..|cpu_iwb_dat_o|buffer_fifo
		/// The following example returns the name of the presently defined current instance:
		/// current_instance .
		/// cpuEngine|cpu_iwb_dat_o|buffer_fifo
		///
		/// See ug835-vivado-tcl-commands.pdf, page 396
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="instance">(Optional) Name of instance</param>
		/// <returns>instance name</returns>
		public virtual SimpleTCLCommand current_instance(bool? quiet = null, bool? verbose = null, string instance = null)
		{
			// TCL Syntax: current_instance [-quiet] [-verbose] [<instance>]
			return
				new SimpleTCLCommand("current_instance")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(instance)
			;
		}
		/// <summary>
		/// Get a list of PartitionDefs
		///
		///
		/// TCL Syntax: current_pr_configuration [-quiet] [-verbose] [<config>...]
		///
		/// Get or set the current PR configuration.
		/// In the Partial Reconfiguration (PR) design flow, the PR configuration lets you specify a
		/// reconfigurable module (RM) to assign to a specific instance of a Partition Definition
		/// (partitionDef). This flow lets you create unique configurations of the design based on the
		/// combination of the core design and one or more RMs. The PR design flow requires the
		/// implementation of each PR configuration, resulting in partial bitstreams for the RMs, but
		/// complete bitstreams for each integrated configuration. Refer to the Vivado Design Suite User
		/// Guide: Dynamic Function eXchange (UG909) for more information.
		/// The current_pr_configuration either returns the PR configuration that is the current or active
		/// configfuration in the design, or lets you specify a PR configuration to make active.
		/// This command returns the name of the current PR configuration, or returns an error if the
		/// command fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 399
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="config">(Optional) Specify the PR configuration to be set as current (active); optional</param>
		/// <returns>list of PartitionDef objects</returns>
		public virtual SimpleTCLCommand current_pr_configuration(bool? quiet = null, bool? verbose = null, string config = null)
		{
			// TCL Syntax: current_pr_configuration [-quiet] [-verbose] [<config>...]
			return
				new SimpleTCLCommand("current_pr_configuration")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(config)
			;
		}
		/// <summary>
		/// Set or get current project
		///
		///
		/// TCL Syntax: current_project [-quiet] [-verbose] [<project>]
		///
		/// Specifies the current project or returns the current project when no project is specified.
		///
		/// The following example sets project_2 as the current project:
		/// current_project project_2
		/// This command makes the current project the focus of all the tool commands. In the GUI mode,
		/// the current project is defined automatically when switching the GUI between projects.
		/// The following example returns the name of the current project in the tool:
		/// current_project
		/// Note: The returned value is the name of the project and not the name or path of the project file.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 401
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="project">(Optional) Project to set as current</param>
		/// <returns>current or newly set project object</returns>
		public virtual SimpleTCLCommand current_project(bool? quiet = null, bool? verbose = null, string project = null)
		{
			// TCL Syntax: current_project [-quiet] [-verbose] [<project>]
			return
				new SimpleTCLCommand("current_project")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(project)
			;
		}
		/// <summary>
		/// Set or get the current run
		///
		///
		/// TCL Syntax: current_run [-synthesis] [-implementation] [-quiet] [-verbose] [<run>]
		///
		/// Defines the current synthesis or implementation run, or returns the name of the current run. The
		/// current run is the one automatically selected when the Synthesize or Implement commands are
		/// launched.
		/// You can use the get_runs command to determine the list of defined runs in the current design.
		///
		/// The following example defines the synth_1 run as the current_run:
		/// current_run synth_1
		/// Note: The -synthesis and -implementation arguments are not required because the name allows the
		/// tool to identify the specific run of interest.
		/// The following command returns the name of the current implementation run:
		/// current_run -implementation -quiet
		///
		/// See ug835-vivado-tcl-commands.pdf, page 403
		/// </summary>
		/// <param name="synthesis">(Optional) Set or get the current synthesis run</param>
		/// <param name="implementation">
		/// (Optional)
		/// Set or get the current implementation run (default unless '-
		/// synthesis' is specified)
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="run">(Optional) Run to set as current; optional</param>
		/// <returns>run object</returns>
		public virtual SimpleTCLCommand current_run(bool? synthesis = null, bool? implementation = null, bool? quiet = null, bool? verbose = null, string run = null)
		{
			// TCL Syntax: current_run [-synthesis] [-implementation] [-quiet] [-verbose] [<run>]
			return
				new SimpleTCLCommand("current_run")
					.Flag("synthesis", synthesis)
					.Flag("implementation", implementation)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(run)
			;
		}
		/// <summary>
		/// Get the current scope or set the current scope
		///
		///
		/// TCL Syntax: current_scope [-quiet] [-verbose] [<hdl_scope>]
		///
		/// Return the current scope in the current simulation, or set the current scope to the specified HDL
		/// scope.
		/// The current_scope command returns the name of the current simulation scope.
		/// If <hdl_scope> is supplied then, the current scope is set to the specified scope.
		///
		/// The following example sets the current scope to the specified HDL scope:
		/// current_scope /testbench/dut
		/// This example returns the current scope name to console:
		/// current_scope
		///
		/// See ug835-vivado-tcl-commands.pdf, page 405
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hdl_scope">(Optional) Default: NULL</param>
		/// <returns>The current scope</returns>
		public virtual SimpleTCLCommand current_scope(bool? quiet = null, bool? verbose = null, string hdl_scope = null)
		{
			// TCL Syntax: current_scope [-quiet] [-verbose] [<hdl_scope>]
			return
				new SimpleTCLCommand("current_scope")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(hdl_scope)
			;
		}
		/// <summary>
		/// Set the current simulation object or get the current simulation object
		///
		///
		/// TCL Syntax: current_sim [-quiet] [-verbose] [<simulationObject>]
		///
		/// Get or set the current Vivado simulation object.
		/// This command can be used after the Vivado simulator has been launched to return or set the
		/// current simulation object.
		///
		/// The following example sets the curent simulation:
		/// current_sim simulation_2
		///
		/// See ug835-vivado-tcl-commands.pdf, page 407
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="simulationObject">
		/// (Optional)
		/// Simulation Object to set the current simulation object to
		/// Default: NULL
		/// </param>
		/// <returns>Returns the current simulation object</returns>
		public virtual SimpleTCLCommand current_sim(bool? quiet = null, bool? verbose = null, string simulationObject = null)
		{
			// TCL Syntax: current_sim [-quiet] [-verbose] [<simulationObject>]
			return
				new SimpleTCLCommand("current_sim")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(simulationObject)
			;
		}
		/// <summary>
		/// Report current simulation time
		///
		///
		/// TCL Syntax: current_time [-s] [-quiet] [-verbose]
		///
		/// Returns the current simulation time to the Tcl Console or Vivado Design Suite Tcl shell.
		///
		/// The following example returns the current time of the current simulation:
		/// current_time
		///
		/// See ug835-vivado-tcl-commands.pdf, page 409
		/// </summary>
		/// <param name="s">(Optional) Short -- suppress the space between numeric part and unit part</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Prints the current simulation time on the console in textual format</returns>
		public virtual SimpleTCLCommand current_time(bool? s = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: current_time [-s] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("current_time")
					.Flag("s", s)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Return the current VCD object or make VCDObject the current VCD object
		///
		///
		/// TCL Syntax: current_vcd [-quiet] [-verbose] [<VCDObject>]
		///
		/// Defines the current Value Change Dump (VCD) object, or returns the name of the current VCD
		/// object in the current simulation.
		/// A VCD file must be opened and assigned to a VCD object using the open_vcd command in
		/// order for there to be a current VCD object.
		/// This command returns the current VCD object.
		///
		/// The following example sets the specified VCD object as current:
		/// current_vcd vcd2
		///
		/// See ug835-vivado-tcl-commands.pdf, page 411
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="VCDObject">(Optional) VCDObject Default: NULL</param>
		public virtual SimpleTCLCommand current_vcd(bool? quiet = null, bool? verbose = null, string VCDObject = null)
		{
			// TCL Syntax: current_vcd [-quiet] [-verbose] [<VCDObject>]
			return
				new SimpleTCLCommand("current_vcd")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(VCDObject)
			;
		}
		/// <summary>
		/// Gets the current WCFG object and sets it to the specified WCFG object if given
		///
		///
		/// TCL Syntax: current_wave_config [-quiet] [-verbose] [<wcfgObj>]
		///
		/// Set or get the current wave configuration object for the current simulation.
		/// In the Vivado® simulator GUI, you can work with a waveform to analyze your design and debug
		/// your code. A wave configuration displays with top-level HDL objects, and can be further
		/// populated using commands like add_wave and add_wave_divider.
		/// This command returns the name of the current wave configuration object.
		///
		/// The following example gets the testbench wave config object and makes it the current wave
		/// configuration in the simulation:
		/// current_wave_config [get_wave_config testbench]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 413
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="wcfgObj">
		/// (Optional)
		/// Sets the current WCFG object to the given value of wcfgObj.
		/// Defaults to current
		/// </param>
		/// <returns>Returns the new or current wave configuration object</returns>
		public virtual SimpleTCLCommand current_wave_config(bool? quiet = null, bool? verbose = null, string wcfgObj = null)
		{
			// TCL Syntax: current_wave_config [-quiet] [-verbose] [<wcfgObj>]
			return
				new SimpleTCLCommand("current_wave_config")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(wcfgObj)
			;
		}
		/// <summary>
		/// Decrypt an AES-GCM encrypted bitstream
		///
		///
		/// TCL Syntax: decrypt_bitstream -encrypted_file <arg> -keyfile <arg> [-force] [-quiet] [-verbose] <file>
		///
		/// During implementation of secure encrypted UltraScale architecture designs, bitstream-level
		/// verification must be performed on the final bitstream against the "golden" bitstream of the Xilinx
		/// tested Security Monitor (SecMon) IP.
		/// The decrypt_bitstream command takes an AES-GCM encrypted bitstream file (.bit
		/// or .rbt) from an implemented design that incorporates the SecMon IP, and an encryption key
		/// file (.nky or .nkz), and returns an unencrypted bitstream file. The decrypted bitstream can then
		/// be used to complete the bitstream verification process.
		/// This command returns the requested file if successful, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 415
		/// </summary>
		/// <param name="encrypted_file">(Required) Input AES-GCM encrypted bitstream (.bit or .rbt)</param>
		/// <param name="keyfile">(Required) File containing encryption keys</param>
		/// <param name="file">(Required) Output decrypted bitstream (.bit, .bin or .rbt)</param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand decrypt_bitstream(string encrypted_file, string keyfile, string file, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: decrypt_bitstream -encrypted_file <arg> -keyfile <arg> [-force] [-quiet] [-verbose] <file>
			return
				new SimpleTCLCommand("decrypt_bitstream")
					.RequiredNamedString("encrypted_file", encrypted_file)
					.RequiredNamedString("keyfile", keyfile)
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Delete specified objects.
		///
		///
		/// TCL Syntax: delete_bd_objs [-quiet] [-verbose] <objects>...
		///
		/// Delete specified objects from the current IP integrator subsystem design.
		/// Objects must be passed directly to the delete_bd_objs command, and not simply referenced
		/// by the object name. Pins are passed to the command by get_bd_pins, for instance, rather than
		/// by pin name.
		/// This command returns nothing if it is successful, and returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 417
		/// </summary>
		/// <param name="objects">(Required) The objects to be deleted</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Pass if successful in deleting objects</returns>
		public virtual SimpleTCLCommand delete_bd_objs(string objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_bd_objs [-quiet] [-verbose] <objects>...
			return
				new SimpleTCLCommand("delete_bd_objs")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Clear a set of clock networks results from memory
		///
		///
		/// TCL Syntax: delete_clock_networks_results [-quiet] [-verbose] <name>
		///
		/// Clear the results of the specified report_clock_networks report from the named result set.
		///
		/// The following example clears the specified results set from memory:
		/// delete_clock_network_results ClkNets
		///
		/// See ug835-vivado-tcl-commands.pdf, page 419
		/// </summary>
		/// <param name="name">(Required) Name for the set of results to clear</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand delete_clock_networks_results(string name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_clock_networks_results [-quiet] [-verbose] <name>
			return
				new SimpleTCLCommand("delete_clock_networks_results")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
			;
		}
		/// <summary>
		/// Deletes the gadgets from project summary dashboard
		///
		///
		/// TCL Syntax: delete_dashboard_gadgets [-quiet] [-verbose] <gadgets>
		///
		/// This command removes the gadget from the Project Summary dashboard, and removes it from
		/// the project.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 421
		/// </summary>
		/// <param name="gadgets">(Required) Gadgets to delete</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand delete_dashboard_gadgets(string gadgets, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_dashboard_gadgets [-quiet] [-verbose] <gadgets>
			return
				new SimpleTCLCommand("delete_dashboard_gadgets")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(gadgets)
			;
		}
		/// <summary>
		/// Delete a debug core
		///
		///
		/// TCL Syntax: delete_debug_core [-quiet] [-verbose] <cores>...
		///
		/// Removes Vivado Lab Edition debug cores from the current project that were added by the
		/// create_debug_core command.
		///
		/// The following command deletes the myCore debug core from the current project:
		/// delete_debug_core myCore
		/// The following command deletes all debug cores from the current project:
		/// delete_debug_core [get_debug_cores]
		/// Note: The get_debug_cores command returns all debug cores as a default.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 423
		/// </summary>
		/// <param name="cores">(Required) Debug cores to delete</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand delete_debug_core(string cores, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_debug_core [-quiet] [-verbose] <cores>...
			return
				new SimpleTCLCommand("delete_debug_core")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(cores)
			;
		}
		/// <summary>
		/// Delete debug port
		///
		///
		/// TCL Syntax: delete_debug_port [-quiet] [-verbose] <ports>...
		///
		/// Deletes ports from Vivado Lab Edition debug cores in the current project. You can disconnect a
		/// signal from a debug port using disconnect_debug_port, or remove the port altogether using
		/// this command.
		///
		/// The following example deletes the DATA port from myCore:
		/// delete_debug_port myCore/DATA
		/// Note: Some ports cannot be deleted because an ILA port requires one CLK port and one TRIG port as a
		/// minimum.
		/// The following example deletes the trigger ports (TRIG) from the myCore debug core:
		/// delete_debug_port [get_debug_ports myCore/TRIG*]
		/// Note: This example will not delete all TRIG ports from myCore, because an ILA core must have at least one
		/// TRIG port. The effect of this command will be to delete the TRIG ports starting at TRIG0 and removing all
		/// of them except the last port.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 425
		/// </summary>
		/// <param name="ports">(Required) Debug ports to delete</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand delete_debug_port(string ports, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_debug_port [-quiet] [-verbose] <ports>...
			return
				new SimpleTCLCommand("delete_debug_port")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(ports)
			;
		}
		/// <summary>
		/// Delete one or more user-defined DRC checks.
		///
		///
		/// TCL Syntax: delete_drc_check [-quiet] [-verbose] <name>...
		///
		/// Delete a single user-defined design rule check from the current project. User-defined design rule
		/// checks are created using the create_drc_checks command.
		/// Note: You cannot delete factory defined rule checks.
		/// Once it has been deleted there is no way to recover a rule check. The undo command will not
		/// work.
		/// Note: This command returns nothing if successful, or returns an error if it fails.
		///
		/// The following example deletes the specified design rule check:
		/// delete_drc_check LJH-1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 427
		/// </summary>
		/// <param name="name">
		/// (Required)
		/// Specify the key for the check to remove. This is the typically
		/// of the form PREFIX-id where PREFIX is a 4-6 letter
		/// abbreviation and id is a unique identifier. Use
		/// get_drc_checks to determine the correct name to use. Only
		/// user-defined DRC checks may be deleted.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand delete_drc_check(string name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_drc_check [-quiet] [-verbose] <name>...
			return
				new SimpleTCLCommand("delete_drc_check")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
			;
		}
		/// <summary>
		/// Delete one or more user defined DRC rule deck objects
		///
		///
		/// TCL Syntax: delete_drc_ruledeck [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Delete one or more user-defined drc_ruledeck objects from the current project. The rule deck
		/// does not have to be empty to be deleted, and once it is deleted there is no way to recover it. The
		/// undo command will not restore a deleted rule deck.
		/// Note: You cannot delete factory defined rule decks.
		/// A rule deck is a collection of design rule checks grouped for convenience, to be run with the
		/// report_drc command at different stages of the FPGA design flow, such as during I/O planning
		/// or placement. The tool comes with a set of factory defined rule decks, but you can also create
		/// new user-defined rule decks with the create_drc_ruledeck command.
		/// Note: This command returns nothing if successful, or returns an error if it fails.
		///
		/// The following example deletes all user-defined rule decks from the current project:
		/// delete_drc_ruledeck
		///
		/// See ug835-vivado-tcl-commands.pdf, page 429
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'drc_ruledeck' objects against patterns. Default: *</param>
		/// <returns>drc_ruledeck</returns>
		public virtual SimpleTCLCommand delete_drc_ruledeck(bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: delete_drc_ruledeck [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("delete_drc_ruledeck")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Delete a fileset
		///
		///
		/// TCL Syntax: delete_fileset [-merge <arg>] [-quiet] [-verbose] <fileset>
		///
		/// Deletes the specified fileset. However, if the fileset cannot be deleted, then no message is
		/// returned.
		///
		/// The following example deletes the sim_2 fileset from the current project.
		/// delete_fileset sim_2
		/// Note: The fileset and all of its files are removed from the project. The files are not removed from the hard
		/// drive.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 432
		/// </summary>
		/// <param name="fileset">(Required) Fileset to be deleted</param>
		/// <param name="merge">(Optional) Fileset to merge files from the deleted fileset into</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand delete_fileset(string fileset, string merge = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_fileset [-merge <arg>] [-quiet] [-verbose] <fileset>
			return
				new SimpleTCLCommand("delete_fileset")
					.OptionalNamedString("merge", merge)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(fileset)
			;
		}
		/// <summary>
		/// Delete hardware AXI Transaction objects
		///
		///
		/// TCL Syntax: delete_hw_axi_txn [-quiet] [-verbose] <hw_axi_txns>...
		///
		/// This command deletes the named AXI transaction objects, hw_axi_txn, from the specified hw_axi
		/// objects.
		/// The create_hw_axi_txn command cannot create an object of the same name as an existing
		/// object. Use this command to delete any existing objects prior to creating new AXI transaction
		/// objects.
		/// This command returns nothing if successful, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 434
		/// </summary>
		/// <param name="hw_axi_txns">(Required) hardware AXI Transaction object to delete</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand delete_hw_axi_txn(string hw_axi_txns, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_hw_axi_txn [-quiet] [-verbose] <hw_axi_txns>...
			return
				new SimpleTCLCommand("delete_hw_axi_txn")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_axi_txns)
			;
		}
		/// <summary>
		/// Removes the HW Bitstream object from a list of hardware devices.
		///
		///
		/// TCL Syntax: delete_hw_bitstream [-of_objects <args>] [-quiet] [-verbose]
		///
		/// This command deletes the hw_bitstream object from the specified hw_device objects.
		/// This clears the PROGRAM.HW_BITSTREAM and PROGRAM.FILE properties on the hw_device
		/// objects, and deletes the hw_bitstream object.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 436
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'hw_bitstream' objects of these types: 'hw_device'.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>hardware devices</returns>
		public virtual SimpleTCLCommand delete_hw_bitstream(string of_objects = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_hw_bitstream [-of_objects <args>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("delete_hw_bitstream")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Removes hw_cfgmem object from memory
		///
		///
		/// TCL Syntax: delete_hw_cfgmem [-quiet] [-verbose] <cfgmem>
		///
		/// Removes the specified hw_cfgmem object from the current hw_device.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 438
		/// </summary>
		/// <param name="cfgmem">(Required) Valid hw_cfgmem object</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand delete_hw_cfgmem(string cfgmem, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_hw_cfgmem [-quiet] [-verbose] <cfgmem>
			return
				new SimpleTCLCommand("delete_hw_cfgmem")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(cfgmem)
			;
		}
		/// <summary>
		/// Delete hardware probe objects
		///
		///
		/// TCL Syntax: delete_hw_probe [-quiet] [-verbose] <hw_probes>...
		///
		/// Delete a user-defined probe from the current hw_ila. The user-define probe must be created by
		/// the create_hw_probe command.
		/// This command returns nothing if successful, or returns an error if it fails.
		///
		/// The following example deletes a user-defined hw_probe object on the current ILA core:
		/// delete_hw_probe [get_hw_probe probeAR]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 440
		/// </summary>
		/// <param name="hw_probes">(Required) hardware probe objects to delete</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand delete_hw_probe(string hw_probes, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_hw_probe [-quiet] [-verbose] <hw_probes>...
			return
				new SimpleTCLCommand("delete_hw_probe")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_probes)
			;
		}
		/// <summary>
		/// Delete a hw_target
		///
		///
		/// TCL Syntax: delete_hw_target [-quiet] [-verbose] [<target_object>]
		///
		/// This command deletes a virtual hardware target from the current_hw_server.
		/// The hw_target object must be a virtual target created by the create_hw_target command, or
		/// an error will be returned.
		/// This command returns nothing if successful, or returns an error if it fails.
		///
		/// The following example deletes the specified hw_target:
		/// delete_hw_target [lindex [get_hw_targets] 1]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 442
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="target_object">(Optional) hardware target object to delete Default: current_hw_target</param>
		public virtual SimpleTCLCommand delete_hw_target(bool? quiet = null, bool? verbose = null, string target_object = null)
		{
			// TCL Syntax: delete_hw_target [-quiet] [-verbose] [<target_object>]
			return
				new SimpleTCLCommand("delete_hw_target")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(target_object)
			;
		}
		/// <summary>
		/// Delete I/O port interfaces from the project
		///
		///
		/// TCL Syntax: delete_interface [-all] [-quiet] [-verbose] <interfaces>...
		///
		/// Deletes an existing interface and optionally deletes all of the associated ports and buses using
		/// the interface.
		///
		/// The following example deletes the specified interface and all of its associated ports and buses:
		/// delete_interface USB0
		///
		/// See ug835-vivado-tcl-commands.pdf, page 444
		/// </summary>
		/// <param name="interfaces">(Required) I/O port interfaces to remove</param>
		/// <param name="all">(Optional) Also remove all of the ports and buses belonging to the interface</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand delete_interface(string interfaces, bool? all = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_interface [-all] [-quiet] [-verbose] <interfaces>...
			return
				new SimpleTCLCommand("delete_interface")
					.Flag("all", all)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(interfaces)
			;
		}
		/// <summary>
		/// Deletes the block fileset and run associated with a given IP.
		///
		///
		/// TCL Syntax: delete_ip_run [-force] [-quiet] [-verbose] <objects>
		///
		/// Deletes the out-of-context (OOC) synthesis and implementation runs for the specified IP
		/// module.
		/// The contents of the run directory are deleted from the project as well as the run. However, the
		/// output products created by the run and copied to the IP sources folder, the DCP file and Verilog
		/// and VHDL structural netlists, are not deleted from the project. You must use the reset_target
		/// or generate_target command to update the IP output products.
		/// IMPORTANT! The command requires an IP object as specified by the get_ips or get_files command,
		/// and will not delete a run based on either the name of the run, or a run object as returned by get_runs.
		///
		/// The following example deletes the OOC synthesis and implementation runs from the specified IP
		/// module:
		/// delete_ip_run [get_ips add1]
		/// Note: In this example, all run results will also be removed from the run directory on the hard drive.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 446
		/// </summary>
		/// <param name="objects">
		/// (Required)
		/// All of the IP objects (from get_ips or get_files) for which the
		/// block fileset and run will be deleted.
		/// </param>
		/// <param name="force">(Optional) Force the deletion of the block fileset and run.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand delete_ip_run(string objects, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_ip_run [-force] [-quiet] [-verbose] <objects>
			return
				new SimpleTCLCommand("delete_ip_run")
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Delete a list of macros
		///
		///
		/// TCL Syntax: delete_macros [-quiet] [-verbose] <macros>
		///
		/// Delete one or more macro defined by the create_macro command.
		///
		/// The following example deletes a macro called usbMacro1:
		/// delete_macros usbMacro1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 448
		/// </summary>
		/// <param name="macros">(Required) Macros to delete</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand delete_macros(string macros, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_macros [-quiet] [-verbose] <macros>
			return
				new SimpleTCLCommand("delete_macros")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(macros)
			;
		}
		/// <summary>
		/// Delete existing PartitionDefs
		///
		///
		/// TCL Syntax: delete_partition_defs [-merge <arg>] [-quiet] [-verbose] <partition_defs>
		///
		/// Delete the specified Partition Definition (partitionDef) objects from the current project.
		/// This command returns a transcript of the file merge process, returns nothing without file merge,
		/// or returns an error if the command fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 450
		/// </summary>
		/// <param name="partition_defs">(Required) List of PartitionDefs to delete</param>
		/// <param name="merge">
		/// (Optional)
		/// Fileset to merge files into from the default RM of deleted
		/// Partition Def
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand delete_partition_defs(string partition_defs, string merge = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_partition_defs [-merge <arg>] [-quiet] [-verbose] <partition_defs>
			return
				new SimpleTCLCommand("delete_partition_defs")
					.OptionalNamedString("merge", merge)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(partition_defs)
			;
		}
		/// <summary>
		/// Remove Pblock
		///
		///
		/// TCL Syntax: delete_pblocks [-hier] [-quiet] [-verbose] <pblocks>...
		///
		/// Deletes the specified Pblocks from the design. Pblocks are created using the create_pblock
		/// command.
		///
		/// The following example deletes the specified Pblock as well as any Pblocks nested inside:
		/// delete_pblocks -hier cpuEngine
		///
		/// See ug835-vivado-tcl-commands.pdf, page 452
		/// </summary>
		/// <param name="pblocks">(Required) Pblocks to delete</param>
		/// <param name="hier">(Optional) Also delete all the children of Pblock</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand delete_pblocks(string pblocks, bool? hier = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_pblocks [-hier] [-quiet] [-verbose] <pblocks>...
			return
				new SimpleTCLCommand("delete_pblocks")
					.Flag("hier", hier)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(pblocks)
			;
		}
		/// <summary>
		/// Delete power results that were stored in memory under a given name.
		///
		///
		/// TCL Syntax: delete_power_results -name <arg> [-quiet] [-verbose]
		///
		/// Deletes the power analysis results for the specified results set.
		/// Note: This command operates silently and does not return direct feedback of its operation
		///
		/// The following example runs power analysis, and then clears the results:
		/// report_power -name my_set
		/// delete_power_results -name my_set
		///
		/// See ug835-vivado-tcl-commands.pdf, page 454
		/// </summary>
		/// <param name="name">(Required) Name for the set of results to clear</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand delete_power_results(string name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_power_results -name <arg> [-quiet] [-verbose]
			return
				new SimpleTCLCommand("delete_power_results")
					.RequiredNamedString("name", name)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Delete existing configurations
		///
		///
		/// TCL Syntax: delete_pr_configurations [-quiet] [-verbose] <configs>
		///
		/// Delete the specified PR configuration from the current project.
		/// This command returns nothing if successful, or returns an error if the command fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 456
		/// </summary>
		/// <param name="configs">(Required) List of Configurations to delete</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand delete_pr_configurations(string configs, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_pr_configurations [-quiet] [-verbose] <configs>
			return
				new SimpleTCLCommand("delete_pr_configurations")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(configs)
			;
		}
		/// <summary>
		/// Deletes a list of available QoR suggestions
		///
		///
		/// TCL Syntax: delete_qor_suggestions [-quiet] [-verbose] [<IDs>]
		///
		/// Removes QoR suggestion objects that are currently in memory. Suggestion objects are generated
		/// running the report_qor_suggestion command, without specifying -of_objects, and by
		/// reading an RQS file using the read_qor_suggestions command. You can get QoR objects by
		/// using the get_qor_suggestions command.
		///
		/// The following deletes all the suggestion objects in memory:
		/// delete_qor_suggestions [get_qor_suggestions]
		/// The following deletes only the Utilization suggestions:
		/// delete_qor_suggestions [get_qor_suggestions -filter {CATEGORY==Utilization}]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 458
		/// </summary>
		/// <param name="IDs">(Required) Match suggestion names against given names</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand delete_qor_suggestions(string IDs, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_qor_suggestions [-quiet] [-verbose] [<IDs>]
			return
				new SimpleTCLCommand("delete_qor_suggestions")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(IDs)
			;
		}
		/// <summary>
		/// Delete existing reconfig modules
		///
		///
		/// TCL Syntax: delete_reconfig_modules [-merge <arg>] [-quiet] [-verbose] <rms>
		///
		/// Delete the specified reconfigurable modules (RMs) from the current project.
		/// This command returns nothing if successful, or returns an error if the command fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 460
		/// </summary>
		/// <param name="rms">(Required) List of Reconfig Modules to delete</param>
		/// <param name="merge">(Optional) Fileset to merge files into from the deleted Reconfig Module</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand delete_reconfig_modules(string rms, string merge = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_reconfig_modules [-merge <arg>] [-quiet] [-verbose] <rms>
			return
				new SimpleTCLCommand("delete_reconfig_modules")
					.OptionalNamedString("merge", merge)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(rms)
			;
		}
		/// <summary>
		/// Delete a set of existing configurable report objects
		///
		///
		/// TCL Syntax: delete_report_configs [-quiet] [-verbose] <report_configs>...
		///
		/// Removes specified report objects from the current project. The report objects are created by the
		/// create_report_config command.
		/// This command returns nothing if successful, or an error if it fails.
		///
		/// The following example deletes the specified report_config object:
		/// delete_report_configs [get_report_configs post_route_datasheet]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 462
		/// </summary>
		/// <param name="report_configs">(Required) List of configurable report objects to delete</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand delete_report_configs(string report_configs, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_report_configs [-quiet] [-verbose] <report_configs>...
			return
				new SimpleTCLCommand("delete_report_configs")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(report_configs)
			;
		}
		/// <summary>
		/// Delete an RPM
		///
		///
		/// TCL Syntax: delete_rpm [-quiet] [-verbose] <rpm>
		///
		/// Deletes the specified Relationally Placed Macro (RPM) from the design.
		/// An RPM is a list of logic elements (FFS, LUT, CY4, RAM, etc.) collected into a set (U_SET, H_SET,
		/// and HU_SET). The placement of each element within the set, relative to other elements of the
		/// set, is controlled by Relative Location Constraints (RLOCs). Logic elements with RLOC constraints
		/// and common set names are associated in an RPM. Refer to the Constraints Guide (UG625) for
		/// more information on defining these constraints.
		/// Only user-defined RPMs can be deleted from the design. RPMs defined by the hierarchy or
		/// defined in the netlist cannot be deleted by this command.
		///
		/// The following example deletes the specified RPM (cs_ila_0/U0) from the design:
		/// delete_rpm cs_ila_0/U0
		///
		/// See ug835-vivado-tcl-commands.pdf, page 464
		/// </summary>
		/// <param name="rpm">(Required) RPM to delete</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand delete_rpm(string rpm, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_rpm [-quiet] [-verbose] <rpm>
			return
				new SimpleTCLCommand("delete_rpm")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(rpm)
			;
		}
		/// <summary>
		/// Delete existing runs
		///
		///
		/// TCL Syntax: delete_runs [-noclean_dir] [-quiet] [-verbose] <runs>
		///
		/// Deletes the specified runs from the project, and deletes all results of the run from the project
		/// directory on the hard drive unless otherwise specified.
		///
		/// The following example deletes the first_pass run from the project:
		/// delete_runs first_pass
		/// Note: In this example, all run results will also be removed from the project directory on the hard drive.
		/// The following command deletes the first_pass run, but leaves the run results on the hard drive:
		/// delete_runs -noclean_dir first_pass
		///
		/// See ug835-vivado-tcl-commands.pdf, page 466
		/// </summary>
		/// <param name="runs">(Required) Run to modify</param>
		/// <param name="noclean_dir">(Optional) Do not remove all output files and directories from disk</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand delete_runs(string runs, bool? noclean_dir = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_runs [-noclean_dir] [-quiet] [-verbose] <runs>
			return
				new SimpleTCLCommand("delete_runs")
					.Flag("noclean_dir", noclean_dir)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(runs)
			;
		}
		/// <summary>
		/// Clear a set of timing results from memory
		///
		///
		/// TCL Syntax: delete_timing_results [-type <arg>] [-quiet] [-verbose] <name>
		///
		/// Clear the specified timing results from the named result set. Both the type of the timing report,
		/// and the name of the timing report must be specified, or the command will fail.
		///
		/// The following example clears the specified results set from memory:
		/// delete_timing_results -type clock_interaction clkNets
		///
		/// See ug835-vivado-tcl-commands.pdf, page 468
		/// </summary>
		/// <param name="name">(Required) Name for the set of results to clear</param>
		/// <param name="type">
		/// (Optional)
		/// Type of timing results to clear; Values: bus_skew,
		/// check_timing, clock_interaction, clock_domain_crossings,
		/// config_timing, datasheet, pulse_width, slack_histogram,
		/// timing_path, timing_summary
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand delete_timing_results(string name, string type = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_timing_results [-type <arg>] [-quiet] [-verbose] <name>
			return
				new SimpleTCLCommand("delete_timing_results")
					.OptionalNamedString("type", type)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
			;
		}
		/// <summary>
		/// Delete utilization results that were stored in memory under a given name.
		///
		///
		/// TCL Syntax: delete_utilization_results -name <arg> [-quiet] [-verbose]
		///
		/// Clear the specified utilization results from the named result set.
		///
		/// The following example clears the specified results set from memory:
		/// delete_utilization_results -name SSO1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 470
		/// </summary>
		/// <param name="name">(Required) Name for the set of results to clear</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand delete_utilization_results(string name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_utilization_results -name <arg> [-quiet] [-verbose]
			return
				new SimpleTCLCommand("delete_utilization_results")
					.RequiredNamedString("name", name)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Delete one or more DRC/METHODOLOGY/CDC message waivers
		///
		///
		/// TCL Syntax: delete_waivers [-scoped] [-quiet] [-verbose] [<objects>...]
		///
		/// After report_drc, report_methodology, or report_cdc commands are run, they return
		/// messages of specific violations or conditions found in the design. These violations can prevent
		/// the design from progressing until they have been resolved or addressed in some way. The
		/// create_waiver command lets you select individual violations or specific checks that can be
		/// waived for a design, letting you move forward in the design flow.
		/// Use the delete_waivers command to remove waivers from the design.
		///
		/// This example deletes all the DRC waivers in the design:
		/// delete_waivers [get_waivers -type DRC]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 472
		/// </summary>
		/// <param name="scoped">
		/// (Optional)
		/// flag waiver to interpret object wildcards as scoped to the
		/// current_instance that is set
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">
		/// (Optional)
		/// List of waiver objects, or a list of message objects (cells,
		/// nets, sites, etc.) for which DRC/METHODOLOGY waiver(s)
		/// were set
		/// </param>
		public virtual SimpleTCLCommand delete_waivers(bool? scoped = null, bool? quiet = null, bool? verbose = null, string objects = null)
		{
			// TCL Syntax: delete_waivers [-scoped] [-quiet] [-verbose] [<objects>...]
			return
				new SimpleTCLCommand("delete_waivers")
					.Flag("scoped", scoped)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(objects)
			;
		}
		/// <summary>
		/// Describe an HDL object (variable, signal, wire, or reg) by printing type and declaration
		/// information
		///
		///
		/// TCL Syntax: describe [-quiet] [-verbose] <hdl_object>
		///
		/// Describe an HDL object (variable, signal, wire, or reg) by printing type and declaration
		/// information, as well as path, and file information for the HDL source of the specified objects.
		/// TIP: The describe command works for a single HDL object. Use the report_objects command for a
		/// brief report on multiple HDL objects.
		/// HDL objects include HDL signals, variables, or constants as defined in the Verilog or VHDL test
		/// bench and source files. An HDL signal includes Verilog wire or reg entities, and VHDL signals.
		/// Examples of HDL variables include Verilog real, realtime, time, and event. HDL constants include
		/// Verilog parameters and localparams, and VHDL generic and constants.
		/// The command returns the description of specified HDL objects, or returns an error if it fails.
		///
		/// Verilog parameters and localparams, and VHDL generic and constants.
		/// The command returns the description of specified HDL objects, or returns an error if it fails.
		/// Arguments
		/// -quiet - (Optional) Execute the command quietly, returning no messages from the command.
		/// The command also returns TCL_OK regardless of any errors encountered during execution.
		/// Note: Any errors encountered on the command-line, while launching the command, will be returned. Only
		/// errors occurring inside the command will be trapped.
		/// -verbose - (Optional) Temporarily override any message limits and return all messages from this
		/// command.
		/// Note: Message limits can be defined with the set_msg_config command.
		/// <hdl_object> - (Required) Specifies a single HDL object to describe.
		/// Note: Objects can be specified by name, or returned as objects by the get_objects command.
		/// Examples
		/// The following example shows how the objects description depends on the scope of the current
		/// simulation:
		/// current_scope testbench
		/// /testbench
		/// describe leds_n
		/// Signal: {leds_n[3:0]}
		/// Path: {/testbench/leds_n}
		/// Location: {File "C:/Data/ug937/sim/testbench.v" Line 9}
		/// current_scope dut
		/// /testbench/dut
		/// describe leds_n
		/// Port(OUT): {LEDS_n[3:0]}
		/// Path: {/testbench/dut/LEDS_n}
		/// Location: {File "C:/Data/sources/sinegen_demo.vhd" Line 42}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 474
		/// </summary>
		/// <param name="hdl_object">(Required) The hdl_object or hdl_scope to describe</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The description of the selected objects</returns>
		public virtual SimpleTCLCommand describe(string hdl_object, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: describe [-quiet] [-verbose] <hdl_object>
			return
				new SimpleTCLCommand("describe")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hdl_object)
			;
		}
		/// <summary>
		/// Automatically detect links between RX and TX endpoints. Create a new link group to contain the
		/// links.
		///
		///
		/// TCL Syntax: detect_hw_sio_links [-force] [-quiet] [-verbose]
		///
		/// Automatically detects existing or previously defined communication pathways between GT
		/// transmitters and receivers that are defined on the open hardware target.
		/// You can use this command if you change board connections while the serial I/O analyzer is
		/// running. The detection algorithm uses changing transmit patterns and detects links on received
		/// patterns to determine how GTs are connected to one another on the open hardware target.
		/// A transmitter or receiver of an individual GT on the IBERT debug core can only be used in one
		/// hw_sio_link at a time, so the command will not check GTs that are used in existing links. The -
		/// force option lets you clear all existing links before scanning the open hardware target to check
		/// all GTs.
		/// The detect_hw_sio_links command defines the found links, and creates a link group to
		/// associate the new links.
		/// This command returns the number of links found and the created hw_sio_linkgroup object, or
		/// returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 476
		/// </summary>
		/// <param name="force">(Optional) Remove all existing links before detecting links</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>A new hardware SIO link group of found links</returns>
		public virtual SimpleTCLCommand detect_hw_sio_links(bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: detect_hw_sio_links [-force] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("detect_hw_sio_links")
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Disconnect an intf_net.
		///
		///
		/// TCL Syntax: disconnect_bd_intf_net [-quiet] [-verbose] <intf_net> <objects>...
		///
		/// Disconnect a single interface net in the IP integrator subsystem design from the specified
		/// objects. An interface is a grouping of signals that share a common function in the IP integrator
		/// subsystem design.
		/// This command lets you disconnect the specified interface net from pins or ports in the IP
		/// subsystem design, without deleting the whole net. To delete the whole net, you should use the
		/// delete_bd_objs command.
		/// This command returns TCL_OK is successful, or TCL_ERROR if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 478
		/// </summary>
		/// <param name="intf_net">(Required) The IntfNet that the objects connect to</param>
		/// <param name="objects">(Required) The objects to disconnect from the intf_net</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>TCL_OK, TCL_ERROR if failed.</returns>
		public virtual SimpleTCLCommand disconnect_bd_intf_net(string intf_net, string objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: disconnect_bd_intf_net [-quiet] [-verbose] <intf_net> <objects>...
			return
				new SimpleTCLCommand("disconnect_bd_intf_net")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(intf_net)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Disconnect a net from the object.
		///
		///
		/// TCL Syntax: disconnect_bd_net [-quiet] [-verbose] <net> <objects>...
		///
		/// Disconnect a single net in the IP integrator subsystem design from the specified objects.
		/// This command lets you disconnect the specified nets from pins or ports in the IP subsystem
		/// design, without deleting the whole net. To delete the whole net, you should use the
		/// delete_bd_objs command.
		/// This command returns TCL_OK if successful, or TCL_ERROR if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 480
		/// </summary>
		/// <param name="net">(Required) The Net that the objects connect to</param>
		/// <param name="objects">(Required) The objects to disconnect from the net</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>TCL_OK, TCL_ERROR if failed.</returns>
		public virtual SimpleTCLCommand disconnect_bd_net(string net, string objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: disconnect_bd_net [-quiet] [-verbose] <net> <objects>...
			return
				new SimpleTCLCommand("disconnect_bd_net")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(net)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Disconnect nets and pins from debug port channels
		///
		///
		/// TCL Syntax: disconnect_debug_port [-channel_index <arg>] [-quiet] [-verbose] <port>
		///
		/// Disconnect signals from the debug ports.
		/// Signals from the Netlist Design are connected to ports of a ILA debug core using the
		/// connect_debug_port command.
		/// A port can also be deleted from the debug core rather than simply disconnected by using the
		/// delete_debug_port command.
		/// If you need to determine the specific name of a port on a debug core, use the
		/// get_debug_ports command to list all ports on a core. You can also use the
		/// report_debug_core command to list all of the cores in the projects, and their specific
		/// parameters.
		///
		/// The following example disconnects only the specified channel index from the PROBE1 port of
		/// myCore:
		/// disconnect_debug_port -channel_index 2 myCore/PROBE1
		/// If you do not specify the channel_index, all of the channels of the specified port will be
		/// disconnected, as in the following example:
		/// disconnect_debug_port myCore/PROBE1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 482
		/// </summary>
		/// <param name="port">(Required) Debug port name</param>
		/// <param name="channel_index">(Optional) Disconnect the net at channel index</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand disconnect_debug_port(string port, string channel_index = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: disconnect_debug_port [-channel_index <arg>] [-quiet] [-verbose] <port>
			return
				new SimpleTCLCommand("disconnect_debug_port")
					.OptionalNamedString("channel_index", channel_index)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(port)
			;
		}
		/// <summary>
		/// Close a connection to a hardware server
		///
		///
		/// TCL Syntax: disconnect_hw_server [-quiet] [-verbose] [<hw_server>]
		///
		/// Disconnect the current or specified Vivado tools hardware server from the Vivado Design Suite.
		/// The current hardware server is either the last connected hardware server, or one you have
		/// manually defined with the current_hw_server command. If you disconnect the current
		/// hardware server, there will be no defined current hardware server until you define a new current
		/// hw_server object.
		/// This command returns nothing if successful, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 484
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_server">(Optional) hardware server Default: current hardware server</param>
		public virtual SimpleTCLCommand disconnect_hw_server(bool? quiet = null, bool? verbose = null, string hw_server = null)
		{
			// TCL Syntax: disconnect_hw_server [-quiet] [-verbose] [<hw_server>]
			return
				new SimpleTCLCommand("disconnect_hw_server")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(hw_server)
			;
		}
		/// <summary>
		/// Disconnect a net from pins or ports
		///
		///
		/// TCL Syntax: disconnect_net [-prune] [-net <arg>] [-objects <args>] [-pinlist <args>] [-quiet] [-verbose]
		///
		/// This command allows the user to disconnect a specified net from one or more pins or ports in the
		/// netlist of an open Synthesized or Implemented Design.
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*
		/// command.
		/// Note: Netlist editing is not allowed on the elaborated RTL design.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 486
		/// </summary>
		/// <param name="objects">(Required) List of pins or ports to disconnect</param>
		/// <param name="prune">
		/// (Optional)
		/// When performing disconnect, remove the net and any
		/// pin/net chain up to the pin on any primitive instance as long
		/// as each object in the chain has only 1 remaining connection.
		/// </param>
		/// <param name="net">
		/// (Optional)
		/// Net to disconnect - optional, net attached to first pin or port
		/// object is used if not specified.
		/// </param>
		/// <param name="pinlist">
		/// (Optional)
		/// List of pin and port objects to disconnect (names of objects
		/// supported, but not as flexibly as with -objects, faster than -
		/// objects.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand disconnect_net(string objects, bool? prune = null, string net = null, string pinlist = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: disconnect_net [-prune] [-net <arg>] [-objects <args>] [-pinlist <args>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("disconnect_net")
					.Flag("prune", prune)
					.OptionalNamedString("net", net)
					.RequiredNamedString("objects", objects)
					.OptionalNamedString("pinlist", pinlist)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Display hardware ILA data in viewer
		///
		///
		/// TCL Syntax: display_hw_ila_data [-wcfg <arg>] [-reset] [-quiet] [-verbose] [<hw_ila_data>...]
		///
		/// This command is intended for use with the graphical user interface of the Vivado Design Suite
		/// logic analyzer feature. It displays the specified ILA debug core data object in a wave config
		/// window of the Vivado logic analyzer.
		/// The ILA debug sample data is acquired from a running device using the upload_hw_ila_data
		/// command. This creates a hw_ila_data object that can be written to a file on disk using the
		/// write_hw_ila_data command. This command reads that ILA data file.
		/// The display characteristics of the ILA debug core in the waveform window are determined by the
		/// Wave Config file. The Wave Config file contains just the list of wave objects (signals, dividers,
		/// groups, virtual buses) to display, and their display properties, plus markers.
		/// A wave configuration object is created in the Vivado logic analyzer with the
		/// create_wave_config command. A Wave Config file is written to disk by the use of the
		/// save_wave_config command, and can be opened with the open_wave_config command.
		/// The open_wave_config command opens a Wave Config file and maps it to the data source in
		/// the current simulation.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 489
		/// </summary>
		/// <param name="wcfg">(Optional) Import alternate wave config file</param>
		/// <param name="reset">(Optional) Force reset wave config file to default configuration</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_ila_data">(Optional) List of hardware ILA data objects. Default: Current hardware ILA data</param>
		public virtual SimpleTCLCommand display_hw_ila_data(string wcfg = null, bool? reset = null, bool? quiet = null, bool? verbose = null, string hw_ila_data = null)
		{
			// TCL Syntax: display_hw_ila_data [-wcfg <arg>] [-reset] [-quiet] [-verbose] [<hw_ila_data>...]
			return
				new SimpleTCLCommand("display_hw_ila_data")
					.OptionalNamedString("wcfg", wcfg)
					.Flag("reset", reset)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(hw_ila_data)
			;
		}
		/// <summary>
		/// Display an existing hardware SIO scan.
		///
		///
		/// TCL Syntax: display_hw_sio_scan [-quiet] [-verbose] <hw_sio_scans>
		///
		/// This command is intended for use with the graphical user interface of the Vivado Design Suite
		/// serial I/O analyzer feature. It displays the specified SIO scan data object, or objects, in a Scan
		/// Plots window of the Vivado IDE.
		/// The SIO scan data can be read from a file on disk using the read_hw_sio_scan command, or
		/// from a hw_sio_scan object created by the run_hw_sio_scan command. The type of plot
		/// displayed is determined by the <scan_type> of the hw_sio_scan object.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 491
		/// </summary>
		/// <param name="hw_sio_scans">(Required) hardware SIO scans</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand display_hw_sio_scan(string hw_sio_scans, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: display_hw_sio_scan [-quiet] [-verbose] <hw_sio_scans>
			return
				new SimpleTCLCommand("display_hw_sio_scan")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_sio_scans)
			;
		}
		/// <summary>
		/// Encrypt files in place with a language specific key file in IEEE 1735. no default
		///
		///
		/// TCL Syntax: encrypt [-key <arg>] -lang <arg> [-ext <arg>] [-quiet] [-verbose] <files>...
		///
		/// TIP: The encrypt command is provided with limited access, and requires a special license to use.
		/// Allows anyone with an encryption license to encrypt Verilog or VHDL files using the IEEE 1735
		/// encryption standard.
		/// Encrypted files can be provided by third-party IP providers to protect their intellectual property,
		/// while still enabling the Vivado Design Suite to read the encrypted files for synthesis and
		/// simulation. The data is in plain text prior to encryption.
		/// IMPORTANT! Unless the -ext option is used, the specified files are encrypted in place, overwriting the input
		/// files with the encrypted files.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 493
		/// </summary>
		/// <param name="lang">(Required) HDL language of the input/output file</param>
		/// <param name="files">(Required) Files to be encrypted in place</param>
		/// <param name="key">(Optional) key file to be used to encrypt; if absent, use embedded keys</param>
		/// <param name="ext">
		/// (Optional)
		/// extension to use for encrypted file; the original source files
		/// will be preserved.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand encrypt(string lang, string files, string key = null, string ext = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: encrypt [-key <arg>] -lang <arg> [-ext <arg>] [-quiet] [-verbose] <files>...
			return
				new SimpleTCLCommand("encrypt")
					.OptionalNamedString("key", key)
					.RequiredNamedString("lang", lang)
					.OptionalNamedString("ext", ext)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(files)
			;
		}
		/// <summary>
		/// End a set of commands that can be undone/redone as a group
		///
		///
		/// TCL Syntax: endgroup [-quiet] [-verbose]
		///
		/// Ends a sequence of commands that can be undone or redone as a series. Use startgroup to
		/// start the sequence of commands.
		/// You can have multiple command groups to undo or redo, but you cannot nest command groups.
		/// You must use endgroup to end a command sequence before using startgroup to create a
		/// new command sequence.
		/// TIP: The startgroup/endgroup commands are provided to support sequences of related commands that
		/// can be undone via the undo command, or redone if needed using the redo command. However, some Tcl
		/// commands can trigger an endgroup unexpectedly, and certain commands do not support either UNDO or
		/// REDO. The limitations are not fully defined.
		///
		/// The following example defines a startgroup, executes a sequence of related commands, and
		/// then executes the endgroup. This sequence of commands can be undone as a group:
		/// startgroup
		/// create_pblock pblock_wbArbEngine
		/// create_pblock pblock_usbEng
		/// add_cells_to_pblock pblock_wbArbEngine \
		/// [get_cells [list wbArbEngine]] -clear_locs
		/// add_cells_to_pblock pblock_usbEng \
		/// [get_cells [list usbEngine1/usbEngineSRAM]] -clear_locs
		/// endgroup
		///
		/// See ug835-vivado-tcl-commands.pdf, page 495
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand endgroup(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: endgroup [-quiet] [-verbose]
			return
				new SimpleTCLCommand("endgroup")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Exclude segment from an address space.
		///
		///
		/// TCL Syntax: exclude_bd_addr_seg [-target_address_space <arg>] [-quiet] [-verbose] [<segment_to_exclude>]
		///
		/// Exclude the specified AXI peripheral address segment from access by the AXI master it is
		/// mapped to, in order to support sparse connectivity and eliminate unneeded device resources.
		/// This command lets you exclude specific peripherals from being accessed by specific AXI masters.
		/// For example, in the case where AXI peripherals P0 and P1 are connected to two masters M0 and
		/// M1, you can use sparse connectivity to let M0 access both P0 and P1, and let M1 accesses P1,
		/// but exclude it from P0.
		/// In the IP integrator block design, address segments of AXI peripherals will have one of three
		/// states:
		/// • Unmapped - An AXI peripheral, or slave interface, is connected to an AXI master, but the
		/// peripheral has not been assigned an address segment in the master's address space and is not
		/// visible to the master.
		/// • Mapped - The AXI peripheral is mapped into the AXI master's address space, assigned an
		/// address segment or range, and is accessible through the master.
		/// • Excluded - The AXI peripheral is mapped to the AXI master, and has been assigned an address,
		/// but is not accessible to the master. The address segment that the AXI slave occupies within
		/// the master address space is also considered filled.
		/// The purpose of excluding the address segment is to restrict access to peripherals that are
		/// connected to multiple masters. The validate_bd_design command will return a critical
		/// warning if a peripheral interface is connected to a master, but not mapped to an address segment
		/// of that master. However, by excluding the peripheral after it is mapped, the resources required to
		/// connect and provide access between the AXI master and the peripheral (the muxes and decoding
		/// for example) can be eliminated to conserve resources on the implemented design.
		/// TIP: When running assign_bd_address, the IP integrator will map unmapped address segments into address
		/// spaces, but will not map excluded address spaces.
		/// This command offers two syntaxes, for a previously mapped address segment, and an unmapped
		/// address segment:
		/// exclude_bd_addr_seg <master_addr_seg>
		/// exclude_bd_addr_seg -target_address_space <master_addr_space>
		/// <slave_addr_seg>
		/// In the second command syntax, when a slave segment is specified, the slave will first be assigned
		/// or mapped to the specified AXI master address space, and then it will be excluded from access by
		/// the master.
		/// This command returns nothing if successful, or returns an error if it failed.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 497
		/// </summary>
		/// <param name="target_address_space">(Optional) Target address space to exclude the slave segment from</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="segment_to_exclude">(Optional) segment to exclude</param>
		/// <returns>The newly excluded segment object, "" if failed.</returns>
		public virtual SimpleTCLCommand exclude_bd_addr_seg(string target_address_space = null, bool? quiet = null, bool? verbose = null, string segment_to_exclude = null)
		{
			// TCL Syntax: exclude_bd_addr_seg [-target_address_space <arg>] [-quiet] [-verbose] [<segment_to_exclude>]
			return
				new SimpleTCLCommand("exclude_bd_addr_seg")
					.OptionalNamedString("target_address_space", target_address_space)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(segment_to_exclude)
			;
		}
		/// <summary>
		/// Execute SVF file on current_hw_target
		///
		///
		/// TCL Syntax: execute_hw_svf [-quiet] [-verbose] <file_name>
		///
		/// The Vivado hardware manager supports programming of hardware devices through the use of
		/// Serial Vector Format (SVF) files. SVF files are ASCII files that contain both programming
		/// instructions and configuration data. These files are used by ATE machines and embedded
		/// controllers to perform boundary-scan operations. The SVF file is an ASCII files that captures the
		/// JTAG commands needed to program the bitstream directly into a Xilinx device, or indirectly into a
		/// flash memory device. The SVF file can be written using the write_hw_svf command, or used
		/// to program a device through the execute_hw_svf command. Refer to the Vivado Design Suite
		/// User Guide: Programming and Debugging (UG908) for more information.
		/// The execute_hw_svf command converts the SVF commands into Vivado Tcl commands and
		/// executes them on the specified target. This process could take some time depending on how big
		/// the SVF file is. The command requires an open, current hw_target object, with a JTAG chain that
		/// matches the device chain specified in the SVF file.
		/// TIP: The execute_hw_svf command is not a general purpose SVF reader, and should only be used to read
		/// and execute SVF files written by the Vivado tools.
		/// This command returns a transcript of its process, or returns an error if it fails.
		///
		/// The following example executes the specified SVF command file in verbose mode to display all of
		/// the commands being run:
		/// open_hw_target {houdini26:3121/xilinx_tcf/Digilent/210203327996A}
		/// execute_hw_svf -verbose C:/Data/k7_design.svf
		///
		/// See ug835-vivado-tcl-commands.pdf, page 500
		/// </summary>
		/// <param name="file_name">(Required) SVF filename</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand execute_hw_svf(string file_name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: execute_hw_svf [-quiet] [-verbose] <file_name>
			return
				new SimpleTCLCommand("execute_hw_svf")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file_name)
			;
		}
		/// <summary>
		/// Export current design as a static example design
		///
		///
		/// TCL Syntax: export_as_example_design -vlnv <arg> [-no_ip_version] [-force] [-quiet] [-verbose] -directory <arg>
		///
		/// See ug835-vivado-tcl-commands.pdf, page 502
		/// </summary>
		/// <param name="vlnv">(Required) VLNV of the example design to be generated</param>
		/// <param name="directory">(Required) Destination directory in which example design needs to be generated</param>
		/// <param name="no_ip_version">
		/// (Optional)
		/// Flag to not include the IP version as part of the IP VLNV in
		/// create_bd_cell commands.
		/// </param>
		/// <param name="force">(Optional) create a directory if it does not exist</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand export_as_example_design(string vlnv, string directory, bool? no_ip_version = null, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: export_as_example_design -vlnv <arg> [-no_ip_version] [-force] [-quiet] [-verbose] -directory <arg>
			return
				new SimpleTCLCommand("export_as_example_design")
					.RequiredNamedString("vlnv", vlnv)
					.Flag("no_ip_version", no_ip_version)
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredNamedString("directory", directory)
			;
		}
		/// <summary>
		/// (User-written application) Create and write a single design checkpoint and stub files for a Block
		/// Design (BD), for use with third party synthesis tools. Perform synthesis as necessary.
		///
		///
		/// TCL Syntax: export_bd_synth [-force] [-keep] [-verbose] [-quiet] <file>
		///
		/// Runs synthesis for a block design (.bd), integrates the design along with any needed sub-designs
		/// (e.g. out-of-context synthesized IP), and writes out a single design checkpoint (.dcp) of the
		/// entire synthesized design, as well as HDL stub files, for use in other synthesis tools. The output
		/// files will be placed in the same directory as the source BD file.
		///
		/// The following command will generate a synthesis checkpoint, with stub files, for the specified
		/// block design:
		/// export_bd_synth [get_files block_1.bd]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 503
		/// </summary>
		/// <param name="file">(Required) The Block Design file to write a synthesized checkpoint for</param>
		/// <param name="force">(Optional) Overwrite existing design checkpoint and stub files</param>
		/// <param name="keep">(Optional) Keep the temporary directory and project</param>
		/// <param name="verbose">(Optional) Print verbose messaging</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <returns>(none) An error will be thrown if the command is not successful</returns>
		public virtual SimpleTCLCommand export_bd_synth(string file, bool? force = null, bool? keep = null, bool? verbose = null, bool? quiet = null)
		{
			// TCL Syntax: export_bd_synth [-force] [-keep] [-verbose] [-quiet] <file>
			return
				new SimpleTCLCommand("export_bd_synth")
					.Flag("force", force)
					.Flag("keep", keep)
					.Flag("verbose", verbose)
					.Flag("quiet", quiet)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// (User-written application) Generate and export IP/IPI user files from a project. This can be
		/// scoped to work on one or more IPs. Argument Usage: [-of_objects <arg>]: IP,IPI or a fileset object
		/// [-ip_user_files_dir <arg>]: Directory path to simulation base directory (for static, dynamic,
		/// wrapper, netlist, script and MEM files) [-ipstatic_source_dir <arg>]: Directory path to the IP static
		/// files [-lib_map_path <arg> = Empty]: Compiled simulation library directory path [-no_script]: Do
		/// not export simulation scripts [-sync]: Delete IP/IPI dynamic and simulation script files [-reset]:
		/// Delete all IP/IPI static, dynamic and simulation script files [-force]: Overwrite files
		///
		///
		/// TCL Syntax: export_ip_user_files [-of_objects <arg>] [-ip_user_files_dir <arg>] [-ipstatic_source_dir <arg>] [-lib_map_path <arg>] [-no_script] [-sync] [-reset] [-force] [-quiet] [-verbose]
		///
		/// Export IP user files repository with static, dynamic, netlist, verilog/vhdl stubs and memory
		/// initializaton files.
		///
		/// The following command will export the dynamic files for the char_fifo IP to <project>/
		/// <project>.ip_user_files/ip/char_fifo directory, and IP static files to <project>/
		/// <project>.ip_user_files/ipstatic directory:
		/// export_ip_user_files -of_objects [get_ips char_fifo]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 505
		/// </summary>
		/// <param name="of_objects">(Optional) IP,IPI or a fileset object Default: None</param>
		/// <param name="ip_user_files_dir">
		/// (Optional)
		/// Directory path to simulation base directory (for static,
		/// dynamic, wrapper, netlist, script and MEM files) Default:
		/// None
		/// </param>
		/// <param name="ipstatic_source_dir">(Optional) Directory path to the IP static files Default: None</param>
		/// <param name="lib_map_path">(Optional) Compiled simulation library directory path Default: Empty</param>
		/// <param name="no_script">(Optional) Do not export simulation scripts Default: 1</param>
		/// <param name="sync">(Optional) Delete IP/IPI dynamic and simulation script files</param>
		/// <param name="reset">(Optional) Delete all IP/IPI static, dynamic and simulation script files</param>
		/// <param name="force">(Optional) Overwrite files</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of files that were exported</returns>
		public virtual SimpleTCLCommand export_ip_user_files(string of_objects = null, string ip_user_files_dir = null, string ipstatic_source_dir = null, string lib_map_path = null, bool? no_script = null, bool? sync = null, bool? reset = null, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: export_ip_user_files [-of_objects <arg>] [-ip_user_files_dir <arg>] [-ipstatic_source_dir <arg>] [-lib_map_path <arg>] [-no_script] [-sync] [-reset] [-force] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("export_ip_user_files")
					.OptionalNamedString("of_objects", of_objects)
					.OptionalNamedString("ip_user_files_dir", ip_user_files_dir)
					.OptionalNamedString("ipstatic_source_dir", ipstatic_source_dir)
					.OptionalNamedString("lib_map_path", lib_map_path)
					.Flag("no_script", no_script)
					.Flag("sync", sync)
					.Flag("reset", reset)
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// (User-written application) Export a script and associated data files (if any) for driving standalone
		/// simulation using the specified simulator.
		///
		///
		/// TCL Syntax: export_simulation [-simulator <arg>] [-of_objects <arg>] [-ip_user_files_dir <arg>] [-ipstatic_source_dir <arg>] [-lib_map_path <arg>] [-script_name <arg>] [-directory <arg>] [-runtime <arg>] [-define <arg>] [-generic <arg>] [-include <arg>] [-use_ip_compiled_libs] [-absolute_path] [-export_source_files] [-32bit] [-force] [-quiet] [-verbose]
		///
		/// Export a simulation script file for the target simulator. Currently the Cadence Incisive Enterprise
		/// Simulator (ies) and the Synopsys VCS MX simulator (vcs_mx) are supported. The generated
		/// script will contain simulator commands for compiling, elaborating and simulating the design.
		/// The command will retrieve the simulation compile order of specified objects, and export this
		/// information in a text file with the compiler commands and default options for the target
		/// simulator. The specified object can be either a simulation fileset or an IP. If the object is not
		/// specified, then the export_simulation command will generate the script for the simulation
		/// top.
		/// Any verilog include directories or file paths for the files containing verilog define statements will
		/// be added to the compiler command line.
		/// By default, the design source file and include directory paths in the compiler command line will
		/// be set relative to the "reference_dir" variable that is defined in the generated script. To make
		/// these paths absolute, specify the -absolute_path option.
		/// The command will also copy data files (if any) from the fileset, or from an IP, to the output
		/// directory. If the design contains "Verilog" sources, then the generated script will also copy "glbl.v"
		/// from the software installation path to the output directory.
		/// A default ".do" file will be created in the output directory for the target simulator that will be
		/// referred in the compiler commands in the script.
		/// Note: In order to perform simulation with the generated script, the simulation libraries must be compiled
		/// first using the compile_simlib command, with the compiled library directory path specified, when
		/// generating this script. The generated simulation script will automatically include the setup files for the
		/// target simulator from the compiled library directory.
		/// This command returns nothing.
		///
		/// The following command generates a simulation script file in the current directory for the "IES"
		/// simulator:
		/// export_simulation -simulator ies -directory .
		/// The following command overwrites an existing script file in the current directory:
		/// export_simulation -force -simulator ies -directory .
		/// The following command generates a simulation script file named test_ies.sh in the ./
		/// test_sim directory:
		/// export_simulation -simulator ies -directory ./test_sim \
		/// -script_name test_ies.sh
		/// The following command generates a script file named top_tb_sim_ies.sh in the ./
		/// test_sim directory for a project with simulation top set to "top_tb". The command will also
		/// copy any data files (.mif, .coe, .dat, etc) to the ./test_sim directory:
		/// export_simulation -simulator ies -directory ./test_sim
		/// The following command generates a script file accum_0_sim_ies.sh for the "accum_0" IP in
		/// the specified output directory for the "IES" simulator:
		/// export_simulation -of_objects [get_files accum_0.xci] \
		/// -simulator ies -directory test_sim
		/// The following command generates a script file accum_0_sim_vcs_mx.sh for the "accum_0" IP
		/// in the specified output directory for the "VCS_MX" simulator:
		/// export_simulation -of_objects [get_ips accum_0] -simulator vcs_mx \
		/// -directory test_sim
		/// The following command generates a script file fifo_tb_sim_vcs_mx.sh for the simulation
		/// fileset "sim_fifo_test" whose top is set to "fifo_tb" in the specified output directory for the "IES"
		/// simulator:
		/// export_simulation -of_objects [get_filesets sim_fifo_test] \
		/// -simulator ies -directory test_sim
		/// The following command exports a script file top_tb_sim_vcs_mx.sh for the "VCS_MX"
		/// simulator in the specified output directory with the design source files compiled for 32 bit
		/// version of the simulator compiler (no 64 bit option will be added to the command line):
		/// export_simulation -force -32bit -simulator vcs_mx -directory
		/// test_bft_vcs_mx
		/// The following example will include /sim_libs/ius/lin64/lib/cds.lib file path in the ./
		/// test_sim/cds.lib file ("INCLUDE /sim_libs/ius/lin64/lib/cds.lib") for referencing the
		/// compiled libraries for "IES" simulator:
		/// export_simulation -lib_map_path "/sim_libs/ius/lin64/lib" \
		/// -simulator ies -directory "test_sim"
		/// The following example will include /sim_libs/vcs/lin64/lib/synopsys_sim.setup file
		/// path in the ./test_sim/synopsys_sim.setup file ("OTHERS=/sim_libs/vcs/lin64/lib/
		/// synopsys_sim.setup") for refrencing the compiled libraries for the "VCS_MX" simulator:
		/// export_simulation -lib_map_path "/sim_libs/vcs/lin64/lib" \
		/// -simulator vcs_mx -directory "test_sim"
		/// The following example generates a script file in ./test_sim/ies directory and then compiles,
		/// elaborates and simulates the design in "IES" simulator:
		/// export_simulation -lib_map_path "/sim_libs/ies/lin64/lib" \
		/// -simulator ies -directory "./test_sim/ies"
		/// cd test_sim/ies
		/// ./top_tb_sim_ies.sh
		/// The following example generates a script file in ./test_sim/vcs_mx directory and then
		/// compile, elaborate and simulate the design in "VCS_MX" simulator:
		/// export_simulation -lib_map_path "/sim_libs/vcs/lin64/lib" \
		/// -simulator vcs_mx -directory "./test_sim/vcs_mx"
		/// cd test_sim/vcs_mx
		/// ./top_tb_sim_vcs_mx.sh
		///
		/// See ug835-vivado-tcl-commands.pdf, page 508
		/// </summary>
		/// <param name="simulator">
		/// (Optional)
		/// Simulator for which the simulation script will be created
		/// (value=all|xsim|modelsim|questa|ies|xceliu m|vcs|
		/// riviera|activehdl) Default: all
		/// </param>
		/// <param name="of_objects">(Optional) Export simulation script for the specified object Default: None</param>
		/// <param name="ip_user_files_dir">
		/// (Optional)
		/// Directory path to the exported IP/BD (Block Design) user
		/// files (for static, dynamic and data files) Default: Empty
		/// </param>
		/// <param name="ipstatic_source_dir">(Optional) Directory path to the exported IP/BD static files Default: Empty</param>
		/// <param name="lib_map_path">
		/// (Optional)
		/// Precompiled simulation library directory path. If not
		/// specified, then please follow the instructions in the
		/// generated script header to manually provide the simulation
		/// library mapping information. Default: Empty
		/// </param>
		/// <param name="script_name">
		/// (Optional)
		/// Output script filename. If not specified, then a file with a
		/// default name will be created. Default: top_module.sh
		/// </param>
		/// <param name="directory">
		/// (Optional)
		/// Directory where the simulation script will be generated
		/// Default: export_sim
		/// </param>
		/// <param name="runtime">
		/// (Optional)
		/// Run simulation for this time (default:full simulation run or
		/// until a logical break or finish condition) Default: Empty
		/// </param>
		/// <param name="define">
		/// (Optional)
		/// Read verilog defines from the list specified with this switch
		/// Default: Empty
		/// </param>
		/// <param name="generic">
		/// (Optional)
		/// Read vhdl generics from the list specified with this switch
		/// Default: Empty
		/// </param>
		/// <param name="include">
		/// (Optional)
		/// Read include directory paths from the list specified with this
		/// switch Default: Empty
		/// </param>
		/// <param name="use_ip_compiled_libs">
		/// (Optional)
		/// Reference pre-compiled IP static library during compilation.
		/// This switch requires -ip_user_files_dir and -
		/// ipstatic_source_dir switches as well for generating scripts
		/// using pre-compiled IP library.
		/// Name Description
		/// </param>
		/// <param name="absolute_path">(Optional) Make all file paths absolute</param>
		/// <param name="export_source_files">(Optional) Copy IP/BD design files to output directory</param>
		/// <param name="_32bit">(Optional) Perform 32bit compilation</param>
		/// <param name="force">(Optional) Overwrite previous files</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>None</returns>
		public virtual SimpleTCLCommand export_simulation(string simulator = null, string of_objects = null, string ip_user_files_dir = null, string ipstatic_source_dir = null, string lib_map_path = null, string script_name = null, string directory = null, string runtime = null, string define = null, string generic = null, string include = null, bool? use_ip_compiled_libs = null, bool? absolute_path = null, bool? export_source_files = null, bool? _32bit = null, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: export_simulation [-simulator <arg>] [-of_objects <arg>] [-ip_user_files_dir <arg>] [-ipstatic_source_dir <arg>] [-lib_map_path <arg>] [-script_name <arg>] [-directory <arg>] [-runtime <arg>] [-define <arg>] [-generic <arg>] [-include <arg>] [-use_ip_compiled_libs] [-absolute_path] [-export_source_files] [-32bit] [-force] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("export_simulation")
					.OptionalNamedString("simulator", simulator)
					.OptionalNamedString("of_objects", of_objects)
					.OptionalNamedString("ip_user_files_dir", ip_user_files_dir)
					.OptionalNamedString("ipstatic_source_dir", ipstatic_source_dir)
					.OptionalNamedString("lib_map_path", lib_map_path)
					.OptionalNamedString("script_name", script_name)
					.OptionalNamedString("directory", directory)
					.OptionalNamedString("runtime", runtime)
					.OptionalNamedString("define", define)
					.OptionalNamedString("generic", generic)
					.OptionalNamedString("include", include)
					.Flag("use_ip_compiled_libs", use_ip_compiled_libs)
					.Flag("absolute_path", absolute_path)
					.Flag("export_source_files", export_source_files)
					.Flag("32bit", _32bit)
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Extract files from a core container to disk
		///
		///
		/// TCL Syntax: extract_files [-base_dir <arg>] [-force] [-no_ip_dir] [-no_paths] [-quiet] [-verbose] <files>...
		///
		/// Extract the files from an IP in core container format.
		/// The core container format for IP is a compressed zip file that reduces the file structure in the
		/// design, and increases tool performance.
		/// This command returns a list of files extracted from the core container IP, or returns an error if it
		/// fails.
		///
		/// The following example extracts the files from the specified core container format IP to the
		/// specified base directory:
		/// extract_files -base_dir C:/Data [get_files char_fifo.xcix]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 513
		/// </summary>
		/// <param name="files">(Required) Name of the file(s) to be extracted</param>
		/// <param name="base_dir">(Optional) Base directory for extracted files Default: ip_files</param>
		/// <param name="force">(Optional) Overwrite existing files</param>
		/// <param name="no_ip_dir">(Optional) Don't include the IP dir as part of the extract directory</param>
		/// <param name="no_paths">(Optional) Don't include directories when extracting files</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of files that were extracted with the new paths</returns>
		public virtual SimpleTCLCommand extract_files(string files, string base_dir = null, bool? force = null, bool? no_ip_dir = null, bool? no_paths = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: extract_files [-base_dir <arg>] [-force] [-no_ip_dir] [-no_paths] [-quiet] [-verbose] <files>...
			return
				new SimpleTCLCommand("extract_files")
					.OptionalNamedString("base_dir", base_dir)
					.Flag("force", force)
					.Flag("no_ip_dir", no_ip_dir)
					.Flag("no_paths", no_paths)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(files)
			;
		}
		/// <summary>
		/// Filter a list, resulting in new list
		///
		///
		/// TCL Syntax: filter [-regexp] [-nocase] [-quiet] [-verbose] [<objects>] [<filter>]
		///
		/// Takes a list of objects, and returns a reduced list of objects that match the specified filter search
		/// pattern.
		///
		/// The following example returns a list of parts filtered for the specified speed grade:
		/// filter [get_parts] {speed == -3}
		/// The following example filters parts based according to speed grade -3 OR speed grade -2. All
		/// parts matching either speed grade will be returned.
		/// filter [get_parts] {speed == -3 || speed == -2}
		/// The following example uses regular expression and returns a list of VStatus ports in the design,
		/// with zero or more wildcards, and the numbers 0 to 9 appearing one or more times within square
		/// brackets:
		/// filter -regexp [get_ports] {NAME =~ VStatus.*\[[0-9]+\]}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 515
		/// </summary>
		/// <param name="regexp">(Optional) Operators =~ and !~ use regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">(Optional) List of objects to filter</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <returns>new list</returns>
		public virtual SimpleTCLCommand filter(bool? regexp = null, bool? nocase = null, bool? quiet = null, bool? verbose = null, string objects = null, string filter = null)
		{
			// TCL Syntax: filter [-regexp] [-nocase] [-quiet] [-verbose] [<objects>] [<filter>]
			return
				new SimpleTCLCommand("filter")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(objects)
					.OptionalString(filter)
			;
		}
		/// <summary>
		/// Find a list of pins, ports or interfaces with a given relationship to the given object.
		///
		///
		/// TCL Syntax: find_bd_objs -relation <arg> [-boundary_type <arg>] [-thru_hier] [-stop_at_interconnect] [-end_type <arg>] [-quiet] [-verbose] <objects>...
		///
		/// Find a list of pins, ports or interfaces with a given relationship to the specified objects.
		/// This command returns a list of pins, ports or interface objects if successful, or returns an error if
		/// it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 518
		/// </summary>
		/// <param name="relation">
		/// (Required)
		/// Relation to the input objs: connected_to, addressable_slave,
		/// addressing_master. 'connected_to' will find corresponding
		/// pins, ports or interfaces that are connected to the given
		/// source objects, across hierarchy boundaries.
		/// </param>
		/// <param name="objects">(Required) One or more source object to start finding from</param>
		/// <param name="boundary_type">
		/// (Optional)
		/// Used when source object is an hierarchical block's pin or
		/// interface pin. Valid values are empty string for same level
		/// (default), 'lower', or 'all'. If 'lower' boundary, searches from
		/// within hierarchy. This option is only valid for relation:
		/// connected_to
		/// </param>
		/// <param name="thru_hier">
		/// (Optional)
		/// Flag used to ignore boundary of hierarchical blocks. If used
		/// used with boundary_type 'lower', flag will only affect the
		/// hierarchical blocks within parent hierarchical block.
		/// </param>
		/// <param name="stop_at_interconnect">
		/// (Optional)
		/// Flag used to stop at the axi_interconnect's boundary when -
		/// thru_hier is used.
		/// </param>
		/// <param name="end_type">
		/// (Optional)
		/// Only to be used with objects that are pins or ports and bus
		/// interface pins or ports. For pins/ports - Default is to return
		/// the sink objects for a given source object and to return the
		/// source object for a given sink object. If 'all' is used for a
		/// given sink object, will return both source and other sink
		/// objectst that are connected to the source object. For bus
		/// interface pins/ports - Default is to return the end
		/// connection that is non-monitor interfaces. If 'monitor' is
		/// used, will only return the monitor interfaces. If 'all' is used,
		/// will return both end connection and monitor interfaces. This
		/// option is only valid for relation: connected_to
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>List of pins, ports or interface objects, "" if failed.</returns>
		public virtual SimpleTCLCommand find_bd_objs(string relation, string objects, string boundary_type = null, bool? thru_hier = null, bool? stop_at_interconnect = null, string end_type = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: find_bd_objs -relation <arg> [-boundary_type <arg>] [-thru_hier] [-stop_at_interconnect] [-end_type <arg>] [-quiet] [-verbose] <objects>...
			return
				new SimpleTCLCommand("find_bd_objs")
					.RequiredNamedString("relation", relation)
					.OptionalNamedString("boundary_type", boundary_type)
					.Flag("thru_hier", thru_hier)
					.Flag("stop_at_interconnect", stop_at_interconnect)
					.OptionalNamedString("end_type", end_type)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Find a routing path between two nodes.
		///
		///
		/// TCL Syntax: find_routing_path [-allow_overlap] [-max_nodes <arg>] [-min_nodes <arg>] [-from <args>] [-to <args>] [-quiet] [-verbose]
		///
		/// Finds a routing solution between two nodes on an unrouted, or partially routed net, in an
		/// implemented design.
		/// This command can be used to define a routing path to assign to the FIXED_ROUTE property of a
		/// net, which can be saved to the XDC file for later reuse. Refer to Vivado Design Suite Tutorial:
		/// Implementation (UG986) for an example of manual routing and the use of the FIXED_ROUTE
		/// property.
		/// You must define nodes for the start and end points of the routing path, and can specify the
		/// maximum and minimum number of nodes to use for the route path, including the start and end
		/// points. The nodes must be specified as objects returned by the get_nodes command. For
		/// unrouted net objects, since nodes have not been assigned to the net, the nodes can be found by
		/// association of the net to the bel_pin or site_pin:
		/// • Net > Bel_Pin > Bel > Tile > Node
		/// • Net > Site_Pin > Tile > Node
		/// For partially routed nets, the nodes can be found associated directly to the net. Refer to the
		/// Vivado Design Suite Properties Reference Guide (UG912) for more information on the relationship
		/// between these objects.
		/// The find_routing_path command returns a list of nodes representing the route path found
		/// from the start point to the end point, or returns "no path found" if the command runs but has no
		/// result, or returns an error if the command fails to run.
		/// The returned list of nodes can be assigned to the FIXED_ROUTE property using the
		/// set_property command as shown in the example.
		/// TIP: The report_property command does not return the string of the FIXED_ROUTE property. Use the
		/// get_property command instead.
		///
		/// The following example finds a routing path for the specified net, using one end as the -from
		/// point and the other end as the -to point, and assigns that path to the specified Tcl variable. Then
		/// it uses that Tcl variable to assign the path to the FIXED_ROUTE property of the net:
		/// set fndPath [find_routing_path -from [lindex [get_nodes -of \
		/// [get_site_pins -of [get_nets wbOutputData_OBUF[14]]]] 0] -to \
		/// [lindex [get_nodes -of [get_site_pins -of \
		/// [get_nets wbOutputData_OBUF[14]]]] 1]]
		/// set_property FIXED_ROUTE $fndPath [get_nets wbOutputData_OBUF[14]]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 521
		/// </summary>
		/// <param name="allow_overlap">(Optional) Solution may include nodes used in existing routes.</param>
		/// <param name="max_nodes">
		/// (Optional)
		/// Specifies the maximum number of nodes (including from
		/// and to nodes) allowed in solution. Default: 100
		/// </param>
		/// <param name="min_nodes">
		/// (Optional)
		/// Specifies the minimum number of nodes (including from
		/// and to nodes) allowed in solution. Default: 2
		/// </param>
		/// <param name="from">(Optional) -from <start node> Start of routing path.</param>
		/// <param name="to">(Optional) -to <end node> End of routing path.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand find_routing_path(bool? allow_overlap = null, string max_nodes = null, string min_nodes = null, string from = null, string to = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: find_routing_path [-allow_overlap] [-max_nodes <arg>] [-min_nodes <arg>] [-from <args>] [-to <args>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("find_routing_path")
					.Flag("allow_overlap", allow_overlap)
					.OptionalNamedString("max_nodes", max_nodes)
					.OptionalNamedString("min_nodes", min_nodes)
					.OptionalNamedString("from", from)
					.OptionalNamedString("to", to)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Find top module candidates in the supplied files, fileset, or active fileset. Returns a rank ordered
		/// list of candidates.
		///
		///
		/// TCL Syntax: find_top [-fileset <arg>] [-files <args>] [-return_file_paths] [-quiet] [-verbose]
		///
		/// Find the most likely candidates for the top module in the files defined in the current fileset, or in
		/// the specified fileset, or in the specified list of files.
		/// The command returns an ordered list of modules that the tool identifies as the best candidates
		/// for the top-level of the design. You can use the lindex command, and choose index 0 to select
		/// the best candidate for the top module.
		///
		/// The following example chooses the best top module of the current design for synthesis:
		/// synth_design -top [lindex [find_top] 0]
		/// Note: Since find_top returns multiple possible candidates, choosing index 0 chooses the best top
		/// candidate for synthesis.
		/// The following example returns the best top module candidate from the specified list of files:
		/// find_top -files [get_files -filter {NAME =~ *or1200*}]
		/// The following example sets the results of find_top into the variable $topVar, then uses that
		/// variable to define the top module in the current fileset using the set_property command:
		/// set topVar [ find_top -files [get_files -filter {NAME =~ *usbf*} ] ]
		/// usbf_top
		/// set_property top $topVar [current_fileset]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 524
		/// </summary>
		/// <param name="fileset">(Optional) Fileset to parse to search for top candidates</param>
		/// <param name="files">(Optional) Files to parse to search for top candidates</param>
		/// <param name="return_file_paths">
		/// (Optional)
		/// For each top returned, also include the associated file path.
		/// The returned value will be a single list of strings, alternating
		/// top names and file paths.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand find_top(string fileset = null, string files = null, bool? return_file_paths = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: find_top [-fileset <arg>] [-files <args>] [-return_file_paths] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("find_top")
					.OptionalNamedString("fileset", fileset)
					.OptionalNamedString("files", files)
					.Flag("return_file_paths", return_file_paths)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Flush VCD simulation output to the VCD output file (equivalent of $dumpflush verilog system
		/// task)
		///
		///
		/// TCL Syntax: flush_vcd [-quiet] [-verbose]
		///
		/// Flush HDL signal information currently in memory into the specified Value Change Dump (VCD)
		/// file.
		/// VCD is an ASCII file containing header information, variable definitions, and the value change
		/// details of a set of HDL signals. The VCD file can be used to view simulation results in a VCD
		/// viewer, or to estimate the power consumption of the design.
		/// Note: You must run the open_vcd command to open a VCD file to write to before using the flush_vcd
		/// command.
		///
		/// The following example flushes the VCD buffer into the current VCD file:
		/// flush_vcd
		///
		/// See ug835-vivado-tcl-commands.pdf, page 526
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand flush_vcd(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: flush_vcd [-quiet] [-verbose]
			return
				new SimpleTCLCommand("flush_vcd")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Generate a base platform based on a given routed checkpoint
		///
		///
		/// TCL Syntax: generate_base_platform [-source <arg>] [-reconfig_platform <arg>] [-base_platform <arg>] [-reconfig_platform_prefix <arg>] [-quiet] [-verbose]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 528
		/// </summary>
		/// <param name="source">(Optional) (Required) Specify routed checkpoint path</param>
		/// <param name="reconfig_platform">(Optional) (Required) Specify reconfigurable platform module name</param>
		/// <param name="base_platform">
		/// (Optional)
		/// (Optional) Specify the output file name, the default file
		/// name is 'base_platform'
		/// </param>
		/// <param name="reconfig_platform_prefix">
		/// (Optional)
		/// (Optional) Specify wrapper port name prefix from
		/// reconfigurable platform module, the default prefix is 'RL_'
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand generate_base_platform(string source = null, string reconfig_platform = null, string base_platform = null, string reconfig_platform_prefix = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: generate_base_platform [-source <arg>] [-reconfig_platform <arg>] [-base_platform <arg>] [-reconfig_platform_prefix <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("generate_base_platform")
					.OptionalNamedString("source", source)
					.OptionalNamedString("reconfig_platform", reconfig_platform)
					.OptionalNamedString("base_platform", base_platform)
					.OptionalNamedString("reconfig_platform_prefix", reconfig_platform_prefix)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Write all the simulation .mem files.
		///
		///
		/// TCL Syntax: generate_mem_files [-force] [-quiet] [-verbose] <directory>
		///
		/// For embedded processor based designs, with associated Executable Linkable Files (ELF) from the
		/// Software Development Kit (SDK), this command merges the Block Memory Map (BMM) for the
		/// design with the program data in the ELF file to generate memory (MEM) files for use during
		/// simulation.
		/// The MEM file is a text file that describes how individual Block RAMs on the Xilinx device are
		/// grouped together to form a contiguous address space called an Address Block, with the ELF data
		/// mapped into the memory.
		/// The file names and the number of MEM files generated is determined by the memory map data
		/// specified by the processor system IP cores, or IP integrator block designs.
		/// This command returns the directory where the MEM files are written, or returns an error if it
		/// fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 529
		/// </summary>
		/// <param name="directory">
		/// (Required)
		/// Directory for exporting .mem files. Values: A directory with
		/// alphanumeric characters.
		/// </param>
		/// <param name="force">(Optional) Overwrite existing .mem files</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The name of the directory</returns>
		public virtual SimpleTCLCommand generate_mem_files(string directory, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: generate_mem_files [-force] [-quiet] [-verbose] <directory>
			return
				new SimpleTCLCommand("generate_mem_files")
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(directory)
			;
		}
		/// <summary>
		/// Generate PBLOCK by exclude static
		///
		///
		/// TCL Syntax: generate_pblock [-cell <arg>] [-inverse_pblock <arg>] [-nested_pblock <arg>] [-nested_width <arg>] [-quiet] [-verbose]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 531
		/// </summary>
		/// <param name="cell">(Optional) Specify cell to add to pblock.</param>
		/// <param name="inverse_pblock">
		/// (Optional)
		/// Specify name of the inverse pblock. The pblock will cover
		/// everything that the static pblock does not.
		/// </param>
		/// <param name="nested_pblock">
		/// (Optional)
		/// Specify name of nested pblock inside inverse_pblock left
		/// adjacent to static pblock.
		/// </param>
		/// <param name="nested_width">
		/// (Optional)
		/// Specify the width of the nested pblock. The nested pblock
		/// height is the same as the adjacent static pblock. Default: 3
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand generate_pblock(string cell = null, string inverse_pblock = null, string nested_pblock = null, string nested_width = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: generate_pblock [-cell <arg>] [-inverse_pblock <arg>] [-nested_pblock <arg>] [-nested_width <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("generate_pblock")
					.OptionalNamedString("cell", cell)
					.OptionalNamedString("inverse_pblock", inverse_pblock)
					.OptionalNamedString("nested_pblock", nested_pblock)
					.OptionalNamedString("nested_width", nested_width)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Generate output products for peripheral object.
		///
		///
		/// TCL Syntax: generate_peripheral [-driver] [-example_design] [-bfm_example_design] [-debug_hw_example_design] [-enable_interrupt] [-force] [-quiet] [-verbose] <peripheral>
		///
		/// Generate the output products for the specified peripheral object. The output products are
		/// written to the IP repository location specified when the IP is created by the
		/// create_peripheral command, under the name of the IP as specified at creation.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 532
		/// </summary>
		/// <param name="peripheral">(Required) peripheral object</param>
		/// <param name="driver">(Optional) Generate driver for peripheral.</param>
		/// <param name="example_design">(Optional) Generate all supported example designs for peripheral.</param>
		/// <param name="bfm_example_design">(Optional) Generate bfm simulation example design for peripheral.</param>
		/// <param name="debug_hw_example_design">(Optional) Generate debug hardware example design for peripheral.</param>
		/// <param name="enable_interrupt">(Optional) Generate peripheral with interrupt suppport.</param>
		/// <param name="force">(Optional) Overwrite the existing IP in the repository.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand generate_peripheral(string peripheral, bool? driver = null, bool? example_design = null, bool? bfm_example_design = null, bool? debug_hw_example_design = null, bool? enable_interrupt = null, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: generate_peripheral [-driver] [-example_design] [-bfm_example_design] [-debug_hw_example_design] [-enable_interrupt] [-force] [-quiet] [-verbose] <peripheral>
			return
				new SimpleTCLCommand("generate_peripheral")
					.Flag("driver", driver)
					.Flag("example_design", example_design)
					.Flag("bfm_example_design", bfm_example_design)
					.Flag("debug_hw_example_design", debug_hw_example_design)
					.Flag("enable_interrupt", enable_interrupt)
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(peripheral)
			;
		}
		/// <summary>
		/// Generate a set of configurable report objects
		///
		///
		/// TCL Syntax: generate_reports [-jobs <arg>] [-quiet] [-verbose] <report_configs>...
		///
		/// Generates specified report objects as created by the create_report_config command.
		/// Because the report objects are associated with specific steps of synthesis or implementation
		/// runs, those steps must be completed prior to the generation of the report. If a step is not
		/// completed, or the report is not enabled, then the generate_report command will return an
		/// error.
		///
		/// The following example generates the specified report object:
		/// generate_report [get_report_configs post_route_datasheet]
		/// TIP: If the report is already GENERATED according to the STATE property, the report will not be regenerated.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 535
		/// </summary>
		/// <param name="report_configs">(Required) List of configurable report objects to generate</param>
		/// <param name="jobs">(Optional) Number of jobs Default: 1</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand generate_reports(string report_configs, string jobs = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: generate_reports [-jobs <arg>] [-quiet] [-verbose] <report_configs>...
			return
				new SimpleTCLCommand("generate_reports")
					.OptionalNamedString("jobs", jobs)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(report_configs)
			;
		}
		/// <summary>
		/// Generate new platform based on base platform and wrapper module
		///
		///
		/// TCL Syntax: generate_rl_platform [-use_source <arg>] [-reconfig_platform <arg>] [-base_platform <arg>] [-platform <arg>] [-quiet] [-verbose]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 537
		/// </summary>
		/// <param name="use_source">(Optional) Specify wrapper checkpoint path</param>
		/// <param name="reconfig_platform">(Optional) (Required) Specify reconfigurable platform module name</param>
		/// <param name="base_platform">(Optional) (Required) Specify base platform checkpoint path</param>
		/// <param name="platform">
		/// (Optional)
		/// (Optional) Specify new platform checkpoint path, the default
		/// file name is 'rl_platform.dcp'
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand generate_rl_platform(string use_source = null, string reconfig_platform = null, string base_platform = null, string platform = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: generate_rl_platform [-use_source <arg>] [-reconfig_platform <arg>] [-base_platform <arg>] [-platform <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("generate_rl_platform")
					.OptionalNamedString("use_source", use_source)
					.OptionalNamedString("reconfig_platform", reconfig_platform)
					.OptionalNamedString("base_platform", base_platform)
					.OptionalNamedString("platform", platform)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Move HD.RECONFIGURABLE and related properties to sub-cells
		///
		///
		/// TCL Syntax: generate_shx_platform [-base_platform <arg>] [-wrapper <arg>] [-output <arg>] [-reconfig_platform <arg>] [-quiet] [-verbose]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 538
		/// </summary>
		/// <param name="base_platform">(Optional) Specify Base Platform DCP path.</param>
		/// <param name="wrapper">(Optional) Specify wrapper DCP path</param>
		/// <param name="output">(Optional) Specify output DCP name.</param>
		/// <param name="reconfig_platform">(Optional) Specify reconfigurable platform name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand generate_shx_platform(string base_platform = null, string wrapper = null, string output = null, string reconfig_platform = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: generate_shx_platform [-base_platform <arg>] [-wrapper <arg>] [-output <arg>] [-reconfig_platform <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("generate_shx_platform")
					.OptionalNamedString("base_platform", base_platform)
					.OptionalNamedString("wrapper", wrapper)
					.OptionalNamedString("output", output)
					.OptionalNamedString("reconfig_platform", reconfig_platform)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Generate target data for the specified source
		///
		///
		/// TCL Syntax: generate_target [-force] [-quiet] [-verbose] <name> <objects>
		///
		/// This command generates target data for the specified IP objects (get_ips) or source file for IP
		/// cores (.xci and .xco), DSP modules (.slx or .mdl), or block designs (.bd). The target data
		/// that is generated are the files necessary to support the IP or block design through the FPGA
		/// design flow.
		/// The instantiation template, synthesis netlist, and simulation netlist are standard targets. However,
		/// each IP in the catalog may also support its own set of targets. You can view the available targets
		/// on an object by examining the SUPPORTED_TARGETS property, or you can use the
		/// list_targets command to list the targets for design source file.
		///
		/// This example generates the change log for all of the IP cores in the current project, forcing
		/// regeneration of any targets that are up-to-date:
		/// generate_target changelog [get_ips] -force
		/// The following example generates the instantiation template and synthesis targets for all of the IP
		/// cores in the current project:
		/// generate_target {instantiation_template synthesis} [get_ips]
		/// TIP: Note the use of the braces to pass the list of targets to the command. The absence of the -force option
		/// means that only out-of-date targets will be regenerated.
		/// The following example generates all targets for the specified block design:
		/// generate_target all \
		/// [get_files C:/Data/project_mb/project_mb.srcs/sources_1/bd/base_mb/
		/// base_mb.bd]
		/// IMPORTANT! The use of get_ips is not supported to generate targets for individual IP within block designs.
		/// The tool will return an error.
		/// The following queries the SUPPORTED_TARGETS property of the specified IP object, and then
		/// generates the example project for the IP:
		/// get_property SUPPORTED_TARGETS [get_ips blk_mem*]
		/// open_example_project -dir C:/Data/examples -force [get_ips blk_mem*]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 539
		/// </summary>
		/// <param name="name">
		/// (Required)
		/// List of targets to be generated, or 'all' to generate all
		/// supported targets
		/// </param>
		/// <param name="objects">(Required) The objects for which data needs to be generated</param>
		/// <param name="force">(Optional) Force target data regeneration</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand generate_target(string name, string objects, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: generate_target [-force] [-quiet] [-verbose] <name> <objects>
			return
				new SimpleTCLCommand("generate_target")
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Get a list of segments
		///
		///
		/// TCL Syntax: get_bd_addr_segs [-regexp] [-hierarchical] [-filter <arg>] [-of_objects <args>] [-excluded] [-addressed] [-unaddressed] [-addressing] [-addressables] [-quiet] [-verbose] [<patterns>]
		///
		/// Get a list of address segments in the current IP integrator subsystem design.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example gets the address segments of the specified address spaces:
		/// get_bd_addr_segs -of_objects [get_bd_addr_spaces -of_objects \
		/// [get_bd_cells /microblaze_1]]
		/// /microblaze_1/Data/SEG1
		/// /microblaze_1/Data/SEG3
		/// /microblaze_1/Instruction/SEG2
		/// Note: If there are no objects matching the pattern you will get a warning.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 542
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="hierarchical">(Optional) Hierarchical cells included</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get segments of these segments, interfaces, or registers</param>
		/// <param name="excluded">(Optional) Get excluded mapped segments -of_objects</param>
		/// <param name="addressed">(Optional) Get addressed segments of given -of_objects</param>
		/// <param name="unaddressed">(Optional) Get unaddressed segments of given objects</param>
		/// <param name="addressing">(Optional) Get addressing segments of given -of_objects</param>
		/// <param name="addressables">(Optional) Get addressable segments of given -of_objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match engine names against patterns Default: *</param>
		/// <returns>List of segment objects, "" if failed.</returns>
		public virtual SimpleTCLCommand get_bd_addr_segs(bool? regexp = null, bool? hierarchical = null, string filter = null, string of_objects = null, bool? excluded = null, bool? addressed = null, bool? unaddressed = null, bool? addressing = null, bool? addressables = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_bd_addr_segs [-regexp] [-hierarchical] [-filter <arg>] [-of_objects <args>] [-excluded] [-addressed] [-unaddressed] [-addressing] [-addressables] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_bd_addr_segs")
					.Flag("regexp", regexp)
					.Flag("hierarchical", hierarchical)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("excluded", excluded)
					.Flag("addressed", addressed)
					.Flag("unaddressed", unaddressed)
					.Flag("addressing", addressing)
					.Flag("addressables", addressables)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of addr_spaces
		///
		///
		/// TCL Syntax: get_bd_addr_spaces [-regexp] [-hierarchical] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Get a list of address spaces in the current IP integrator subsystem design.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example lists all of the address spaces in the current IP integrator subsystem
		/// design, listing one per line:
		/// join [get_bd_addr_spaces] \n
		/// /mdm_1/S_AXI
		/// /microblaze_1/Data
		/// /microblaze_1/Instruction
		/// /microblaze_1_axi_intc/s_axi
		/// /microblaze_1_local_memory/dlmb_bram_if_cntlr/SLMB
		/// /microblaze_1_local_memory/dlmb_bram_if_cntlr/SLMB1
		/// /microblaze_1_local_memory/dlmb_bram_if_cntlr/SLMB2
		/// /microblaze_1_local_memory/dlmb_bram_if_cntlr/SLMB3
		/// /microblaze_1_local_memory/dlmb_bram_if_cntlr/S_AXI_CTRL
		/// /microblaze_1_local_memory/ilmb_bram_if_cntlr/SLMB
		/// /microblaze_1_local_memory/ilmb_bram_if_cntlr/SLMB1
		/// /microblaze_1_local_memory/ilmb_bram_if_cntlr/SLMB2
		/// /microblaze_1_local_memory/ilmb_bram_if_cntlr/SLMB3
		/// /microblaze_1_local_memory/ilmb_bram_if_cntlr/S_AXI_CTRL
		/// /microblaze_1_local_memory/lmb_bram/S_1
		/// Note: If there are no objects matching the pattern you will get a warning.
		/// The following example returns all of the properties attached to the third in a list, or index 2, of all
		/// address spaces in the current subsystem design:
		/// report_property -all [lindex [get_bd_addr_spaces] 2 ]
		/// Property Type Read-only Visible Value
		/// CLASS string true true bd_addr_space
		/// NAME string false true /microblaze_1/Instruction
		/// OFFSET string false true
		/// PATH string true true /microblaze_1/Instruction
		/// RANGE string false true -1
		/// TYPE string false true
		///
		/// See ug835-vivado-tcl-commands.pdf, page 546
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="hierarchical">(Optional) Hierarchical cells included</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get addr_spaces of these segments or interfaces</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match engine names against patterns Default: *</param>
		/// <returns>List of addr_space objects, "" if failed.</returns>
		public virtual SimpleTCLCommand get_bd_addr_spaces(bool? regexp = null, bool? hierarchical = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_bd_addr_spaces [-regexp] [-hierarchical] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_bd_addr_spaces")
					.Flag("regexp", regexp)
					.Flag("hierarchical", hierarchical)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of block diagram cells
		///
		///
		/// TCL Syntax: get_bd_cells [-regexp] [-hierarchical] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Get a list of cells in the current IP integrator subsystem design, or current subsystem instance. IP
		/// integrator subsystem cells are either IP cores drawn from the IP integrator catalog, or hierarchical
		/// modules created in the subsystem design with the create_bd_cell command.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example gets a list of cells that include the specified IP integrator subsystem pin,
		/// and sorts the list to remove duplicate entries:
		/// lsort -unique [get_bd_cells -of_objects [get_bd_pins -hierarchical *aclk*]]
		/// Note: If there are no cells matching the pattern you will get a warning.
		/// The following example gets a list of all cells in all levels of the subsystem design hierarchy, and
		/// then filters the list to include only those cells whose name includes the specified text, or
		/// hierarchy:
		/// get_bd_cells -hierarchical -filter {NAME=~"/newMod1/*"}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 550
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="hierarchical">(Optional) Hierarchical cells included</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get cells of these pins or nets</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match engine names against patterns Default: *</param>
		/// <returns>List of block diagram cell objects, "" if failed.</returns>
		public virtual SimpleTCLCommand get_bd_cells(bool? regexp = null, bool? hierarchical = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_bd_cells [-regexp] [-hierarchical] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_bd_cells")
					.Flag("regexp", regexp)
					.Flag("hierarchical", hierarchical)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of designs
		///
		///
		/// TCL Syntax: get_bd_designs [-regexp] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
		///
		/// Gets a list of IP subsystem designs open in the current project that match a specified search
		/// pattern. The default command gets a list of all open IP subsystem designs in the project.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example gets all open IP subsystem designs in the current project:
		/// get_bd_designs
		///
		/// See ug835-vivado-tcl-commands.pdf, page 554
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get diagrams of these bd-cells or pins or nets</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match engine names against patterns Default: *</param>
		/// <returns>List of design objects, "" if failed.</returns>
		public virtual SimpleTCLCommand get_bd_designs(bool? regexp = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_bd_designs [-regexp] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
			return
				new SimpleTCLCommand("get_bd_designs")
					.Flag("regexp", regexp)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of intf_nets
		///
		///
		/// TCL Syntax: get_bd_intf_nets [-regexp] [-hierarchical] [-filter <arg>] [-boundary_type <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of interface nets in the current IP integrator subsystem design that match a specified
		/// search pattern. The default command gets a list of all interface nets in the subsystem design.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example gets the interface net attached to the specified pin of an IP integrator
		/// hierarchical module, and returns both the net at the level of the hierarchical module, and the net
		/// inside the hierarchical module:
		/// get_bd_intf_nets -boundary_type both -of_objects [get_bd_pins /newMod1/
		/// aclk]
		/// Note: If there are no interface nets matching the pattern you will get a warning.
		/// The following example returns a list of all interface nets at all levels of the IP integrator
		/// subsystem design hierarchy:
		/// get_bd_intf_nets -hierarchical
		///
		/// See ug835-vivado-tcl-commands.pdf, page 557
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="hierarchical">(Optional) Hierarchical cells included</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="boundary_type">
		/// (Optional)
		/// Used when source object is on a hierarchical block's
		/// interface pin. Valid values are 'upper', 'lower', or 'both'. If
		/// 'lower' boundary, searches from the lower level of hierarchy
		/// onwards. This option is only valid for connected_to relations.
		/// Default: upper
		/// </param>
		/// <param name="of_objects">
		/// (Optional)
		/// One or a list of cells or interface pins/ports objects. List
		/// must be of one object type.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match engine names against patterns Default: *</param>
		/// <returns>List of pin objects, "" if failed.</returns>
		public virtual SimpleTCLCommand get_bd_intf_nets(bool? regexp = null, bool? hierarchical = null, string filter = null, string boundary_type = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_bd_intf_nets [-regexp] [-hierarchical] [-filter <arg>] [-boundary_type <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_bd_intf_nets")
					.Flag("regexp", regexp)
					.Flag("hierarchical", hierarchical)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("boundary_type", boundary_type)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of intf_pins
		///
		///
		/// TCL Syntax: get_bd_intf_pins [-regexp] [-hierarchical] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of interface pin objects on the current IP subsystem design that match a specified
		/// search pattern. The default command gets a list of all interface pins in the subsystem design.
		/// The external connections of an IP integrator cell, or hierarchical module, are pins and interface
		/// pins. The external connections in an IP subsystem design are ports, or interface ports. Use the
		/// get_bd_ports and get_bd_intf_ports commands to select the port objects.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example gets a list of interface pins attached to the specified cell:
		/// get_bd_intf_pins -of [get_bd_cells new_vidOut_1]
		/// Note: If there are no interface pins matching the pattern, the tool will return a warning.
		/// The following example gets a list of all interface pins, throughout the hierarchy of the IP
		/// integrator subsystem design, which match the specified name pattern:
		/// get_bd_intf_pins -hierarchical m_apb*
		/// The following example gets a list of interface pins attached to the specified subsystem net:
		/// get_bd_intf_pins -of [get_bd_intf_nets vidout_1_vtg_ce]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 561
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="hierarchical">(Optional) Hierarchical cells included</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// (Optional)
		/// One or a list of cells, interface nets or pins objects. List must
		/// be of one object type.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match engine names against patterns Default: *</param>
		/// <returns>List of pin objects, "" if failed.</returns>
		public virtual SimpleTCLCommand get_bd_intf_pins(bool? regexp = null, bool? hierarchical = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_bd_intf_pins [-regexp] [-hierarchical] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_bd_intf_pins")
					.Flag("regexp", regexp)
					.Flag("hierarchical", hierarchical)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of intf_ports
		///
		///
		/// TCL Syntax: get_bd_intf_ports [-regexp] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of interface port objects in the current IP integrator subsystem design that match a
		/// specified search pattern. The default command gets a list of all interface ports in the subsystem
		/// design.
		/// The external connections in an IP subsystem design are ports, or interface ports. The external
		/// connections in an IP integrator cell, or hierarchical module, are pins and interface pins. Use the
		/// get_bd_pins and get_bd_intf_pins commands to select the pin objects.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example gets the interface ports in the subsystem design that operate in Master
		/// mode:
		/// get_bd_intf_ports -filter {MODE=="master"}
		/// Note: If there are no interface ports matching the pattern, the tool will return a warning.
		/// This example returns the block design interface port that the specified bd_port is part of:
		/// get_bd_intf_ports -of [get_bd_ports sys_diff_clock_clk_n]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 565
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) One or a list of interface nets or ports objects.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match engine names against patterns Default: *</param>
		/// <returns>List of port objects, "" if failed.</returns>
		public virtual SimpleTCLCommand get_bd_intf_ports(bool? regexp = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_bd_intf_ports [-regexp] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_bd_intf_ports")
					.Flag("regexp", regexp)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of nets
		///
		///
		/// TCL Syntax: get_bd_nets [-regexp] [-hierarchical] [-filter <arg>] [-boundary_type <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of nets in the current IP integrator subsystem design that match a specified search
		/// pattern. The default command gets a list of all nets in the subsystem design.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example gets the net attached to the specified pin of an IP integrator hierarchical
		/// module, and returns both the net at the level of the hierarchical module, and the net inside the
		/// hierarchical module:
		/// get_bd_nets -boundary_type both -of_objects [get_bd_pins /newMod1/aclk]
		/// Note: If there are no nets matching the pattern you will get a warning.
		/// The following example returns a list of all nets at all levels of the IP integrator subsystem design
		/// hierarchy:
		/// get_bd_nets -hierarchical
		///
		/// See ug835-vivado-tcl-commands.pdf, page 568
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="hierarchical">(Optional) Hierarchical cells included</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="boundary_type">
		/// (Optional)
		/// Used when source object is on a hierarchical block's pin.
		/// Valid values are 'upper', 'lower', or 'both'. If 'lower'
		/// boundary, searches from the lower level of hierarchy
		/// onwards. This option is only valid for connected_to relations.
		/// Default: upper
		/// </param>
		/// <param name="of_objects">
		/// (Optional)
		/// One or a list of cells or pins/ports objects. List must be of
		/// one object type.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match engine names against patterns Default: *</param>
		/// <returns>List of pin objects, "" if failed.</returns>
		public virtual SimpleTCLCommand get_bd_nets(bool? regexp = null, bool? hierarchical = null, string filter = null, string boundary_type = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_bd_nets [-regexp] [-hierarchical] [-filter <arg>] [-boundary_type <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_bd_nets")
					.Flag("regexp", regexp)
					.Flag("hierarchical", hierarchical)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("boundary_type", boundary_type)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of pins
		///
		///
		/// TCL Syntax: get_bd_pins [-regexp] [-hierarchical] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of pin objects on the current IP subsystem design that match a specified search
		/// pattern. The default command gets a list of all pins in the subsystem design.
		/// The external connections in an IP integrator cell, or hierarchical module, are pins and interface
		/// pins. The external connections in an IP subsystem design are ports, or interface ports. Use the
		/// get_bd_ports and get_bd_intf_ports commands to select the port objects.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example gets a list of pins attached to the specified cell:
		/// get_bd_pins -of [get_bd_cells new_vidOut_1]
		/// Note: If there are no pins matching the pattern, the tool will return a warning.
		/// The following example gets a list of all pins, throughout the hierarchy of the IP integrator
		/// subsystem design, which match the specified name pattern:
		/// get_bd_pins -hierarchical LMB*
		/// The following example gets a list of pins attached to the specified subsystem net:
		/// get_bd_pins -of [get_bd_nets vidout_1_vtg_ce]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 572
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="hierarchical">(Optional) Hierarchical cells included</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// (Optional)
		/// One or a list of cells, nets or interface pins objects. List must
		/// be of one object type.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match engine names against patterns Default: *</param>
		/// <returns>List of pin objects, "" if failed.</returns>
		public virtual SimpleTCLCommand get_bd_pins(bool? regexp = null, bool? hierarchical = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_bd_pins [-regexp] [-hierarchical] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_bd_pins")
					.Flag("regexp", regexp)
					.Flag("hierarchical", hierarchical)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of ports
		///
		///
		/// TCL Syntax: get_bd_ports [-regexp] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of port objects in the current IP integrator subsystem design that match a specified
		/// search pattern. The default command gets a list of all ports in the subsystem design.
		/// The external connections in an IP subsystem design are ports, or interface ports. The external
		/// connections in an IP integrator cell, or hierarchical module, are pins and interface pins. Use the
		/// get_bd_pins and get_bd_intf_pins commands to select the pin objects.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example gets the ports connected to the specified IP subsystem net:
		/// get_bd_ports -of_objects [get_bd_nets bridge_1_apb_m]
		/// Note: If there are no ports matching the pattern, the tool will return a warning.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 576
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) One or a list of nets or interface ports objects.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match engine names against patterns Default: *</param>
		/// <returns>List of port objects, "" if failed.</returns>
		public virtual SimpleTCLCommand get_bd_ports(bool? regexp = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_bd_ports [-regexp] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_bd_ports")
					.Flag("regexp", regexp)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of registers
		///
		///
		/// TCL Syntax: get_bd_regs [-of_objects <args>] [-quiet] [-verbose]
		///
		/// Get a list of registers using the objects of address segments, interface pins, and external interface
		/// ports. The register objects will provide the register's display name and the memory offset
		/// address. There is no default behavior for this command as it requires the use of -of_objects
		/// argument with a valid value that is an object of the address segments, interface pins, or external
		/// interface ports. The command will get the registers directly from the address segment objects or
		/// from address segments associated with the specified interface pin or interface port objects.
		///
		/// The following example creates an external interface pin, assigns an address space, and then gets
		/// the registers associated with that address space:
		/// % create_bd_cell -type ip -vlnv xilinx.com:ip:axi_gpio:2.0 axi_gpio_0
		/// % make_bd_intf_pins_external [get_bd_intf_pins axi_gpio_0/S_AXI]
		/// % assign_bd_address
		/// % get_bd_addr_segs
		/// /axi_gpio_0/S_AXI/Reg /S_AXI_0/SEG_axi_gpio_0_Reg
		/// % set seg [get_bd_addr_segs /axi_gpio_0/S_AXI/Reg]
		/// /axi_gpio_0/S_AXI/Reg
		/// % get_bd_regs -of_objects $seg
		/// GPIO_DATA GPIO_TRI GPIO2_DATA GPIO2_TRI GIER IP_IER IP_ISR
		/// %set regs [get_bd_regs -of_objects $seg]
		/// GPIO_DATA GPIO_TRI GPIO2_DATA GPIO2_TRI GIER IP_IER IP_ISR
		/// % set reg [lindex $regs 0]
		/// GPIO_DATA
		/// % report_property $reg
		/// Property Type Read-only Visible Value
		/// CLASS string true true bd_reg
		/// DISPLAYNAME string true true Channel_1_GPIO_DATA
		/// NAME string true true GPIO_DATA
		/// OFFSET string true true 0x0
		///
		/// See ug835-vivado-tcl-commands.pdf, page 579
		/// </summary>
		/// <param name="of_objects">(Required) Get registers of segments, interface pins, external interface ports</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>List of register objects, "" if failed.</returns>
		public virtual SimpleTCLCommand get_bd_regs(string of_objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_bd_regs [-of_objects <args>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("get_bd_regs")
					.RequiredNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Get a list of bel_pins. If a design is loaded, gets the constructed site type bels.
		///
		///
		/// TCL Syntax: get_bel_pins [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Returns a list of pins on the specified BELs, or matching a specified search pattern.
		/// The default command gets a list of all pins on all BELs on the device.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example returns the pins of the specified BELs associated with the specified range
		/// of sites on the device:
		/// get_bel_pins -of_objects [get_bels -of_objects [get_sites \
		/// -range {SLICE_X0Y0 SLICE_X1Y1}] ]
		/// The following example returns the clock enable (CE) pins of all BELs on the device:
		/// get_bel_pins *CE
		///
		/// See ug835-vivado-tcl-commands.pdf, page 581
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get the bel_pin of these bels, sites, pins, or nets.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match bel_pin against patterns Default: *</param>
		/// <returns>bel_pin</returns>
		public virtual SimpleTCLCommand get_bel_pins(bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_bel_pins [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_bel_pins")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of bels. If a design is loaded, gets the constructed site type bels.
		///
		///
		/// TCL Syntax: get_bels [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-include_routing_bels] [-quiet] [-verbose] [<patterns>]
		///
		/// Basic Elements, or BELs, are building blocks of logic, such as flip-flops, LUTs, and carry logic, that
		/// make up a SLICE. This command returns a list of BELs on the target part that match a specified
		/// search pattern in an open design.
		/// The default command gets a list of all BELs on the device.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example returns the total number of BELs on the target part:
		/// llength [get_bels]
		/// The following example returns the BELs associated with the specified site:
		/// get_bels -of_objects [get_sites PHASER_IN_PHY_X0Y5]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 584
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get the bels of these slr, tiles, sites, cells, clock_regions or nets.</param>
		/// <param name="include_routing_bels">(Optional) Also look for and include matching rbels.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match bels against patterns Default: *</param>
		/// <returns>bels</returns>
		public virtual SimpleTCLCommand get_bels(bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, bool? include_routing_bels = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_bels [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-include_routing_bels] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_bels")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("include_routing_bels", include_routing_bels)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Gets the list of board bus net objects
		///
		///
		/// TCL Syntax: get_board_bus_nets [-regexp] [-nocase] [-all] [-filter <arg>] -of_objects <args> [-quiet] [-verbose] [<patterns>...]
		///
		/// Gets a list of individual connection bus nets of the specified connection bus object, or the board
		/// component or board component pin objects.
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite
		/// installation area, stores information regarding board attributes. The board provides a
		/// representation of the overall system that the Xilinx device is a part of, and can help define key
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.
		/// You can create custom boards by defining a custom Board Interface file, as described in the
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).
		/// Connection buses define the connections between the Xilinx device (part0) and other
		/// components on the board. Bus nets define individual connections of the connection bus.
		/// This command returns a list of connection bus nets, or returns an error if it fails.
		///
		/// The following example gets the connection bus nets associated with the specified component of
		/// the current board:
		/// get_board_bus_nets -of_objects [get_board_components {*iic_main*}]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 587
		/// </summary>
		/// <param name="of_objects">
		/// (Required)
		/// Get 'board_bus_net' objects of these types: 'board_bus
		/// board_component board_component_pin'.
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="all">(Optional) Returns all enabled as well as disabled buses</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// (Optional)
		/// match board net names against patterns Default: * Values:
		/// The default search pattern is the wildcard *, or .* when -
		/// regexp is specified.
		/// </param>
		/// <returns>list of bus nets in the board</returns>
		public virtual SimpleTCLCommand get_board_bus_nets(string of_objects, bool? regexp = null, bool? nocase = null, bool? all = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_board_bus_nets [-regexp] [-nocase] [-all] [-filter <arg>] -of_objects <args> [-quiet] [-verbose] [<patterns>...]
			return
				new SimpleTCLCommand("get_board_bus_nets")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.Flag("all", all)
					.OptionalNamedString("filter", filter)
					.RequiredNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Gets the list of board bus objects
		///
		///
		/// TCL Syntax: get_board_buses [-regexp] [-nocase] [-all] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
		///
		/// Gets a list of connection buses defined on the current board, as defined in the Board Interface
		/// file.
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite
		/// installation area, stores information regarding board attributes. The board provides a
		/// representation of the overall system that the Xilinx device is a part of, and can help define key
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.
		/// You can create custom boards by defining a custom Board Interface file, as described in the
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).
		/// Connection buses define the connections between the Xilinx device (part0) and other
		/// components on the board.
		/// This command returns a list of buses, or returns an error if it fails.
		///
		/// The following example gets the connection buses associated with the specified component of
		/// the current board:
		/// get_board_buses -of_objects [get_board_components sgmii]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 590
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="all">(Optional) Returns all enabled as well as disabled buses</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// (Optional)
		/// Get 'board_bus' objects of these types: 'board
		/// board_component board_bus_net'.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// (Optional)
		/// match board bus names against patterns Default: * Values:
		/// The default search pattern is the wildcard *, or .* when -
		/// regexp is specified.
		/// </param>
		/// <returns>list of buses in the board</returns>
		public virtual SimpleTCLCommand get_board_buses(bool? regexp = null, bool? nocase = null, bool? all = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_board_buses [-regexp] [-nocase] [-all] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
			return
				new SimpleTCLCommand("get_board_buses")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.Flag("all", all)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Gets the list of interfaces in the board components that implement busdef specified by VLNV
		///
		///
		/// TCL Syntax: get_board_component_interfaces [-regexp] [-nocase] [-all] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
		///
		/// Gets a list of interfaces defined on the components found on the current board, as defined in the
		/// Board Interface file.
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite
		/// installation area, stores information regarding board attributes. The board provides a
		/// representation of the overall system that the Xilinx device is a part of, and can help define key
		/// aspects of the design, such as clock constraints, I/O port assignments, defined components and
		/// supported interfaces. You can create custom boards by defining a custom Board Interface file, as
		/// described in the Vivado Design Suite User Guide: System-Level Design Entry (UG895).
		/// The component interface defines related groups of signals that are found on a component, or a
		/// component mode.
		/// This command returns a list of component interfaces, or returns an error if it fails.
		///
		/// The following example gets the component interfaces defined in the Board Interface file for the
		/// specified board component:
		/// get_board_component_interfaces -of_objects [get_board_components *part0*]
		/// The following example gets the component interfaces defined in the Board Interface file, and
		/// then uses that information to create interfaces in the current project:
		/// #Get and Create Interfaces for I/O Ports
		/// foreach x [get_board_component_interfaces] {
		/// create_interface $x }
		///
		/// See ug835-vivado-tcl-commands.pdf, page 593
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="all">(Optional) Returns all enabled as well as disabled interfaces</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// (Optional)
		/// Get 'board_component_interface' objects of these types:
		/// 'board board_component'.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// (Optional)
		/// Match Bus Interface names against patterns Default: *
		/// Values: The default search pattern is the wildcard *, or .*
		/// when -regexp is specified.
		/// </param>
		/// <returns>list of bus interfaces</returns>
		public virtual SimpleTCLCommand get_board_component_interfaces(bool? regexp = null, bool? nocase = null, bool? all = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_board_component_interfaces [-regexp] [-nocase] [-all] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
			return
				new SimpleTCLCommand("get_board_component_interfaces")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.Flag("all", all)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Gets the list of component mode objects
		///
		///
		/// TCL Syntax: get_board_component_modes [-regexp] [-nocase] [-all] [-filter <arg>] -of_objects <args> [-quiet] [-verbose] [<patterns>...]
		///
		/// Gets a list of various component modes defined on the current board, as defined in the Board
		/// Interface file.
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite
		/// installation area, stores information regarding board attributes. The board provides a
		/// representation of the overall system that the Xilinx device is a part of, and can help define key
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.
		/// You can create custom boards by defining a custom Board Interface file, as described in the
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).
		/// The component mode defines various modes of operations that the components on a board may
		/// have, and the interfaces and preferred IP of those modes.
		/// This command returns a list of component modes, or returns an error if it fails.
		///
		/// The following example gets the component modes defined in the Board Interface file of the
		/// specified board:
		/// get_board_component_modes -of_objects [get_board_components *part0*]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 596
		/// </summary>
		/// <param name="of_objects">(Required) Get 'board_component_mode' objects of these types: 'board_component'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="all">(Optional) Returns all enabled as well as disabled interfaces</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// (Optional)
		/// match board component modes against patterns Default: *
		/// Values: The default search pattern is the wildcard *, or .*
		/// when -regexp is specified.
		/// </param>
		/// <returns>list of component modes in the board</returns>
		public virtual SimpleTCLCommand get_board_component_modes(string of_objects, bool? regexp = null, bool? nocase = null, bool? all = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_board_component_modes [-regexp] [-nocase] [-all] [-filter <arg>] -of_objects <args> [-quiet] [-verbose] [<patterns>...]
			return
				new SimpleTCLCommand("get_board_component_modes")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.Flag("all", all)
					.OptionalNamedString("filter", filter)
					.RequiredNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Gets the list of board_part pins object
		///
		///
		/// TCL Syntax: get_board_component_pins [-regexp] [-nocase] [-filter <arg>] -of_objects <args> [-quiet] [-verbose] [<patterns>...]
		///
		/// Gets a list of individual board component pins of the specified board component object of the
		/// current_board.
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite
		/// installation area, stores information regarding board attributes. The board provides a
		/// representation of the overall system that the Xilinx device is a part of, and can help define key
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.
		/// You can create custom boards by defining a custom Board Interface file, as described in the
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).
		/// Board components define the list of components found on the board defined by the Board
		/// Interface file. Component pins enumerate the individual pins of the component.
		/// This command returns a list of component pin objects, or returns an error if it fails.
		///
		/// The following example gets the component pins associated with the specified Xilinx device
		/// (part0) component object of the current board:
		/// get_board_component_pins -of_objects [get_board_components *part0*]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 599
		/// </summary>
		/// <param name="of_objects">
		/// (Required)
		/// Get 'board_component_pin' objects of these types:
		/// 'board_component board_bus_net'.
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// (Optional)
		/// match board component pin names against patterns
		/// Default: * Values: The default search pattern is the wildcard
		/// *, or .* when -regexp is specified.
		/// </param>
		/// <returns>list of pins in the board_part</returns>
		public virtual SimpleTCLCommand get_board_component_pins(string of_objects, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_board_component_pins [-regexp] [-nocase] [-filter <arg>] -of_objects <args> [-quiet] [-verbose] [<patterns>...]
			return
				new SimpleTCLCommand("get_board_component_pins")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.RequiredNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get the list of components available in the board
		///
		///
		/// TCL Syntax: get_board_components [-regexp] [-nocase] [-all] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
		///
		/// Gets a list of components defined on the current board, as defined in the Board Interface file.
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite
		/// installation area, stores information regarding board attributes. The board provides a
		/// representation of the overall system that the Xilinx device is a part of, and can help define key
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.
		/// You can create custom boards by defining a custom Board Interface file, as described in the
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).
		/// This command returns a list of components, or returns an error if it fails.
		///
		/// The following example gets the components defined in the Board Interface file of the specified
		/// board:
		/// get_board_components -of_objects [get_boards zed]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 602
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="all">(Optional) Returns all enabled as well as disabled components</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// (Optional)
		/// Get 'board_component' objects of these types: 'board
		/// board_bus board_component_pin'.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// (Optional)
		/// Match component names against patterns Default: *
		/// Values: The default search pattern is the wildcard *, or .*
		/// when -regexp is specified.
		/// </param>
		/// <returns>list of component objects</returns>
		public virtual SimpleTCLCommand get_board_components(bool? regexp = null, bool? nocase = null, bool? all = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_board_components [-regexp] [-nocase] [-all] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
			return
				new SimpleTCLCommand("get_board_components")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.Flag("all", all)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Gets the list of interface ports object
		///
		///
		/// TCL Syntax: get_board_interface_ports [-regexp] [-nocase] [-filter <arg>] -of_objects <args> [-quiet] [-verbose] [<patterns>...]
		///
		/// Gets a list of various physical ports assigned to the component interfaces defined on the current
		/// board, as defined in the Board Interface file. The interface ports can be returned from component
		/// interfaces as specified by the get_board_component_interfaces command, or from the
		/// component pins returned by get_board_component_pins.
		/// The Board Interface file, board.xml located in the data/boards folder of the Vivado Design
		/// Suite installation area, stores information regarding board attributes. The board provides a
		/// representation of the overall system that the Xilinx device is a part of, and can help define key
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.
		/// You can create custom boards by defining a custom Board Interface file, as described in the
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).
		/// In the Board Interface file, a component interface includes a map of the logical ports, that are
		/// defined in the interface file, with a physical port that relates to the component pin or pins on the
		/// Xilinx device (part0).
		/// This command returns a list of the physical ports of the specified component interface, or returns
		/// an error if it fails.
		///
		/// The following example gets the board interface ports defined in the Board Interface file for the
		/// specified board component:
		/// get_board_interface_ports -of_objects \
		/// [get_board_component_interfaces *gmii*]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 605
		/// </summary>
		/// <param name="of_objects">
		/// (Required)
		/// Get 'board_component_pin' objects of these types:
		/// 'board_component_interface board_component_pin'.
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// (Optional)
		/// match interface port names against patterns Default: *
		/// Values: The default search pattern is the wildcard *, or .*
		/// when -regexp is specified.
		/// </param>
		/// <returns>list of ports in the given interface</returns>
		public virtual SimpleTCLCommand get_board_interface_ports(string of_objects, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_board_interface_ports [-regexp] [-nocase] [-filter <arg>] -of_objects <args> [-quiet] [-verbose] [<patterns>...]
			return
				new SimpleTCLCommand("get_board_interface_ports")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.RequiredNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Gets the list of ip preference objects
		///
		///
		/// TCL Syntax: get_board_ip_preferences [-regexp] [-nocase] [-filter <arg>] -of_objects <args> [-quiet] [-verbose] [<patterns>...]
		///
		/// Gets a list of IP preferences defined on the current board, as defined in the Board Interface file.
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite
		/// installation area, stores information regarding board attributes. The board provides a
		/// representation of the overall system that the Xilinx device is a part of, and can help define key
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.
		/// You can create custom boards by defining a custom Board Interface file, as described in the
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).
		/// IP preferences define the preferred IP to connect a component interface to in the Board Interface
		/// file.
		/// This command returns a list of preferred IP for specified component interfaces, or component
		/// modes, or returns an error if it fails.
		///
		/// The following example gets the IP preferences of the specified component interfaces:
		/// get_board_ip_preferences -of_objects \
		/// [get_board_component_interfaces *clock*]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 608
		/// </summary>
		/// <param name="of_objects">
		/// (Required)
		/// Get 'ip_preference' objects of these types:
		/// 'board_component_mode board_component_interface'.
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// (Optional)
		/// match ip preferences against patterns Default: * Values: The
		/// default search pattern is the wildcard *, or .* when -regexp
		/// is specified.
		/// </param>
		/// <returns>list of ip preferences for the component</returns>
		public virtual SimpleTCLCommand get_board_ip_preferences(string of_objects, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_board_ip_preferences [-regexp] [-nocase] [-filter <arg>] -of_objects <args> [-quiet] [-verbose] [<patterns>...]
			return
				new SimpleTCLCommand("get_board_ip_preferences")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.RequiredNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Gets the list of board jumper objects
		///
		///
		/// TCL Syntax: get_board_jumpers [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
		///
		/// Gets a list of jumpers defined on the current board, as defined in the Board Interface file.
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite
		/// installation area, stores information regarding board attributes. The board provides a
		/// representation of the overall system that the Xilinx device is a part of, and can help define key
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.
		/// You can create custom boards by defining a custom Board Interface file, as described in the
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).
		/// The jumpers defined in the board file can be used to enable specific component modes and
		/// interfaces of the board.
		/// This command returns a list of jumpers, or returns an error if it fails.
		///
		/// The following example gets the jumpers defined in the Board Interface file of the specified board:
		/// get_board_jumpers -of_objects [get_boards kc705]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 611
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get 'board_jumper' objects of these types: 'board'.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// (Optional)
		/// match jumper names against patterns Default: * Values:
		/// The default search pattern is the wildcard *, or .* when -
		/// regexp is specified.
		/// </param>
		/// <returns>list of jumpers in the board</returns>
		public virtual SimpleTCLCommand get_board_jumpers(bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_board_jumpers [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
			return
				new SimpleTCLCommand("get_board_jumpers")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Gets the list of board parameter objects
		///
		///
		/// TCL Syntax: get_board_parameters [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
		///
		/// Gets a list of parameters defined on the current board, as defined in the Board Interface file.
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite
		/// installation area, stores information regarding board attributes. The board provides a
		/// representation of the overall system that the Xilinx device is a part of, and can help define key
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.
		/// You can create custom boards by defining a custom Board Interface file, as described in the
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).
		/// The parameters defined in the board file specify custom or user-defined characteristics of the
		/// board.
		/// This command returns a list of board parameters, or returns an error if it fails.
		///
		/// The following example gets the parameters defined in the Board Interface file of the current
		/// board:
		/// get_board_parameters
		///
		/// See ug835-vivado-tcl-commands.pdf, page 614
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// (Optional)
		/// Get 'board_parameter' objects of these types: 'board
		/// board_component board_component_interface'.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// (Optional)
		/// match parameter names against patterns Default: * Values:
		/// The default search pattern is the wildcard *, or .* when -
		/// regexp is specified.
		/// </param>
		/// <returns>list of parameters in the board</returns>
		public virtual SimpleTCLCommand get_board_parameters(bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_board_parameters [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
			return
				new SimpleTCLCommand("get_board_parameters")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Gets the list of interfaces in the board_part that implement busdef specified by VLNV
		///
		///
		/// TCL Syntax: get_board_part_interfaces [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
		///
		/// Gets a list of interfaces defined on the Xilinx device, or current board part as defined by the
		/// BOARD_PART property, on the board in use by the current project or open design.
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite
		/// installation area, stores information regarding board attributes. The board provides a
		/// representation of the overall system that the Xilinx device is a part of, and can help define key
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.
		/// You can create custom boards by defining a custom Board Interface file, as described in the
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).
		/// The board part provides a representation of the Xilinx device in the context of the board-level
		/// system, and is represented by the part0 component in the Board Interface file. The
		/// current_board_part command returns the board part in use by the current project.
		/// The interfaces defined on the current board part define related groups of signals that can be used
		/// to quickly connect the elements of a block design in Vivado IP integrator, or configure IP from
		/// the Xilinx IP catalog. The interfaces available on the current_board_part can be used to
		/// define the interfaces required in an IP subsystem design, using create_bd_interface_port
		/// or create_bd_port. It can also be used to define the interfaces available in the overall FPGA
		/// design using create_interface and create_port.
		/// This command returns a list of available interfaces on the current board part, or returns an error
		/// if it fails.
		///
		/// The following example gets a list of all interfaces defined on the current board part:
		/// join [get_board_part_interfaces] \n
		///
		/// See ug835-vivado-tcl-commands.pdf, page 617
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// (Optional)
		/// Get 'board_component_interface' objects of these types:
		/// 'board board_component'.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// (Optional)
		/// Match Bus Interface names against patterns Default: *
		/// Values: The default search pattern is the wildcard *, or .*
		/// when -regexp is specified.
		/// </param>
		/// <returns>list of bus interfaces</returns>
		public virtual SimpleTCLCommand get_board_part_interfaces(bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_board_part_interfaces [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
			return
				new SimpleTCLCommand("get_board_part_interfaces")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Gets the list of board_part pins object
		///
		///
		/// TCL Syntax: get_board_part_pins [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
		///
		/// Gets a list of component pin objects on the current board part in use by the current project or
		/// design.
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite
		/// installation area, stores information regarding board attributes. The board provides a
		/// representation of the overall system that the Xilinx device is a part of, and can help define key
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.
		/// You can create custom boards by defining a custom Board Interface file, as described in the
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).
		/// The board part provides a representation of the Xilinx device in the context of the board-level
		/// system, and is represented by the part0 component in the Board Interface file. The
		/// current_board_part command returns the board part in use by the current project.
		/// The board part pin represents the component pin of an implemented interface on the Xilinx
		/// device. The component pin includes properties like LOC, IOSTANDARD, and SLEW. Board part
		/// pins can be scalar or vector, so it is always represented as bitwise.
		/// The board part pins can be used to define and place PORTS in the top-level FPGA design, using
		/// the create_port and set_property PACKAGE_PIN commands.
		/// This command returns a list of component pins, or returns an error if it fails.
		///
		/// This example returns the physical pins of the specified board part interface:
		/// get_board_part_pins -of [get_board_part_interfaces push_buttons_5bits]
		/// The following example assigns the PACKAGE_PIN and IOSTANDARD properties on the specified
		/// port in the current design according to the properties on the leds_8bits pins in the current board:
		/// set_property PACKAGE_PIN [get_property LOC \
		/// [get_board_part_pins leds_8bits_TRI_O[1]]] [get_ports LEDS_n[1]]
		/// set_property IOSTANDARD [get_property IOSTANDARD \
		/// [get_board_part_pins leds_8bits_TRI_O[1]]] [get_ports LEDS_n[1]]
		/// The following example gets a list of board part pins assigned to the leds_8bits board part
		/// interface; stores those pins in a Tcl variable $boardPins, and then prints the LOC property for
		/// each of those pins:
		/// set boardPins [get_board_part_pins -of \
		/// [get_board_part_interfaces -filter {NAME == led_8bits}]]
		/// foreach pin $boardPins {puts "The location of $pin is: \
		/// [get_property LOC $pin]"}
		/// The location of leds_8bits_tri_o[0] is: AB8
		/// The location of leds_8bits_tri_o[1] is: AA8
		/// The location of leds_8bits_tri_o[2] is: AC9
		/// The location of leds_8bits_tri_o[3] is: AB9
		/// The location of leds_8bits_tri_o[4] is: AE26
		/// The location of leds_8bits_tri_o[5] is: G19
		/// The location of leds_8bits_tri_o[6] is: E18
		/// The location of leds_8bits_tri_o[7] is: F16
		///
		/// See ug835-vivado-tcl-commands.pdf, page 621
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// (Optional)
		/// Get 'board_component_pin' objects of these types:
		/// 'board_component_interface board_interface_port'.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// (Optional)
		/// match board_part pin names against patterns Default: *
		/// Values: The default search pattern is the wildcard *, or .*
		/// when -regexp is specified.
		/// </param>
		/// <returns>list of pins in the board_part</returns>
		public virtual SimpleTCLCommand get_board_part_pins(bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_board_part_pins [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
			return
				new SimpleTCLCommand("get_board_part_pins")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get the list of board_part available in the project
		///
		///
		/// TCL Syntax: get_board_parts [-regexp] [-nocase] [-latest_file_version] [-latest_hw_revision] [-filter <arg>] [-quiet] [-verbose] [<patterns>...]
		///
		/// Gets a list of available board parts in the board repository, as defined by the Board Interface files
		/// available for use by the current project or design.
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite
		/// installation area, stores information regarding board attributes. The board provides a
		/// representation of the overall system that the Xilinx device is a part of, and can help define key
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.
		/// You can create custom boards by defining a custom Board Interface file, as described in the
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).
		/// The board part provides a representation of the Xilinx device in the context of the board-level
		/// system, and is represented by the part0 component in the Board Interface file. The
		/// current_board_part command returns the board part in use by the current project. Refer to
		/// the current_board_part command for the different methods of defining the board in use.
		/// This command returns the list of available Xilinx devices (part0) in the Board Interface files
		/// defined in the current board repository, or returns an error if it fails.
		///
		/// The following example returns the board parts matching the specified filter search pattern:
		/// get_board_parts -filter {BOARD_NAME=~z*}
		/// The following example returns all board parts matching the specified search patterns:
		/// get_board_parts {*av* *kc*}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 625
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="latest_file_version">(Optional) Show only latest board parts by file version</param>
		/// <param name="latest_hw_revision">(Optional) Show only latest board parts by board revision</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// (Optional)
		/// Match Board Part names against patterns Default: * Values:
		/// The default search pattern is the wildcard *, or .* when -
		/// regexp is specified.
		/// </param>
		/// <returns>list of board_part objects</returns>
		public virtual SimpleTCLCommand get_board_parts(bool? regexp = null, bool? nocase = null, bool? latest_file_version = null, bool? latest_hw_revision = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_board_parts [-regexp] [-nocase] [-latest_file_version] [-latest_hw_revision] [-filter <arg>] [-quiet] [-verbose] [<patterns>...]
			return
				new SimpleTCLCommand("get_board_parts")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.Flag("latest_file_version", latest_file_version)
					.Flag("latest_hw_revision", latest_hw_revision)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get the list of boards available in the project
		///
		///
		/// TCL Syntax: get_boards [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
		///
		/// Gets a list of evaluation boards available for use by the current project.
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite
		/// installation area, stores information regarding board attributes. The board provides a
		/// representation of the overall system that the Xilinx device is a part of, and can help define key
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.
		/// You can create custom boards by defining a custom Board Interface file, as described in the
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).
		/// The board in use by the project is returned by the current_board_part command.
		/// The board can be specified:
		/// • When the project is created by selecting Boards from the Default Part dialog box.
		/// • By setting the BOARD property on the current project as shown in the example.
		/// • By selecting the Project Device in the Settings dialog box in an open project in the Vivado IDE.
		/// Refer to the Vivado Design Suite User Guide: System-Level Design Entry (UG895) for information on
		/// creating projects, and on configuring project settings.
		/// IMPORTANT! When you specify the board with the set_property command, the target part is also
		/// changed to match the part required by the specified BOARD property.
		/// This command returns a list of boards that are available for use by the current project, or returns
		/// an error if it fails.
		///
		/// The following example reports the properties of the specified evaluation board:
		/// report_property [get_boards -filter {LIBRARY_NAME==artix7}]
		/// The following example returns all boards matching the specified search patterns:
		/// get_boards {*ar* *kc*}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 629
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get 'board' objects of these types: 'board_component'.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// (Optional)
		/// Match Board names against patterns Default: * Values: The
		/// default search pattern is the wildcard *, or .* when -regexp
		/// is specified.
		/// </param>
		/// <returns>list of board objects</returns>
		public virtual SimpleTCLCommand get_boards(bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_boards [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
			return
				new SimpleTCLCommand("get_boards")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of CDC violations from a previous report_cdc run
		///
		///
		/// TCL Syntax: get_cdc_violations [-name <arg>] [-regexp] [-filter <arg>] [-nocase] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of violation objects found in the design when the report_cdc command is run. The
		/// properties of individual violation objects can be queried using report_property or
		/// list_property commands for details of the violation.
		/// Violation objects are associated with the clock-domain crossing paths in the current design. The
		/// design objects associated with a methodology violation object can be obtained using the -
		/// of_objects option of the appropriate get_* command, such as get_cells, or get_nets
		/// for instance.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example reports the CDC violations found in the current design, then returns a list
		/// of all those violations:
		/// report_cdc
		/// get_cdc_violations
		/// The following example generates list of violations in the named CDC report, and then gets the
		/// pins associated with any violations found:
		/// report_cdc -name cdc_1
		/// get_pins -of_objects [get_cdc_violations -name cdc_1]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 632
		/// </summary>
		/// <param name="name">(Optional) Get the results with this name</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// (Optional)
		/// Match CDC violations against patterns Default: * Values: The
		/// default search pattern is the wildcard *, or .* when -regexp
		/// is specified.
		/// </param>
		/// <returns>list of CDC violation objects</returns>
		public virtual SimpleTCLCommand get_cdc_violations(string name = null, bool? regexp = null, string filter = null, bool? nocase = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_cdc_violations [-name <arg>] [-regexp] [-filter <arg>] [-nocase] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_cdc_violations")
					.OptionalNamedString("name", name)
					.Flag("regexp", regexp)
					.OptionalNamedString("filter", filter)
					.Flag("nocase", nocase)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of cells in the current design
		///
		///
		/// TCL Syntax: get_cells [-hsc <arg>] [-hierarchical] [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-match_style <arg>] [-include_replicated_objects] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of cell objects in the current design that match a specified search pattern. The default
		/// command returns a list of all cells in the current_instance of the open design, as specified by the
		/// current_instance command.
		/// You can use the -hierarchical option to extract cells from the hierarchy of the current
		/// design.
		/// The get_cells command also includes an option to get all replicated cells that are added to a
		/// design during physical optimization, or phys_opt_design. The use of the -
		/// include_replicated_objects option returns the replicated cells of an object when the
		/// original cell is returned. You can use this option to ensure that constraints or properties that are
		/// applied to a cell are also applied to its replicated cells.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example uses regular expression to return cells in the BFT example design that
		/// match the filter expressions for NAME and REF_NAME. In the first command the NAME is
		/// specified in the search pattern, while the second command filters on the NAME property. These
		/// commands return the same results:
		/// get_cells -regexp -filter { REF_NAME =~ FD.* } .*validFor.*
		/// get_cells -regexp -filter { NAME =~ .*validFor.* && REF_NAME =~ FD.* }
		/// The following example searches all levels of the hierarchy for cells beginning with cpu, or fft, and
		/// joins each cell returned with the newline character to put it on a separate line:
		/// join [get_cells -hier {cpu* fft*}] \n
		/// This example gets a list of properties and property values attached to the second object of the
		/// list returned by get_cells:
		/// report_property [lindex [get_cells] 1]
		/// Note: If there are no cells matching the pattern you will get a warning.
		/// This example prints a list of the library cells instantiated into the design at all levels of the
		/// hierarchy, sorting the list for unique names so that each cell is only printed one time:
		/// foreach cell [lsort -unique [get_property LIB_CELL [get_cells -hier \
		/// -filter {IS_PRIMITIVE==1}]]] {puts $cell}
		/// The following example demonstrates the effect of -hierarchical searches, without and with
		/// -regexp:
		/// get_cells -hierarchical *mmcm*
		/// mmcm_replicator_inst_1
		/// mmcm_replicator_inst_1/mmcm_stage[0].mmcm_channel[0].mmcm
		/// get_cells -hierarchical -regexp .*mmcm.*
		/// mmcm_replicator_inst_1
		/// mmcm_replicator_inst_1/mmcm_stage[0].mmcm_channel[0].mmcm
		/// mmcm_replicator_inst_1/mmcm_stage[0].mmcm_channel[0].mmcm/GND
		/// mmcm_replicator_inst_1/mmcm_stage[0].mmcm_channel[0].mmcm/MMCM_Base
		/// Note: The last two cells (GND and MMCM_Base) were not returned in the first example (without -
		/// regexp) because the cell names do not match the search pattern, as it is applied to each level of the
		/// hierarchy.
		/// The following example runs the report_drc command on the current design, and returns any
		/// cells associated with DRC violations:
		/// report_drc -name drc_1
		/// get_cells -of_objects [get_drc_violations]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 635
		/// </summary>
		/// <param name="hsc">(Optional) Hierarchy separator Default: /</param>
		/// <param name="hierarchical">(Optional) Search level-by-level in current instance</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// (Optional)
		/// Get cells of these pins, timing paths, nets, bels, clock
		/// regions, sites, or drc violations
		/// </param>
		/// <param name="match_style">(Optional) Style of pattern matching Default: sdc Values: ucf, sdc</param>
		/// <param name="include_replicated_objects">
		/// (Optional)
		/// Include replicated objects when searching for patterns. This
		/// option is valid only when patterns is specified.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match cell names against patterns Default: *</param>
		/// <returns>list of cell objects</returns>
		public virtual SimpleTCLCommand get_cells(string hsc = null, bool? hierarchical = null, bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, string match_style = null, bool? include_replicated_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_cells [-hsc <arg>] [-hierarchical] [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-match_style <arg>] [-include_replicated_objects] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_cells")
					.OptionalNamedString("hsc", hsc)
					.Flag("hierarchical", hierarchical)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.OptionalNamedString("match_style", match_style)
					.Flag("include_replicated_objects", include_replicated_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of cfgmem_parts available in the software
		///
		///
		/// TCL Syntax: get_cfgmem_parts [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Get a list of configuration flash memory devices supported by the Vivado Design Suite or Vivado
		/// Lab Edition.
		/// Xilinx® FPGAs can be configured from an external nonvolatile memory device, or they can be
		/// configured by an external smart source, such as a microprocessor, DSP processor,
		/// microcontroller, PC, or board tester. The two configuration datapaths include a serial datapath
		/// that is used to minimize the device pin requirements for configuration, and a parallel 8-bit, 16-bit,
		/// or 32-bit datapath used for higher performance or link to industry-standard interfaces ideal for
		/// external data sources like processors, or x8- or x16-parallel flash memory.
		/// The process whereby the design specific data is loaded or programmed into the Xilinx FPGA is
		/// called configuration. The create_hw_cfgmem command defines a flash memory device used
		/// for configuring and booting the hardware device.
		/// After the hw_cfgmem object is created, and associated with the hw_device, the configuration
		/// memory can be programmed with the bitstream and other data from a memory configuration file
		/// created with the write_cfgmem command. The hw_cfgmem object is programmed using the
		/// program_hw_cfgmem command.
		/// The configuration memory part can be used to define the hardware configuration memory in the
		/// Hardware Manager of the Vivado Design Suite, to enable programming and debugging the design
		/// in the FPGA hardware. Use the create_hw_cfgmem command to define the configuration
		/// memory for use with the current hardware device.
		/// This command returns a list of cfgmem_part objects that match the specified search criteria, or
		/// returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 640
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get 'cfgmem_part' objects of these types: 'part hw_device'.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'cfgmem_part' objects against patterns. Default: *</param>
		/// <returns>list of cfgmem_part objects</returns>
		public virtual SimpleTCLCommand get_cfgmem_parts(bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_cfgmem_parts [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_cfgmem_parts")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get the clock regions for the current device.
		///
		///
		/// TCL Syntax: get_clock_regions [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of clock regions on the target part that match a specified search pattern. The default
		/// command gets a list of all clock regions on the device in an open design.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example returns the clock regions matching the search pattern:
		/// get_clock_regions X0*
		/// The following example returns the clock regions filtered by the specified property:
		/// get_clock_regions -filter {LOW_X==0}
		/// Note: These two examples return the same set of clock regions.
		/// The following example returns the clock regions that the specified ILA debug core trigger is
		/// assigned to, or placed in:
		/// get_clock_regions -of_objects [get_cells -hierarchical basic_trigger*]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 644
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions.</param>
		/// <param name="nocase">
		/// (Optional)
		/// Perform case-insensitive matching. (valid only when -regexp
		/// specified).
		/// </param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// (Optional)
		/// Get the clock_regions of these tiles, sites, slrs, cells, or
		/// package bank
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match objects' name against patterns. Default: *</param>
		/// <returns>clock_regions</returns>
		public virtual SimpleTCLCommand get_clock_regions(bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_clock_regions [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_clock_regions")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of clocks in the current design
		///
		///
		/// TCL Syntax: get_clocks [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-match_style <arg>] [-include_generated_clocks] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of clocks in the current design that match a specified search pattern. The default
		/// command gets a list of all clocks in the design, like the all_clocks command.
		/// Clocks can be created using the create_clock or the create_generated_clock
		/// commands, or can be automatically generated by the tool, at the output of an MMCM for
		/// instance.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example gets a list of clocks matching the various search patterns:
		/// get_clocks {*clock *ck *Clk}
		/// Note: If there are no clocks matching the pattern you will get a warning.
		/// The following example gets the master clock object, and all generated clocks derived from that
		/// clock:
		/// get_clocks -include_generated_clocks wbClk
		/// The following example gets all properties and property values attached to the specified clock:
		/// report_property -all [get_clocks wbClk]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 647
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get clocks of these pins, nets, or cells</param>
		/// <param name="match_style">(Optional) Style of pattern matching, valid values are ucf, sdc Default: sdc</param>
		/// <param name="include_generated_clocks">(Optional) Include auto-inferred/generated_clocks also.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match clock names against patterns Default: *</param>
		/// <returns>list of clocks</returns>
		public virtual SimpleTCLCommand get_clocks(bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, string match_style = null, bool? include_generated_clocks = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_clocks [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-match_style <arg>] [-include_generated_clocks] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_clocks")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.OptionalNamedString("match_style", match_style)
					.Flag("include_generated_clocks", include_generated_clocks)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Create the Project summary dashboard
		///
		///
		/// TCL Syntax: get_dashboard_gadgets [-quiet] [-verbose] [<patterns>...]
		///
		/// Gets a list of the dashboard gadgets in the current project.
		///
		/// The following example returns the dashboard gadgets in the current project:
		/// get_dashboard_gadgets
		///
		/// See ug835-vivado-tcl-commands.pdf, page 651
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// (Optional)
		/// Match gadget names against patterns Default: * Values: The
		/// default search pattern is the wildcard *
		/// </param>
		public virtual SimpleTCLCommand get_dashboard_gadgets(bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_dashboard_gadgets [-quiet] [-verbose] [<patterns>...]
			return
				new SimpleTCLCommand("get_dashboard_gadgets")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of debug cores in the current design
		///
		///
		/// TCL Syntax: get_debug_cores [-filter <arg>] [-of_objects <args>] [-regexp] [-nocase] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of Vivado Lab Edition debug cores in the current project that match a specified search
		/// pattern. The default command gets a list of all debug cores in the project.
		/// Debug cores are added to the project with the create_debug_core command. When a ILA
		/// debug core (labtools_ila_v3) is added to the project, it is contained within a Debug Hub core
		/// (labtools_xsdbmasterlib_v2), and includes a CLK port and a PROBE port as a default. Additional
		/// ports can be added to the debug core with the use of the create_debug_port command.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following command gets a list of the Vivado Lab Edition debug cores in the current project:
		/// get_debug_cores
		/// Note: A Debug Hub core is returned as one of the debug cores in the project. You cannot directly create
		/// this core, but it is automatically added by the tool when you add any ILA cores to the project.
		/// The following example gets the properties of the specified debug core:
		/// report_property [get_debug_cores myCore]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 653
		/// </summary>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get cores of these debug ports or nets</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match debug cores against patterns Default: *</param>
		/// <returns>list of debug_core objects</returns>
		public virtual SimpleTCLCommand get_debug_cores(string filter = null, string of_objects = null, bool? regexp = null, bool? nocase = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_debug_cores [-filter <arg>] [-of_objects <args>] [-regexp] [-nocase] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_debug_cores")
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of debug ports in the current design
		///
		///
		/// TCL Syntax: get_debug_ports [-filter <arg>] [-of_objects <args>] [-regexp] [-nocase] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of ports defined on ILA debug cores in the current project that match a specified
		/// search pattern. The default command gets a list of all debug ports in the project.
		/// Debug ports are defined when ILA debug cores are created with the create_debug_core
		/// command. Ports can be added to existing debug cores with the create_debug_port
		/// command.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following command gets a list of the ports from the ILA debug cores in the current project,
		/// with a PORT_WIDTH property of 8:
		/// get_debug_ports -filter {PORT_WIDTH==8}
		/// The following example gets the properties attached to the specified debug port:
		/// report_property [get_debug_ports myCore/PROBE1]
		/// Note: The debug port is defined by the core_name/port_name combination.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 656
		/// </summary>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get ports of these debug cores</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match debug ports against patterns Default: *</param>
		/// <returns>list of debug_port objects</returns>
		public virtual SimpleTCLCommand get_debug_ports(string filter = null, string of_objects = null, bool? regexp = null, bool? nocase = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_debug_ports [-filter <arg>] [-of_objects <args>] [-regexp] [-nocase] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_debug_ports")
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of designs in the current project
		///
		///
		/// TCL Syntax: get_designs [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of open designs in the current project that match a specified search pattern. The
		/// default command gets a list of all open designs in the project.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example gets all open designs in the current project:
		/// get_designs
		/// The following example gets the assigned properties of an open design matching the search
		/// pattern:
		/// report_property [get_designs r*]
		/// Note: If there are no designs matching the pattern you will get a warning.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 659
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match design names against patterns Default: *</param>
		/// <returns>list of design objects</returns>
		public virtual SimpleTCLCommand get_designs(bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_designs [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_designs")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of DRC rule check objects
		///
		///
		/// TCL Syntax: get_drc_checks [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-abbrev <arg>] [-ruledecks <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of the currently defined DRC checks. This list includes both factory defined design rule
		/// checks, and user-defined checks created by the create_drc_check command.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following command gets a list of all AVAL design rule checks:
		/// get_drc_checks AVAL*
		/// The following example gets the checks associated with the specified rule deck:
		/// get_drc_checks -of_objects [get_drc_ruledecks placer_checks]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 662
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'rule_check' objects of these types: 'drc_ruledeck'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="abbrev">(Optional) Get the largest ID for this abbrev</param>
		/// <param name="ruledecks">(Optional) Containers of Report DRC rule checks Default: default</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'rule_check' objects against patterns. Default: *</param>
		/// <returns>list of DRC rule_check objects</returns>
		public virtual SimpleTCLCommand get_drc_checks(string of_objects = null, bool? regexp = null, bool? nocase = null, string filter = null, string abbrev = null, string ruledecks = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_drc_checks [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-abbrev <arg>] [-ruledecks <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_drc_checks")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("abbrev", abbrev)
					.OptionalNamedString("ruledecks", ruledecks)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of DRC rule deck objects
		///
		///
		/// TCL Syntax: get_drc_ruledecks [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of currently defined rule decks for use with the report_drc command.
		/// A rule deck is a collection of design rule checks grouped for convenience, to be run at different
		/// stages of the FPGA design flow, such as during I/O planning or placement. The tool comes with a
		/// set of factory defined rule decks, but you can also create new user-defined rule decks with the
		/// create_drc_ruledeck command, and add checks to the rule deck using the
		/// add_drc_checks command.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example gets a list of rule decks defined in the current project:
		/// get_drc_ruledecks
		/// The following example lists each of the checks associated with the placer_checks rule deck on a
		/// separate line:
		/// foreach rule [get_drc_checks -of_objects \
		/// [get_drc_ruledecks placer_checks]] {puts $rule}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 665
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'drc_ruledeck' objects of these types: 'rule_check'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'drc_ruledeck' objects against patterns. Default: *</param>
		/// <returns>drc_ruledeck</returns>
		public virtual SimpleTCLCommand get_drc_ruledecks(string of_objects = null, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_drc_ruledecks [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_drc_ruledecks")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of DRC violations from a previous report_drc run
		///
		///
		/// TCL Syntax: get_drc_violations [-name <arg>] [-regexp] [-filter <arg>] [-nocase] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of violation objects found in the design when the report_drc command is run.
		/// Violation objects are created at the time DRC is run, either by the internal design rule checks
		/// provided by the Vivado tools, or created by the create_drc_violation command in user￾defined DRC checks. The properties of individual violation objects can be queried using
		/// report_property or list_property commands for details of the violation.
		/// Violation objects are associated with the cells, nets, pins, or ports in the current design, or sites
		/// on the current device. The design objects associated with a DRC violation object can be obtained
		/// using the -of_objects option of the appropriate get_* command, such as get_cells, or
		/// get_nets for instance.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example reports the DRC violations found in the current design, then returns a list
		/// of all those violations:
		/// report_drc
		/// get_drc_violations
		/// The following example gets the properties of the specified DRC violation:
		/// report_property [lindex [get_drc_violations] 0]
		/// The following example returns the list of violations in the specified DRC report of the current
		/// design, and then returns the ports associated with any violations of the unspecified I/O Standard
		/// rule (NSTD):
		/// get_drc_violations -name drc_1
		/// get_ports -of_objects [get_drc_violations -name drc_1 NSTD*]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 668
		/// </summary>
		/// <param name="name">(Optional) Get the results with this name</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// (Optional)
		/// Match drc_violations against patterns Default: * Values: The
		/// default search pattern is the wildcard *, or .* when -regexp
		/// is specified.
		/// </param>
		/// <returns>list of DRC violation objects</returns>
		public virtual SimpleTCLCommand get_drc_violations(string name = null, bool? regexp = null, string filter = null, bool? nocase = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_drc_violations [-name <arg>] [-regexp] [-filter <arg>] [-nocase] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_drc_violations")
					.OptionalNamedString("name", name)
					.Flag("regexp", regexp)
					.OptionalNamedString("filter", filter)
					.Flag("nocase", nocase)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of example designs
		///
		///
		/// TCL Syntax: get_example_designs [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>...]
		///
		/// The command returns a list of example designs available in the current release of the Vivado
		/// Design Suite, or returns an error if it fails.
		/// Example designs can be opened, or instantiated into the Vivado Design Suite, onto specific target
		/// hardware devices or boards.
		///
		/// The following example returns reports the properties of each of the example designs in the
		/// current release:
		/// foreach x [get_example_designs] {
		/// puts "********* Design $x **************"
		/// report_property -all $x}
		/// Note: The reported properties include the PARTS property which lists the compatible parts for the example
		/// design.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 672
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// (Optional)
		/// The patterns to match against Default: * Values: The default
		/// search pattern is the wildcard *, or .* when -regexp is
		/// specified.
		/// </param>
		/// <returns>list of design objects</returns>
		public virtual SimpleTCLCommand get_example_designs(bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_example_designs [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>...]
			return
				new SimpleTCLCommand("get_example_designs")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of source files
		///
		///
		/// TCL Syntax: get_files [-regexp] [-nocase] [-filter <arg>] [-compile_order <arg>] [-used_in <arg>] [-references] [-all] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of files in the current project that match a specified search pattern. The default
		/// command gets a list of all files in the project.
		/// The get_files command returns a machine readable list of files in the project, in a design, or in
		/// a sub-design such as an IP core or block design. You can filter the results returned by
		/// get_files using one of the command arguments such as -of_objects, -compile_order,
		/// -used_in, and -filter.
		/// The -compile_order and -used_in options must be used together to return a list of files
		/// from the sources or constraints filesets used in synthesis, simulation, or implementation, sorted
		/// according to the order of evaluation by the Vivado tools. The -compile_order and -used_in
		/// options use complex file ordering rules that can change based on header files, include files, or
		/// other language options. You can also filter files returned by get_files according to the
		/// USED_IN property, using the -filter option instead of the -used_in option.
		/// You can use the report_compile_order command to generate a report of all files in the
		/// sources or constraints filesets, used in synthesis, simulation, AND implementation, sorted into
		/// different sections.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example returns the VHDL files in the design that are used in simulation:
		/// get_files -filter {FILE_TYPE == VHDL && USED_IN =~ simulation*}
		/// This example returns the design source files that are used in simulation:
		/// get_files -compile_order sources -used_in simulation
		/// This example gets a list of files associated with the specified IP core composite file (ip.xci), from
		/// the sources_1 fileset that are used in synthesis:
		/// get_files -compile_order sources -used_in synthesis -of [get_files ip.xci]
		/// The following example gets a list of the files found in the sources_1 and constrs_1 filesets:
		/// get_files -of [get_filesets {sources_1 constrs_1}]
		/// Note: If there are no files matching the pattern you will get a warning.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 675
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="compile_order">(Optional) Get files by type and in compilation order (must use with - used_in)</param>
		/// <param name="used_in">(Optional) Get files used in a specific step (must use with - compile_order)</param>
		/// <param name="references">
		/// (Optional)
		/// Get files referenced in the provided objects (must use with -
		/// of_objects)
		/// </param>
		/// <param name="all">(Optional) Include all internal files.</param>
		/// <param name="of_objects">(Optional) Get 'file' objects of these types: 'file fileset ip reconfig_module'.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match file names against patterns Default: *</param>
		/// <returns>list of file objects</returns>
		public virtual SimpleTCLCommand get_files(bool? regexp = null, bool? nocase = null, string filter = null, string compile_order = null, string used_in = null, bool? references = null, bool? all = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_files [-regexp] [-nocase] [-filter <arg>] [-compile_order <arg>] [-used_in <arg>] [-references] [-all] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_files")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("compile_order", compile_order)
					.OptionalNamedString("used_in", used_in)
					.Flag("references", references)
					.Flag("all", all)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of filesets in the current project
		///
		///
		/// TCL Syntax: get_filesets [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of filesets in the current project that match a specified search pattern. The default
		/// command gets a list of all filesets in the project.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example returns the source files in the Source Set:
		/// get_files -of_objects [get_filesets sources_1]
		/// The following example makes project_2 the active project, and then gets a list of filesets
		/// beginning with the letter s or the letter r:
		/// current_project project_2
		/// get_filesets s* r* -quiet
		/// Note: If there are no filesets matching the pattern, such as r*, you will get a warning that no filesets
		/// matched the specified pattern. However, in the above example the use of -quiet will suppress that
		/// warning message.
		/// The following example gets filesets beginning with the letter C, using a case insensitive regular
		/// expression:
		/// get_filesets C.* -regexp -nocase
		/// In the above example, constrs_1 and constrs_2 constraint sets would be returned if defined in
		/// the current project.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 679
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get 'fileset' objects of these types: 'reconfig_module'.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match fileset names against patterns Default: *</param>
		/// <returns>list of fileset objects</returns>
		public virtual SimpleTCLCommand get_filesets(bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_filesets [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_filesets")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of generated clocks in the current design
		///
		///
		/// TCL Syntax: get_generated_clocks [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-match_style <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of generated clocks in the current project that match a specified search pattern. The
		/// default command gets a list of all generated clocks in the project.
		/// A generated clock can be added to the design using the create_generated_clock
		/// command, or can be automatically generated by the tool, at the output of an MMCM for
		/// instance.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example gets the names of all generated clocks in the current project:
		/// get_generated_clocks
		///
		/// See ug835-vivado-tcl-commands.pdf, page 682
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get generated clocks of these pins, ports or nets</param>
		/// <param name="match_style">(Optional) Style of pattern matching, valid values are ucf, sdc Default: sdc</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match generated clock names against patterns Default: *</param>
		/// <returns>list of clocks</returns>
		public virtual SimpleTCLCommand get_generated_clocks(bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, string match_style = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_generated_clocks [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-match_style <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_generated_clocks")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.OptionalNamedString("match_style", match_style)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get custom command arguments
		///
		///
		/// TCL Syntax: get_gui_custom_command_args -command_name <arg> [-regexp] [-nocase] [-quiet] [-verbose] [<patterns>...]
		///
		/// Returns the list of GUI custom command argument names for a particular GUI custom command.
		/// You can use the get_gui_custom_commands to determine the list of defined custom
		/// commands.
		///
		/// The following example returns a list of command arguments for the GUI custom command abc:
		/// get_gui_custom_command_args -command_name abc
		///
		/// See ug835-vivado-tcl-commands.pdf, page 685
		/// </summary>
		/// <param name="command_name">
		/// (Required)
		/// Unique name of the custom command whose arguments
		/// need to be displayed.
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the custom command argument names against patterns Default: *</param>
		/// <returns>list of custom command argument names</returns>
		public virtual SimpleTCLCommand get_gui_custom_command_args(string command_name, bool? regexp = null, bool? nocase = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_gui_custom_command_args -command_name <arg> [-regexp] [-nocase] [-quiet] [-verbose] [<patterns>...]
			return
				new SimpleTCLCommand("get_gui_custom_command_args")
					.RequiredNamedString("command_name", command_name)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get custom commands
		///
		///
		/// TCL Syntax: get_gui_custom_commands [-regexp] [-nocase] [-quiet] [-verbose] [<patterns>...]
		///
		/// Returns the list of GUI custom commands.
		///
		/// The following example returns a list of all the GUI custom commands which has names starting
		/// with 'p':
		/// get_gui_custom_commands p*
		///
		/// See ug835-vivado-tcl-commands.pdf, page 687
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the custom command names against patterns Default: *</param>
		/// <returns>list of custom command names</returns>
		public virtual SimpleTCLCommand get_gui_custom_commands(bool? regexp = null, bool? nocase = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_gui_custom_commands [-regexp] [-nocase] [-quiet] [-verbose] [<patterns>...]
			return
				new SimpleTCLCommand("get_gui_custom_commands")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get hierarchical separator character
		///
		///
		/// TCL Syntax: get_hierarchy_separator [-quiet] [-verbose]
		///
		/// Gets the character currently used for separating levels of hierarchy in the design. You can set the
		/// hierarchy separator using the set_hierarchy_separator command.
		///
		/// The following example gets the currently defined hierarchy separator:
		/// get_hierarchy_separator
		///
		/// See ug835-vivado-tcl-commands.pdf, page 689
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand get_hierarchy_separator(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_hierarchy_separator [-quiet] [-verbose]
			return
				new SimpleTCLCommand("get_hierarchy_separator")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Get highlighted objects
		///
		///
		/// TCL Syntax: get_highlighted_objects [-color_index <arg>] [-rgb <args>] [-color <arg>] [-quiet] [-verbose]
		///
		/// Gets the highlighted objects in the current design open in the Vivado IDE. Objects can be
		/// highlighted with the highlight_objects command.
		/// You can get all highlighted objects in the design, or specify highlighted objects by color, by color
		/// index, or by RGB value.
		/// Note: This Tcl command works only when Vivado is run in GUI mode.
		///
		/// The following example gets all the highlighted objects in the current design:
		/// get_highlighted_objects
		/// The following example gets the object in the current design that are highlighted in the specified
		/// color:
		/// get_highlighted_objects -color cyan
		///
		/// See ug835-vivado-tcl-commands.pdf, page 690
		/// </summary>
		/// <param name="color_index">(Optional) Color index</param>
		/// <param name="rgb">(Optional) RGB color index list</param>
		/// <param name="color">(Optional) Valid values are red green blue magenta yellow cyan and orange</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of highlighted objects</returns>
		public virtual SimpleTCLCommand get_highlighted_objects(string color_index = null, string rgb = null, string color = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_highlighted_objects [-color_index <arg>] [-rgb <args>] [-color <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("get_highlighted_objects")
					.OptionalNamedString("color_index", color_index)
					.OptionalNamedString("rgb", rgb)
					.OptionalNamedString("color", color)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Get a list of hardware AXI transactions.
		///
		///
		/// TCL Syntax: get_hw_axi_txns [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Returns the read or write transactions for the specified JTAG to AXI Master core, hw_axi object.
		/// The JTAG to AXI Master is a customizable IP core that works as an AXI Master to drive AXI
		/// transactions and drive AXI signals that are internal to the hardware device. This IP can be used in
		/// Vivado® IP integrator or can be instantiated in HDL in a Vivado project.
		/// The JTAG-AXI core supports all memory-mapped AXI interfaces, except AXI4-Stream, and
		/// supports the AXI-Lite protocol. The AXI interface can be selected as a property of the core. The
		/// width of AXI data bus is customizable. This IP can drive any AXI4-Lite or Memory Mapped Slave
		/// directly, and can also be connected as the AXI Master to the interconnect. Run-time interaction
		/// with this core requires the use of the Vivado logic analyzer feature. Detailed documentation on
		/// the IP core can be found in the LogiCORE IP JTAG to AXI Master Product Guide (PG174). A tutorial
		/// showing its use can be found in the Vivado Design Suite Tutorial: Programming and Debugging
		/// (UG936).
		/// The JTAG to AXI Master core must be instantiated in the RTL code, from the Xilinx IP catalog.
		/// AXI transactions are defined as complete READ or WRITE transactions between the AXI master
		/// and various slaves.
		/// This command returns a list of hw_axi_txn objects on the hw_device, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 692
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'hw_axi_txn' objects of these types: 'hw_axi'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_axi_txn' objects against patterns. Default: *</param>
		/// <returns>hw_axi_txns</returns>
		public virtual SimpleTCLCommand get_hw_axi_txns(string of_objects = null, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_hw_axi_txns [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_hw_axi_txns")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of hardware AXI objects.
		///
		///
		/// TCL Syntax: get_hw_axis [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Returns the JTAG to AXI Master core objects, or hw_axi objects, defined on the current hardware
		/// device.
		/// The JTAG to AXI Master is a customizable IP core that works as an AXI Master to drive AXI
		/// transactions and drive AXI signals that are internal to the hardware device. This IP can be used in
		/// Vivado® IP integrator or can be instantiated from the Xilinx® IP catalog into the HDL of a Vivado
		/// project. Run-time interaction with this core requires the use of the Vivado logic analyzer feature.
		/// The JTAG-AXI core supports all memory-mapped AXI interfaces, except AXI4-Stream, and
		/// supports the AXI-Lite protocol. The AXI interface can be defined as a property of the core. The
		/// width of the AXI data bus is customizable. This IP can drive any AXI4-Lite or Memory Mapped
		/// Slave directly, and can also be connected as the AXI Master to the interconnect. Detailed
		/// documentation on the IP core can be found in the LogiCORE IP JTAG to AXI Master Product Guide
		/// (PG174). A tutorial showing its use can be found in the Vivado Design Suite Tutorial: Programming
		/// and Debugging (UG936).
		/// AXI cores can be found in the synthesized or implemented design netlist using the
		/// get_debug_cores command. This will return instances of the debug cores in the design that
		/// are related to the hw_axi objects, and other debug cores on the hw_device.
		/// This command returns a list of AXI Master core objects, hw_axis, on the hw_device, or returns an
		/// error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 695
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'hw_axi' objects of these types: 'hw_device'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_axi' objects against patterns. Default: *</param>
		/// <returns>hw_axi</returns>
		public virtual SimpleTCLCommand get_hw_axis(string of_objects = null, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_hw_axis [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_hw_axis")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of hardware cfgmems.
		///
		///
		/// TCL Syntax: get_hw_cfgmems [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Get a list of hardware configuration memory (hw_cfgmem) objects created for the current
		/// hw_device.
		/// Xilinx FPGAs are configured by loading design-specific configuration data, in the form of a
		/// bitstream file, into the internal memory of the hw_device. The hw_cfgmem defines a flash
		/// memory device used for configuring and booting the Xilinx FPGA device. Once the hw_cfgmem
		/// object is created, and associated with the hw_device, the configuration memory can be
		/// programmed with the bitstream and other data using the program_hw_cfgmem command.
		/// The hw_cfgmem object is associated with the specified hw_device object through the
		/// PROGRAM.HW_CFGMEM property on the device object. The get_hw_cfgmems command lets
		/// you work with the hw_cfgmem object.
		/// This command returns a list of hw_cfgmem objects that match the specified search criteria, or
		/// returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 698
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_cfgmem' objects against patterns. Default: *</param>
		/// <returns>hardware cfgmems</returns>
		public virtual SimpleTCLCommand get_hw_cfgmems(bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_hw_cfgmems [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_hw_cfgmems")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get list of Versal integrated and soft DDRMC cores.
		///
		///
		/// TCL Syntax: get_hw_ddrmcs [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Xilinx Versal devices include integrated DDR Memory Controllers (DDRMC), as well as fabric
		/// based memory controllers. Refer to the LogiCore IP Product Guide: Versal ACAP Network on Chip
		/// and Integrated Memory Controller (PG313) for more information on the integrated controller core.
		/// Refer to Versal ACAP Soft DDR4 Memory IP (PG353) for more information on the fabric based
		/// memory controller. The memory controllers contain memory configuration and memory
		/// calibration data that can be accessed from the Xilinx Vivado Hardware Manager. The calibration
		/// and margin data are organized and presented in a graphical format for ease of analysis.
		/// The get_hw_ddrmc command returns a list of memory cores on the current hardware device.
		///
		/// The following example returns the HBM with the specified DISPLAY_NAME:
		/// get_hw_hbms -filter {DISPLAY_NAME == HBM_2}
		/// The following example returns the DDRMC with the specified DISPLAY_NAME:
		/// get_hw_ddrmcs -filter {DISPLAY_NAME == DDRMC_1}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 701
		/// </summary>
		/// <param name="of_objects">
		/// (Optional)
		/// Get 'hw_ddrmc' objects of these types: 'hw_server
		/// hw_target hw_device'.
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_ddrmc' objects against patterns. Default: *</param>
		/// <returns>integrated and soft DDRMC cores</returns>
		public virtual SimpleTCLCommand get_hw_ddrmcs(string of_objects = null, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_hw_ddrmcs [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_hw_ddrmcs")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of hardware devices.
		///
		///
		/// TCL Syntax: get_hw_devices [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Returns the hardware devices on the open target of a connected hardware server.
		/// Each hardware target can have one or more Xilinx devices to program, or to use for debugging
		/// purposes. The current device is specified or returned by the current_hw_device command.
		/// This command returns a list of available hardware device objects, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 704
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'hw_device' objects of these types: 'hw_target'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_device' objects against patterns. Default: *</param>
		/// <returns>hardware devices</returns>
		public virtual SimpleTCLCommand get_hw_devices(string of_objects = null, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_hw_devices [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_hw_devices")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get list of hardware HBM cores.
		///
		///
		/// TCL Syntax: get_hw_hbms [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Certain Xilinx® UltraScale+ devices include an integrated High-Bandwidth Memory (HBM)
		/// controller. Refer to the LogiCore IP Product Guide: AXI High Bandwidth Memory Controller
		/// (PG276) for more information on this core. The HBM controller and memory stacks contain both
		/// performance counters and temperature sensors that can be accessed through an HBM activity
		/// monitor (amon) from within the Xilinx Vivado hardware manager. The HBM activity monitor can
		/// be used to gain real-time access to performance monitoring and temperature sensors on the
		/// physical device. The Vivado hardware manager displays read, write, and overall throughput of
		/// data, as well as the device temperature. The activity monitor displays, captures, and exports data
		/// to a CSV file when it is running.
		/// The get_hw_hbms command returns a list of HBM cores on the current hardware target.
		///
		/// The following example returns the HBM with the specified DISPLAY_NAME:
		/// get_hw_hbms -filter {DISPLAY_NAME == HBM_2}
		/// This example returns all the HBM objects in the current device:
		/// get_hw_hbms
		///
		/// See ug835-vivado-tcl-commands.pdf, page 707
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'hw_hbm' objects of these types: 'hw_server hw_target hw_device'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_hbm' objects against patterns. Default: *</param>
		/// <returns>hardware HBM cores</returns>
		public virtual SimpleTCLCommand get_hw_hbms(string of_objects = null, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_hw_hbms [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_hw_hbms")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of hardware ILA data objects.
		///
		///
		/// TCL Syntax: get_hw_ila_datas [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Returns the ILA data objects in the Vivado logic analyzer.
		/// The upload_hw_ila_data command creates a hw_ila_data object in the process of moving
		/// the captured data from the ILA debug core, hw_ila, on the physical FPGA device, hw_device. The
		/// read_hw_ila_data command can also create a hw_ila_data object when reading an ILA data
		/// file from disk.
		/// The hw_ila_data object can be viewed in the waveform viewer of the Vivado logic analyzer by
		/// using the display_hw_ila_data command, and can be written to disk using the
		/// write_hw_ila_data command.
		/// This command returns a list of available hardware ILA data objects, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 710
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'hw_ila_data' objects of these types: 'hw_ila hw_device'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_ila_data' objects against patterns. Default: *</param>
		/// <returns>hardware ILA data</returns>
		public virtual SimpleTCLCommand get_hw_ila_datas(string of_objects = null, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_hw_ila_datas [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_hw_ila_datas")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of hardware ILA.
		///
		///
		/// TCL Syntax: get_hw_ilas [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Returns the ILA debug core objects defined on the current hardware device.
		/// The Integrated Logic Analyzer (ILA) debug core lets you perform in-system debug of
		/// implemented designs, or design bitstreams, on a programmed Xilinx FPGA. The ILA core includes
		/// many advanced features of modern logic analyzers, including boolean trigger equations, and edge
		/// transition triggers. You can use the ILA core to probe specific signals of the design, to trigger on
		/// programmed hardware events, and capture data from the Xilinx FPGA in real-time. Refer to
		/// LogiCORE IP Integrated Logic Analyzer (PG172) for details of the ILA core.
		/// You can add ILA debug cores into the RTL source files of a design, or in the synthesized netlist
		/// using the create_debug_core command. Refer to the Vivado Design Suite User Guide: Vivado
		/// Programming and Debugging (UG908) for more information on adding debug cores and signal
		/// probes to the design. You can get the debug cores in the synthesized netlist by using the
		/// get_debug_core commands. However, though they are related, the design debug cores are
		/// separate from the hardware debug cores found in the Hardware Manager feature of the Vivado
		/// Design Suite.
		/// Debug cores and probes are written to the probes file (.ltx) using the write_debug_probes
		/// command and associated with the hardware device, along with the bitstream file (.bit), using
		/// the PROBES.FILE and PROGRAM.FILE properties of the hw_device object. The hardware device
		/// is programmed with this information using the program_hw_devices command.
		/// The steps to debug your design in hardware using an ILA debug core are:
		/// 1. Connect to the hardware server and target using connect_hw_server and
		/// open_hw_target.
		/// 2. Program the FPGA with the bitstream (.bit) and probes (.ltx) files using
		/// program_hw_devices.
		/// 3. Set up the ILA debug core trigger and capture controls using set_property to set
		/// properties of the ILA.
		/// 4. Arm the ILA debug core trigger using run_hw_ila.
		/// 5. View the captured data from the ILA debug core in the Waveform window of the Vivado
		/// logic analyzer feature using display_hw_ila_data.
		/// 6. Optionally use the VIO debug core to drive control signals and/or view design status signals.
		/// See get_hw_vios for more information.
		/// 7. Optionally use the JTAG-to-AXI Master debug core to run transactions to interact with
		/// various AXI slave cores in your design. See get_hw_axis for more information.
		/// This command returns a list of ILA debug core objects on the device, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 713
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'hw_ila' objects of these types: 'hw_device'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_ila' objects against patterns. Default: *</param>
		/// <returns>hardware ILAs</returns>
		public virtual SimpleTCLCommand get_hw_ilas(string of_objects = null, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_hw_ilas [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_hw_ilas")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get list of hardware Migs cores.
		///
		///
		/// TCL Syntax: get_hw_migs [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Returns the hw_mig objects on the current hardware device.
		/// Memory IP included in the Xilinx IP catalog are used to generate memory controllers and
		/// interfaces for Xilinx® devices. Memory IP includes different IP cores from the Xilinx IP catalog
		/// depending on the device architecture and memory interface specified. Refer to Zynq-7000 SoC
		/// and 7 Series Devices Memory Interface Solutions (UG586), or UltraScale Architecture-Based FPGAs
		/// Memory Interface Solutions (PG150), for details of the available memory IP.
		/// When added to a design, the memory IP needs to be implemented into the design. This occurs
		/// after the design is synthesized, during the design optimization phase of implementation, or
		/// opt_design, or can be done manually with the implement_mig_cores command.
		/// A memory controller can be debug enabled when added into the design from the Xilinx IP
		/// catalog. In the Vivado logic analyzer, or the Vivado Lab Edition, memory controllers implemented
		/// into a design are associated with hw_mig objects, one hw_mig object per debug-enabled memory
		/// controller. The hw_mig object will have all the properties needed to get the calibration status and
		/// draw the per-bit eye margin views.
		/// In the Vivado logic analyzer, or Vivado Lab Edition, the hw_mig object lets you verify the
		/// calibration and read window margins in your memory interface design. You can use the hardware
		/// manager GUI to check the calibration status, verify the read margin for both rising and falling
		/// edges of the clock or DQS. You can also use an ILA core to verify the data integrity for the read
		/// and write operations.
		/// This command returns a list of hw_mig objects on the current hardware device, or returns an
		/// error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 717
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'hw_mig' objects of these types: 'hw_server hw_target hw_device'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_mig' objects against patterns. Default: *</param>
		/// <returns>hardware migs cores</returns>
		public virtual SimpleTCLCommand get_hw_migs(string of_objects = null, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_hw_migs [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_hw_migs")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of hardware probes.
		///
		///
		/// TCL Syntax: get_hw_probes [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Returns the hw_probe objects in the Hardware Manager that are defined on signals in the design,
		/// or that are assigned to the specified ILA or VIO debug cores.
		/// You can add ILA and VIO debug cores in the RTL source files of a design by customizing the core
		/// from the IP catalog, or add ILA debug cores into the synthesized netlist using the
		/// create_debug_core command.
		/// Signals in the design can be probed to monitor signal values and track hardware events on the
		/// FPGA device. Debug probes can be added to ILA debug cores in the synthesized netlist design
		/// using the create_debug_port command, and connected to signals in the design using
		/// connect_debug_port. Probes can only be added to VIO debug cores when the IP core is
		/// customized, or re-customized, from the IP catalog, and signals connected to it in the RTL design.
		/// Refer to the Vivado Design Suite User Guide: Vivado Programming and Debugging (UG908) for more
		/// information on adding ILA and VIO debug cores and signal probes to the design.
		/// Debug cores and probes are written to a probes file (.ltx) with write_debug_probes, and
		/// associated with the hardware device, along with the bitstream file (.bit), using the PROBES.FILE
		/// and PROGRAM.FILE properties of the hw_device object. The hardware device is programmed
		/// with this information using the program_hw_devices command.
		/// This command returns a list of debug probe objects on the device, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 721
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'hw_probe' objects of these types: 'hw_interface hw_ila hw_vio'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_probe' objects against patterns. Default: *</param>
		/// <returns>hardware probes</returns>
		public virtual SimpleTCLCommand get_hw_probes(string of_objects = null, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_hw_probes [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_hw_probes")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of hardware servers.
		///
		///
		/// TCL Syntax: get_hw_servers [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// IMPORTANT! You must use the open_hw command to open the Hardware Manager in the Vivado Design
		/// Suite before using this command.
		/// This command returns hardware server objects that are connected to the current instance of the
		/// Vivado Design Suite through the use of the connect_hw_server command.
		/// Hardware servers are instances of the Xilinx hardware server (hw_server) application running
		/// remotely, or on the local machine. The hardware server manages connections to a hardware
		/// target, for instance a hardware board containing a JTAG chain of one or more Xilinx devices to be
		/// used for programming and debugging your FPGA design.
		/// This command returns a list of connected hardware server objects.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 725
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_server' objects against patterns. Default: *</param>
		/// <returns>hardware servers</returns>
		public virtual SimpleTCLCommand get_hw_servers(bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_hw_servers [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_hw_servers")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get list of hardware SIO GT commons.
		///
		///
		/// TCL Syntax: get_hw_sio_commons [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Returns the QPLL objects, hw_sio_commons, defined on the IBERT debug core on the current
		/// hardware device.
		/// For each serial transceiver channel, there is a ring PLL called Channel PLL (CPLL). In Xilinx
		/// UltraScale and 7 series FPGAs, the high-speed transceivers have an additional common or shared
		/// PLL per quad, or Quad PLL (QPLL). This QPLL is a shared LC PLL to support high speed, high
		/// performance, and low power multi-lane applications.
		/// On the device, the GTXE2_CHANNEL component has the serial transceiver and CPLL units and
		/// the GTXE2_COMMON has the QPLL unit.
		/// This command returns a list of QPLL objects on the device as hw_sio_common objects, or returns
		/// an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 728
		/// </summary>
		/// <param name="of_objects">
		/// (Optional)
		/// Get 'hw_sio_common' objects of these types: 'hw_server
		/// hw_target hw_device hw_sio_ibert hw_sio_gtgroup
		/// hw_sio_pll'.
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_sio_common' objects against patterns. Default: *</param>
		/// <returns>hardware SIO GT commons</returns>
		public virtual SimpleTCLCommand get_hw_sio_commons(string of_objects = null, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_hw_sio_commons [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_hw_sio_commons")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get list of hardware SIO GT groups.
		///
		///
		/// TCL Syntax: get_hw_sio_gtgroups [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Returns the groups of GTs, hw_sio_gtgroups, as they relate to the quads that are in use on the
		/// IBERT debug core on the current hardware device.
		/// GT groups, relate to the IO Banks on the hardware device, with the number of available banks
		/// and GT pins determined by the target device. On the Kintex-7 xc7k325 part, for example, there
		/// are four quads, each containing four differential GT pins, and two differential REFCLK pins. Each
		/// GT pin has its own transmitter, TX, and receiver, RX. Quads can also include one shared PLL per
		/// quad, or Quad PLL. The quads are defined on the IBERT debug core, and can be customized with
		/// a number of user settings when the IBERT is added into the RTL design. Refer to the LogiCORE IP
		/// Integrated Bit Error Ratio Tester (IBERT) for 7 Series GTX Transceivers v3.0 (PG132)or to 7 Series
		/// FPGAs GTX/GTH Transceivers User Guide (UG476) or UltraScale Architecture GTH Transceivers User
		/// Guide (UG576) for more information.
		/// This command returns a list of GT group objects on the IBERT debug core, or returns an error if it
		/// fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 731
		/// </summary>
		/// <param name="of_objects">
		/// (Optional)
		/// Get 'hw_sio_gtgroup' objects of these types: 'hw_server
		/// hw_target hw_device hw_sio_ibert hw_sio_common
		/// hw_sio_pll hw_sio_gt hw_sio_tx hw_sio_rx'.
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_sio_gtgroup' objects against patterns. Default: *</param>
		/// <returns>hardware SIO GT groups.</returns>
		public virtual SimpleTCLCommand get_hw_sio_gtgroups(string of_objects = null, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_hw_sio_gtgroups [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_hw_sio_gtgroups")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get list of hardware SIO GTs.
		///
		///
		/// TCL Syntax: get_hw_sio_gts [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Returns the Gigabit Transceiver objects (GTs), hw_sio_gt, that are in use on the IBERT debug core
		/// on the current hardware device.
		/// The customizable LogiCORE™ IP Integrated Bit Error Ratio Tester (IBERT) core for Xilinx® FPGAs
		/// is designed for evaluating and monitoring the Gigabit Transceivers (GTs). The IBERT core enables
		/// in-system serial I/O validation and debug, letting you measure and optimize your high-speed
		/// serial I/O links in your FPGA-based system. Refer to the LogiCORE IP Integrated Bit Error Ratio
		/// Tester (IBERT) for 7 Series GTX Transceivers v3.0 (PG132)or to 7 Series FPGAs GTX/GTH Transceivers
		/// User Guide (UG476) or UltraScale Architecture GTH Transceivers User Guide (UG576) for more
		/// information.
		/// Using the IBERT debug core you can configure and tune the GT transmitters and receivers
		/// through the Dynamic Reconfiguration Port (DRP) port of the GTX transceiver. This lets you
		/// change property settings on the GTs, as well as registers that control the values on the ports.
		/// This command returns a list of GT objects on the IBERT debug core, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 735
		/// </summary>
		/// <param name="of_objects">
		/// (Optional)
		/// Get 'hw_sio_gt' objects of these types: 'hw_server hw_target
		/// hw_device hw_sio_ibert hw_sio_gtgroup hw_sio_pll hw_sio_tx
		/// hw_sio_rx hw_sio_link'.
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_sio_gt' objects against patterns. Default: *</param>
		/// <returns>hardware SIO GTs</returns>
		public virtual SimpleTCLCommand get_hw_sio_gts(string of_objects = null, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_hw_sio_gts [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_hw_sio_gts")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get list of hardware SIO IBERT cores.
		///
		///
		/// TCL Syntax: get_hw_sio_iberts [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Returns the Integrated Bit Error Ratio Tester (IBERT) debug core objects, hw_sio_ibert, defined
		/// on the current hardware device.
		/// The customizable LogiCORE™ IP Integrated Bit Error Ratio Tester (IBERT) core for Xilinx® FPGAs
		/// is designed for evaluating and monitoring the Gigabit Transceivers (GTs). The IBERT core enables
		/// in-system serial I/O validation and debug, letting you measure and optimize your high-speed
		/// serial I/O links in your FPGA-based system. Refer to the LogiCORE IP Integrated Bit Error Ratio
		/// Tester (IBERT) for 7 Series GTX Transceivers v3.0 (PG132) for more information.
		/// The IBERT debug core lets you configure and control the major features of GTs on the device,
		/// including:
		/// • TX pre-emphasis and post-emphasis
		/// • TX differential swing
		/// • RX equalization
		/// • Decision Feedback Equalizer (DFE)
		/// • Phase-Locked Loop (PLL) divider settings
		/// You can use the IBERT core when you are interested in addressing a range of in-system debug
		/// and validation problems; from simple clocking and connectivity issues to complex margin analysis
		/// and channel optimization issues.
		/// This command returns a list of IBERT debug core objects on the device, or returns an error if it
		/// fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 738
		/// </summary>
		/// <param name="of_objects">
		/// (Optional)
		/// Get 'hw_sio_ibert' objects of these types: 'hw_server
		/// hw_target hw_device hw_sio_gtgroup hw_sio_gt
		/// hw_sio_common hw_sio_pll hw_sio_tx hw_sio_rx hw_sio_link'.
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_sio_ibert' objects against patterns. Default: *</param>
		/// <returns>hardware SIO IBERT cores.</returns>
		public virtual SimpleTCLCommand get_hw_sio_iberts(string of_objects = null, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_hw_sio_iberts [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_hw_sio_iberts")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get list of hardware SIO link groups.
		///
		///
		/// TCL Syntax: get_hw_sio_linkgroups [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Returns the defined groups, or associations of communication links between TX and RX objects
		/// on the GTs of the IBERT debug core defined on the current hardware device.
		/// Vivado Serial I/O analyzer is a link-based analyzer. The links define the communication paths and
		/// protocols between transmitters and receivers of the GigaBit transceivers on the device. Link
		/// groups, or hw_sio_linkgroup objects, let you associate links into related groups, to collectively
		/// configure properties and run scans.
		/// This command returns a list of linkgroups on the IBERT debug core, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 742
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'hw_sio_linkgroup' objects of these types: 'hw_sio_link'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_sio_linkgroup' objects against patterns. Default: *</param>
		/// <returns>hardware SIO link groups</returns>
		public virtual SimpleTCLCommand get_hw_sio_linkgroups(string of_objects = null, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_hw_sio_linkgroups [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_hw_sio_linkgroups")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get list of hardware SIO links.
		///
		///
		/// TCL Syntax: get_hw_sio_links [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Returns the communication links between TX and RX objects on the GTs of the IBERT debug
		/// core defined on the current hardware device.
		/// Vivado Serial I/O analyzer is a link-based analyzer, which lets you link between any transmitter
		/// and receiver within the IBERT design. The links define the communication paths and protocols
		/// between transmitters and receivers of the GigaBit transceivers on the device. You can configure
		/// the links by using the set_property command to specify property values on the link object.
		/// This command returns a list of link objects on the IBERT debug core, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 745
		/// </summary>
		/// <param name="of_objects">
		/// (Optional)
		/// Get 'hw_sio_link' objects of these types: 'hw_server
		/// hw_target hw_device hw_sio_ibert hw_sio_gtgroup hw_sio_gt
		/// hw_sio_tx hw_sio_rx hw_sio_linkgroup'.
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_sio_link' objects against patterns. Default: *</param>
		/// <returns>hardware SIO links</returns>
		public virtual SimpleTCLCommand get_hw_sio_links(string of_objects = null, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_hw_sio_links [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_hw_sio_links")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get list of hardware SIO PLLs.
		///
		///
		/// TCL Syntax: get_hw_sio_plls [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Returns the PLL objects, hw_sio_pll, defined on the IBERT debug core on the current hardware
		/// device.
		/// For each serial transceiver channel, there is a ring PLL called Channel PLL (CPLL). In Xilinx
		/// UltraScale and 7 series FPGAs, the GTX has an additional shared PLL per quad, or Quad PLL
		/// (QPLL). This QPLL is a shared LC PLL to support high speed, high performance, and low power
		/// multi-lane applications.
		/// On the device, the GTXE2_CHANNEL component has the serial transceiver and CPLL units and
		/// the GTXE2_COMMON has the QPLL unit.
		/// This command returns a list of all PLL objects, both CPLLs and QPLLs on the device, or returns an
		/// error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 748
		/// </summary>
		/// <param name="of_objects">
		/// (Optional)
		/// Get 'hw_sio_pll' objects of these types: 'hw_server hw_target
		/// hw_device hw_sio_ibert hw_sio_gtgroup hw_sio_gt
		/// hw_sio_common'.
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_sio_pll' objects against patterns. Default: *</param>
		/// <returns>hardware SIO PLLs</returns>
		public virtual SimpleTCLCommand get_hw_sio_plls(string of_objects = null, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_hw_sio_plls [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_hw_sio_plls")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get list of hardware SIO RXs.
		///
		///
		/// TCL Syntax: get_hw_sio_rxs [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Returns the receiver objects, hw_sio_rx, of the Gigabit Transceivers (GTs) that are in use on the
		/// IBERT debug core on the current hardware device.
		/// On the hardware device, each GT includes an independent receiver, which consists of a PCS and
		/// a PMA. High-speed serial data flows from traces on the board into the PMA of the GTX/GTH
		/// transceiver RX, into the PCS, and finally into the FPGA logic.
		/// This command returns a list of receiver objects on the device, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 751
		/// </summary>
		/// <param name="of_objects">
		/// (Optional)
		/// Get 'hw_sio_rx' objects of these types: 'hw_server hw_target
		/// hw_device hw_sio_ibert hw_sio_gtgroup hw_sio_gt
		/// hw_sio_link'.
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_sio_rx' objects against patterns. Default: *</param>
		/// <returns>hardware SIO RXs</returns>
		public virtual SimpleTCLCommand get_hw_sio_rxs(string of_objects = null, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_hw_sio_rxs [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_hw_sio_rxs")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get list of hardware SIO scans.
		///
		///
		/// TCL Syntax: get_hw_sio_scans [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Returns serial I/O analyzer scan objects for the IBERT debug core.
		/// To analyze the margin of a given link, it is often helpful to run a scan of the link using the
		/// specialized Eye Scan hardware of Xilinx UltraScale devices or 7 Series FPGAs. The Vivado serial
		/// I/O analyzer feature lets you to create, run, and save link scans.
		/// This command returns one or more hw_sio_scan objects, or returns an error if he command fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 754
		/// </summary>
		/// <param name="of_objects">
		/// (Optional)
		/// Get 'hw_sio_scan' objects of these types: 'hw_sio_rx
		/// hw_sio_link hw_sio_sweep'.
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_sio_scan' objects against patterns. Default: *</param>
		/// <returns>hardware SIO scans</returns>
		public virtual SimpleTCLCommand get_hw_sio_scans(string of_objects = null, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_hw_sio_scans [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_hw_sio_scans")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get list of hardware SIO sweeps.
		///
		///
		/// TCL Syntax: get_hw_sio_sweeps [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Return the serial I/O analyzer link sweep objects defined on the IBERT debug core.
		/// To analyze the margin of a given link, it is often helpful to run a scan of the link using the
		/// specialized features of Xilinx UltraScale devices or 7 series FPGAs. It can also be helpful to run
		/// multiple scans on a the link with different configuration settings for the GTs. This can help you
		/// determine which settings are best for your design. The Vivado serial I/O analyzer feature enables
		/// you to define, run, and save link sweeps, or collections of link scans run across a range of values.
		/// This command returns a link sweep object that you can use with the run_hw_sio_sweep
		/// command to run analysis on the specified links, or GT receivers. You can also save the sweep
		/// scan to disk using the write_hw_sio_sweep command.
		/// You can remove the created sweep object using remove_hw_sio_sweep.
		/// This command returns one or more hw_sio_sweep objects, or returns an error if the command
		/// fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 757
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'hw_sio_sweep' objects of these types: 'hw_sio_link hw_sio_scan'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_sio_sweep' objects against patterns. Default: *</param>
		/// <returns>hardware SIO sweeps</returns>
		public virtual SimpleTCLCommand get_hw_sio_sweeps(string of_objects = null, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_hw_sio_sweeps [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_hw_sio_sweeps")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get list of hardware SIO TXs.
		///
		///
		/// TCL Syntax: get_hw_sio_txs [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Returns the transmitter objects, hw_sio_tx, of the Gigabit Transceivers (GTs) that are in use on the
		/// IBERT debug core on the current hardware device.
		/// On the hardware device, each GT includes an independent transmitter, which consists of a PCS
		/// and a PMA. Parallel data flows from the device logic into the FPGA TX interface, through the PCS
		/// and PMA, and then out the TX driver as high-speed serial data.
		/// This command returns a list of transmitter objects on the device, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 761
		/// </summary>
		/// <param name="of_objects">
		/// (Optional)
		/// Get 'hw_sio_tx' objects of these types: 'hw_server hw_target
		/// hw_device hw_sio_ibert hw_sio_gtgroup hw_sio_gt
		/// hw_sio_link'.
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_sio_tx' objects against patterns. Default: *</param>
		/// <returns>hardware SIO TXs</returns>
		public virtual SimpleTCLCommand get_hw_sio_txs(string of_objects = null, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_hw_sio_txs [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_hw_sio_txs")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get the system monitor register value
		///
		///
		/// TCL Syntax: get_hw_sysmon_reg [-quiet] [-verbose] <hw_sysmon> <hexaddress>
		///
		/// Returns the hex value of the system monitor register defined at the specified address of the
		/// specified hw_sysmon object.
		/// The System Monitor (SYSMON) Analog-to-Digital Converter (ADC) is used to measure die
		/// temperature and voltage on the hw_device. The sysmon monitors the physical environment via
		/// on-chip temperature and supply sensors. The ADC can access up to 17 external analog input
		/// channels.
		/// Data for the system monitor is stored in dedicated registers, called status and control registers,
		/// accessible through the hw_sysmon_reg object. Refer to the Register Interface in UltraScale
		/// Architecture System Monitor User Guide (UG580), or 7 Series FPGAs and Zynq-7000 SoC XADC Dual
		/// 12-Bit 1 MSPS Analog-to-Digital Converter User Guide (UG480) for more information on the
		/// addresses of specific system monitor registers.
		/// Although the get_hw_sysmon_reg command lets you directly access the values stored in
		/// registers of the hw_sysmon object, the recommended procedure is to retrieve the values of
		/// registers as formatted properties of the hw_sysmon object. For example, the following code
		/// retrieves the TEMPERATURE on the system monitor as a formatted property of the hw_sysmon
		/// object rather than accessing the hex value of the sysmon register:
		/// set opTemp [get_property TEMPERATURE [get_hw_sysmons]
		/// The get_property command returns the TEMPERATURE as a formatted value in degrees
		/// Celsius, Fahrenheit, or Kelvin as determined by the TEMPERATURE_SCALE property on the
		/// hw_sysmon object.
		/// TIP: You can also be sure the property value on the object is current by issuing the refresh_hw_sysmon
		/// command prior to get_property.
		/// The get_hw_sysmon_reg command returns the unformatted hex value of the hw_sysmon_reg
		/// object on the specified hw_sysmons at the specified address, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 764
		/// </summary>
		/// <param name="hw_sysmon">(Required) hw_sysmon object</param>
		/// <param name="hexaddress">(Required) Hex address to read from</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Register value in Hex.</returns>
		public virtual SimpleTCLCommand get_hw_sysmon_reg(string hw_sysmon, string hexaddress, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_hw_sysmon_reg [-quiet] [-verbose] <hw_sysmon> <hexaddress>
			return
				new SimpleTCLCommand("get_hw_sysmon_reg")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_sysmon)
					.RequiredString(hexaddress)
			;
		}
		/// <summary>
		/// Get list of hardware SysMons.
		///
		///
		/// TCL Syntax: get_hw_sysmons [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Returns the Sysmon debug core objects defined on the current hardware device.
		/// The System Monitor (SYSMON) Analog-to-Digital Converter (ADC) is used to measure die
		/// temperature and voltage on the hw_device. The Sysmon monitors the physical environment via
		/// on-chip temperature and supply sensors. The ADC provides a high-precision analog interface for
		/// a range of applications. The ADC can access up to 17 external analog input channels. Refer to
		/// UltraScale Architecture System Monitor User Guide (UG580), or 7 Series FPGAs and Zynq-7000 SoC
		/// XADC Dual 12-Bit 1 MSPS Analog-to-Digital Converter User Guide (UG480) for more information on
		/// a specific device architecture.
		/// The hw_sysmon data is stored in dedicated registers called status registers accessible through the
		/// hw_sysmon_reg object. The values of the system monitor registers can be returned by the
		/// get_hw_sysmon_reg command.
		/// Every device that supports the system monitor will automatically have one or more hw_sysmon
		/// objects created when refresh_hw_device is called. When the hw_sysmon object is created, it
		/// is assigned a property for all the temperature and voltage registers, as well as the control
		/// registers. On the hw_sysmon object, the values assigned to the temperature and voltage registers
		/// are already translated to Celsius/Fahrenheit and Voltage.
		/// Although you can use the get_hw_sysmon_reg command to access the hex values stored in
		/// registers of a system monitor, you can also retrieve values of certain registers as formatted
		/// properties of the hw_sysmon object. For example, the following code retrieves the
		/// TEMPERATURE property of the specified hw_sysmon object rather than directly accessing the
		/// hex value of the register:
		/// set opTemp [get_property TEMPERATURE [get_hw_sysmons]
		/// This command returns a list of hw_sysmon objects on the current or specified hw_device, or
		/// returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 767
		/// </summary>
		/// <param name="of_objects">
		/// (Optional)
		/// Get 'hw_sysmon' objects of these types: 'hw_server
		/// hw_target hw_device'.
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_sysmon' objects against patterns. Default: *</param>
		/// <returns>hardware sysmons</returns>
		public virtual SimpleTCLCommand get_hw_sysmons(string of_objects = null, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_hw_sysmons [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_hw_sysmons")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of hardware targets.
		///
		///
		/// TCL Syntax: get_hw_targets [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Returns the available hardware targets of the connected hardware servers.
		/// The hardware target is a system board containing a JTAG chain of one or more Xilinx devices that
		/// you can program with a bitstream file, or use to debug your design. Connections between
		/// hardware targets on the system board and the Vivado Design Suite are managed by the Xilinx
		/// hardware server application, and the connect_hw_server command. Refer to Vivado Design
		/// Suite User Guide: Programming and Debugging (UG908) for a list of supported JTAG download
		/// cables and devices.
		/// Use the open_hw_target command to open a connection to one of the available hardware
		/// targets. The open target is automatically defined as the current hardware target. Alternatively,
		/// you can define the current target with the current_hw_target command, and then open a
		/// connection to the current target. The Vivado Design Suite directs programming and debug
		/// commands to the open target through the hardware server connection.
		/// This command returns a list of available hardware targets through all connected hardware
		/// servers, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 771
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'hw_target' objects of these types: 'hw_server'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_target' objects against patterns. Default: *</param>
		/// <returns>hardware targets</returns>
		public virtual SimpleTCLCommand get_hw_targets(string of_objects = null, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_hw_targets [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_hw_targets")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of hardware VIOs.
		///
		///
		/// TCL Syntax: get_hw_vios [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Returns the Virtual Input/Output (VIO) debug core objects that are defined on the current
		/// hardware device, hw_device.
		/// The Virtual Input/Output (VIO) debug core can both monitor and drive internal signals on a
		/// programmed Xilinx FPGA in real time. In the absence of physical access to the target hardware,
		/// you can use this debug feature to drive and monitor signals that are present on the physical
		/// device.
		/// The VIO core has hardware probes, hw_probe objects, to monitor and drive specific signals on
		/// the design. Input probes monitor signals as inputs to the VIO core. Output probes drive signals to
		/// specified values from the VIO core. Values on the debug core are driven onto the signals at the
		/// probe using the commit_hw_vio command.
		/// The VIO debug core needs to be instantiated in the RTL code, therefore you need to know what
		/// nets you want monitor and drive prior to debugging the design. The IP catalog provides the VIO
		/// core under the Debug category. Detailed documentation on the VIO core can be found in the
		/// LogiCORE IP Virtual Input/Output Product Guide (PG159).
		/// This command returns a list of VIO debug core objects on the device, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 774
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'hw_vio' objects of these types: 'hw_device'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_vio' objects against patterns. Default: *</param>
		/// <returns>hardware VIOs</returns>
		public virtual SimpleTCLCommand get_hw_vios(string of_objects = null, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_hw_vios [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_hw_vios")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of I/O port interfaces in the current design
		///
		///
		/// TCL Syntax: get_interfaces [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of IO interfaces in the current project that match a specified search pattern. The
		/// default command gets a list of all IO interfaces in the project.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example gets a list of all interfaces in the project:
		/// get_interfaces
		///
		/// See ug835-vivado-tcl-commands.pdf, page 777
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get interfaces of these pins or nets</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match I/O port interfaces against patterns Default: *</param>
		/// <returns>list of interface objects</returns>
		public virtual SimpleTCLCommand get_interfaces(bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_interfaces [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_interfaces")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of IO standards.
		///
		///
		/// TCL Syntax: get_io_standards [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Get a list of IOSTANDARDs available for use on the target device.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example gets a list of differential IOSTANDARDs available for use on the target
		/// device:
		/// get_io_standards -filter {IS_DIFFERENTIAL}
		/// Note: If there are no objects matching the pattern you will get a warning.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 780
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// (Optional)
		/// Get the IO standards of these bels, sites, package_pins,
		/// io_banks, ports.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match IO standards against patterns Default: *</param>
		/// <returns>IO standards</returns>
		public virtual SimpleTCLCommand get_io_standards(bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_io_standards [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_io_standards")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of iobanks.
		///
		///
		/// TCL Syntax: get_iobanks [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of I/O Banks on the target device in the current project that match a specified search
		/// pattern. The default command gets a list of all I/O Banks on the target device.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example returns the I/O Bank of the specified package pin:
		/// get_iobanks -of_objects [get_package_pins H4]
		/// This example returns the GT Banks on the device:
		/// get_iobanks -filter {BANK_TYPE == BT_MGT}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 783
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// (Optional)
		/// Get the iobanks of these package_pins, ports, clock regions,
		/// slrs or sites.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match iobanks against patterns Default: *</param>
		/// <returns>iobanks</returns>
		public virtual SimpleTCLCommand get_iobanks(bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_iobanks [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_iobanks")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of results for IP upgrades during the current project
		///
		///
		/// TCL Syntax: get_ip_upgrade_results [-srcset <arg>] [-quiet] [-verbose] [<objects>...]
		///
		/// Returns the names of the upgrade_log files for the specified IPs.
		/// This command is used by the Vivado IDE to populate the IP Status Report window with
		/// information from the upgrade_log file. You can use the command to quickly obtain the
		/// upgrade_log file name, and then use the appropriate file commands, to read or display the
		/// contents.
		/// This command returns the upgrade_log file names of the specified IP objects, or returns an error
		/// if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 786
		/// </summary>
		/// <param name="srcset">
		/// (Optional)
		/// (Optional) Specifies the source file set containing the
		/// upgraded IP Default: The current source fileset Values:
		/// Source set name
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">
		/// (Optional)
		/// IP to be upgraded Values: IP instance(s) within the design,
		/// as returned by 'get_ips <instance name>' or 'get_bd_cells
		/// <cell name>'
		/// </param>
		/// <returns>list of IP upgrade results</returns>
		public virtual SimpleTCLCommand get_ip_upgrade_results(string srcset = null, bool? quiet = null, bool? verbose = null, string objects = null)
		{
			// TCL Syntax: get_ip_upgrade_results [-srcset <arg>] [-quiet] [-verbose] [<objects>...]
			return
				new SimpleTCLCommand("get_ip_upgrade_results")
					.OptionalNamedString("srcset", srcset)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(objects)
			;
		}
		/// <summary>
		/// Get a list of IP from the current IP Catalog
		///
		///
		/// TCL Syntax: get_ipdefs [-name] [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-all] [-quiet] [-verbose] [<patterns>...]
		///
		/// Get a list of IP cores defined in the IP catalog of the current project, based on the specified
		/// search pattern. The default is to return all IP cores defined in the Vivado tools IP catalog.
		/// By default, the search is based on the VLNV property of the IP cores in the catalog. You can
		/// specify the -name option to search on the display name of IP cores instead.
		///
		/// The following example returns a list of all IP cores with NAME property matching the specified
		/// pattern:
		/// get_ipdefs -filter {NAME=~*agilent*}
		/// TIP: The filter operator '=~' loosely matches the specified pattern.
		/// The following example returns a list of all AXI compliant IP cores:
		/// get_ipdefs -filter {IS_AXI==1}
		/// The following example returns IP from both the Vivado tools standard IP catalog and the IP
		/// integrator IP catalog:
		/// get_ipdefs -all *axi_interconnect*
		/// The following example filters the above results with the DESIGN_TOOL_CONTEXTS property to
		/// return only the IP integrator IP:
		/// get_ipdefs -all *axi_interconnect* -filter {DESIGN_TOOL_CONTEXTS =~*IPI*}
		/// TIP: By filtering on the DESIGN_TOOL_CONTEXTS property, you can identify IP from the IP integrator catalog
		/// instead of the Vivado tools standard catalog.
		/// In some cases, where multiple versions of an IP are returned, you can also filter on the
		/// UPGRADE_VERSIONS property to get as specific version or the latest IP version, as shown in the
		/// following example:
		/// get_ipdefs -all *axi_interconnect* -filter {UPGRADE_VERSIONS == ""}
		/// TIP: The {UPGRADE_VERSIONS == ""} filter returns IP defs that have no upgrade, and so are the latest version.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 788
		/// </summary>
		/// <param name="name">(Optional) Match the pattern against IP display name instead of VLNV</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get the IPDefs of the objects specified: IP inst or XCI file.</param>
		/// <param name="all">(Optional) Return hidden IP</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// (Optional)
		/// The patterns to match against Default: * Values: The default
		/// search pattern is the wildcard *, or .* when -regexp is
		/// specified.
		/// </param>
		/// <returns>List of Catalog IP objects</returns>
		public virtual SimpleTCLCommand get_ipdefs(bool? name = null, bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, bool? all = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_ipdefs [-name] [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-all] [-quiet] [-verbose] [<patterns>...]
			return
				new SimpleTCLCommand("get_ipdefs")
					.Flag("name", name)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("all", all)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of IPs in the current design
		///
		///
		/// TCL Syntax: get_ips [-regexp] [-nocase] [-all] [-filter <arg>] [-exclude_bd_ips] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
		///
		/// Get a list of IP cores in the current project based on the specified search pattern. The default
		/// command returns a list of all IPs in the project.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example returns a list of IP cores with names beginning with the string "EDK":
		/// get_ips EDK*
		///
		/// See ug835-vivado-tcl-commands.pdf, page 792
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="all">(Optional) Include subcore IP in search</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="exclude_bd_ips">(Optional) Exclude all IP owned by a block design.</param>
		/// <param name="of_objects">(Optional) Get 'ip' objects of these types: 'ip file'.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// (Optional)
		/// Match IP names against patterns Default: * Values: The
		/// default search pattern is the wildcard *, or .* when -regexp
		/// is specified.
		/// </param>
		/// <returns>list of IP objects</returns>
		public virtual SimpleTCLCommand get_ips(bool? regexp = null, bool? nocase = null, bool? all = null, string filter = null, bool? exclude_bd_ips = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_ips [-regexp] [-nocase] [-all] [-filter <arg>] [-exclude_bd_ips] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
			return
				new SimpleTCLCommand("get_ips")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.Flag("all", all)
					.OptionalNamedString("filter", filter)
					.Flag("exclude_bd_ips", exclude_bd_ips)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of Library Cells
		///
		///
		/// TCL Syntax: get_lib_cells [-regexp] [-filter <arg>] [-nocase] [-include_unsupported] [-of_objects <args>] [-quiet] [-verbose] <patterns>
		///
		/// Get a list of cells in the library for the target part of the current design. Use this command to
		/// query and look for a specific library cell, or type of cell and to get the properties of the cells.
		/// This command requires a hierarchical name which includes the library name as well as the cell
		/// name: lib_name/cell_name.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example gets the number of the cells in the library for the target part in the current
		/// design, and then gets the number of AND type cells in that library:
		/// llength [get_lib_cells [get_libs]/*]
		/// 795
		/// llength [get_lib_cells [get_libs]/AND*]
		/// 18
		/// The following example gets the library cell for the specified cell object:
		/// get_lib_cells -of_objects [lindex [get_cells] 1]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 795
		/// </summary>
		/// <param name="patterns">(Required) Match library cell names against patterns.</param>
		/// <param name="regexp">(Optional) Patterns are regular expressions.</param>
		/// <param name="filter">(Optional) Filter list with expression.</param>
		/// <param name="nocase">
		/// (Optional)
		/// Perform case-insensitive matching when a pattern has been
		/// specified. This argument applies to the use of -regexp only.
		/// </param>
		/// <param name="include_unsupported">(Optional) Include test-only library cells.</param>
		/// <param name="of_objects">
		/// (Optional)
		/// Get the library cells of the objects passed in here. Valid
		/// objects are cells or instances (ie, get_cells), cell pins (ie,
		/// get_pins) and library pins (ie, get_lib_pins).
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of library cells</returns>
		public virtual SimpleTCLCommand get_lib_cells(string patterns, bool? regexp = null, string filter = null, bool? nocase = null, bool? include_unsupported = null, string of_objects = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_lib_cells [-regexp] [-filter <arg>] [-nocase] [-include_unsupported] [-of_objects <args>] [-quiet] [-verbose] <patterns>
			return
				new SimpleTCLCommand("get_lib_cells")
					.Flag("regexp", regexp)
					.OptionalNamedString("filter", filter)
					.Flag("nocase", nocase)
					.Flag("include_unsupported", include_unsupported)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(patterns)
			;
		}
		/// <summary>
		/// Get a list of Library Cell Pins
		///
		///
		/// TCL Syntax: get_lib_pins [-regexp] [-filter <arg>] [-nocase] [-of_objects <args>] [-quiet] [-verbose] <patterns>
		///
		/// Gets a list of the pins on a specified cell of the cell library for the target part in the current design.
		/// Note: This command requires a hierarchical name which includes the library name and cell name as well as
		/// the pins: lib_name/cell_name/pins.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example gets a list of all library cell pins:
		/// get_lib_pins xt_virtex6/AND2/*
		/// The following example gets a list of all pins, of all cells in the cell library for the target device:
		/// get_lib_pins [get_libs]/*/*
		///
		/// See ug835-vivado-tcl-commands.pdf, page 798
		/// </summary>
		/// <param name="patterns">
		/// (Required)
		/// Match library cell pin names against patterns of the form
		/// <library cell pattern>/<library pin pattern>.
		/// </param>
		/// <param name="regexp">(Optional) Patterns are regular expressions</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="nocase">
		/// (Optional)
		/// Perform case-insensitive matching when a pattern has been
		/// specified. This argument applies to the use of -regexp only.
		/// </param>
		/// <param name="of_objects">
		/// (Optional)
		/// Get the library cell pins of the objects passed in here. Valid
		/// objects are cells or instances (ie, get_cells), cell pins (ie,
		/// get_pins) and library cells (ie get_lib_cells).
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of library cell pins</returns>
		public virtual SimpleTCLCommand get_lib_pins(string patterns, bool? regexp = null, string filter = null, bool? nocase = null, string of_objects = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_lib_pins [-regexp] [-filter <arg>] [-nocase] [-of_objects <args>] [-quiet] [-verbose] <patterns>
			return
				new SimpleTCLCommand("get_lib_pins")
					.Flag("regexp", regexp)
					.OptionalNamedString("filter", filter)
					.Flag("nocase", nocase)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(patterns)
			;
		}
		/// <summary>
		/// Get a list of Libraries
		///
		///
		/// TCL Syntax: get_libs [-regexp] [-filter <arg>] [-nocase] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets the cell library for the target device in the current design. There is a library for each device
		/// family because there are primitives that may be available in one device family but not in others.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example gets the cell library for the target part:
		/// get_libs
		///
		/// See ug835-vivado-tcl-commands.pdf, page 801
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are regular expressions</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="nocase">
		/// (Optional)
		/// Perform case-insensitive matching when a pattern has been
		/// specified. This argument applies to the use of -regexp only.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match library names against patterns. Default: *</param>
		/// <returns>list of libraries</returns>
		public virtual SimpleTCLCommand get_libs(bool? regexp = null, string filter = null, bool? nocase = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_libs [-regexp] [-filter <arg>] [-nocase] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_libs")
					.Flag("regexp", regexp)
					.OptionalNamedString("filter", filter)
					.Flag("nocase", nocase)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of macros in the current design
		///
		///
		/// TCL Syntax: get_macros [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of macros in the current design that match a specified search pattern. The default
		/// command returns a list of all macros in the design.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example returns the properties currently assigned to the macro matching the
		/// specified search pattern:
		/// report_property [get_macro *Macro1]
		/// Note: If there are no macros matching the pattern you will get a warning.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 804
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get macros of these cells</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match macro names against patterns Default: *</param>
		/// <returns>list of macro objects</returns>
		public virtual SimpleTCLCommand get_macros(bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_macros [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_macros")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get marked objects
		///
		///
		/// TCL Syntax: get_marked_objects [-rgb <args>] [-color <arg>] [-quiet] [-verbose]
		///
		/// Get the marked objects in the current design open in the Vivado IDE. Objects can be marked
		/// with the mark_objects command.
		/// You can get all marked objects in the design, or specify marked objects by color, or by RGB value.
		/// Note: This Tcl command works only when Vivado is run in GUI mode.
		///
		/// The following example gets all the marked objects in the current design:
		/// get_marked_objects
		/// The following example gets the object in the current design that are marked in the specified
		/// color:
		/// get_marked_objects -color yellow
		///
		/// See ug835-vivado-tcl-commands.pdf, page 807
		/// </summary>
		/// <param name="rgb">(Optional) RGB color index list</param>
		/// <param name="color">(Optional) Valid values are red green blue magenta yellow cyan and orange</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of marked objects</returns>
		public virtual SimpleTCLCommand get_marked_objects(string rgb = null, string color = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_marked_objects [-rgb <args>] [-color <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("get_marked_objects")
					.OptionalNamedString("rgb", rgb)
					.OptionalNamedString("color", color)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Get a list of Methodology rule check objects
		///
		///
		/// TCL Syntax: get_methodology_checks [-regexp] [-nocase] [-filter <arg>] [-abbrev <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of the currently defined methodology checks. This list includes the factory defined
		/// methodology checks for process and timing.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following command gets a list of all synthesis methodology checks:
		/// get_methodology_checks SYNTH*
		///
		/// See ug835-vivado-tcl-commands.pdf, page 809
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="abbrev">(Optional) Get the largest ID for this abbrev</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'rule_check' objects against patterns. Default: *</param>
		/// <returns>list of Methodology rule_check objects</returns>
		public virtual SimpleTCLCommand get_methodology_checks(bool? regexp = null, bool? nocase = null, string filter = null, string abbrev = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_methodology_checks [-regexp] [-nocase] [-filter <arg>] [-abbrev <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_methodology_checks")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("abbrev", abbrev)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of Methodology violations from a previous report_methodology run
		///
		///
		/// TCL Syntax: get_methodology_violations [-name <arg>] [-regexp] [-filter <arg>] [-nocase] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of violation objects found in the design when the report_methodology command
		/// is run. The properties of individual violation objects can be queried using report_property or
		/// list_property commands for details of the violation.
		/// Violation objects are associated with the cells, nets, pins, or ports in the current design, or sites
		/// on the current device. The design objects associated with a methodology violation object can be
		/// obtained using the -of_objects option of the appropriate get_* command, such as
		/// get_cells, or get_nets for instance.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example reports the methodology violations found in the current design, then
		/// returns a list of all those violations:
		/// report_methodology
		/// get_methodology_violations
		/// The following example generates list of violations in the named methodology report, and then
		/// gets the pins associated with any violations found:
		/// report_methodology -name method_1
		/// get_pins -of_objects [get_methodology_violations -name method_1]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 812
		/// </summary>
		/// <param name="name">(Optional) Get the results with this name</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// (Optional)
		/// Match methodology_violations against patterns Default: *
		/// Values: The default search pattern is the wildcard *, or .*
		/// when -regexp is specified.
		/// </param>
		/// <returns>list of Methodology violation objects</returns>
		public virtual SimpleTCLCommand get_methodology_violations(string name = null, bool? regexp = null, string filter = null, bool? nocase = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_methodology_violations [-name <arg>] [-regexp] [-filter <arg>] [-nocase] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_methodology_violations")
					.OptionalNamedString("name", name)
					.Flag("regexp", regexp)
					.OptionalNamedString("filter", filter)
					.Flag("nocase", nocase)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Returns the current message count, limit, or the message configuration rules previously defined
		/// by the set_msg_config command.
		///
		///
		/// TCL Syntax: get_msg_config [-id <arg>] [-severity <arg>] [-rules] [-limit] [-count] [-quiet] [-verbose]
		///
		/// Returns the current message limit or count applied to a specified message ID or severity, or
		/// returns all message configuration rules defined in the current project. Message configuration
		/// rules are defined using the set_msg_config command.
		/// When used with -count this command will display the total number of messages that have
		/// been generated with the matching message id, or for the specified severity.
		/// IMPORTANT! The get_msg_config command reports the message count for the original CPU process from
		/// which Vivado was launched. Any sub-processes that the Vivado Design Suite launches, such as sub-processes
		/// used by the launch_runs command to launch synthesis and implementation runs, will not be reported in the
		/// message count. This can create confusion when the message count returned by get_msg_config -count
		/// is different from what is displayed in the Vivado IDE for instance, or different from what you expect. For this
		/// reason, the -count option is best used for non-project based designs.
		/// When used with -limit this command will display the current limit of messages with the
		/// matching message id, or for the specified severity.
		/// When used with -rules, it will display a table of all message configuration rules currently in
		/// effect.
		/// Note: You can only return the limit, the count, or the rules in a single get_msg_config command. An
		/// error is returned if more than one action is attempted.
		///
		/// The following example gets the current count of the specified INFO message:
		/// get_msg_config -id "Common 17-81" -count
		/// The following example returns the message configuration rules in the current project:
		/// get_msg_config -rules
		/// This example changes the severity of messages with the specified message ID, gets the current
		/// message configuration rules, and then shows two different command forms to reset the specific
		/// rule and restore the message:
		/// set_msg_config -id "Common 17-361" -severity INFO -new_severity WARNING
		/// get_msg_config -rules
		/// ---------------------
		/// Message control rules currently in effect are:
		/// Rule Name Rule Current
		/// Message Count
		/// 1 set_msg_config -ruleid {1} -id {Common 17-361} -severity {INFO} -
		/// new_severity {WARNING} 0
		/// ---------------------
		/// reset_msg_config -id "Common 17-361" -default_severity
		/// reset_msg_config -ruleid {1}
		/// TIP: In the preceding example, only one of the reset_msg_config commands is needed to reset the
		/// message.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 815
		/// </summary>
		/// <param name="id">
		/// (Optional)
		/// The message id to match. Should be used in conjunction
		/// with -limit or -count Default: empty
		/// </param>
		/// <param name="severity">
		/// (Optional)
		/// The message severity to match. Should be used in
		/// conjunction with -limit or -count Default: empty
		/// </param>
		/// <param name="rules">
		/// (Optional)
		/// Show a table displaying all message control rules for the
		/// current project
		/// </param>
		/// <param name="limit">
		/// (Optional)
		/// Show the limit for the number of messages matching either
		/// -id or -severity that will be displayed
		/// </param>
		/// <param name="count">
		/// (Optional)
		/// Show the number of messages matching either -id or -
		/// severity that have been displayed
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand get_msg_config(string id = null, string severity = null, bool? rules = null, bool? limit = null, bool? count = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_msg_config [-id <arg>] [-severity <arg>] [-rules] [-limit] [-count] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("get_msg_config")
					.OptionalNamedString("id", id)
					.OptionalNamedString("severity", severity)
					.Flag("rules", rules)
					.Flag("limit", limit)
					.Flag("count", count)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Get the routed or estimated delays in picoseconds on a net from the driver to each load pin.
		///
		///
		/// TCL Syntax: get_net_delays -of_objects <args> [-regexp] [-nocase] [-patterns <arg>] [-filter <arg>] [-to <args>] [-interconnect_only] [-quiet] [-verbose]
		///
		/// Get delay objects for the specified nets in the current design, from the driver to each load pin, or
		/// to specified load pins, through specific pins.
		/// The delay object contains properties defining the maximum and minimum delays for the fast and
		/// slow process corners. Use the get_property command to extract the property of interest from
		/// the delay object. Delay property values on the delay object are specified in picoseconds.
		/// TIP: In most cases the Vivado tools return delay values specified in nanoseconds, but the delay object uses
		/// picoseconds.
		/// The values returned are calculated or estimated depending upon whether the net is routed.
		/// Delay values can include the actual delay of routed interconnect, or estimated net delays for
		/// unrouted nets. The net delay can also include delay through logic elements or device sites, or just
		/// include the interconnect delay.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		/// The get_net_delays command returns the delay objects for the specified nets, or returns an
		/// error if it fails.
		///
		/// The following example gets the interconnect delay values for the specified net, and returns it in
		/// the form of a delay object:
		/// report_property -all [lindex [get_net_delays -interconnect_only \
		/// -of_objects [get_nets control_reg[*]]] 16 ]
		/// TIP: The FAST_MAX, FAST_MIN, SLOW_MAX, and SLOW_MIN properties on the delay object are reported in
		/// picoseconds.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 818
		/// </summary>
		/// <param name="of_objects">(Required) Get 'net_delay' objects of these types: 'net'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="patterns">(Optional) Match the 'net_delay' objects against patterns. Default: *</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="to">(Optional) Get the delay of the net to the given terminal(s) or port(s).</param>
		/// <param name="interconnect_only">
		/// (Optional)
		/// Include only interconnect delays. The default is to include
		/// the intra-site delay.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>net_delays</returns>
		public virtual SimpleTCLCommand get_net_delays(string of_objects, bool? regexp = null, bool? nocase = null, string patterns = null, string filter = null, string to = null, bool? interconnect_only = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_net_delays -of_objects <args> [-regexp] [-nocase] [-patterns <arg>] [-filter <arg>] [-to <args>] [-interconnect_only] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("get_net_delays")
					.RequiredNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("patterns", patterns)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("to", to)
					.Flag("interconnect_only", interconnect_only)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Get a list of nets in the current design
		///
		///
		/// TCL Syntax: get_nets [-hsc <arg>] [-hierarchical] [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-match_style <arg>] [-top_net_of_hierarchical_group] [-segments] [-boundary_type <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of nets in the current design that match a specified search pattern. The default
		/// command gets a list of all nets in the current_instance of the open design, as specified by the
		/// current_instance command.
		/// You can use the -hierarchical option to extract nets from the hierarchy of the current
		/// design.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example runs the report_drc command on the current design, returns the list of
		/// violations in the specified DRC report, and then returns any nets associated with the driverless
		/// net rule (NDRV):
		/// report_drc -name drc_1
		/// get_drc_violations -name drc_1
		/// get_nets -of_objects [get_drc_violations -name drc_1 NDRV*]
		/// The following example returns a list of nets that have been marked for debug with the
		/// connect_debug_port command:
		/// get_nets -hier -filter {MARK_DEBUG==1}
		/// This example returns the net attached to the specified hierarchical pin object, then returns the
		/// net segments attached to the pin object, then returns the top-level net segment attached to the
		/// pin object:
		/// get_nets \
		/// -of [get_pins cpuEngine/or1200_cpu/or1200_sprs/esr_reg[9]_i_3/I0]
		/// get_nets -segments \
		/// -of [get_pins cpuEngine/or1200_cpu/or1200_sprs/esr_reg[9]_i_3/I0]
		/// get_nets -top -segments \
		/// -of [get_pins cpuEngine/or1200_cpu/or1200_sprs/esr_reg[9]_i_3/I0]
		/// In the following example, the first command applies the -filter to find nets that have the
		/// IS_INTERNAL property, and then -segment is applied to return the segments of those nets. This
		/// command returns 0 net segments (and a warning). The second command, returns the segments
		/// of all nets, and filters the results to find the segments that have the IS_INTERNAL property, of
		/// which there are 448:
		/// llength [get_nets -segments -filter {IS_INTERNAL}]
		/// WARNING: [Vivado 12-1023] No nets matched for command 'get_nets -segments
		/// -filter IS_INTERNAL'.
		/// 0
		/// llength [filter [get_nets -segments] {IS_INTERNAL}]
		/// 448
		///
		/// See ug835-vivado-tcl-commands.pdf, page 822
		/// </summary>
		/// <param name="hsc">(Optional) Hierarchy separator Default: /</param>
		/// <param name="hierarchical">(Optional) Search level-by-level in current instance</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// (Optional)
		/// Get nets of these pins, ports, cells, timing paths or clocks,
		/// drc violations
		/// </param>
		/// <param name="match_style">(Optional) Style of pattern matching, valid values are ucf, sdc Default: sdc</param>
		/// <param name="top_net_of_hierarchical_group">
		/// (Optional)
		/// Return net segment(s) which belong(s) to the high level of a
		/// hierarchical net
		/// </param>
		/// <param name="segments">(Optional) Return all segments of a net across the hierarchy</param>
		/// <param name="boundary_type">
		/// (Optional)
		/// Return net segment connected to a hierarchical pin which
		/// resides at the same level as the pin (upper) or at the level
		/// below (lower), or both. Valid values are : upper, lower, both
		/// Default: upper
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match net names against patterns Default: *</param>
		/// <returns>list of net objects</returns>
		public virtual SimpleTCLCommand get_nets(string hsc = null, bool? hierarchical = null, bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, string match_style = null, bool? top_net_of_hierarchical_group = null, bool? segments = null, string boundary_type = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_nets [-hsc <arg>] [-hierarchical] [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-match_style <arg>] [-top_net_of_hierarchical_group] [-segments] [-boundary_type <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_nets")
					.OptionalNamedString("hsc", hsc)
					.Flag("hierarchical", hierarchical)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.OptionalNamedString("match_style", match_style)
					.Flag("top_net_of_hierarchical_group", top_net_of_hierarchical_group)
					.Flag("segments", segments)
					.OptionalNamedString("boundary_type", boundary_type)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of nodes in the device.
		///
		///
		/// TCL Syntax: get_nodes [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-uphill] [-downhill] [-flyover] [-from <args>] [-to <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Returns a list of nodes on the device that match a specified search pattern in an open design.
		/// The default command gets a list of all nodes on the device.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example returns the nodes associated with the specified tile:
		/// get_nodes -of_objects [get_tiles CLBLM_R_X11Y158]
		/// The following example returns the nodes downhill from the specified node:
		/// get_nodes -downhill -of_objects [get_nodes LIOB33_SING_X0Y199/IOB_PADOUT0]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 827
		/// </summary>
		/// <param name="of_objects">
		/// (Optional)
		/// Get 'node' objects of these types: 'net tile node bel_pin
		/// site_pin wire pip speed_model'.
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="uphill">
		/// (Optional)
		/// Get the nodes uphill (driver) from the site_pin, pip, node or
		/// tile(s) provided in the -of_objects.
		/// </param>
		/// <param name="downhill">
		/// (Optional)
		/// Get the nodes downhill (loads) from the site_pin, pip, node
		/// or tile(s) provided in the -of_objects.
		/// </param>
		/// <param name="flyover">(Optional) Get the nodes that fly over the given tile(s).</param>
		/// <param name="from">
		/// (Optional)
		/// -from <pip/site pin> Return the nodes beginning at this pip
		/// or site pin. May be used in combination with uphill. Default
		/// is downhill. -all is implied.
		/// </param>
		/// <param name="to">
		/// (Optional)
		/// -to <pip/site pin> Return the nodes ending at this wire or
		/// site pin. May be used in combination with uphill. Default is
		/// downhill. -all is implied.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'node' objects against patterns. Default: *</param>
		/// <returns>nodes</returns>
		public virtual SimpleTCLCommand get_nodes(string of_objects = null, bool? regexp = null, bool? nocase = null, string filter = null, bool? uphill = null, bool? downhill = null, bool? flyover = null, string from = null, string to = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_nodes [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-uphill] [-downhill] [-flyover] [-from <args>] [-to <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_nodes")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("uphill", uphill)
					.Flag("downhill", downhill)
					.Flag("flyover", flyover)
					.OptionalNamedString("from", from)
					.OptionalNamedString("to", to)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of HDL objects in one or more HDL scopes as per the specified pattern
		///
		///
		/// TCL Syntax: get_objects [-filter <arg>] [-r] [-local] [-regexp] [-nocase] [-quiet] [-verbose] [<patterns>...]
		///
		/// Returns a list of HDL objects matching the specified search pattern in one or more HDL scopes.
		/// HDL objects include HDL signals, variables, or constants as defined in the Verilog or VHDL test
		/// bench and source files. An HDL signal includes Verilog wire or reg entities, and VHDL signals.
		/// Examples of HDL variables include Verilog real, realtime, time, and event. HDL constants include
		/// Verilog parameters and localparams, and VHDL generic and constants.
		/// The HDL scope, or scope, is defined by a declarative region in the HDL code such as a module,
		/// function, task, process, or begin-end blocks in Verilog. VHDL scopes include entity/architecture
		/// definitions, block, function, procedure, and process blocks.
		///
		/// Verilog parameters and localparams, and VHDL generic and constants.
		/// The HDL scope, or scope, is defined by a declarative region in the HDL code such as a module,
		/// function, task, process, or begin-end blocks in Verilog. VHDL scopes include entity/architecture
		/// definitions, block, function, procedure, and process blocks.
		/// Arguments
		/// -recursive | -r - (Optional) Apply the command to the current scope, and all sub-scopes of
		/// the current scope.
		/// -regexp - (Optional) Specifies that the search <patterns> are written as regular expressions.
		/// Both search <patterns> and -filter expressions must be written as regular expressions when
		/// this argument is used. Xilinx regular expression Tcl commands are always anchored to the start of
		/// the search string. You can add ".*" to the beginning or end of a search string to widen the search
		/// to include a substring. See http://perldoc.perl.org/perlre.html for help with regular expression
		/// syntax.
		/// Note: The Tcl built-in command regexp is not anchored, and works as a standard Tcl command. For more
		/// information refer to http://www.tcl.tk/man/tcl8.5/TclCmd/regexp.htm.
		/// -nocase - (Optional) Perform case-insensitive matching when a pattern has been specified. This
		/// argument applies to the use of -regexp only.
		/// -filter <args> - (Optional) Filter the results list with the specified expression. The -filter
		/// argument filters the list of objects returned by get_objects based on property values on the
		/// objects. You can find the properties on an object with the report_property or
		/// list_property commands. In the case of the HDL object, "NAME", "SCOPE" and "TYPE" are
		/// some of the properties that can be used to filter results.
		/// The filter search pattern should be quoted to avoid having to escape special characters that may
		/// be found in net, pin, or cell names, or other properties. String matching is case-sensitive and is
		/// always anchored to the start and to the end of the search string. The wildcard “*” character can
		/// be used at the beginning or at the end of a search string to widen the search to include a
		/// substring of the property value.
		/// Note: The filter returns an object if a specified property exists on the object, and the specified pattern
		/// matches the property value on the object. In the case of the "*" wildcard character, this will match a
		/// property with a defined value of "".
		/// For string comparison, the specific operators that can be used in filter expressions are "equal"
		/// (==), "not-equal" (!=), "match" (=~), and "not-match" (!~). Numeric comparison operators <, >, <=,
		/// and >= can also be used. Multiple filter expressions can be joined by AND and OR (&& and ||).
		/// The following gets input pins that do NOT contain the “RESET” substring within their name:
		/// get_pins * -filter {DIRECTION == IN && NAME !~ "*RESET*"}
		/// Boolean (bool) type properties can be directly evaluated in filter expressions as true or not true:
		/// -filter {IS_PRIMITIVE && !IS_LOC_FIXED}
		/// -quiet - (Optional) Execute the command quietly, returning no messages from the command.
		/// The command also returns TCL_OK regardless of any errors encountered during execution.
		/// Note: Any errors encountered on the command-line, while launching the command, will be returned. Only
		/// errors occurring inside the command will be trapped.
		/// -verbose - (Optional) Temporarily override any message limits and return all messages from this
		/// command.
		/// Note: Message limits can be defined with the set_msg_config command.
		/// <patterns> - (Optional) Match HDL objects against the specified patterns. The default pattern is
		/// the wildcard '*' which returns all the children in the current scope. The search pattern can be
		/// defined in two ways:
		/// • <patterns> - Specifies only the search pattern for the objects to get. This method returns all
		/// objects in the current scope (and any sub-scopes when -recursive is used).
		/// • <scope>/<pattern> - Specifies the scope of interest, relative to the current scope, and the
		/// pattern for objects to locate. In this case, the specified <scope>, and any sub-scopes of it if -
		/// recursive is used, are identified starting from the current scope. Then all objects matching
		/// the search <pattern> are identified and returned.
		/// Examples
		/// The following example specifies the current_scope, then gets all HDL objects in that scope:
		/// current_scope ./cpuEngine
		/// get_objects
		/// The following example returns the count of all objects in the current scope, and then returns the
		/// count of all objects in the current scope, and all sub-scopes of it:
		/// llength [get_objects]
		/// 182
		/// llength [get_objects -recursive ]
		/// 2182
		/// The following example specifies the <scope>/<pattern> search pattern as discussed above.
		/// Notice that the cpuEngine scope and various sub-scopes of it are identified, then objects
		/// matching the cl* pattern in those scopes are returned:
		/// get_objects -recursive -filter {type == internal_signal} cpuEngine/cl*
		/// /top/cpuEngine/clk_i
		/// /top/cpuEngine/iwb_biu/clk
		/// /top/cpuEngine/iwb_biu/clmode
		/// /top/cpuEngine/or1200_cpu/clk
		/// ...
		/// /top/cpuEngine/or1200_immu_top/or1200_immu_tlb/itlb_mr_ram/clk
		/// Search the current scope, and all sub-scopes, for any internal signals whose names start with cl
		/// or ma:
		/// get_objects -recursive -filter {type == internal_signal} ma* cl*
		///
		/// See ug835-vivado-tcl-commands.pdf, page 831
		/// </summary>
		/// <param name="filter">
		/// (Optional)
		/// filters <patterns> according to the specified property￾matching expressions
		/// </param>
		/// <param name="r">(Optional) Searches recursively for objects</param>
		/// <param name="local">
		/// (Optional)
		/// Searches objects in the subprogram frame selected for the
		/// current scope
		/// </param>
		/// <param name="regexp">
		/// (Optional)
		/// Search using regular expressions, search design objects
		/// from which to create wave objects by design object name.
		/// The application supplying the design objects determines
		/// how the match is to be performed. Items must be strings.
		/// </param>
		/// <param name="nocase">(Optional) Perform a case insensitive match (only used with regexp)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// (Optional)
		/// Patterns to search for. Default is * where all HDL objects are
		/// returned
		/// </param>
		/// <returns>Returns all the objects found given the specified pattern</returns>
		public virtual SimpleTCLCommand get_objects(string filter = null, bool? r = null, bool? local = null, bool? regexp = null, bool? nocase = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_objects [-filter <arg>] [-r] [-local] [-regexp] [-nocase] [-quiet] [-verbose] [<patterns>...]
			return
				new SimpleTCLCommand("get_objects")
					.OptionalNamedString("filter", filter)
					.Flag("r", r)
					.Flag("local", local)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of package pins
		///
		///
		/// TCL Syntax: get_package_pins [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of the pins on the selected package for the target device. The default command gets a
		/// list of all pins on the package.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example gets a list of the package pins associated with the specified bytegroup of
		/// an UltraScale device:
		/// get_package_pins -of [get_pkgpin_bytegroups BANK44_BYTE0]
		/// The following example gets the number of clock capable (CC) pins on the package:
		/// llength [get_package_pins -filter {IS_CLK_CAPABLE==1}]
		/// Note: If there are no pins matching the pattern you will get a warning.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 835
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// (Optional)
		/// Get the list of package pin objects of these sites, bels,
		/// iobanks, pkgpin_bytegroups, pkgpin_nibbles, or ports.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match list of package pin objects against patterns Default: *</param>
		/// <returns>list of package pin objects</returns>
		public virtual SimpleTCLCommand get_package_pins(bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_package_pins [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_package_pins")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a parameter value
		///
		///
		/// TCL Syntax: get_param [-quiet] [-verbose] <name>
		///
		/// This command gets the currently defined value for a specified tool parameter. These parameters
		/// are user-definable configuration settings that control various behaviors within the tool. Refer to
		/// report_param for a description of what each parameter configures or controls.
		///
		/// The following example returns the current value of the MaxThreads parameter used for multi￾threaded processes:
		/// get_param general.MaxThreads
		///
		/// See ug835-vivado-tcl-commands.pdf, page 838
		/// </summary>
		/// <param name="name">(Required) Parameter name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>parameter value</returns>
		public virtual SimpleTCLCommand get_param(string name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_param [-quiet] [-verbose] <name>
			return
				new SimpleTCLCommand("get_param")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
			;
		}
		/// <summary>
		/// Get a list of PartitionDefs
		///
		///
		/// TCL Syntax: get_partition_defs [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// IMPORTANT! You must first define the project as a Partial Reconfiguration (PR) project by setting the
		/// PR_FLOW property on the project to TRUE, or by using the Tools → Enable Partial Reconfiguration command.
		/// Get a list of all Partition Definition (partitionDef) objects in the current design, or the
		/// partitionDefs that match a specified search pattern.
		/// The Partial Reconfiguration flow lets you create Partition Definitions (partitionDefs) from
		/// hierarchical cells in a design, and to specify reconfigurable modules (RMs) to be assigned to these
		/// partitionDefs to create a unique configurations of the design based on the combination of the
		/// core design and one or more RMs. The PR design flow requires the implementation of each PR
		/// configuration, resulting in partial bitstreams for the RMs, but complete bitstreams for each
		/// integrated configuration. Refer to the Vivado Design Suite User Guide: Dynamic Function eXchange
		/// (UG909) for more information.
		/// This command returns a list of partitionDef objects, or returns an error if the command fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 840
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match partition definition names against patterns Default: *</param>
		/// <returns>list of PartitionDef objects</returns>
		public virtual SimpleTCLCommand get_partition_defs(bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_partition_defs [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_partition_defs")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of parts available in the software
		///
		///
		/// TCL Syntax: get_parts [-regexp] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of parts that match a specified search pattern. The default command gets a list of all
		/// parts.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example gets a list of 7vx485t parts, speed grade -1:
		/// get_parts -filter {DEVICE =~ xc7vx485t* && speed == -1}
		/// The following example gets the number of 7 series and 6 series Virtex parts:
		/// llength [get_parts -regexp {xc7v.* xc6V.*} -nocase]
		/// Note: If there are no parts matching the pattern, the tool will return a warning.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 843
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get the parts of the objects specified: project, design, or run.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// (Optional)
		/// Match part names against patterns Default: * Values: The
		/// default search pattern is the wildcard *, or .* when -regexp
		/// is specified.
		/// </param>
		/// <returns>list of part objects</returns>
		public virtual SimpleTCLCommand get_parts(bool? regexp = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_parts [-regexp] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_parts")
					.Flag("regexp", regexp)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of path groups in the current design
		///
		///
		/// TCL Syntax: get_path_groups [-regexp] [-nocase] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of timing path groups in the current project that match a specified search pattern. The
		/// default command gets a list of all path groups in the design.
		/// Path groups are automatically created when a new clock is created in the design, containing all
		/// paths in that clocks domain. Path groups can also be manually created with the use of the
		/// group_path command.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example gets a list of all the path groups in the design.
		/// get_path_groups
		/// The following example gets all path groups with the string "Clk" somewhere in the name:
		/// get_path_groups *Clk*
		/// Note: If no path groups match the pattern you will get a warning.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 846
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match path group names against patterns Default: *</param>
		/// <returns>list of path groups</returns>
		public virtual SimpleTCLCommand get_path_groups(bool? regexp = null, bool? nocase = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_path_groups [-regexp] [-nocase] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_path_groups")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of Pblocks in the current design
		///
		///
		/// TCL Syntax: get_pblocks [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-include_nested_pblock] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of Pblocks defined in the current project that match a specific pattern. The default
		/// command gets a list of all Pblocks in the project.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example gets a list of all Pblocks in the current project:
		/// get_pblocks
		/// This example gets a list of all Pblocks which do not have a Slice Range defined:
		/// get_pblocks -filter {GRIDTYPES !~ SLICE}
		/// The following example gets the Pblock assignments of the specified cell:
		/// get_pblocks -of [get_cells CORE/BR_TOP/RLD67_MUX/REG_PMBIST_C1]
		/// This example returns the specified Pblock, including any nested Pblocks:
		/// get_pblocks -include_nested_pblocks usbTop
		///
		/// See ug835-vivado-tcl-commands.pdf, page 848
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get Pblocks of these cells</param>
		/// <param name="include_nested_pblock">(Optional) Display the the list of nested pblocks</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match Pblock names against patterns Default: *</param>
		/// <returns>list of Pblock objects</returns>
		public virtual SimpleTCLCommand get_pblocks(bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, bool? include_nested_pblock = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_pblocks [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-include_nested_pblock] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_pblocks")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("include_nested_pblock", include_nested_pblock)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of pins in the current design
		///
		///
		/// TCL Syntax: get_pins [-hsc <arg>] [-hierarchical] [-regexp] [-nocase] [-leaf] [-filter <arg>] [-of_objects <args>] [-match_style <arg>] [-include_replicated_objects] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of pin objects in the current design that match a specified search pattern. The default
		/// command gets a list of all pins in the current_instance of the open design, as specified by the
		/// current_instance command. You can use the -hierarchical option to extract pins from
		/// the hierarchy of the current design.
		/// IMPORTANT! Because there are so many pins in the design, the get_pins command can cause performance
		/// issues, and add significant time to processing design constraints. In many cases, a design constraint that is
		/// written with the get_pins command can be rewritten using the get_cells command, as shown in the
		/// examples, to significantly improve constraint processing and performance of the Vivado tool.
		/// The get_pins command also includes an option to get all replicated pins that are added to a
		/// design during physical optimization, or phys_opt_design. The use of the -
		/// include_replicated_objects option returns the pins on replicated cells when the pins of
		/// an original cell are returned. You can use this option to ensure that constraints or properties that
		/// are applied to the pins of a cell are also applied to the pins of its replicated cells.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example gets a list of pins attached to the specified cells:
		/// get_pins -of_objects [get_cells usb*]
		/// Note: If there are no pins matching the pattern, the tool will return a warning.
		/// This example shows how using get_cells can improve the performance of the get_pins
		/// command:
		/// [get_pins -hier * -filter {NAME=~xx*/yy*}]
		/// can be rewritten as:
		/// [get_pins -filter {REF_PIN_NAME=~yy*} -of [get_cells -hier xx*]]
		/// The following shows how rewriting the set_max_delay constraint can significantly improve
		/// performance:
		/// set_max_delay 15 -from [get_pins -hier \
		/// -filter name=~*/aclk_dpram_reg*/*/CLK] \
		/// -to [get_cells -hier -filter name=~*/bclk_dout_reg*] -datapath_only
		/// can be rewritten as:
		/// set_max_delay 15 -from [get_pins -of \
		/// [get_cells -hier -filter name=~*aclk_dpram_reg*/*] \
		/// -filter {REF_PIN_NAME == CLK}] \
		/// -to [get_pins -of [get_cells -hier -filter {name =~ */bclk_dout_reg*}]
		/// \
		/// -filter {REF_PIN_NAME == D}] -datapath_only
		/// TIP: Although the second command syntax is more complex, the performance gains can be significant.
		/// This example runs the report_drc command on the current design, and then returns any pins
		/// associated with DRC violations:
		/// report_drc -name drc_1
		/// get_pins -of_objects [get_drc_violations]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 851
		/// </summary>
		/// <param name="hsc">(Optional) Hierarchy separator Default: /</param>
		/// <param name="hierarchical">(Optional) Search level-by-level in current instance</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="leaf">(Optional) Get leaf/global pins of nets with -of_objects</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get pins of these cells, nets, timing paths, clocks, drc violations</param>
		/// <param name="match_style">(Optional) Style of pattern matching, valid values are ucf, sdc Default: sdc</param>
		/// <param name="include_replicated_objects">
		/// (Optional)
		/// Include replicated objects when searching for patterns. This
		/// option is valid only when patterns is specified.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match pin names against patterns Default: *</param>
		/// <returns>list of pin objects</returns>
		public virtual SimpleTCLCommand get_pins(string hsc = null, bool? hierarchical = null, bool? regexp = null, bool? nocase = null, bool? leaf = null, string filter = null, string of_objects = null, string match_style = null, bool? include_replicated_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_pins [-hsc <arg>] [-hierarchical] [-regexp] [-nocase] [-leaf] [-filter <arg>] [-of_objects <args>] [-match_style <arg>] [-include_replicated_objects] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_pins")
					.OptionalNamedString("hsc", hsc)
					.Flag("hierarchical", hierarchical)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.Flag("leaf", leaf)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.OptionalNamedString("match_style", match_style)
					.Flag("include_replicated_objects", include_replicated_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of programmable interconnect points (pips) on the current device.
		///
		///
		/// TCL Syntax: get_pips [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-uphill] [-downhill] [-from <args>] [-to <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Programmable interconnect points, or PIPs, provide the physical routing paths on the device used
		/// to connect logic networks. This command returns a list of PIPs on the device that match a
		/// specified search pattern. The command requires a design to be open.
		/// The default command gets a list of all PIPs on the device. However, this is not a recommended
		/// use of the command due to the number of pips on a device. You should specify the -
		/// of_objects argument to limit the number of pips returned.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example returns the PIPs associated with the specified tile:
		/// get_pips -of_object [get_tiles DSP_R_X9Y75]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 856
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get the pips of these sites, tiles, wires, nodes, pips, or nets.</param>
		/// <param name="uphill">(Optional) Get the pips uphill from the provided wire or pip.</param>
		/// <param name="downhill">(Optional) Get the pips downhill from the provided wire or pip.</param>
		/// <param name="from">
		/// (Optional)
		/// -from <pip/site pin> Return the ordered list of pips
		/// beginning at this pip or site pin. May be used in
		/// combination with uphill. Default is downhill. -all is implied.
		/// </param>
		/// <param name="to">
		/// (Optional)
		/// -to <pip/site pin> Return the ordered list of pips ending at
		/// this wire or site pin. May be used in combination with uphill.
		/// Default is downhill. -all is implied.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match pips against patterns Default: *</param>
		/// <returns>pips</returns>
		public virtual SimpleTCLCommand get_pips(bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, bool? uphill = null, bool? downhill = null, string from = null, string to = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_pips [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-uphill] [-downhill] [-from <args>] [-to <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_pips")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("uphill", uphill)
					.Flag("downhill", downhill)
					.OptionalNamedString("from", from)
					.OptionalNamedString("to", to)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of package pin byte groups.
		///
		///
		/// TCL Syntax: get_pkgpin_bytegroups [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of the byte groups on the I/O banks of the current Xilinx UltraScale device.
		/// For 7 series devices, the hierarchy of IO Banks is divided into two object types: I/O Banks and
		/// Package Pins. For Xilinx UltraScale FPGA devices, the IO Bank hierarchy includes two additional
		/// divisions: Byte groups and Nibbles.
		/// The relationships of these objects on an UltraScale device are defined as follows:
		/// • An iobank has 2 or 4 bytegroups.
		/// • Each pkgpin_bytegroup has 2 nibbles, an upper and lower, and has 13 package pins.
		/// • Each pkgpin_nibble has 6 or 7 pins, and is the upper or lower nibble of the pkgpin_bytegroup.
		/// • A package_pin is one pin of an iobank, a pkgpin_bytegroup, or a pkgpin_nibble.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example gets a list of all pins on the package of the target device:
		/// get_pkgpin_bytegroups -of [get_iobanks 44]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 860
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get the pin_group of these package_pins, iobank, site, or port.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match pin_group against patterns Default: *</param>
		/// <returns>pin_group</returns>
		public virtual SimpleTCLCommand get_pkgpin_bytegroups(bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_pkgpin_bytegroups [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_pkgpin_bytegroups")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of pkgpin nibbles.
		///
		///
		/// TCL Syntax: get_pkgpin_nibbles [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Return a list of nibbles, or half-bytes, on the I/O banks of the current Xilinx UltraScale device.
		/// For 7 series devices, the hierarchy of IO Banks is divided into two object types: I/O Banks and
		/// Package Pins. For Xilinx UltraScale FPGA devices, the IO Bank hierarchy includes two additional
		/// divisions: Byte groups and Nibbles.
		/// The relationships of these objects on an UltraScale device are defined as follows:
		/// • An iobank has 2 or 4 bytegroups.
		/// • Each pkgpin_bytegroup has 2 nibbles, an upper and lower, and has 13 package pins.
		/// • Each pkgpin_nibble has 6 or 7 pins, and is the upper or lower nibble of the pkgpin_bytegroup.
		/// • A package_pin is one pin of an iobank, a pkgpin_bytegroup, or a pkgpin_nibble.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example returns the Upper nibbles associated with the specified IO bank:
		/// get_pkgpin_nibbles -of [get_iobanks 44] -filter {TYPE == U}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 863
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get the pin_nibble of these package_pins, iobank, site, or port.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match pin_nibble against patterns Default: *</param>
		/// <returns>pin_nibble</returns>
		public virtual SimpleTCLCommand get_pkgpin_nibbles(bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_pkgpin_nibbles [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_pkgpin_nibbles")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of ports in the current design
		///
		///
		/// TCL Syntax: get_ports [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-match_style <arg>] [-scoped_to_current_instance] [-no_traverse] [-prop_thru_buffers] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of port objects in the current design that match a specified search pattern. The default
		/// command gets a list of all ports in the design.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example gets a list of pins attached to the specified cell:
		/// get_ports -of_objects [lindex [get_cells] 1]
		/// Note: If there are no ports matching the pattern, the tool will return a warning.
		/// The following example runs the report_drc command on the current design, returns the list of
		/// violations in the specified DRC report, and then returns the ports associated with any violations
		/// of the unspecified I/O Standard rule (NSTD):
		/// report_drc -name drc_1
		/// get_drc_violations -name drc_1
		/// get_ports -of_objects [get_drc_violations -name drc_1 NSTD*]
		/// This example specifies a cell for the current instance, returns the pins scoped to the current
		/// instance, and returns the top-level ports connected to those pins:
		/// current_instance [get_cells dac_spi*]
		/// get_ports -scoped_to_current_instance
		/// get_ports -scoped_to_current_instance -prop_thru_buffers
		///
		/// See ug835-vivado-tcl-commands.pdf, page 866
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// (Optional)
		/// Get ports of these nets, instances, sites, clocks, timing paths,
		/// io standards, io banks, package pins, drc violations
		/// </param>
		/// <param name="match_style">(Optional) Style of pattern matching, valid values are ucf, sdc Default: sdc</param>
		/// <param name="scoped_to_current_instance">
		/// (Optional)
		/// Match patterns on instance pins specified using current
		/// instance, and then find top level connected ports.
		/// </param>
		/// <param name="no_traverse">(Optional) Do not traverse to find top level terminals.</param>
		/// <param name="prop_thru_buffers">
		/// (Optional)
		/// Allow propagate through buffers when traversing to find
		/// top level terminals connected to pins of scoped instance.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match port names against patterns Default: *</param>
		/// <returns>list of port objects</returns>
		public virtual SimpleTCLCommand get_ports(bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, string match_style = null, bool? scoped_to_current_instance = null, bool? no_traverse = null, bool? prop_thru_buffers = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_ports [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-match_style <arg>] [-scoped_to_current_instance] [-no_traverse] [-prop_thru_buffers] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_ports")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.OptionalNamedString("match_style", match_style)
					.Flag("scoped_to_current_instance", scoped_to_current_instance)
					.Flag("no_traverse", no_traverse)
					.Flag("prop_thru_buffers", prop_thru_buffers)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Internal TCL task for reporting PPLOCs on pins or nets
		///
		///
		/// TCL Syntax: get_pplocs -nets <args> -pins <args> [-count] [-unlocked] [-locked] [-level <arg>] [-quiet] [-verbose]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 870
		/// </summary>
		/// <param name="nets">(Required) List of nets to report its PPLOCs</param>
		/// <param name="pins">(Required) List of pins to report its PPLOCs</param>
		/// <param name="count">(Optional) Count number of PPLOCs;; Do not report PPLOC or node names.</param>
		/// <param name="unlocked">(Optional) Report unlocked/unfixed PPLOCs only</param>
		/// <param name="locked">(Optional) Report locked/fixed PPLOCs only; use -level to specify locked level.</param>
		/// <param name="level">
		/// (Optional)
		/// Specify locked level; Valid values are placement and routing.
		/// Default: placement
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>PPLOC nodes or number of PPLOCs</returns>
		public virtual SimpleTCLCommand get_pplocs(string nets, string pins, bool? count = null, bool? unlocked = null, bool? locked = null, string level = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_pplocs -nets <args> -pins <args> [-count] [-unlocked] [-locked] [-level <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("get_pplocs")
					.RequiredNamedString("nets", nets)
					.RequiredNamedString("pins", pins)
					.Flag("count", count)
					.Flag("unlocked", unlocked)
					.Flag("locked", locked)
					.OptionalNamedString("level", level)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Get a list of partition configurations
		///
		///
		/// TCL Syntax: get_pr_configurations [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Get a list of PR configuration objects in the current project.
		/// In the Partial Reconfiguration (PR) design flow, the PR configuration lets you specify a
		/// reconfigurable module (RM) to assign to a specific instance of a Partition Definition
		/// (partitionDef). This flow lets you create unique configurations of the design based on the
		/// combination of the core design and one or more RMs. The PR design flow requires the
		/// implementation of each PR configuration, resulting in partial bitstreams for the RMs, but
		/// complete bitstreams for each integrated configuration. Refer to the Vivado Design Suite User
		/// Guide: Dynamic Function eXchange (UG909) for more information.
		/// This command returns a list of PR configuration objects, or returns an error if the command fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 871
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match partition configuration names against patterns Default: *</param>
		/// <returns>list of Configuration objects</returns>
		public virtual SimpleTCLCommand get_pr_configurations(bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_pr_configurations [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_pr_configurations")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of available unisim primitives for a part
		///
		///
		/// TCL Syntax: get_primitives [-regexp] [-nocase] [-filter <arg>] [-part <arg>] [-retarget] [-macro] [-hierarchy] [-quiet] [-verbose] [<patterns>]
		///
		/// Get a list of all supported primitives for the specified device. This command can be used on an
		/// open elaborated, synthesized, or implemented design, in which case it will get the PART from the
		/// current design. You can also specify the -part option to return the primitives for any device.
		/// By default the command always returns native primitives that can be placed on the target part
		/// without modification. The -retarget, -macro, and -hierarchy options add additional
		/// primitives to the list returned.
		///
		/// The following example gets the native primitives for the current part, and includes macro
		/// primitives:
		/// get_primitives -macro
		///
		/// See ug835-vivado-tcl-commands.pdf, page 874
		/// </summary>
		/// <param name="patterns">(Required) Match primitive types against patterns Default: *</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="part">(Optional) Part to get primitives for</param>
		/// <param name="retarget">
		/// (Optional)
		/// Include primitive types that will be automatically retargeted
		/// to the current (or specified) part
		/// </param>
		/// <param name="macro">
		/// (Optional)
		/// Include primitive types that always convert into more basic,
		/// natively supported primitives, such as logic gates
		/// </param>
		/// <param name="hierarchy">
		/// (Optional)
		/// Include primitive types that will be automatically expanded
		/// into a hierarchy of leaf cells during implementation
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>primitive types</returns>
		public virtual SimpleTCLCommand get_primitives(string patterns, bool? regexp = null, bool? nocase = null, string filter = null, string part = null, bool? retarget = null, bool? macro = null, bool? hierarchy = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_primitives [-regexp] [-nocase] [-filter <arg>] [-part <arg>] [-retarget] [-macro] [-hierarchy] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_primitives")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("part", part)
					.Flag("retarget", retarget)
					.Flag("macro", macro)
					.Flag("hierarchy", hierarchy)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(patterns)
			;
		}
		/// <summary>
		/// Get a list of projects
		///
		///
		/// TCL Syntax: get_projects [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of open projects that match the specified search pattern. The default gets a list of all
		/// open projects.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example gets a list of all open projects.
		/// get_projects
		/// The following example sets a variable called project_found to the length of the list of projects
		/// returned by get_projects, then prints either that projects were found or were not found as
		/// appropriate:
		/// set project_found [llength [get_projects ISC*] ]
		/// if {$project_found > 0} {puts "Project Found."} \
		/// else {puts "No Projects Found."}
		/// Note: If there are no projects matching the pattern you will get a warning.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 877
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match project names against patterns Default: *</param>
		/// <returns>list of project objects</returns>
		public virtual SimpleTCLCommand get_projects(bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_projects [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_projects")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get properties of object
		///
		///
		/// TCL Syntax: get_property [-min] [-max] [-quiet] [-verbose] <name> <object>
		///
		/// Gets the current value of the named property from the specified object or objects. If multiple
		/// objects are specified, a list of values is returned.
		/// If the property is not currently assigned to the object, or is assigned without a value, then the
		/// get_property command returns nothing, or the null string. If multiple objects are queried, the
		/// null string is added to the list of values returned.
		/// If multiple objects are passed to the get_property command, you can use the -min or -max
		/// options to return the smallest or greatest value of the property specified by name. This feature
		/// can be useful when setting timing constraints.
		/// RECOMMENDED: For numeric properties, the min/max determination is based on numeric values. For all
		/// other properties, the determination is based on string sorting.
		/// This command returns a value, or list of values, or returns an error if it fails.
		///
		/// The following example gets the NAME property from the specified cell:
		/// get_property NAME [lindex [get_cells] 3]
		/// The following example returns the smallest PERIOD property from the specified clock objects:
		/// get_property -min PERIOD [get_clocks]
		/// This example demonstrates the string based sorting of the SITE property for the specified ports:
		/// get_property SITE [get_ports]
		/// IOB_X1Y75 IOB_X1Y76 IOB_X1Y98 IOB_X1Y125 IOB_X0Y94 IOB_X1Y95 IOB_X1Y96
		/// IOB_X1Y93 IOB_X1Y94
		/// get_property -min SITE [get_ports]
		/// IOB_X0Y94
		/// get_property -max SITE [get_ports]
		/// IOB_X1Y98
		/// Note: While IOB_X1Y125 is the largest site value on the port objects, the property value IOB_X1Y98 is
		/// returned because of the sorting of the property values as strings.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 880
		/// </summary>
		/// <param name="name">(Required) Name of property whose value is to be retrieved</param>
		/// <param name="@object">(Required) Object to query for properties</param>
		/// <param name="min">(Optional) Return only the minimum value</param>
		/// <param name="max">(Optional) Return only the maximum value</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>property value</returns>
		public virtual SimpleTCLCommand get_property(string name, string @object, bool? min = null, bool? max = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_property [-min] [-max] [-quiet] [-verbose] <name> <object>
			return
				new SimpleTCLCommand("get_property")
					.Flag("min", min)
					.Flag("max", max)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
					.RequiredString(@object)
			;
		}
		/// <summary>
		/// Get a list of available QoR suggestions
		///
		///
		/// TCL Syntax: get_qor_suggestions [-filter <arg>] [-quiet] [-verbose] [<IDs>]
		///
		/// Get existing QoR suggestion objects created by the report_qor_suggestions command, or
		/// read into the design using read_qor_suggestions. The selected QoR objects can be written
		/// to a file using the write_qor_suggestions command. The suggestions created by the report
		/// command remain in memory until delete_qor_suggestions is run, or until it is overwritten
		/// by another report.
		/// This command returns a list of existing QoR suggestion objects from the open design, or returns
		/// an error if it fails.
		///
		/// To return an individual suggestion, you can supply the full ID:
		/// get_qor_suggestions RQS_CLOCK-5_1-1
		/// Due to the naming style of suggestions, wildcard searches do NOT work directly. However you
		/// can use the filter command with -regexp to use wildcards as follows:
		/// filter -regexp [get_qor_suggestions] {NAME =~ RQS_CLOCK.*}
		/// You can also filter suggestions objects within a given category. Available categories include:
		/// Timing, Congestion, Utilization, XDC, Clocking, and Strategy. For example, the following returns
		/// suggestions related to the Timing category:
		/// get_qor_suggestions -filter {CATEGORY==Timing}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 883
		/// </summary>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="IDs">(Optional) Match suggestion names against given names</param>
		/// <returns>list of qor suggestion objects</returns>
		public virtual SimpleTCLCommand get_qor_suggestions(string filter = null, bool? quiet = null, bool? verbose = null, string IDs = null)
		{
			// TCL Syntax: get_qor_suggestions [-filter <arg>] [-quiet] [-verbose] [<IDs>]
			return
				new SimpleTCLCommand("get_qor_suggestions")
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(IDs)
			;
		}
		/// <summary>
		/// Get a list of ReconfigModules
		///
		///
		/// TCL Syntax: get_reconfig_modules [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Get a list of reconfigurable modules (RMs) in the current design that match a specified search
		/// pattern. The default command returns a list of all RMs in the current project.
		/// This command returns a list of RM objects, or returns an error if the command fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 885
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get 'reconfig_module' objects of these types: 'partition_def'.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match reconfigurable module names against patterns Default: *</param>
		/// <returns>list of ReconfigModule objects</returns>
		public virtual SimpleTCLCommand get_reconfig_modules(bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_reconfig_modules [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_reconfig_modules")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of Configurable Report objects
		///
		///
		/// TCL Syntax: get_report_configs [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Returns a list of report objects created by the create_report_config command.
		/// This command returns the list of report objects matching the search pattern and filters, or returns
		/// an error if it fails.
		///
		/// The following example gets all of the report objects in the current project:
		/// get_report_configs
		/// The following example gets all of the report objects in the current project that are associated
		/// with the opt_design step:
		/// get_report_configs -filter {RUN_STEP == opt_design}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 888
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get 'report' objects of these types: 'run'.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match report names against patterns Default: *</param>
		/// <returns>list of Configurable Report objects</returns>
		public virtual SimpleTCLCommand get_report_configs(bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_report_configs [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_report_configs")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of runs
		///
		///
		/// TCL Syntax: get_runs [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of synthesis and implementation runs in the current project that match a specified
		/// search pattern. The default command gets a list of all runs defined in the project.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example gets a list of all incomplete runs in the current project:
		/// get_runs -filter {PROGRESS < 100}
		/// The following example gets a list of runs matching the specified pattern:
		/// get_runs imp*
		/// Note: If there are no runs matching the pattern you will get a warning.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 891
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get 'run' objects of these types: 'reconfig_module'.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match run names against patterns Default: *</param>
		/// <returns>list of run objects</returns>
		public virtual SimpleTCLCommand get_runs(bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_runs [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_runs")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of children HDL scopes of a scope
		///
		///
		/// TCL Syntax: get_scopes [-filter <arg>] [-regexp] [-nocase] [-r] [-quiet] [-verbose] [<patterns>...]
		///
		/// Get a list of children HDL scopes of the current or specified scope
		/// This command returns a list of scope objects, or returns an error.
		///
		/// The following example recursively returns all of the children scopes of the specified scope:
		/// get_scopes -r /testbench/dut
		///
		/// See ug835-vivado-tcl-commands.pdf, page 894
		/// </summary>
		/// <param name="filter">
		/// (Optional)
		/// filters <patterns> according to the specified property￾matching expressions
		/// </param>
		/// <param name="regexp">(Optional) interprets <patterns> using regular expressions</param>
		/// <param name="nocase">(Optional) only when regexp is used, performs a case insensitive match</param>
		/// <param name="r">
		/// (Optional)
		/// only when a glob or regular expression pattern is used,
		/// descends recursively into children scopes to search for
		/// <patterns>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// (Optional)
		/// the pattern strings to search for scopes. Default: * (all
		/// children scopes)
		/// </param>
		/// <returns>Returns HDL scope objects from the given arguments</returns>
		public virtual SimpleTCLCommand get_scopes(string filter = null, bool? regexp = null, bool? nocase = null, bool? r = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_scopes [-filter <arg>] [-regexp] [-nocase] [-r] [-quiet] [-verbose] [<patterns>...]
			return
				new SimpleTCLCommand("get_scopes")
					.OptionalNamedString("filter", filter)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.Flag("r", r)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get selected objects
		///
		///
		/// TCL Syntax: get_selected_objects [-primary] [-quiet] [-verbose]
		///
		/// Gets the objects currently selected in the Vivado IDE by the select_objects command. Can
		/// get the primary selected object and any secondary selected objects as well.
		/// Note: This Tcl command works only when Vivado is run in GUI mode.
		/// Primary objects are directly selected, while secondary objects are selected based on the selection
		/// rules currently defined by the Tools → Settings command. Refer to the Vivado Design Suite User
		/// Guide: Using the IDE (UG893) for more information on setting selection rules.
		/// This command returns a Tcl list of selected objects, even a list with just one object. This can be an
		/// issue for some of the Vivado tool commands that do not accept a list of objects, such as the
		/// current_instance command. In this case you can use lindex to pass a specific object from
		/// the get_selected_objects list to the current_instance command:
		/// current_instance [lindex [get_selected_objects] 0]
		///
		/// The following example reports the properties of all currently selected objects, both primary and
		/// secondary:
		/// report_property [get_selected_objects]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 897
		/// </summary>
		/// <param name="primary">(Optional) Do not include objects that were selected due to selection rules</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of selected objects</returns>
		public virtual SimpleTCLCommand get_selected_objects(bool? primary = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_selected_objects [-primary] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("get_selected_objects")
					.Flag("primary", primary)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Get registered simulators
		///
		///
		/// TCL Syntax: get_simulators [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Get the list of simulators registered for use with the Vivado Design Suite unified simulation
		/// environment.
		/// The Vivado Design Suite comes with some simulators pre-registered for use with the unified
		/// simulation environment. You can also register your own third-party simulators using the
		/// register_simulator command.
		/// This command returns the names of registered simulators, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 899
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match simulator names against patterns Default: *</param>
		public virtual SimpleTCLCommand get_simulators(bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_simulators [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_simulators")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of site_pins.
		///
		///
		/// TCL Syntax: get_site_pins [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
		///
		/// Returns a list of site pins of the specified site, node, logical cell pin, or net objects in an open
		/// design.
		/// This command recommends the use of the -of_objects argument to prevent high run times
		/// and compute resources.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example returns the site_pins of the specified Nets:
		/// get_site_pins -of_objects [get_nets *Clk]
		/// IOB_X1Y24/I
		/// The following example returns the output site_pins associated with the site SLICE_X21Y92:
		/// get_site_pins -of_objects [get_sites SLICE_X21Y92] -filter
		/// {DIRECTION==OUT}
		/// SLICE_X21Y92/A SLICE_X21Y92/AMUX SLICE_X21Y92/AQ
		/// SLICE_X21Y92/B SLICE_X21Y92/BMUX SLICE_X21Y92/BQ
		/// SLICE_X21Y92/C SLICE_X21Y92/CMUX SLICE_X21Y92/COUT
		/// SLICE_X21Y92/CQ SLICE_X21Y92/D SLICE_X21Y92/DMUX
		/// SLICE_X21Y92/DQ
		///
		/// See ug835-vivado-tcl-commands.pdf, page 902
		/// </summary>
		/// <param name="of_objects">
		/// (Optional)
		/// Get 'site_pin' objects of these types: 'site xdef_site node pin
		/// net bel_pin'.
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'site_pin' objects against patterns. Default: *</param>
		/// <returns>site_pins</returns>
		public virtual SimpleTCLCommand get_site_pins(string of_objects = null, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_site_pins [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_site_pins")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of site_pips from the given object.
		///
		///
		/// TCL Syntax: get_site_pips [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Programmable interconnect points, or PIPs, provide the physical routing paths on the device used
		/// to connect logic networks. This command returns a list of PIPs on specified sites that match a
		/// specified search pattern. The command requires a design to be open.
		/// This command requires the use of the -of_objects option to specify the sites to return PIPs
		/// from.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example returns the pins of the specified BELs associated with the specified range
		/// of sites on the device:
		/// get_site_pips -of_objects [get_sites SLICE_X21Y92]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 905
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get the site_pips of these sites.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match site_pips against patterns Default: *</param>
		/// <returns>site_pips</returns>
		public virtual SimpleTCLCommand get_site_pips(bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_site_pips [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_site_pips")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of Sites
		///
		///
		/// TCL Syntax: get_sites [-regexp] [-filter <arg>] [-nocase] [-range <args>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Gets a list of sites on the target device that match a specified search pattern. The default
		/// command gets a list of all sites on the target device.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example gets a list of all sites available on the target device:
		/// get_sites
		/// The following example returns the number of sites that are not currently used on the device.
		/// Both command forms in the example return the same results. The second command directly
		/// evaluates the IS_USED boolean property:
		/// llength [get_sites -filter {IS_USED==0}]
		/// -or￾llength [get_sites -filter !IS_USED]
		/// Note: If no sites match the pattern you will get a warning.
		/// The following example gets all of the sites on the device, and returns the unique SITE_TYPEs:
		/// set sites [get_sites]
		/// set type {}
		/// foreach x $sites {
		/// set prop [get_property SITE_TYPE $x]
		/// if { [lsearch -exact $type $prop] == -1 } {
		/// lappend type $prop
		/// }
		/// }
		/// foreach y $type {
		/// puts "SITE_TYPE: $y"
		/// }
		/// The following example shows three different forms for specifying the range of sites to return:
		/// get_sites -range {SLICE_X0Y0 SLICE_X1Y1}
		/// SLICE_X0Y0 SLICE_X0Y1 SLICE_X1Y0 SLICE_X1Y1
		/// get_sites -range SLICE_X0Y0 -range SLICE_X1Y1
		/// SLICE_X0Y0 SLICE_X0Y1 SLICE_X1Y0 SLICE_X1Y1
		/// get_sites -range {SLICE_X0Y0:SLICE_X1Y1}
		/// SLICE_X0Y0 SLICE_X0Y1 SLICE_X1Y0 SLICE_X1Y1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 908
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="range">
		/// (Optional)
		/// Match site names which fall into the range. Range is defined
		/// by exactly two site names.
		/// </param>
		/// <param name="of_objects">
		/// (Optional)
		/// Get the sites of slrs, tiles, bels, pins, package_pins, ports,
		/// pblocks, nets, site_types, io_banks, cells, clock_regions or
		/// drc_violation
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// (Optional)
		/// Match site names against patterns. Bonded sites will also
		/// match on package pin names. Default: *
		/// </param>
		/// <returns>list of site objects</returns>
		public virtual SimpleTCLCommand get_sites(bool? regexp = null, string filter = null, bool? nocase = null, string range = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_sites [-regexp] [-filter <arg>] [-nocase] [-range <args>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_sites")
					.Flag("regexp", regexp)
					.OptionalNamedString("filter", filter)
					.Flag("nocase", nocase)
					.OptionalNamedString("range", range)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of slrs.
		///
		///
		/// TCL Syntax: get_slrs [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Get a list of the super logic regions (SLRs) on the target device. On Devices that do not contain
		/// multiple SLRs, the SLR0 is returned.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example highlights each of the SLRs on the target device in a different color:
		/// foreach x [get_slrs] {
		/// incr i
		/// highlight_objects -color_index $i $x
		/// }
		/// Note: If there are no cells matching the pattern you will get a warning.
		/// The following example returns the number of super long lines (SLLs) between super logic regions
		/// on the current device:
		/// get_property NUM_SLLS [get_slrs SLR0]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 912
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// (Optional)
		/// Get the slr of these device, tiles, sites, bels, sitepins, belpins,
		/// clock region, node, pip, pin, package pin, iobank, cell.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match slr against patterns Default: *</param>
		/// <returns>slr</returns>
		public virtual SimpleTCLCommand get_slrs(bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_slrs [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_slrs")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of speed_models in the device.
		///
		///
		/// TCL Syntax: get_speed_models [-of_objects <args>] [-regexp] [-nocase] [-patterns <arg>] [-filter <arg>] [-speed_pattern <arg>] [-quiet] [-verbose]
		///
		/// Get speed models for UltraScale architecture device resources in the current design.
		/// Speed files are provided by Xilinx for each device and speed grade. Speed files contain speed
		/// models. There are speed models for the various elements of a device: nodes, pips, bels. There are
		/// speed models for setup and hold, propagation delays, jitter, etc.
		/// The speed models include information on the delays in nanoseconds (ns) associated with device
		/// resources like BELs and SITEs and routing resources. Speed models are used by the Vivado
		/// timing engine to perform analysis of the current design in the context of the target part.
		/// The objects returned are the speed models associated with specific physical resources like pips
		/// and wires, drawn directly from the speed files. These can include capacitance and resistance
		/// values and buffer models.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		/// This command returns the specified speed model objects, or returns an error if the command
		/// fails.
		///
		/// The following example reports the properties on the speed model for an A6LUT:
		/// report_property -all [lindex [get_speed_models -of \
		/// [get_bels SLICE_X0Y0/A6LUT]] 0]
		/// Property Type Read-only Value
		/// CLASS string true speed_model
		/// DELAY double true 0.043
		/// FAST_MAX double true 0.035
		/// FAST_MIN double true 0.028
		/// IS_INSTANCE_SPECIFIC bool true 1
		/// NAME string true bel_d_lut6_a1_o6
		/// NAME_LOGICAL string true bel_d_lut6_a1_o6
		/// SLOW_MAX double true 0.043
		/// SLOW_MIN double true 0.036
		/// SPEED_INDEX int true 65535
		/// TYPE string true bel_delay
		/// The following example returns the delays, in nanoseconds, for a specific A6LUT on the device,
		/// followed by the delay name for the specified object:
		/// set x [get_speed_models -of [get_bels SLICE_X0Y0/A6LUT]]
		/// puts [format "%6.3f : %s" [get_property DELAY [lindex $x 0 ]] \
		/// [get_property NAME [lindex $x 0 ]]]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 915
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'speed_model' objects of these types: 'node bel pip cell'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="patterns">(Optional) Match the 'speed_model' objects against patterns. Default: *</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="speed_pattern">(Optional) Returns a single model that exactly matches the pattern.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>speed_models</returns>
		public virtual SimpleTCLCommand get_speed_models(string of_objects = null, bool? regexp = null, bool? nocase = null, string patterns = null, string filter = null, string speed_pattern = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_speed_models [-of_objects <args>] [-regexp] [-nocase] [-patterns <arg>] [-filter <arg>] [-speed_pattern <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("get_speed_models")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("patterns", patterns)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("speed_pattern", speed_pattern)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Get list of processes in a design, which are waiting inside a subprogram
		///
		///
		/// TCL Syntax: get_stacks [-of_instance <arg>] [-quiet] [-verbose]
		///
		/// Returns list of HDL scopes for all the processes in a design which are waiting inside a
		/// subprogram. With -of_instance switch, the output can be limited to such processes of the
		/// given instance only.
		///
		/// The following example gets a list of all sites available on the target device:
		/// module top;
		/// int i;
		/// function void f(input int in1);
		/// automatic int a;
		/// a = in1 + 7;
		/// $display($time, " in f :: a %d in1 %d ", a, in1);
		/// endfunction
		/// task automatic t(input int in2);
		/// int b;
		/// b = in2 + 10;
		/// $display($time, " in t :: in2 %d b %d ", in2, b);
		/// #5;
		/// f(b); // Case C
		/// $display($time, " Back in t : after wait and f(%d) ", b);
		/// endtask
		/// initial begin // "/top/Initial18_0"
		/// $display($time, " in initial 1 ");
		/// i = 200;
		/// t(i); // Case B
		/// $display($time, " Back in initial 1 after t(%d) ", i);
		/// end
		/// initial begin // "/top/Initial25_1"
		/// $display($time, " in initial 2 ");
		/// #2;
		/// f(50); // Case A
		/// $display($time, " Back in initial 2 after f(50) ");
		/// end
		/// endmodule
		/// When simulation is stopped inside function "f" for its call at 'Case A' , the two processes /top/
		/// Initial18_0, and /top/Initial25_1, are waiting inside task "t" (call at 'CaseB') and
		/// function "f" (call at 'CaseA') respectively.
		/// 1. > get_stacks
		/// /top/Initial18_0 /top/Initial25_1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 919
		/// </summary>
		/// <param name="of_instance">(Optional) Default: NULL</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>
		/// </returns>
		public virtual SimpleTCLCommand get_stacks(string of_instance = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_stacks [-of_instance <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("get_stacks")
					.OptionalNamedString("of_instance", of_instance)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Get a list of IPI example designs
		///
		///
		/// TCL Syntax: get_template_bd_designs [-quiet] [-verbose]
		///
		/// The command returns the list of template block designs available in the current release of the
		/// Vivado Design Suite, or returns an error if it fails.
		///
		/// The following example returns the list of available block design templates in the current release:
		/// get_template_bd_designs
		///
		/// See ug835-vivado-tcl-commands.pdf, page 921
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of IPI design objects</returns>
		public virtual SimpleTCLCommand get_template_bd_designs(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_template_bd_designs [-quiet] [-verbose]
			return
				new SimpleTCLCommand("get_template_bd_designs")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Get a list of tiles.
		///
		///
		/// TCL Syntax: get_tiles [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// This command returns a list of tiles on the device in an open design. The default command gets a
		/// list of all tiles on the device.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example returns the total number of tiles where the number of timing arcs is
		/// greater than 100 and 150 respectively:
		/// llength [get_tiles -filter {NUM_ARCS>100} ]
		/// 13468
		/// llength [get_tiles -filter {NUM_ARCS>150} ]
		/// 11691
		///
		/// See ug835-vivado-tcl-commands.pdf, page 922
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// (Optional)
		/// Get the tiles of these slr, sites, bels, site_pins, bel_pins,
		/// nodes, wires, pips, nets, clock_regions.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match tiles against patterns Default: *</param>
		/// <returns>tiles</returns>
		public virtual SimpleTCLCommand get_tiles(bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_tiles [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_tiles")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Get a list of timing arcs
		///
		///
		/// TCL Syntax: get_timing_arcs [-from <args>] [-to <args>] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose]
		///
		/// Gets a list of timing arcs for the specified objects. You can filter the timing arcs according to
		/// specified properties.
		/// Timing arcs are a part of a timing path. A timing arc can be a wire between two pins, or can be
		/// the internal path of a logic instance between an input pin and output pin, or clock input and data
		/// output pins.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example returns the timing arc from the output pin of the specified buffer:
		/// report_property -all [get_timing_arcs -of_objects [get_cells go_IBUF_inst]]
		/// The following example returns the timing arcs of the specified cell:
		/// get_timing_arcs -of_objects [get_cells count_reg[6]]
		/// {count_reg[6]/C --> count_reg[6]/Q [Reg Clk to Q] }
		/// {count_reg[6]/C --> count_reg[6]/D [setup] }
		/// {count_reg[6]/C --> count_reg[6]/D [hold] }
		/// {count_reg[6]/C --> count_reg[6]/CLR [recovery] }
		/// {count_reg[6]/C --> count_reg[6]/CE [hold] }
		/// {count_reg[6]/C --> count_reg[6]/CLR [removal] }
		/// {count_reg[6]/C --> count_reg[6]/CE [setup] }
		/// {count_reg[6]/CLR --> count_reg[6]/Q [Reg Set/Clr] }
		///
		/// See ug835-vivado-tcl-commands.pdf, page 925
		/// </summary>
		/// <param name="from">(Optional) List of pin or ports</param>
		/// <param name="to">(Optional) List of pin or ports</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get timing arcs for these cells</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of timing arc objects</returns>
		public virtual SimpleTCLCommand get_timing_arcs(string from = null, string to = null, string filter = null, string of_objects = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_timing_arcs [-from <args>] [-to <args>] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("get_timing_arcs")
					.OptionalNamedString("from", from)
					.OptionalNamedString("to", to)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Get timing paths
		///
		///
		/// TCL Syntax: get_timing_paths [-from <args>] [-rise_from <args>] [-fall_from <args>] [-to <args>] [-rise_to <args>] [-fall_to <args>] [-through <args>] [-rise_through <args>] [-fall_through <args>] [-delay_type <arg>] [-setup] [-hold] [-max_paths <arg>] [-nworst <arg>] [-unique_pins] [-slack_lesser_than <arg>] [-slack_greater_than <arg>] [-group <args>] [-no_report_unconstrained] [-user_ignored] [-routable_nets] [-sort_by <arg>] [-filter <arg>] [-regexp] [-nocase] [-cell <args>] [-quiet] [-verbose]
		///
		/// Gets timing path objects that meet the specified criteria. This command can be used to predefine
		/// timing paths to pass to the report_timing command for instance. Another usage of this
		/// command is to create custom reporting and analysis.
		/// The get_timing_paths command is very similar to the report_timing command.
		/// However, get_timing_paths returns timing path objects which can be queried for properties,
		/// or passed to other Tcl commands for processing, where report_timing returns a file or a
		/// string.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example gets the five worst timing paths from the specified endpoint, and reports
		/// all the properties of the fourth timing path in the list:
		/// report_property -all [lindex [get_timing_paths -to [get_ports led_pins[*]]
		/// \
		/// -nworst 5] 3]
		/// The following example defines a procedure called custom_report, then reports the 100 worst
		/// paths from the clk_tx_clk_core_1 path group using that proc:
		/// proc custom_report { listOfPaths } {
		/// puts [format {%-40s %-40s %-20s %-20s %7s} "Startpoint" "Endpoint" \
		/// "Launch Clock" "Capture Clock" "Slack"]
		/// puts [string repeat "-" 140]
		/// foreach path $listOfPaths {
		/// set startpoint [get_property STARTPOINT_PIN $path]
		/// set startclock [get_property STARTPOINT_CLOCK $path]
		/// set endpoint [get_property ENDPOINT_PIN $path]
		/// set endclock [get_property ENDPOINT_CLOCK $path]
		/// set slack [get_property SLACK $path]
		/// puts [format {%-40s %-40s %-20s %-20s %7s} $startpoint $endpoint \
		/// $startclock $endclock $slack]
		/// }
		/// }
		/// set paths [get_timing_paths -group clk_tx_clk_core_1 -max_paths 100]\
		/// custom_report $path
		/// The following example illustrates how timing path objects can be used with the
		/// report_timing command:
		/// set paths [get_timing_paths -group clk_tx_clk_core_1 -max_paths 100]
		/// report_timing -of_objects $paths
		/// Which is the equivalent of:
		/// report_timing -group clk_tx_clk_core_1 -max_paths 100
		/// The following example returns timing paths where the logic levels are greater than the specified
		/// number of logic levels:
		/// get_timing_paths -max_paths 1000 -filter {LOGIC_LEVELS > 1}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 928
		/// </summary>
		/// <param name="from">(Optional) From pins, ports, cells or clocks</param>
		/// <param name="rise_from">(Optional) Rising from pins, ports, cells or clocks</param>
		/// <param name="fall_from">(Optional) Falling from pins, ports, cells or clocks</param>
		/// <param name="to">(Optional) To pins, ports, cells or clocks</param>
		/// <param name="rise_to">(Optional) Rising to pins, ports, cells or clocks</param>
		/// <param name="fall_to">(Optional) Falling to pins, ports, cells or clocks</param>
		/// <param name="through">(Optional) Through pins, ports, cells or nets</param>
		/// <param name="rise_through">(Optional) Rising through pins, ports, cells or nets</param>
		/// <param name="fall_through">(Optional) Falling through pins, ports, cells or nets</param>
		/// <param name="delay_type">
		/// (Optional)
		/// Type of path delay: Values: max, min, min_max, max_rise,
		/// max_fall, min_rise, min_fall Default: max
		/// </param>
		/// <param name="setup">(Optional) Get max delay timing paths (equivalent to -delay_type max)</param>
		/// <param name="hold">(Optional) Get min delay timing paths (equivalent to -delay_type min)</param>
		/// <param name="max_paths">(Optional) Maximum number of paths to return: Value >=1 Default: 1</param>
		/// <param name="nworst">(Optional) List N worst paths to endpoint: Value >=1 Default: 1</param>
		/// <param name="unique_pins">(Optional) for each unique set of pins, show at most 1 path per path group</param>
		/// <param name="slack_lesser_than">(Optional) Include paths with slack less than this Default: 1e+30</param>
		/// <param name="slack_greater_than">(Optional) Include paths with slack greater than this Default: -1e+30</param>
		/// <param name="group">(Optional) Limit paths in this group(s)</param>
		/// <param name="no_report_unconstrained">(Optional) Do not get unconstrained paths</param>
		/// <param name="user_ignored">
		/// (Optional)
		/// only report paths which have infinite slack because of
		/// set_false_path or set_clock_groups timing constraints
		/// </param>
		/// <param name="routable_nets">
		/// (Optional)
		/// store the number of routable nets traversed as a property
		/// on timing paths.
		/// </param>
		/// <param name="sort_by">(Optional) Sorting order of paths: Values: group, slack Default: slack</param>
		/// <param name="filter">(Optional) Filter list with expression Name Description</param>
		/// <param name="regexp">(Optional) Patterns specified in filter are full regular expressions</param>
		/// <param name="nocase">
		/// (Optional)
		/// Perform case-insensitive matching for patterns specified in
		/// filter (valid only when -regexp specified)
		/// </param>
		/// <param name="cell">(Optional) run get_timing_paths on the cell</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand get_timing_paths(string from = null, string rise_from = null, string fall_from = null, string to = null, string rise_to = null, string fall_to = null, string through = null, string rise_through = null, string fall_through = null, string delay_type = null, bool? setup = null, bool? hold = null, string max_paths = null, string nworst = null, bool? unique_pins = null, string slack_lesser_than = null, string slack_greater_than = null, string group = null, bool? no_report_unconstrained = null, bool? user_ignored = null, bool? routable_nets = null, string sort_by = null, string filter = null, bool? regexp = null, bool? nocase = null, string cell = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_timing_paths [-from <args>] [-rise_from <args>] [-fall_from <args>] [-to <args>] [-rise_to <args>] [-fall_to <args>] [-through <args>] [-rise_through <args>] [-fall_through <args>] [-delay_type <arg>] [-setup] [-hold] [-max_paths <arg>] [-nworst <arg>] [-unique_pins] [-slack_lesser_than <arg>] [-slack_greater_than <arg>] [-group <args>] [-no_report_unconstrained] [-user_ignored] [-routable_nets] [-sort_by <arg>] [-filter <arg>] [-regexp] [-nocase] [-cell <args>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("get_timing_paths")
					.OptionalNamedString("from", from)
					.OptionalNamedString("rise_from", rise_from)
					.OptionalNamedString("fall_from", fall_from)
					.OptionalNamedString("to", to)
					.OptionalNamedString("rise_to", rise_to)
					.OptionalNamedString("fall_to", fall_to)
					.OptionalNamedString("through", through)
					.OptionalNamedString("rise_through", rise_through)
					.OptionalNamedString("fall_through", fall_through)
					.OptionalNamedString("delay_type", delay_type)
					.Flag("setup", setup)
					.Flag("hold", hold)
					.OptionalNamedString("max_paths", max_paths)
					.OptionalNamedString("nworst", nworst)
					.Flag("unique_pins", unique_pins)
					.OptionalNamedString("slack_lesser_than", slack_lesser_than)
					.OptionalNamedString("slack_greater_than", slack_greater_than)
					.OptionalNamedString("group", group)
					.Flag("no_report_unconstrained", no_report_unconstrained)
					.Flag("user_ignored", user_ignored)
					.Flag("routable_nets", routable_nets)
					.OptionalNamedString("sort_by", sort_by)
					.OptionalNamedString("filter", filter)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("cell", cell)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Get current value of the selected HDL object (variable, signal, wire, reg)
		///
		///
		/// TCL Syntax: get_value [-radix <arg>] [-quiet] [-verbose] <hdl_object>
		///
		/// Get the value of a single HDL object at the current simulation run time.
		/// TIP: Use the report_values command to return the values of more than one HDL objects.
		/// HDL objects include HDL signals, variables, or constants as defined in the Verilog or VHDL test
		/// bench and source files. An HDL signal includes Verilog wire or reg entities, and VHDL signals.
		/// Examples of HDL variables include Verilog real, realtime, time, and event.
		/// HDL constants include Verilog parameters and localparams, and VHDL generic and constants.
		/// The HDL scope, or scope, is defined by a declarative region in the HDL code such as a module,
		/// function, task, process, or begin-end blocks in Verilog. VHDL scopes include entity/architecture
		/// definitions, block, function, procedure, and process blocks.
		///
		/// HDL constants include Verilog parameters and localparams, and VHDL generic and constants.
		/// The HDL scope, or scope, is defined by a declarative region in the HDL code such as a module,
		/// function, task, process, or begin-end blocks in Verilog. VHDL scopes include entity/architecture
		/// definitions, block, function, procedure, and process blocks.
		/// Arguments
		/// -radix <arg> - (Optional) Specifies the radix to use when returning the value of the specified
		/// object. Allowed values are: default, dec, bin, oct, hex, unsigned, ascii, or smag.
		/// Note: The radix dec indicates a signed decimal. Specify the radix unsigned when dealing with unsigned
		/// data.
		/// -quiet - (Optional) Execute the command quietly, returning no messages from the command.
		/// The command also returns TCL_OK regardless of any errors encountered during execution.
		/// Note: Any errors encountered on the command-line, while launching the command, will be returned. Only
		/// errors occurring inside the command will be trapped.
		/// -verbose - (Optional) Temporarily override any message limits and return all messages from this
		/// command.
		/// Note: Message limits can be defined with the set_msg_config command.
		/// <hdl_object> - (Required) Specifies a single HDL object to get the value of. The object can be
		/// specified by name, or can be returned as an object from the get_objects command.
		/// Examples
		/// The following example gets the value of the sysClk signal:
		/// get_value sysClk
		/// Z
		/// This example shows the difference between the bin, dec, and unsigned radix on the value
		/// returned from the specified bus:
		/// get_value -radix bin /test/bench_VStatus_pad_0_i[7:0]
		/// 10100101
		/// get_value -radix unsigned /test/bench_VStatus_pad_0_i[7:0]
		/// 165
		/// get_value -radix dec /test/bench_VStatus_pad_0_i[7:0]
		/// -91
		///
		/// See ug835-vivado-tcl-commands.pdf, page 934
		/// </summary>
		/// <param name="hdl_object">(Required) The hdl_object to retrieve the current value</param>
		/// <param name="radix">
		/// (Optional)
		/// radix specifies the radix to use for printing the values of the
		/// hdl_objects. Allowed values are: default, dec, bin, oct,hex,
		/// unsigned, ascii, smag
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Returns a string representation of value of a hdl_object</returns>
		public virtual SimpleTCLCommand get_value(string hdl_object, string radix = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_value [-radix <arg>] [-quiet] [-verbose] <hdl_object>
			return
				new SimpleTCLCommand("get_value")
					.OptionalNamedString("radix", radix)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hdl_object)
			;
		}
		/// <summary>
		/// Get one or more DRC/METHODOLOGY/CDC message waivers
		///
		///
		/// TCL Syntax: get_waivers [-type <arg>] [-id <arg>] [-of_objects <args>] [-regexp] [-filter <arg>] [-nocase] [-quiet] [-verbose] [<patterns>]
		///
		/// The create_waiver command lets you select individual DRC, methodology, or CDC violations
		/// or rule checks that can be waived for a design, letting you move forward in the design flow. The
		/// get_waivers command lets you query the defined waiver objects in the current design.
		/// A waiver must be specified for an individual DRC or methodology violation, or for a specific DRC
		/// or methodology check, or for a CDC path. The waiver must be assigned to a specific object, or
		/// specific violation ID, or for paths using -from/-to arguments. You can format the
		/// get_waivers command to return the specific types of waivers you are looking for, or waivers
		/// associated with specific objects.
		/// You can report the waivers defined in the current design with report_waivers, and remove
		/// waivers from the design using delete_waivers.
		///
		/// This example gets any waivers in the current design:
		/// get_waivers
		/// The following example gets all DRC check waivers:
		/// get_waivers -type DRC *
		/// The following example gets all waivers associated with the specified objects:
		/// get_waivers -of_objects [get_ports {src_in* dest_out*}]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 936
		/// </summary>
		/// <param name="type">(Optional) Type of waiver - DRC, METHODOLOGY, CDC, ALL</param>
		/// <param name="id">(Optional) ID of the DRC/METHODOLOGY/CDC message being waived</param>
		/// <param name="of_objects">
		/// (Optional)
		/// List of objects (cells, nets, pins, sites, etc.) for which DRC/
		/// METHODLOGY/CDC waiver(s) were set
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// (Optional)
		/// Match waiver names against patterns Default: * Values: The
		/// default search pattern is the wildcard *, or .* when -regexp
		/// is specified.
		/// </param>
		/// <returns>waivers</returns>
		public virtual SimpleTCLCommand get_waivers(string type = null, string id = null, string of_objects = null, bool? regexp = null, string filter = null, bool? nocase = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_waivers [-type <arg>] [-id <arg>] [-of_objects <args>] [-regexp] [-filter <arg>] [-nocase] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_waivers")
					.OptionalNamedString("type", type)
					.OptionalNamedString("id", id)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.OptionalNamedString("filter", filter)
					.Flag("nocase", nocase)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Gets the wave configs that match the given options
		///
		///
		/// TCL Syntax: get_wave_configs [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>...]
		///
		/// Get the wave configuration objects that match the specified search options in the current
		/// simulation.
		/// In the Vivado® simulator GUI, you can work with a waveform to analyze your design and debug
		/// your code. The Wave Config file contains the list of wave objects (signals, dividers, groups, virtual
		/// buses) to display, and their display properties, plus markers. A wave configuration displays with
		/// top-level HDL objects, and can be further populated using commands like add_wave and
		/// add_wave_divider.
		/// This command returns the matching wave configuration objects, or returns nothing if no objects
		/// matched the search pattern.
		///
		/// The following example returns all wave configuration objects, in the current simulation, that have
		/// unsaved changes:
		/// get_wave_config -filter {NEEDS_SAVE}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 939
		/// </summary>
		/// <param name="regexp">(Optional) interprets <patterns> using regular expressions</param>
		/// <param name="nocase">(Optional) only when regexp is used, performs a case insensitive match</param>
		/// <param name="filter">
		/// (Optional)
		/// filters <patterns> according to the specified property￾matching expressions
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) the pattern strings to search for wave configuration names</param>
		/// <returns>Wave configs that match the given options</returns>
		public virtual SimpleTCLCommand get_wave_configs(bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_wave_configs [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>...]
			return
				new SimpleTCLCommand("get_wave_configs")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Gets wave objects from a wave configuration
		///
		///
		/// TCL Syntax: get_waves [-of <args>] [-regexp] [-nocase] [-filter <arg>] [-recursive] [-r] [-long_name] [-short_name] [-quiet] [-verbose] <patterns>...
		///
		/// See ug835-vivado-tcl-commands.pdf, page 942
		/// </summary>
		/// <param name="patterns">(Required) the design objects from which to create wave objects</param>
		/// <param name="of">(Optional) the wave configuration, group, or virtual bus to search</param>
		/// <param name="regexp">(Optional) interprets <patterns> using regular expressions</param>
		/// <param name="nocase">(Optional) only when regexp is used, performs a case insensitive match</param>
		/// <param name="filter">
		/// (Optional)
		/// filters <patterns> according to the specified property￾matching expressions
		/// </param>
		/// <param name="recursive">
		/// (Optional)
		/// if the design object is a scope, this option specifies that
		/// wave objects for all design objects under that scope should
		/// be created
		/// </param>
		/// <param name="r">
		/// (Optional)
		/// if the design object is a scope, this option specifies that
		/// wave objects for all design objects under that scope should
		/// be created
		/// </param>
		/// <param name="long_name">(Optional) search wave objects using the long form of their names</param>
		/// <param name="short_name">(Optional) search wave objects using the short form of their names</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>a collection of found wave objects</returns>
		public virtual SimpleTCLCommand get_waves(string patterns, string of = null, bool? regexp = null, bool? nocase = null, string filter = null, bool? recursive = null, bool? r = null, bool? long_name = null, bool? short_name = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_waves [-of <args>] [-regexp] [-nocase] [-filter <arg>] [-recursive] [-r] [-long_name] [-short_name] [-quiet] [-verbose] <patterns>...
			return
				new SimpleTCLCommand("get_waves")
					.OptionalNamedString("of", of)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.Flag("recursive", recursive)
					.Flag("r", r)
					.Flag("long_name", long_name)
					.Flag("short_name", short_name)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(patterns)
			;
		}
		/// <summary>
		/// Get a list of wires.
		///
		///
		/// TCL Syntax: get_wires [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-uphill] [-downhill] [-from <args>] [-to <args>] [-quiet] [-verbose] [<patterns>]
		///
		/// Returns a list of wires in the design that match a specified search pattern in an open design.
		/// The default command gets a list of all wires in the design.
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,
		/// or string, to the list is not permitted and will result in a Tcl error.
		///
		/// The following example returns the wires associated with the specified tile:
		/// get_wires -of_objects [get_tiles IO_INT_INTERFACE_L_X0Y198]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 943
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get the wires of these tiles, nodes, pips, or nets.</param>
		/// <param name="uphill">(Optional) Get the wires uphill from the provided pip.</param>
		/// <param name="downhill">(Optional) Get the wires downhill from the provided pip.</param>
		/// <param name="from">
		/// (Optional)
		/// -from <pip/site pin> Return the ordered list of wires
		/// beginning at this pip or site pin. May be used in
		/// combination with uphill. Default is downhill. -all is implied.
		/// </param>
		/// <param name="to">
		/// (Optional)
		/// -to <pip/site pin> Return the ordered list of wires ending at
		/// this wire or site pin. May be used in combination with uphill.
		/// Default is downhill. -all is implied.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match wires against patterns Default: *</param>
		/// <returns>wires</returns>
		public virtual SimpleTCLCommand get_wires(bool? regexp = null, bool? nocase = null, string filter = null, string of_objects = null, bool? uphill = null, bool? downhill = null, string from = null, string to = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: get_wires [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-uphill] [-downhill] [-from <args>] [-to <args>] [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("get_wires")
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("uphill", uphill)
					.Flag("downhill", downhill)
					.OptionalNamedString("from", from)
					.OptionalNamedString("to", to)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Create a hierarchical cell, and then move the group of cells into the hierarchy cell. The
		/// connections between these cells are maintained; the connections between these cells and other
		/// cells are maintained through crossing hierarchy cell.
		///
		///
		/// TCL Syntax: group_bd_cells [-prefix <arg>] [-quiet] [-verbose] [<target_cell_name>] [<cells>...]
		///
		/// Create a new hierarchical module in the current IP integrator subsystem design, and move the
		/// specified cells into that module.
		/// You can also optionally move a group of specified cells into the hierarchical module. The
		/// connections between the specified cells are maintained. The connections between the cells being
		/// moved are maintained; connections between these cells and other cells that are not being moved
		/// are maintained automatically by IP integrator adding pins and ports to cross the hierarchical
		/// boundary.
		/// You can also move cells into the hierarchical module by using the move_bd_cells command
		/// after the hierarchical module has been created using the create_bd_cells command.
		/// The command returns the name of the created hierarchical module if successful, or an error
		/// message if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 946
		/// </summary>
		/// <param name="target_cell_name">(Required) Target cell</param>
		/// <param name="cells">(Required) Match engine names against cell names Default: *</param>
		/// <param name="prefix">(Optional) Prefix name to add to cells</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>0 if success.</returns>
		public virtual SimpleTCLCommand group_bd_cells(string target_cell_name, string cells, string prefix = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: group_bd_cells [-prefix <arg>] [-quiet] [-verbose] [<target_cell_name>] [<cells>...]
			return
				new SimpleTCLCommand("group_bd_cells")
					.OptionalNamedString("prefix", prefix)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(target_cell_name)
					.RequiredString(cells)
			;
		}
		/// <summary>
		/// Groups paths for cost function calculations
		///
		///
		/// TCL Syntax: group_path [-name <args>] [-weight <arg>] [-default] [-from <args>] [-to <args>] [-through <args>] [-quiet] [-verbose]
		///
		/// This command lets you group a set of paths for cost function calculations, primarily for timing
		/// analysis. The Vivado tool automatically defines path groups of clock signals for special handling.
		/// User-defined path groups can be specified generally as from a startpoint, or to an endpoint, or as
		/// specific paths from-through-to specific points. Once a path group has been created, some timing
		/// analysis can be performed against it with the report_timing command.
		/// You can specify a weight for an existing path group of clocks, and let the placement, routing, and
		/// optimization engines prioritize those paths first.
		/// To remove a path from a path group, you must specify the -default option to remove the path
		/// from a named path group and restore the path to the standard "default" path group.
		/// This option has the following limitations:
		/// • For paths originally assigned by the tool to a clock path group, the -default option will
		/// revert those paths to the clock path group instead of reverting them to the "default" path
		/// group.
		/// • group_path -default and reset_path are completely independent commands. The
		/// reset_path command doesn't affect path groups, and the group_path command doesn't
		/// affect other timing exceptions .
		/// The path groups currently defined in a design can be found by using the get_path_groups
		/// command.
		/// Note: This command operates silently and does not return direct feedback of its operation.
		///
		/// The following example creates a group named signal_grp to the specified registers' endpoints
		/// matching *signal*reg/D, and then reports timing on the specified group:
		/// group_path -to [get_pins *signal*reg/D -hierarchical] -name signal_grp
		/// report_timing -group signal_grp
		/// The path group signal_grp is also returned by the get_path_groups command:
		/// get_path_groups signal_grp
		/// The following example removes the path from the signal_grp, restoring it to the default path
		/// group:
		/// group_path -to [get_pins *signal*reg/D -hierarchical] -default
		///
		/// See ug835-vivado-tcl-commands.pdf, page 948
		/// </summary>
		/// <param name="name">(Optional) The name of group, can be multiple names</param>
		/// <param name="weight">(Optional) Cost function Weight, Valid values are 1, 2 Default: 1.0</param>
		/// <param name="@default">(Optional) Restore path to its default group</param>
		/// <param name="from">(Optional) Filter by paths starting at these path startpoints</param>
		/// <param name="to">(Optional) Filter by paths terminating at these path endpoints</param>
		/// <param name="through">(Optional) Consider paths through pins, cells or nets</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand group_path(string name = null, string weight = null, bool? @default = null, string from = null, string to = null, string through = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: group_path [-name <args>] [-weight <arg>] [-default] [-from <args>] [-to <args>] [-through <args>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("group_path")
					.OptionalNamedString("name", name)
					.OptionalNamedString("weight", weight)
					.Flag("default", @default)
					.OptionalNamedString("from", from)
					.OptionalNamedString("to", to)
					.OptionalNamedString("through", through)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Display help for one or more topics
		///
		///
		/// TCL Syntax: help [-category <arg>] [-args] [-syntax] [-long] [-prop <arg>] [-class <arg>] [-message <arg>] [-quiet] [-verbose] [<pattern_or_object>]
		///
		/// Returns a long description of the specified Tcl command; or a list of available Xilinx Tcl command
		/// categories; or a list of commands matching a specific pattern.
		/// The default help command without any arguments returns a list of Tcl command categories that
		/// can be further explored. Command categories are groups of commands performing a specific
		/// function, like File I/O commands for instance.
		/// Available options for the help command can return just the command syntax for a quick
		/// reminder of how the command should be structured; the command syntax and a brief description
		/// of each argument; or the long form of the command with more detailed descriptions and
		/// examples of the command.
		/// To limit the memory usage of the Vivado Design Suite, some features of the tool are only loaded
		/// into memory when that feature set is used. To access the complete list of Tcl commands and help
		/// text associated with a given feature, you must load the feature into memory using the
		/// load_features command.
		/// The help command can also return any available information related to various properties
		/// assignable to design objects. Use the -prop and -class options to return help information for
		/// properties.
		/// This command returns the specified help text, or an error.
		///
		/// The following example returns a list of Xilinx Tcl command categories:
		/// help
		/// This example loads the simulator feature of the Vivado Design Suite, and then returns a list of Tcl
		/// commands in the simulation and waveform categories:
		/// load_features simulator
		/// help -category simulation
		/// help -category waveform
		/// Returns a list of all commands matching the specified search pattern:
		/// help *file*
		/// This list can be used to quickly locate a command for a specific purpose, such as remove_files
		/// or delete_files.
		/// The following help command returns a long description of the remove_files command and its
		/// arguments:
		/// help remove_files
		/// Note: You can also use the -args option to get a brief description of the command.
		/// This example defines a procedure called short, and returns the -args form of help for the
		/// specified command:
		/// proc short cmdName {help -args $cmdName}
		/// Note: You can add this procedure to your init.tcl file to load this command every time the tool is
		/// launched. Refer to Chapter 1, Introduction of the Vivado Design Suite Tcl Command Reference (UG835) for
		/// more information on the init.tcl file.
		/// The following examples show how to obtain help for properties of design objects, or a class of
		/// design objects:
		/// help -class cell -prop NAME
		/// help -prop NAME [get_cells cpuEngine]
		/// Note: In the preceding example, the first command returns general information related to the NAME
		/// property, while the second command also returns the value of the NAME property on the specified design
		/// object.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 951
		/// </summary>
		/// <param name="category">(Optional) Search for topics in the specified category</param>
		/// <param name="args">(Optional) Display arguments description</param>
		/// <param name="syntax">(Optional) Display syntax description</param>
		/// <param name="@long">(Optional) Display long help description</param>
		/// <param name="prop">(Optional) Display property help for matching property names Default: *</param>
		/// <param name="@class">(Optional) Display object type help</param>
		/// <param name="message">
		/// (Optional)
		/// Display information about the message with the given
		/// message. Every message delivered by the tool has a unique
		/// global message ID that consists of an application sub￾system code and a message identifier. Example: -message
		/// {Common 17-8}.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="pattern_or_object">(Optional) Display help for topics that match the specified pattern Default: *</param>
		public virtual SimpleTCLCommand help(string category = null, bool? args = null, bool? syntax = null, bool? @long = null, string prop = null, string @class = null, string message = null, bool? quiet = null, bool? verbose = null, string pattern_or_object = null)
		{
			// TCL Syntax: help [-category <arg>] [-args] [-syntax] [-long] [-prop <arg>] [-class <arg>] [-message <arg>] [-quiet] [-verbose] [<pattern_or_object>]
			return
				new SimpleTCLCommand("help")
					.OptionalNamedString("category", category)
					.Flag("args", args)
					.Flag("syntax", syntax)
					.Flag("long", @long)
					.OptionalNamedString("prop", prop)
					.OptionalNamedString("class", @class)
					.OptionalNamedString("message", message)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(pattern_or_object)
			;
		}
		/// <summary>
		/// Highlight objects in different colors
		///
		///
		/// TCL Syntax: highlight_objects [-color_index <arg>] [-rgb <args>] [-color <arg>] [-leaf_cells] [-quiet] [-verbose] <objects>
		///
		/// Highlights the specified or selected object or objects in a color as determined by one of the
		/// available color options.
		/// TIP: Only one of the available color option should be used to specify the highlight color. However, if more than
		/// one color option is used, the order of precedence to define the color is -rgb, -color_index, and -color.
		/// Selected objects are automatically unselected in order to display the objects in the specified
		/// highlight color. Objects can be unhighlighted with the unhighlight_objects command.
		///
		/// The following example highlights the currently selected objects in the color red:
		/// highlight_objects -color red [get_selected_objects]
		/// This example highlights the specified cells in green:
		/// highlight_objects -color green -leaf_cells [get_cells cpuEngine/*]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 955
		/// </summary>
		/// <param name="objects">(Required) Objects to highlight</param>
		/// <param name="color_index">(Optional) Color index</param>
		/// <param name="rgb">(Optional) RGB color index list</param>
		/// <param name="color">(Optional) Valid values are red green blue magenta yellow cyan and orange</param>
		/// <param name="leaf_cells">(Optional) Leaf cells</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand highlight_objects(string objects, string color_index = null, string rgb = null, string color = null, bool? leaf_cells = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: highlight_objects [-color_index <arg>] [-rgb <args>] [-color <arg>] [-leaf_cells] [-quiet] [-verbose] <objects>
			return
				new SimpleTCLCommand("highlight_objects")
					.OptionalNamedString("color_index", color_index)
					.OptionalNamedString("rgb", rgb)
					.OptionalNamedString("color", color)
					.Flag("leaf_cells", leaf_cells)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Implement debug core
		///
		///
		/// TCL Syntax: implement_debug_core [-quiet] [-verbose] [<cores>...]
		///
		/// Implements the Vivado logic analyzer debug cores in the current project. The tools will be run
		/// once for any ILA debug cores specified, and run one more time for the Debug Hub core if all
		/// cores are specified. The ILA core (labtools_ila_v3) is the only core type currently supported by the
		/// create_debug_core command. The tool automatically adds a Debug Hub core
		/// (labtools_xsdbmasterlib_v2) to contain and configure the ILA cores in the project.
		/// The Vivado tool creates Debug Hub core and ILA cores initially as black boxes. These cores must
		/// be implemented prior to running through place and route. After the core is created with
		/// create_debug_core, and while ports are being added and connected with
		/// create_debug_port and connect_debug_port, the content of the debug core is not
		/// defined or visible within the design.
		/// Debug core implementation is automatic when you launch an implementation run using the
		/// launch_runs command, or during design optimization using opt_design. However, you can
		/// also use the implement_debug_core command to implement one or more of the cores in the
		/// design without having to implement the whole design.
		///
		/// The following example implements all debug cores in the current project:
		/// implement_debug_core [get_debug_cores]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 957
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="cores">(Optional) Debug core</param>
		public virtual SimpleTCLCommand implement_debug_core(bool? quiet = null, bool? verbose = null, string cores = null)
		{
			// TCL Syntax: implement_debug_core [-quiet] [-verbose] [<cores>...]
			return
				new SimpleTCLCommand("implement_debug_core")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(cores)
			;
		}
		/// <summary>
		/// Call IP Services to regenerate an IP, then stitch it into the current netlist
		///
		///
		/// TCL Syntax: implement_mig_cores [-outputdir <arg>] [-rtlonly] [-force] [-debug_output] [-quiet] [-verbose]
		///
		/// Implements the memory IP cores in the current project.
		/// Memory IP included in the Xilinx® IP catalog are used to generate memory controllers and
		/// interfaces for Xilinx devices. Memory IP includes different IP cores from the Xilinx IP catalog
		/// depending on the device architecture and memory interface specified. Refer to Zynq-7000 SoC
		/// and 7 Series Devices Memory Interface Solutions (UG586), or UltraScale Architecture-Based FPGAs
		/// Memory Interface Solutions (PG150), for details of the available memory IP.
		/// The implement_mig_cores command generates the RTL information for the physical
		/// interface (PHY) of the memory controller, and integrates the synthesized netlist of the memory
		/// controller into the top-level design.
		/// A memory controller can be debug enabled when added into the design from the Xilinx IP
		/// catalog. In the Vivado logic analyzer, or the Vivado Lab Edition, memory controllers implemented
		/// into a design are associated with hw_mig objects, one hw_mig object per debug-enabled memory
		/// controller. The hw_mig object will have all the properties needed to get the calibration status and
		/// draw the per-bit eye margin views.
		/// Implementation of the memory IP, and debug core, is automatic when you launch an
		/// implementation run using the launch_runs command, or when you run opt_design.
		/// However, you can also use the implement_mig_cores command to integrate the memory IP
		/// without having to implement the whole design.
		/// TIP: All pins of the memory controller must be assigned prior to running the implement_mig_cores
		/// command, or an error will be returned. You can use report_drc to check the status of the memory controller.
		/// This command returns a transcript of its process, or returns an error if it fails.
		///
		/// The following example implements the memory IP cores in the current design:
		/// implement_mig_cores
		///
		/// See ug835-vivado-tcl-commands.pdf, page 959
		/// </summary>
		/// <param name="outputdir">(Optional) Target Output Directory for PHY IP Generated Files Default: empty</param>
		/// <param name="rtlonly">
		/// (Optional)
		/// Run the complete process to generate the PHY RTL code but
		/// do not replace the PHY core netlist
		/// </param>
		/// <param name="force">
		/// (Optional)
		/// Implement all non-optimized memory cores. When use with
		/// -rtlonly, optimized cores will be included, as well.
		/// </param>
		/// <param name="debug_output">(Optional) Enable debugging output.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand implement_mig_cores(string outputdir = null, bool? rtlonly = null, bool? force = null, bool? debug_output = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: implement_mig_cores [-outputdir <arg>] [-rtlonly] [-force] [-debug_output] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("implement_mig_cores")
					.OptionalNamedString("outputdir", outputdir)
					.Flag("rtlonly", rtlonly)
					.Flag("force", force)
					.Flag("debug_output", debug_output)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Call IP Services to regenerate an IP, then stitch it into the current netlist
		///
		///
		/// TCL Syntax: implement_xphy_cores [-outputdir <arg>] [-rtlonly] [-force] [-debug_output] [-quiet] [-verbose]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 961
		/// </summary>
		/// <param name="outputdir">(Optional) Target Output Directory for PHY IP Generated Files Default: empty</param>
		/// <param name="rtlonly">
		/// (Optional)
		/// Run the complete process to generate the PHY RTL code but
		/// do not replace the PHY core netlist
		/// </param>
		/// <param name="force">
		/// (Optional)
		/// Implement all non-optimized memory cores. When use with
		/// -rtlonly, optimized cores will be included, as well.
		/// </param>
		/// <param name="debug_output">(Optional) Enable debugging output.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand implement_xphy_cores(string outputdir = null, bool? rtlonly = null, bool? force = null, bool? debug_output = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: implement_xphy_cores [-outputdir <arg>] [-rtlonly] [-force] [-debug_output] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("implement_xphy_cores")
					.OptionalNamedString("outputdir", outputdir)
					.Flag("rtlonly", rtlonly)
					.Flag("force", force)
					.Flag("debug_output", debug_output)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Import files and/or directories into the active fileset
		///
		///
		/// TCL Syntax: import_files [-fileset <arg>] [-force] [-of_objects <args>] [-norecurse] [-flat] [-relative_to <arg>] [-quiet] [-verbose] [<files>...]
		///
		/// Imports one or more files or the source file contents of one or more directories to the specified
		/// fileset.
		/// For every file added to a project the Vivado Design Suite attempts to store and maintain both a
		/// relative path and an absolute path to the file or directory. When a project is opened, these paths
		/// are used to locate the files and directories. By default the Vivado Design Suite applies a Relative
		/// First approach to resolving paths, searching the relative path first, then the absolute path. You
		/// can use the PATH_MODE property to change how the Vivado tool resolves file paths or
		/// properties for specific objects. For more information, see the Vivado Design Suite Properties
		/// Reference Guide (UG912).
		/// IMPORTANT! Importing multiple files one at a time can cause noticeable performance degradation. It is more
		/// efficient to use a single import_files command to import a list of files:
		/// import_files {file1 file2 file3 ... fileN}
		/// This command is different from the add_files command, which adds files by reference into the
		/// specified fileset. This command imports the files into the local project folders under
		/// project.srcs\<fileset>\imports and then adds the file to the specified fileset.
		///
		/// The following example imports the top.ucf file into the constrs_1 constraint fileset.
		/// import_files -fileset constrs_1 top.ucf
		/// The following example imports the valid source files into the source fileset (sources_1) as a
		/// default since the -fileset argument is not specified. In addition, the -norecurse argument
		/// restricts the tool to looking only in the specified \level1 directory and not searching any
		/// subdirectories. All valid source files will be imported into the \imports folder of the project
		/// because the -flat argument has been specified.
		/// import_files C:/Data/FPGA_Design/level1 -norecurse -flat
		/// Note: Without the -flat option a \level1 directory would be created inside of the \imports folder of
		/// the project.
		/// The following example imports files into the source fileset (sources_1) because the -fileset
		/// argument is not specified. Valid source files are imported from the \level1 directory, and all
		/// subdirectories, and the files will be written into the \imports folder of the project starting at
		/// the \Data directory due to the use of the -relative_to argument.
		/// import_files C:/Data/FPGA_Design/level1 -relative_to C:/Data
		///
		/// See ug835-vivado-tcl-commands.pdf, page 962
		/// </summary>
		/// <param name="fileset">(Optional) Fileset name</param>
		/// <param name="force">(Optional) Overwrite files of the same name in project directory</param>
		/// <param name="of_objects">(Optional) RMs to import the files to</param>
		/// <param name="norecurse">(Optional) Disables the default behavior of recursive directory searches</param>
		/// <param name="flat">(Optional) Import the files into a flat directory structure</param>
		/// <param name="relative_to">(Optional) Import the files with respect to the given relative directory</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="files">(Optional) Name of the files to import into fileset</param>
		/// <returns>A list of file objects that were imported</returns>
		public virtual SimpleTCLCommand import_files(string fileset = null, bool? force = null, string of_objects = null, bool? norecurse = null, bool? flat = null, string relative_to = null, bool? quiet = null, bool? verbose = null, string files = null)
		{
			// TCL Syntax: import_files [-fileset <arg>] [-force] [-of_objects <args>] [-norecurse] [-flat] [-relative_to <arg>] [-quiet] [-verbose] [<files>...]
			return
				new SimpleTCLCommand("import_files")
					.OptionalNamedString("fileset", fileset)
					.Flag("force", force)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("norecurse", norecurse)
					.Flag("flat", flat)
					.OptionalNamedString("relative_to", relative_to)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(files)
			;
		}
		/// <summary>
		/// Import an IP file and add it to the fileset
		///
		///
		/// TCL Syntax: import_ip [-srcset <arg>] [-name <arg>] [-quiet] [-verbose] [<files>]
		///
		/// Adds an existing XCI or XCO file as an IP source into the current project, and copies it into the
		/// local project directory structure.
		/// The import_ip command allows you to read existing IP files directly, and copy them into the
		/// local project folders. Use the read_ip or add_files command to add IP files by reference into
		/// the current project.
		/// Use the create_ip command to create new IP files from the current IP catalog.
		///
		/// The following example copies the 10gig ethernet core into the current project, and assigns it a
		/// name of IP_block1:
		/// import_ip C:/Data/FPGA_Design/10gig_eth.xci -name IP_block1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 965
		/// </summary>
		/// <param name="srcset">
		/// (Optional)
		/// (Optional) Specifies the source file set containing the objects
		/// to be upgraded Default: The current source fileset Values:
		/// Source set name
		/// </param>
		/// <param name="name">
		/// (Optional)
		/// (Optional) Specifies a replacement name for the imported
		/// IP; may not be used with multiple files. Default: The current
		/// name for the imported IP Values: The new name for the
		/// imported IP
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="files">
		/// (Optional)
		/// Names of the IP files to be imported Values: A list of XCI
		/// (and/or XCO) file name(s)
		/// </param>
		/// <returns>list of file objects that were added</returns>
		public virtual SimpleTCLCommand import_ip(string srcset = null, string name = null, bool? quiet = null, bool? verbose = null, string files = null)
		{
			// TCL Syntax: import_ip [-srcset <arg>] [-name <arg>] [-quiet] [-verbose] [<files>]
			return
				new SimpleTCLCommand("import_ip")
					.OptionalNamedString("srcset", srcset)
					.OptionalNamedString("name", name)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(files)
			;
		}
		/// <summary>
		/// Imports the given Synplify project file
		///
		///
		/// TCL Syntax: import_synplify [-copy_sources] [-quiet] [-verbose] <file>
		///
		/// Imports Synplify synthesis project files (.prj) into the current project, including the various
		/// source files used in the synthesis run.
		///
		/// The following example creates a new project and imports the specified Synplify project file,
		/// copying the various source files from the Synplify project into the local project directories:
		/// create_project syn_test C:/Data/FPGA_Design/syn_test
		/// import_synplify -copy_sources C:/Data/syn_data.prj
		///
		/// See ug835-vivado-tcl-commands.pdf, page 967
		/// </summary>
		/// <param name="file">(Required) Name of the Synplify project file to be imported</param>
		/// <param name="copy_sources">
		/// (Optional)
		/// Copy all the sources from synplify project file into the
		/// created project
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of files object that were imported from the Synplify file</returns>
		public virtual SimpleTCLCommand import_synplify(string file, bool? copy_sources = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: import_synplify [-copy_sources] [-quiet] [-verbose] <file>
			return
				new SimpleTCLCommand("import_synplify")
					.Flag("copy_sources", copy_sources)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Import XISE project file settings into the created project
		///
		///
		/// TCL Syntax: import_xise [-copy_sources] [-quiet] [-verbose] <file>
		///
		/// Imports an ISE project file (XISE) into the current project. This allows ISE projects to be quickly
		/// migrated into the Vivado Design Suite for synthesis, simulation, and implementation. All project
		/// source files, constraint files, simulation files, and run settings are imported from the ISE project
		/// and recreated in the current project.
		/// This command should be run on a new empty project. Since source files, constraints, and run
		/// settings are imported from the ISE project, any existing source files or constraints may be
		/// overwritten.
		///
		/// The following example creates a new project called importISE, and then imports the ISE project
		/// file (first_use.xise) into the new project.
		/// create_project importISE C:/Data/importISE import_xise \
		/// C:/Data/FPGA_design/ise_designs/drp_des/first_use.xise
		/// Note: This example does not specify the -copy_sources argument, so all source files in the ISE project
		/// will be added to the current project by reference.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 969
		/// </summary>
		/// <param name="file">(Required) Name of the XISE project file to be imported</param>
		/// <param name="copy_sources">(Optional) Copy all ISE sources into the created project</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>true</returns>
		public virtual SimpleTCLCommand import_xise(string file, bool? copy_sources = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: import_xise [-copy_sources] [-quiet] [-verbose] <file>
			return
				new SimpleTCLCommand("import_xise")
					.Flag("copy_sources", copy_sources)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Imports the given XST project file
		///
		///
		/// TCL Syntax: import_xst [-copy_sources] [-quiet] [-verbose] <file>
		///
		/// Imports XST synthesis project files into the current project, including the various source files
		/// used in the XST run.
		///
		/// The following example creates a new project called xst_test, and imports the drp_des.xst
		/// file:
		/// create_project xst_test C:/Data/FPGA_Design/xst_test
		/// import_xst C:/Data/ise_designs/drp_des.xst
		///
		/// See ug835-vivado-tcl-commands.pdf, page 971
		/// </summary>
		/// <param name="file">(Required) Name of the XST project file to be imported</param>
		/// <param name="copy_sources">(Optional) Copy all the sources from xst project file into the created project</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of files object that were imported from the XST file</returns>
		public virtual SimpleTCLCommand import_xst(string file, bool? copy_sources = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: import_xst [-copy_sources] [-quiet] [-verbose] <file>
			return
				new SimpleTCLCommand("import_xst")
					.Flag("copy_sources", copy_sources)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// include segment from an address space.
		///
		///
		/// TCL Syntax: include_bd_addr_seg [-quiet] [-verbose] [<segment_to_include>]
		///
		/// Reverses the exclusion of an AXI peripheral address segment from access by the AXI master, and
		/// restores the address segment to a mapped state.
		/// In the block design, address segments of AXI peripherals can have one of three states:
		/// • Unmapped - An AXI peripheral, or slave interface, is connected to an AXI master, but the
		/// peripheral has not been assigned an address segment in the master's address space and is not
		/// visible to the master.
		/// • Mapped - The AXI peripheral is mapped into the AXI master's address space, assigned an
		/// address segment or range, and is accessible through the master.
		/// • Excluded - The AXI peripheral is mapped to the AXI master, and has been assigned an address
		/// segment, but is not accessible to the master. The address segment that the AXI slave occupies
		/// within the master address space is also considered filled.
		/// The exclude_bd_addr_seg command lets you exclude specific address segments from access
		/// by the AXI master they are mapped to. The include_bd_addr_seg restores access to the
		/// mapped address segment.
		/// This command returns nothing if successful, or returns an error if it failed.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 973
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="segment_to_include">(Optional) Segment to include</param>
		/// <returns>The newly included segment object, "" if failed.</returns>
		public virtual SimpleTCLCommand include_bd_addr_seg(bool? quiet = null, bool? verbose = null, string segment_to_include = null)
		{
			// TCL Syntax: include_bd_addr_seg [-quiet] [-verbose] [<segment_to_include>]
			return
				new SimpleTCLCommand("include_bd_addr_seg")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(segment_to_include)
			;
		}
		/// <summary>
		/// Infer differential pairs, typically for ports just imported from a CSV or XDC file
		///
		///
		/// TCL Syntax: infer_diff_pairs [-file_type <arg>] [-quiet] [-verbose] [<file>...]
		///
		/// The infer_diff_pairs command can be used in an I/O Pin Planning project, after importing
		/// the I/O pin information using the read_csv or read_xdc command.
		/// There are several attributes that identify differential pairs in the file: Signal Name, DiffPair Signal,
		/// DiffPair Type, and I/O Standard.
		/// The tool will identify differential pairs using the following methods:
		/// • Matching Diff Pair - This is a direct definition of the two signals which make up a differential
		/// pair. Two port entries, each have DiffPair Signal values linking to the Signal Name of the other,
		/// and have complementary DiffPair Type values, one N and one P. The tool checks to ensure
		/// that the other attributes such as I/O Standard are compatible when forming the diff pair.
		/// • Unmatched Diff Pair - Two port entries, with complementary DiffPair Type values (one N, one
		/// P), but only one port has a DiffPair Signal linking to the other Signal Name. The tool will create
		/// the differential pair if all other attributes are compatible.
		/// • Single Port Diff Pair - A single port entry with a differential I/O Standard, a DiffPair Type value,
		/// and a DiffPair Signal that does not otherwise appear in the CSV. The tool will create the
		/// opposite side of the differential pair (the N or P side), with all properties matching those on
		/// the original port.
		/// • Inferred Diff Pair - Two ports entries, with Signal Names that imply the N and P side. The tool
		/// will infer a differential pair if all other attributes are compatible.
		/// After reading the port definitions from a CSV or XDC file, the tool will report that some
		/// differential pairs can be inferred from the data. You can run the infer_diff_pairs command
		/// to infer these differential pairs if you choose.
		///
		/// The following example imports the specified XDC file, and then infers differential pairs from the
		/// file:
		/// read_xdc C:/Vivado_Install/io_1.xdc
		/// infer_diff_pairs C:/Vivado_Install/io_1.xdc -file_type xdc
		///
		/// See ug835-vivado-tcl-commands.pdf, page 975
		/// </summary>
		/// <param name="file_type">(Optional) Input file type: 'csv' or 'xdc' Default: file type</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="file">(Optional) Pin Planning CSV or XDC file Default: file</param>
		public virtual SimpleTCLCommand infer_diff_pairs(string file_type = null, bool? quiet = null, bool? verbose = null, string file = null)
		{
			// TCL Syntax: infer_diff_pairs [-file_type <arg>] [-quiet] [-verbose] [<file>...]
			return
				new SimpleTCLCommand("infer_diff_pairs")
					.OptionalNamedString("file_type", file_type)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(file)
			;
		}
		/// <summary>
		/// Creates an example design from a predefined template in an open project.
		///
		///
		/// TCL Syntax: instantiate_example_design [-design <arg>] [-hier <arg>] [-project <arg>] [-project_location <arg>] [-options <args>] [-quiet] [-verbose] <template>
		///
		/// This command creates an example design from a predefined template in an open project. The
		/// target part specified by the open project must be compatible with the example design, as defined
		/// in the SUPPORTED_PARTS property of the example, or an error is returned.
		/// For the embedded processor example designs, base_microblaze and base_zynq, the example
		/// design must be created in an open block design in the Vivado IP integrator. Embedded processor
		/// example designs require the use of a board as defined by the BOARD_PART property, rather than
		/// a target part. Refer to the current_board_part command for more information.
		/// The command returns the name of the example design used and a transcript of commands; or it
		/// returns an error if it fails.
		///
		/// The following example creates a new project as specified, overwriting an existing project of the
		/// same name if one is found, specifies the BOARD_PART property for the project, creates a new
		/// empty block design in the Vivado IP integrator, and then instantiates the Zynq embedded
		/// processor example design:
		/// create_project zynq1 -force
		/// set_property BOARD_PART em.avnet.com:zed:1.3 [current_project]
		/// create_bd_design myFirstZynq
		/// instantiate_example_design -design myFirstZynq \
		/// [lindex [get_example_designs] 1]
		/// This example reports the configurable properties of the specified example design:
		/// report_property [lindex [get_example_designs] 3] CONFIG.*
		/// This example creates a new empty project as specified, sets a target BOARD for the project,
		/// creates and opens a new empty block design, and then instantiates the configurable example
		/// design:
		/// create_project mb1 C:/Data/Vivado_Tutorial/Tutorial_Created_Data/mb1
		/// set_property board_part xilinx.com:kcu105:part0:1.1 [current_project]
		/// create_bd_design design_1
		/// instantiate_example_design -design design_1 \
		/// -options { Data_Cache.VALUE 8K Include_DDR4.VALUE true \
		/// Local_memory.VALUE 128K }\
		/// xilinx.com:design:config_mb:1.0
		///
		/// See ug835-vivado-tcl-commands.pdf, page 977
		/// </summary>
		/// <param name="template">(Required) Configurable Design Name</param>
		/// <param name="design">(Optional) Block Design Name</param>
		/// <param name="hier">(Optional) Hierarchy Block</param>
		/// <param name="project">(Optional) Project Name</param>
		/// <param name="project_location">(Optional) Project location Default: .</param>
		/// <param name="options">(Optional) Configurable options</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Returns the name of the template applied.</returns>
		public virtual SimpleTCLCommand instantiate_example_design(string template, string design = null, string hier = null, string project = null, string project_location = null, string options = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: instantiate_example_design [-design <arg>] [-hier <arg>] [-project <arg>] [-project_location <arg>] [-options <args>] [-quiet] [-verbose] <template>
			return
				new SimpleTCLCommand("instantiate_example_design")
					.OptionalNamedString("design", design)
					.OptionalNamedString("hier", hier)
					.OptionalNamedString("project", project)
					.OptionalNamedString("project_location", project_location)
					.OptionalNamedString("options", options)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(template)
			;
		}
		/// <summary>
		/// Creates a block design in IP integrator from a predefined template.
		///
		///
		/// TCL Syntax: instantiate_template_bd_design -design <arg> [-hier <arg>] [-options <args>] [-quiet] [-verbose] <template>
		///
		/// This command creates an example design from a template Block Design in the IP integrator of
		/// the Vivado Design Suite.
		/// The template diagram is created in an existing and open block design. In addition, the target part
		/// specified by the current project or in-memory project must be compatible with the template
		/// design or an error is returned.
		/// The command returns a transcript of its process, or returns an error if it fails.
		///
		/// The following example builds the specified template block design in the specified design:
		/// instantiate_template_bd_design -design myFirstZynq \
		/// [lindex [get_template_bd_designs] 1]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 980
		/// </summary>
		/// <param name="design">(Required) Block Design Name</param>
		/// <param name="template">(Required) Configurable Design Name</param>
		/// <param name="hier">(Optional) Hierarchy Block</param>
		/// <param name="options">(Optional) Configurable options</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Returns the name of the template applied.</returns>
		public virtual SimpleTCLCommand instantiate_template_bd_design(string design, string template, string hier = null, string options = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: instantiate_template_bd_design -design <arg> [-hier <arg>] [-options <args>] [-quiet] [-verbose] <template>
			return
				new SimpleTCLCommand("instantiate_template_bd_design")
					.RequiredNamedString("design", design)
					.OptionalNamedString("hier", hier)
					.OptionalNamedString("options", options)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(template)
			;
		}
		/// <summary>
		/// Interactive phys_opt_design.
		///
		///
		/// TCL Syntax: iphys_opt_design [-fanout_opt] [-critical_cell_opt] [-placement_opt] [-rewire] [-net <arg>] -cluster <args> -place_cell <args> [-place] [-dsp_register_opt] [-bram_register_opt] [-uram_register_opt] [-shift_register_opt] [-cell <arg>] [-packing] [-unpacking] [-port <arg>] [-critical_pin_opt] [-skipped_optimization] [-insert_negative_edge_ffs] [-hold_fix] [-slr_crossing_opt] [-auto_pipeline] [-quiet] [-verbose]
		///
		/// The iphys_opt_design command describes a specific optimization that was performed by the
		/// phys_opt_design command, such as replicating a critical cell or pulling registers from a block
		/// RAM to improve critical path delay. The iphys_opt_design command includes all the
		/// information necessary to recreate both the post-optimization logical netlist and the placement
		/// changes required for the optimized netlist.
		/// Interactive physical optimization can be used in two ways:
		/// • Applying post-placement physical optimizations to the pre-placement netlist to improve the
		/// overall placement result and improve design performance.
		/// • Saving the physical optimizations in a Tcl script to be repeated as needed.
		/// The various optimizations performed by phys_opt_design can be written to an iphys_opt Tcl
		/// script by write_iphys_opt_tcl, and read into the design by the read_iphys_opt_tcl
		/// command.
		/// TIP: The iphys_opt_design command is intended for use inside the iphys_opt Tcl script file. These
		/// commands can be edited in the context of the iphys_opt Tcl script, but they are not intended to be specified at
		/// the command line.
		/// This command returns a transcript of its processes, or an error if it fails.
		///
		/// The following example performs a critical cell optimization on the specified net and cluster of
		/// ports:
		/// iphys_opt_design -critical_cell_opt -net \
		/// {ADUR_CORE_INST/CPE_INST/CPE_ANT_RESOURCE_TDM_INST0 \
		/// /CPE_ANT_LINE_IQ_TDM_ANT0_INST/CPE_PN_MULT_INST/CPE_PN_MUL_INST3 \
		/// /Q_PNI_MULT_INST/pn_mult_reg[3][0]} \
		/// -cluster {pn_mult[3]_i_14_replica {\
		/// {ADUR_CORE_INST/CPE_INST/CPE_ANT_RESOURCE_TDM_INST0 \
		/// /CPE_ANT_LINE_IQ_TDM_ANT0_INST/CPE_PN_MULT_INST/CPE_PN_MUL_INST2 \
		/// /Q_ADD_INST/pn_mult_reg[3]_i_6_CARRY8/S[0]}}}\
		/// -cluster {pn_mult[3]_i_14_replica_1 {\
		/// {ADUR_CORE_INST/CPE_INST/CPE_ANT_RESOURCE_TDM_INST0 \
		/// /CPE_ANT_LINE_IQ_TDM_ANT0_INST/CPE_PN_MULT_INST/CPE_PN_MUL_INST0 \
		/// /Q_ADD_INST/pn_mult_reg[3]_i_10_CARRY8/S[0]}}}\
		/// The following example performs a shift register optimization on the specified cell:
		/// iphys_opt_design -shift_register_opt -cell \
		/// {ADUR_CORE_INST/EMIF_INTERFACE_INST/EMIF_HOST_IF_INST/DLY_INST1 \
		/// /PD_INST_FPGA/delay_chain_reg[9][16]_srl9} -port D
		///
		/// See ug835-vivado-tcl-commands.pdf, page 982
		/// </summary>
		/// <param name="cluster">(Required) Clusters of load pins</param>
		/// <param name="place_cell">(Required) Place cell or cell connecting to pin to loc</param>
		/// <param name="fanout_opt">(Optional) Fanout optimization including very high fanout optimizations</param>
		/// <param name="critical_cell_opt">(Optional) Do cell-duplication based optimization on timing critical nets</param>
		/// <param name="placement_opt">(Optional) Move cells to reduce delay on timing-critical nets</param>
		/// <param name="rewire">(Optional) Do rewiring optimization</param>
		/// <param name="net">(Optional) net to be optimized</param>
		/// <param name="place">(Optional) Replay placement of the transformation</param>
		/// <param name="dsp_register_opt">(Optional) DSP register optimization</param>
		/// <param name="bram_register_opt">(Optional) BRAM register optimization</param>
		/// <param name="uram_register_opt">(Optional) UltraRAM register optimization</param>
		/// <param name="shift_register_opt">(Optional) Shift register optimization</param>
		/// <param name="cell">(Optional) cell to be optimized</param>
		/// <param name="packing">(Optional) Packing in DSP/BRAM</param>
		/// <param name="unpacking">(Optional) Unpacking in DSP/BRAM</param>
		/// <param name="port">(Optional) Port in DSP/BRAM that is optimized</param>
		/// <param name="critical_pin_opt">(Optional) Pin Swap optimization</param>
		/// <param name="skipped_optimization">(Optional) The change is not committed</param>
		/// <param name="insert_negative_edge_ffs">(Optional) Inserting negative edge triggered FFs for high hold mitigation</param>
		/// <param name="hold_fix">(Optional) Inserting buffers for hold fix optimization</param>
		/// <param name="slr_crossing_opt">(Optional) Optimize slr crossing nets</param>
		/// <param name="auto_pipeline">(Optional) Auto pipeline</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand iphys_opt_design(string cluster, string place_cell, bool? fanout_opt = null, bool? critical_cell_opt = null, bool? placement_opt = null, bool? rewire = null, string net = null, bool? place = null, bool? dsp_register_opt = null, bool? bram_register_opt = null, bool? uram_register_opt = null, bool? shift_register_opt = null, string cell = null, bool? packing = null, bool? unpacking = null, string port = null, bool? critical_pin_opt = null, bool? skipped_optimization = null, bool? insert_negative_edge_ffs = null, bool? hold_fix = null, bool? slr_crossing_opt = null, bool? auto_pipeline = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: iphys_opt_design [-fanout_opt] [-critical_cell_opt] [-placement_opt] [-rewire] [-net <arg>] -cluster <args> -place_cell <args> [-place] [-dsp_register_opt] [-bram_register_opt] [-uram_register_opt] [-shift_register_opt] [-cell <arg>] [-packing] [-unpacking] [-port <arg>] [-critical_pin_opt] [-skipped_optimization] [-insert_negative_edge_ffs] [-hold_fix] [-slr_crossing_opt] [-auto_pipeline] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("iphys_opt_design")
					.Flag("fanout_opt", fanout_opt)
					.Flag("critical_cell_opt", critical_cell_opt)
					.Flag("placement_opt", placement_opt)
					.Flag("rewire", rewire)
					.OptionalNamedString("net", net)
					.RequiredNamedString("cluster", cluster)
					.RequiredNamedString("place_cell", place_cell)
					.Flag("place", place)
					.Flag("dsp_register_opt", dsp_register_opt)
					.Flag("bram_register_opt", bram_register_opt)
					.Flag("uram_register_opt", uram_register_opt)
					.Flag("shift_register_opt", shift_register_opt)
					.OptionalNamedString("cell", cell)
					.Flag("packing", packing)
					.Flag("unpacking", unpacking)
					.OptionalNamedString("port", port)
					.Flag("critical_pin_opt", critical_pin_opt)
					.Flag("skipped_optimization", skipped_optimization)
					.Flag("insert_negative_edge_ffs", insert_negative_edge_ffs)
					.Flag("hold_fix", hold_fix)
					.Flag("slr_crossing_opt", slr_crossing_opt)
					.Flag("auto_pipeline", auto_pipeline)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Issues an error that you can not run this command
		///
		///
		/// TCL Syntax: launch_chipscope_analyzer [-run <arg>] [-csproject <arg>] [-quiet] [-verbose]
		///
		/// Launches the ChipScope™ Pro Analyzer tool for the active run, or a specified Implemented
		/// Design run. You can setup a Netlist Design for use with ChipScope prior to implementation, using
		/// the create_debug_core, create_debug_port, and connect_debug_port commands.
		/// The Implemented Design must also have a bitstream file generated by BitGen for
		/// launch_chipscope_analyzer to run. If BitGen has not been run, an error will be returned.
		/// Note: It is not enough to use the write_bitstream command to create a bitstream file. You must follow
		/// the steps outlined below in the second example.
		///
		/// The following example launches ChipScope Pro Analyzer, specifying the implementation run to
		/// use and the name of the ChipScope project to create:
		/// launch_chipscope_analyzer -run impl_3 -csproject impl_3_cs_project
		/// The following example sets the add_step Bitgen property for the impl_4 run, launches the
		/// impl_4 run, and then launches the ChipScope Pro Analyzer on the specified run:
		/// set_property add_step Bitgen [get_runs impl_4]
		/// launch_runs impl_4 -jobs 2
		/// launch_chipscope_analyzer -run impl_4
		/// Note: In this example the ChipScope project will be called csdefaultproj.cpj.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 986
		/// </summary>
		/// <param name="run">(Optional) Implemented run to launch ChipScope Analyzer with</param>
		/// <param name="csproject">(Optional) ChipScope project</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand launch_chipscope_analyzer(string run = null, string csproject = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: launch_chipscope_analyzer [-run <arg>] [-csproject <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("launch_chipscope_analyzer")
					.OptionalNamedString("run", run)
					.OptionalNamedString("csproject", csproject)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Issues an error that you can not run this command
		///
		///
		/// TCL Syntax: launch_impact [-run <arg>] [-ipf <arg>] [-quiet] [-verbose]
		///
		/// Launch iMPACT to configure your device and generate programming files. You can also read back
		/// and verify design configuration data, debug configuration problems, or execute XSVF files.
		/// You must generate the bitstream file using write_bitstream prior to using iMPACT.
		/// The command returns the list of files read.
		///
		/// The following example launches iMPACT using the specified implementation run:
		/// launch_impact -run impl_3
		///
		/// See ug835-vivado-tcl-commands.pdf, page 988
		/// </summary>
		/// <param name="run">(Optional) Implemented run to launch iMPACT with</param>
		/// <param name="ipf">(Optional) Project for iMPACT</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand launch_impact(string run = null, string ipf = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: launch_impact [-run <arg>] [-ipf <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("launch_impact")
					.OptionalNamedString("run", run)
					.OptionalNamedString("ipf", ipf)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Launch a set of runs
		///
		///
		/// TCL Syntax: launch_runs [-jobs <arg>] [-scripts_only] [-lsf <arg>] [-sge <arg>] [-cluster_configuration <arg>] [-dir <arg>] [-to_step <arg>] [-next_step] [-host <args>] [-remote_cmd <arg>] [-email_to <args>] [-email_all] [-pre_launch_script <arg>] [-post_launch_script <arg>] [-custom_script <arg>] [-force] [-quiet] [-verbose] <runs>...
		///
		/// Launches synthesis and implementation runs when running the Vivado tools in Project Mode.
		/// Refer to the Vivado Design Suite User Guide: Design Flows Overview (UG892) for a complete
		/// description of Project Mode and Non-Project Mode.
		/// A run must be previously defined using the create_run command, and the properties of the
		/// run must be previously configured using the set_property command. Both synthesis and
		/// implementation runs can be specified in the same launch_runs command. However, to launch
		/// an implementation run, the parent synthesis run must already be complete.
		/// In Non-Project Mode, Vivado synthesis can be launched directly using the synth_design
		/// command, and does not require the use of a defined run.
		/// In Non-Project Mode, Vivado implementation steps can be launched individually with the
		/// opt_design, power_opt_design, place_design, route_design, phys_opt_design,
		/// and write_bitstream commands.
		///
		/// The following command launches three different synthesis runs with two parallel jobs:
		/// launch_runs synth_1 synth_2 synth_4 -jobs 2
		/// Note: The results for each run will be written to a separate folder synth_1, synth_2, and synth_4
		/// inside of the <project>.runs directory.
		/// The following example creates a results directory to write run results. In this case a separate
		/// folder named impl_3, impl_4, and synth_3 will be written to the specified directory. In
		/// addition, the -scripts_only argument tells the tool to write runme.bat scripts to each of
		/// these folders but not to launch the runs at this time.
		/// launch_runs impl_3 impl_4 synth_3 -dir C:/Data/FPGA_Design/results -
		/// scripts_only
		/// The following example configures the impl_1 run, setting options for Vivado Implementation
		/// 2013, enabling some of the optional optimizations, and then launches the run to the
		/// place_design step:
		/// set_property flow {Vivado Implementation 2013} [get_runs impl_1]
		/// set_property STEPS.POWER_OPT_DESIGN.IS_ENABLED true [get_runs impl_1]
		/// set_property STEPS.POST_PLACE_POWER_OPT_DESIGN.IS_ENABLED true \
		/// [get_runs impl_1]
		/// set_property STEPS.PHYS_OPT_DESIGN.IS_ENABLED true [get_runs impl_1]
		/// launch_runs -to_step place_design impl_1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 990
		/// </summary>
		/// <param name="runs">(Required) Runs to launch</param>
		/// <param name="jobs">(Optional) Number of jobs Default: 1</param>
		/// <param name="scripts_only">(Optional) Only generate scripts</param>
		/// <param name="lsf">
		/// (Optional)
		/// Use LSF to launch jobs. Required argument is the bsub
		/// command line to pass to LSF Default: empty
		/// </param>
		/// <param name="sge">
		/// (Optional)
		/// Use SGE to launch jobs. Required argument is the qsub
		/// command line to pass to SGE Default: empty
		/// </param>
		/// <param name="cluster_configuration">
		/// (Optional)
		/// Run jobs on a particular cluster configuration (picks cluster
		/// configuration from GUI settings). Default: empty
		/// </param>
		/// <param name="dir">(Optional) Launch directory</param>
		/// <param name="to_step">
		/// (Optional)
		/// Last Step to run. Ignored when launching multiple runs. Not
		/// valid with -next_step
		/// </param>
		/// <param name="next_step">
		/// (Optional)
		/// Run next step. Ignored when launching multiple runs. Not
		/// valid with -to_step.
		/// </param>
		/// <param name="host">
		/// (Optional)
		/// Launch on specified remote host with a specified number of
		/// jobs. Example: -host {machine1 2} -host {machine2 4}
		/// </param>
		/// <param name="remote_cmd">(Optional) Command to log in to remote hosts Default: ssh -q -o BatchMode=yes</param>
		/// <param name="email_to">
		/// (Optional)
		/// List of email addresses to notify when jobs complete (only
		/// applicable with -host)
		/// </param>
		/// <param name="email_all">(Optional) Send email after each job completes (only applicable with - host)</param>
		/// <param name="pre_launch_script">(Optional) Script to run before launching each job (only applicable with -host)</param>
		/// <param name="post_launch_script">(Optional) Script to run after each job completes (only applicable with - host)</param>
		/// <param name="custom_script">
		/// (Optional)
		/// User run script map file which contains run name to user
		/// run script mapping
		/// </param>
		/// <param name="force">
		/// (Optional)
		/// Run the command, even if there are pending constraint
		/// changes, which will be lost (in a Partial Reconfig design)
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand launch_runs(string runs, string jobs = null, bool? scripts_only = null, string lsf = null, string sge = null, string cluster_configuration = null, string dir = null, string to_step = null, bool? next_step = null, string host = null, string remote_cmd = null, string email_to = null, bool? email_all = null, string pre_launch_script = null, string post_launch_script = null, string custom_script = null, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: launch_runs [-jobs <arg>] [-scripts_only] [-lsf <arg>] [-sge <arg>] [-cluster_configuration <arg>] [-dir <arg>] [-to_step <arg>] [-next_step] [-host <args>] [-remote_cmd <arg>] [-email_to <args>] [-email_all] [-pre_launch_script <arg>] [-post_launch_script <arg>] [-custom_script <arg>] [-force] [-quiet] [-verbose] <runs>...
			return
				new SimpleTCLCommand("launch_runs")
					.OptionalNamedString("jobs", jobs)
					.Flag("scripts_only", scripts_only)
					.OptionalNamedString("lsf", lsf)
					.OptionalNamedString("sge", sge)
					.OptionalNamedString("cluster_configuration", cluster_configuration)
					.OptionalNamedString("dir", dir)
					.OptionalNamedString("to_step", to_step)
					.Flag("next_step", next_step)
					.OptionalNamedString("host", host)
					.OptionalNamedString("remote_cmd", remote_cmd)
					.OptionalNamedString("email_to", email_to)
					.Flag("email_all", email_all)
					.OptionalNamedString("pre_launch_script", pre_launch_script)
					.OptionalNamedString("post_launch_script", post_launch_script)
					.OptionalNamedString("custom_script", custom_script)
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(runs)
			;
		}
		/// <summary>
		/// Launch simulation
		///
		///
		/// TCL Syntax: launch_simulation [-step <arg>] [-simset <arg>] [-mode <arg>] [-type <arg>] [-scripts_only] [-of_objects <args>] [-absolute_path] [-install_path <arg>] [-noclean_dir] [-quiet] [-verbose]
		///
		/// Launch a simulator to perform analysis and verification of a design.
		/// The launch_simulation command creates a script file for the target simulator and then
		/// executes this file in the simulation run directory. The simulation results are saved in the log files
		/// created in the run directory.
		/// To run simulation for a specific simulator, you must first define the target simulator by setting the
		/// TARGET_SIMULATOR property on the design project:
		/// set_property TARGET_SIMULATOR <name> [current_project]
		/// The TARGET_SIMULATOR property can have a value of XSim, ModelSim, IES, Xcelium, VCS,
		/// Riviera, or ActiveHDL. The default value is XSim, the Vivado simulator.
		/// The target simulator can also be defined from the Vivado IDE. Create or open a project, select
		/// Tools → Settings → Simulation menu item, and select the Target simulator from the drop-down
		/// menu. The available choices are: Vivado simulator, ModelSim Simulator, Questa Advanced
		/// Simulator, Incisive Enterprise Simulator (IES), Xcelium Parallel Simulator, Verilog Compiler
		/// Simulator (VCS), Riviera-PRO Simulator, and Active-HDL Simulator.
		/// TIP: Some of these simulators are only available on Linux and some are only available on Windows.
		/// The launch_simulation command uses a three-step process comprised of compile,
		/// elaborate, and simulate steps. A script file for the target simulator is created for each step in the
		/// process, (compile.bat, elaborate.bat, simulate.bat), and written to the simulation run
		/// directory.
		/// TIP: On Linux the script files are named with the .sh suffix instead of .bat.
		/// By default, launch_simulation will run these script files in sequence to run the simulation.
		/// You can create the scripts without running them by using the -scripts_only option.
		/// This command returns a transcript of its process, or returns an error if it fails.
		///
		/// The following commands run behavioral simulation of the design using the Vivado simulator:
		/// set_property target_simulator "XSim" [current_project]
		/// launch_simulation
		/// The following commands run post-synthesis functional simulation of the design using the
		/// ModelSim Simulator:
		/// set_property target_simulator "ModelSim" [current_project]
		/// launch_simulation -mode "post-synthesis" -type "functional"
		/// The following commands run post-implementation functional simulation of the design using the
		/// Cadence IES Simulator:
		/// set_property target_simulator "IES" [current_project]
		/// launch_simulation -mode "post-implementation" -type "functional"
		/// The following commands run post-implementation timing simulation of the design using the
		/// Synopsys VCS Simulator:
		/// set_property target_simulator "VCS" [current_project]
		/// launch_simulation -mode "post-implementation" -type "timing"
		/// The following command generates behavioral simulation scripts for the target simulator in the
		/// simulation run directory:
		/// launch_simulation -scripts_only
		/// The following commands run behavioral simulation flow of the design for the "my_simset"
		/// simulation fileset for the target simulator in the simulation run directory:
		/// launch_simulation -simset [get_filesets my_simset]
		/// The following command runs behavioral simulation flow for the char_fifo.xci IP for the
		/// target simulator in the simulation run directory, and does not clean up prior simulation files:
		/// launch_simulation -noclean_dir -of_objects [get_files char_fifo.xci]
		/// The following command generates absolute paths for the source files in the generated script files:
		/// launch_simulation -absolute_path
		/// The following command will pick the simulator tools from the specified installation path instead
		/// of from the PATH variable:
		/// launch_simulation -install_path /tools/ius/13.20.005/tools/bin
		///
		/// See ug835-vivado-tcl-commands.pdf, page 995
		/// </summary>
		/// <param name="step">
		/// (Optional)
		/// Launch a simulation step. Values: all, compile, elaborate,
		/// simulate. Default:all (launch all steps). Default: all
		/// </param>
		/// <param name="simset">(Optional) Name of the simulation fileset</param>
		/// <param name="mode">
		/// (Optional)
		/// Simulation mode. Values: behavioral, post-synthesis, post￾implementation Default: behavioral
		/// </param>
		/// <param name="type">
		/// (Optional)
		/// Netlist type. Values: functional, timing. This is only
		/// applicable when mode is set to post-synthesis or post￾implementation
		/// </param>
		/// <param name="scripts_only">(Optional) Only generate scripts</param>
		/// <param name="of_objects">
		/// (Optional)
		/// Generate compile order file for this object (applicable with -
		/// scripts_only option only)
		/// </param>
		/// <param name="absolute_path">(Optional) Make design source file paths in 'absolute' format</param>
		/// <param name="install_path">(Optional) Custom installation directory path</param>
		/// <param name="noclean_dir">(Optional) Do not remove simulation run directory files</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand launch_simulation(string step = null, string simset = null, string mode = null, string type = null, bool? scripts_only = null, string of_objects = null, bool? absolute_path = null, string install_path = null, bool? noclean_dir = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: launch_simulation [-step <arg>] [-simset <arg>] [-mode <arg>] [-type <arg>] [-scripts_only] [-of_objects <args>] [-absolute_path] [-install_path <arg>] [-noclean_dir] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("launch_simulation")
					.OptionalNamedString("step", step)
					.OptionalNamedString("simset", simset)
					.OptionalNamedString("mode", mode)
					.OptionalNamedString("type", type)
					.Flag("scripts_only", scripts_only)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("absolute_path", absolute_path)
					.OptionalNamedString("install_path", install_path)
					.Flag("noclean_dir", noclean_dir)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Limit the maximum size of the VCD file on disk (equivalent of $dumplimit verilog task)
		///
		///
		/// TCL Syntax: limit_vcd [-quiet] [-verbose] <filesize>
		///
		/// Specify the size limit, in bytes, of the Value Change Dump (VCD) file. This command operates like
		/// the Verilog $dumplimit simulator directive.
		/// When the specified file size limit has been reached, the dump process stops, and a comment is
		/// inserted into the VCD file to indicate that the file size limit has been reached.
		/// Note: You must run the open_vcd command before using the limit_vcd command.
		///
		/// The following example limits the current VCD file:
		/// limit_vcd 1000
		///
		/// See ug835-vivado-tcl-commands.pdf, page 999
		/// </summary>
		/// <param name="filesize">(Required) Specify the maximum size of the VCD file in bytes.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand limit_vcd(string filesize, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: limit_vcd [-quiet] [-verbose] <filesize>
			return
				new SimpleTCLCommand("limit_vcd")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(filesize)
			;
		}
		/// <summary>
		/// Open a netlist design
		///
		///
		/// TCL Syntax: link_design [-name <arg>] [-part <arg>] [-constrset <arg>] [-top <arg>] [-mode <arg>] [-pr_config <arg>] [-reconfig_partitions <args>] [-partitions <args>] [-ignore_timing] [-quiet] [-verbose]
		///
		/// Opens a new or existing netlist design, linking the netlist files and constraints with the target part
		/// to create the design. This command is intended for use with netlist source files, such as files
		/// generated by third party synthesis tools, or Vivado synthesis through the synth_design
		/// command.
		/// The DESIGN_MODE property for the current source fileset must be defined as GateLvl in order
		/// to open a netlist design. If not, you will get the following error:
		/// ERROR: The design mode of 'sources_1' must be GateLvl.
		/// The -top switch is required for third-party synthesis designs. The netlist for the design must be
		/// rooted in a specific module. For project-based designs you can specify the TOP property on the
		/// project. However, in non-project mode, you must use the -top option for the link_design
		/// command.
		/// For project based designs with RTL source files, use launch_runs to launch synthesis or
		/// implementation, and then use the open_run command to open the design.
		/// For non-project based designs, use the open_checkpoint command to open a checkpoint into
		/// memory, opening the design in Non-Project Mode. Refer to the Vivado Design Suite User Guide:
		/// Design Flows Overview (UG892) for more information on Project Mode and Non-Project Mode.
		///
		/// The following creates a new netlist design called Net1:
		/// link_design -name Net1
		/// Note: The default source set, constraint set, and part will be used in this example.
		/// The following example opens a netlist design called Net1, and specifies the constraint set to be
		/// used:
		/// link_design -name Net1 -constrset con1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1001
		/// </summary>
		/// <param name="name">(Optional) Design name</param>
		/// <param name="part">(Optional) Target part</param>
		/// <param name="constrset">(Optional) Constraint fileset to use</param>
		/// <param name="top">(Optional) Specify the top module name when the structural netlist is Verilog</param>
		/// <param name="mode">(Optional) The design mode. Values: default, out_of_context Default: default</param>
		/// <param name="pr_config">(Optional) PR Configuration to apply while opening the design</param>
		/// <param name="reconfig_partitions">(Optional) List of reconfigurable partitions to load while opening the design</param>
		/// <param name="partitions">(Optional) List of partitions to load while opening the design</param>
		/// <param name="ignore_timing">(Optional) open a netlist design without the timing constraints.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>design object</returns>
		public virtual SimpleTCLCommand link_design(string name = null, string part = null, string constrset = null, string top = null, string mode = null, string pr_config = null, string reconfig_partitions = null, string partitions = null, bool? ignore_timing = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: link_design [-name <arg>] [-part <arg>] [-constrset <arg>] [-top <arg>] [-mode <arg>] [-pr_config <arg>] [-reconfig_partitions <args>] [-partitions <args>] [-ignore_timing] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("link_design")
					.OptionalNamedString("name", name)
					.OptionalNamedString("part", part)
					.OptionalNamedString("constrset", constrset)
					.OptionalNamedString("top", top)
					.OptionalNamedString("mode", mode)
					.OptionalNamedString("pr_config", pr_config)
					.OptionalNamedString("reconfig_partitions", reconfig_partitions)
					.OptionalNamedString("partitions", partitions)
					.Flag("ignore_timing", ignore_timing)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// List available features.
		///
		///
		/// TCL Syntax: list_features [-quiet] [-verbose]
		///
		/// In order to reduce the memory footprint of the Vivado Design Suite, there are groups of Tcl
		/// commands called "features" which are unavailable for use until you run a command from that
		/// feature set, or unless you explicitly load the feature using the load_features command.
		/// This command lists the available features sets of the Vivado Design Suite that can be loaded with
		/// the load_features command.
		/// Note: If a feature has been previously loaded, it will not be listed as a feature available to load.
		/// This command returns a list of features, or an error message.
		///
		/// The following example returns the list of features available to load into the Vivado Design Suite:
		/// list_features
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1005
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand list_features(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: list_features [-quiet] [-verbose]
			return
				new SimpleTCLCommand("list_features")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Return probe sample values
		///
		///
		/// TCL Syntax: list_hw_samples [-quiet] [-verbose] [<hw_probe>]
		///
		/// Writes data samples from the specified hw_probe object on the current hw_ila.
		/// The number of captured samples returned from the specified probe is equal to the DATA_DEPTH
		/// property of the ILA core. The default data depth is 1024 samples. Data values are returned in the
		/// radix specified for the hw_probe, as determined by the DISPLAY_RADIX property.
		/// TIP: For any samples to be returned, data must have been captured by the specified port.
		/// The values are listed to the standard output, or can be captured to a Tcl variable for post￾processing, or output to a file.
		/// The following is an example Tcl script that lists the data samples from hw_probes of interest:
		/// # Define a list of probes to get the data samples from
		/// set probeList [get_hw_probes *AR*]
		/// #Specify the radix for the return values
		/// set_property DISPLAY_RADIX BINARY [get_hw_probes *AR*]
		/// # Define a filename to write data to
		/// set fileName C:/Data/probeData1.txt
		/// # Open the specified file in write mode
		/// set FH [open $fileName w]
		/// # Write probe data for each probe
		/// foreach x $probeList {
		/// puts $FH "$x:"
		/// puts $FH [list_hw_samples $x]
		/// }
		/// # Close the output file
		/// close $FH
		/// puts "Probe data written to $fileName\n"
		/// This command returns the requested output, or returns an error if it fails.
		///
		/// The following example returns the data samples for the specified probe:
		/// list_hw_samples [get_hw_probes *probe18]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1007
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_probe">(Optional) hw_probe object</param>
		/// <returns>samples</returns>
		public virtual SimpleTCLCommand list_hw_samples(bool? quiet = null, bool? verbose = null, string hw_probe = null)
		{
			// TCL Syntax: list_hw_samples [-quiet] [-verbose] [<hw_probe>]
			return
				new SimpleTCLCommand("list_hw_samples")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(hw_probe)
			;
		}
		/// <summary>
		/// Get all parameter names
		///
		///
		/// TCL Syntax: list_param [-quiet] [-verbose]
		///
		/// Gets a list of user-definable configuration parameters. These parameters configure a variety of
		/// settings and behaviors of the tool. For more information on a specific parameter use the
		/// report_param command, which returns a description of the parameter as well as its current
		/// value.
		///
		/// The following example returns a list of all user-definable parameters:
		/// list_param
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1009
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list</returns>
		public virtual SimpleTCLCommand list_param(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: list_param [-quiet] [-verbose]
			return
				new SimpleTCLCommand("list_param")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// List properties of object
		///
		///
		/// TCL Syntax: list_property [-class <arg>] [-regexp] [-quiet] [-verbose] [<object>] [<pattern>]
		///
		/// Gets a list of all properties on a specified object or class.
		/// Note: report_property also returns a list of properties on an object or class of objects, but also reports
		/// the property type and property value.
		///
		/// The following example returns all properties of the specified CELL object:
		/// list_property [get_cells cpuEngine]
		/// The following example returns the properties matching the specified search pattern from the BEL
		/// class of objects:
		/// list_property -class bel *NUM*
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1011
		/// </summary>
		/// <param name="@class">(Optional) Object type to query for properties. Ignored if object is specified.</param>
		/// <param name="regexp">(Optional) Pattern is treated as a regular expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="@object">(Optional) Object to query for properties</param>
		/// <param name="pattern">(Optional) Pattern to match properties against Default: *</param>
		/// <returns>list of property names</returns>
		public virtual SimpleTCLCommand list_property(string @class = null, bool? regexp = null, bool? quiet = null, bool? verbose = null, string @object = null, string pattern = null)
		{
			// TCL Syntax: list_property [-class <arg>] [-regexp] [-quiet] [-verbose] [<object>] [<pattern>]
			return
				new SimpleTCLCommand("list_property")
					.OptionalNamedString("class", @class)
					.Flag("regexp", regexp)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(@object)
					.OptionalString(pattern)
			;
		}
		/// <summary>
		/// List legal property values of object
		///
		///
		/// TCL Syntax: list_property_value [-default] [-class <arg>] [-quiet] [-verbose] <name> [<object>]
		///
		/// Gets a list of valid values for an enumerated type property of either a class of objects or a
		/// specific object.
		/// Note: The command cannot be used to return valid values for properties other than Enum properties. The
		/// report_property command will return the type of property to help you identify Enum properties.
		///
		/// The following example returns the list of valid values for the KEEP_HIERARCHY property from
		/// cell objects:
		/// list_property_value KEEP_HIERARCHY -class cell
		/// The following example returns the same result, but uses an actual cell object in place of the
		/// general cell class:
		/// list_property_value KEEP_HIERARCHY [get_cells cpuEngine]
		/// The following example returns the default value for the specified property by using the current
		/// design as a representative of the design class:
		/// list_property_value -default BITSTREAM.GENERAL.COMPRESS [current_design]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1013
		/// </summary>
		/// <param name="name">(Required) Name of property whose legal values is to be retrieved</param>
		/// <param name="@default">(Optional) Show only the default value.</param>
		/// <param name="@class">
		/// (Optional)
		/// Object type to query for legal property values. Ignored if
		/// object is specified.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="@object">(Optional) Object to query for legal properties values</param>
		/// <returns>list of property values</returns>
		public virtual SimpleTCLCommand list_property_value(string name, bool? @default = null, string @class = null, bool? quiet = null, bool? verbose = null, string @object = null)
		{
			// TCL Syntax: list_property_value [-default] [-class <arg>] [-quiet] [-verbose] <name> [<object>]
			return
				new SimpleTCLCommand("list_property_value")
					.Flag("default", @default)
					.OptionalNamedString("class", @class)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
					.OptionalString(@object)
			;
		}
		/// <summary>
		/// List applicable targets for the specified source
		///
		///
		/// TCL Syntax: list_targets [-quiet] [-verbose] <files>
		///
		/// List the targets that are available for a specified IP core, DSP module, or IP Subsystem. The
		/// following file types are accepted: .xci, .xco, .mdl, .bd, .bxml.
		/// Use the generate_targets command to generate the listed targets.
		/// The command returns the list of available targets. If no targets are available for the specified file
		/// objects, nothing is returned.
		///
		/// The following example lists the available targets for any DSP modules in the design:
		/// list_targets [get_files *.mdl]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1015
		/// </summary>
		/// <param name="files">(Required) Source file for which the targets needs to be listed</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of targets</returns>
		public virtual SimpleTCLCommand list_targets(string files, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: list_targets [-quiet] [-verbose] <files>
			return
				new SimpleTCLCommand("list_targets")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(files)
			;
		}
		/// <summary>
		/// Load Tcl commands for a specified feature.
		///
		///
		/// TCL Syntax: load_features [-quiet] [-verbose] [<features>...]
		///
		/// Load the specified features of the Vivado Design Suite into memory.
		/// In order to reduce the memory footprint of the Vivado Design Suite, there are groups of Tcl
		/// commands called "features" which are unavailable for use until you run a command from that
		/// feature set, or unless you explicitly load the feature using the load_features command.
		/// For example, the load_features simulator command loads the commands for the Vivado
		/// simulator, as does directly launching the Vivado simulator using the launch_xsim command.
		/// To access the complete list of Tcl commands associated with a feature of the Vivado Design
		/// Suite, and the help text for these commands, you can load the feature into the application
		/// memory using the load_features command without actually running the feature of the tool.
		/// You can list the features that are available to be loaded using the list_features command.
		/// The list of features is dynamic, and changes from release to release.
		/// The command returns nothing if successful, or an error message if failed.
		///
		/// The following example loads the Vivado simulator feature:
		/// load_features simulator
		/// The following example loads all of the loadable feature sets of the Vivado Design Suite:
		/// load_features [list_features]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1017
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="features">
		/// (Optional)
		/// Feature(s) to load, use list_features for a list of available
		/// features.
		/// </param>
		public virtual SimpleTCLCommand load_features(bool? quiet = null, bool? verbose = null, string features = null)
		{
			// TCL Syntax: load_features [-quiet] [-verbose] [<features>...]
			return
				new SimpleTCLCommand("load_features")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(features)
			;
		}
		/// <summary>
		/// Locks or unlocks netlist, placement or routing of a design. The 'lock/unlock' will only applied on
		/// physically placed cells and routed nets
		///
		///
		/// TCL Syntax: lock_design [-level <arg>] [-unlock] [-export] [-quiet] [-verbose] [<cell>]
		///
		/// This command is used in the Hierarchical Design Flows for Design Preservation and Partial
		/// Reconfiguration. Refer to the Vivado Design Suite User Guide: Hierarchical Design (UG905) for more
		/// information on these design flows, and the use of this command.
		/// The lock_design command is used to lock down the placement and/or routing of a design, or
		/// of the specified cell of a design. After reading in an Out-of-Context (OOC) design checkpoint
		/// using the read_checkpoint command, the preservation level for the module must be defined.
		/// This command sets the IS_LOC_FIXED, IS_BEL_FIXED, and IS_ROUTE_FIXED properties of the
		/// specified logic.
		///
		/// The following example locks the netlist, placement, and routing data for the specified cells of the
		/// current design:
		/// lock_design -level routing [get_cells usbEngine*]
		/// This example unlocks the routing data for the specified cells of the current design, while leaving
		/// the netlist and placement data locked from the prior example:
		/// lock_design -unlock -level routing [get_cells usbEngine*]
		/// The following example unlocks the routing, placement, and netlist data for the specified cells of
		/// the current design:
		/// lock_design -unlock -level logical [get_cells usbEngine*]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1019
		/// </summary>
		/// <param name="level">
		/// (Optional)
		/// specify the locking and unlocking level; Valid values are
		/// logical, placement, and routing. Default: placement
		/// </param>
		/// <param name="unlock">
		/// (Optional)
		/// Unlock cells, if cells are not specified, whole design is
		/// unlocked; '-level' parameter must be specified for
		/// unlocking.
		/// </param>
		/// <param name="export">(Optional) mark that the constraints can be exported.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="cell">
		/// (Optional)
		/// Lock cells, if cells are not specified, whole design is locked.
		/// Notice only placed cells and routed nets will be locked.
		/// Default: *
		/// </param>
		public virtual SimpleTCLCommand lock_design(string level = null, bool? unlock = null, bool? export = null, bool? quiet = null, bool? verbose = null, string cell = null)
		{
			// TCL Syntax: lock_design [-level <arg>] [-unlock] [-export] [-quiet] [-verbose] [<cell>]
			return
				new SimpleTCLCommand("lock_design")
					.OptionalNamedString("level", level)
					.Flag("unlock", unlock)
					.Flag("export", export)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(cell)
			;
		}
		/// <summary>
		/// Log Switching Activity Interchange Format (SAIF) toggle for specified wire, signal, or reg
		///
		///
		/// TCL Syntax: log_saif [-quiet] [-verbose] <hdl_objects>...
		///
		/// Writes the switching activity rates for the specified HDL signals during the current simulation.
		/// The Switching Activity Interchange format (SAIF) file is an ASCII file containing header
		/// information, and toggle counts for the specified signals of the design. It also contains the timing
		/// attributes which specify time durations for signals at level 0, 1, X, or Z.
		/// The log_saif command can only be used after the open_saif command has opened an SAIF
		/// file in the current simulation to capture switching activity rates.
		///
		/// The following example logs switching activity for all signals in the current_scope:
		/// log_saif [ get_objects ]
		/// Log SAIF for only the internal signals starting with name c of the scope /tb/UUT:
		/// log_saif [get_objects -filter { type == internal_signal }/tb/UUT/c*]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1022
		/// </summary>
		/// <param name="hdl_objects">(Required) The hdl_objects to log</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Does not return any object</returns>
		public virtual SimpleTCLCommand log_saif(string hdl_objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: log_saif [-quiet] [-verbose] <hdl_objects>...
			return
				new SimpleTCLCommand("log_saif")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hdl_objects)
			;
		}
		/// <summary>
		/// Log Value Change Dump (VCD) simulation output for specified wire, signal, or reg
		///
		///
		/// TCL Syntax: log_vcd [-level <arg>] [-quiet] [-verbose] [<hdl_objects>...]
		///
		/// Indicates which HDL objects to write into the Value Change Dump (VCD) file. In some designs
		/// the simulation results can become quite large; the log_vcd command lets you define the
		/// specific content of interest. This command models the behavior of the Verilog $dumpvars
		/// system task.
		/// HDL objects include HDL signals, variables, or constants as defined in the Verilog or VHDL test
		/// bench and source files. An HDL signal includes Verilog wire or reg entities, and VHDL signals.
		/// Examples of HDL variables include Verilog real, realtime, time, and event.
		/// This command specifies which HDL objects and how many levels of design hierarchy to write
		/// into the VCD file. The actual values of the objects are written to the VCD file when you run the
		/// checkpoint_vcd or flush_vcd commands at a specific time during simulation.
		/// IMPORTANT! You must use the open_vcd command before using any other *_vcd commands.
		/// Nothing is returned by this command.
		///
		/// This command specifies which HDL objects and how many levels of design hierarchy to write
		/// into the VCD file. The actual values of the objects are written to the VCD file when you run the
		/// checkpoint_vcd or flush_vcd commands at a specific time during simulation.
		/// IMPORTANT! You must use the open_vcd command before using any other *_vcd commands.
		/// Nothing is returned by this command.
		/// Arguments
		/// -level <arg> - (Optional) Specifies the number of levels of design hierarchy to traverse when
		/// locating HDL objects to write to the VCD file. The default value of 0 causes the tool to dump all
		/// values for the specified HDL objects at the level of hierarchy defined by <hdl_objects>, and all
		/// levels below that. A value of 1 indicates that only the level of hierarchy specified by
		/// <hdl_objects> should be written to the VCD file.
		/// -quiet - (Optional) Execute the command quietly, returning no messages from the command.
		/// The command also returns TCL_OK regardless of any errors encountered during execution.
		/// Note: Any errors encountered on the command-line, while launching the command, will be returned. Only
		/// errors occurring inside the command will be trapped.
		/// -verbose - (Optional) Temporarily override any message limits and return all messages from this
		/// command.
		/// Note: Message limits can be defined with the set_msg_config command.
		/// <hdl_objects> - (Optional) Specifies the HDL objects to identify and write changing values into
		/// the VCD file. The level of hierarchy is also represented in the hdl_objects pattern. For
		/// instance /tb/UUT/* indicates all HDL objects within the /tb/UUT level of the design.
		/// Examples
		/// Log value changes for all the ports from the scope /tb/UUT:
		/// log_vcd [get_objects -filter { type == port } /tb/UUT/* ]
		/// Note: Since -levels is not specified, all levels below the specified scope will be searched for ports
		/// matching the specified pattern as well.
		/// Log VCD for all the objects in the current_scope:
		/// log_vcd *
		/// log_vcd [ get_objects *]
		/// Log value changes for only internal signals with names starting with C, of the root scope /tb/
		/// UUT:
		/// log_vcd [get_objects -filter { type == internal_signal }./C*]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1024
		/// </summary>
		/// <param name="level">(Optional) Number of levels to log (for HDL scopes) Default: 0</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hdl_objects">(Optional) Which HDL objects to log</param>
		/// <returns>Does not return any object</returns>
		public virtual SimpleTCLCommand log_vcd(string level = null, bool? quiet = null, bool? verbose = null, string hdl_objects = null)
		{
			// TCL Syntax: log_vcd [-level <arg>] [-quiet] [-verbose] [<hdl_objects>...]
			return
				new SimpleTCLCommand("log_vcd")
					.OptionalNamedString("level", level)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(hdl_objects)
			;
		}
		/// <summary>
		/// Log simulation output for specified wire, signal, or reg for viewing using Vivado Simulators
		/// waveform viewer. Unlike add_wave, this command does not add the waveform object to
		/// waveform viewer (i.e. Waveform Configuration). It simply enables logging of output to the Vivado
		/// Simulators Waveform Database (WDB).
		///
		///
		/// TCL Syntax: log_wave [-recursive] [-r] [-verbose] [-v] [-quiet] <hdl_objects>...
		///
		/// Log simulation activity for the specified HDL objects into the waveform database file (.wdb) for
		/// viewing using Vivado simulator waveform viewer.
		/// In the Vivado simulator, an HDL object is an entity that can hold a value, such as a wire, signal, or
		/// register.
		/// Unlike add_wave, this command does not add the waveform object to waveform configuration.
		/// It simply enables logging of waveform activity to the Vivado simulator waveform database
		/// (WDB). See the Vivado Design Suite User Guide: Logic Simulation (UG900) for more information.
		/// This command returns nothing.
		///
		/// The following example logs the waveform activities for the specified HDL objects.
		/// log_wave -r [get_objects /testbench/dut/*]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1026
		/// </summary>
		/// <param name="hdl_objects">(Required) Which hdl_objects to trace</param>
		/// <param name="recursive">(Optional) Searches recursively for objects</param>
		/// <param name="r">(Optional) Searches recursively for objects</param>
		/// <param name="verbose">(Optional) Displays all warnings</param>
		/// <param name="v">(Optional) Displays all warnings</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		public virtual SimpleTCLCommand log_wave(string hdl_objects, bool? recursive = null, bool? r = null, bool? verbose = null, bool? v = null, bool? quiet = null)
		{
			// TCL Syntax: log_wave [-recursive] [-r] [-verbose] [-v] [-quiet] <hdl_objects>...
			return
				new SimpleTCLCommand("log_wave")
					.Flag("recursive", recursive)
					.Flag("r", r)
					.Flag("verbose", verbose)
					.Flag("v", v)
					.Flag("quiet", quiet)
					.RequiredString(hdl_objects)
			;
		}
		/// <summary>
		/// Turns on or off printing of file name and line number of the hdl statement being simulated
		///
		///
		/// TCL Syntax: ltrace [-quiet] [-verbose] <value>
		///
		/// Enables line-level tracing for simulation debugging purposes.
		/// During simulation the simulation source file and line number being evaluated is returned to the
		/// Tcl console.
		/// TIP: Process tracing with the ptrace command provides more detailed information than is available with line
		/// tracing.
		/// This feature can also be enabled using the LINE_TRACING property on the current simulation
		/// object:
		/// set_property LINE_TRACING on [current_sim]
		/// The command returns the state of line tracing, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1028
		/// </summary>
		/// <param name="value">(Required) value: on, true, yes. Otherwise set to off, false, no</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand ltrace(string value, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: ltrace [-quiet] [-verbose] <value>
			return
				new SimpleTCLCommand("ltrace")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(value)
			;
		}
		/// <summary>
		/// Create external port for the corresponding interface pins. If a cell is specified, create external
		/// interface ports for all unconnected interface pins.
		///
		///
		/// TCL Syntax: make_bd_intf_pins_external [-quiet] [-verbose] <objects>...
		///
		/// Create an external interface port in the current block design and connect that to the selected
		/// block interface pin. If a bd_cell is specified as the argument, all unconnected block interface pins
		/// of that cell will be made external. The created external interface port will have the same
		/// properties as the selected block interface pin.
		/// IMPORTANT! For a group of block interface pins, one external port will be created per block interface pin.
		/// The selected block interface pin, if unconnected, will be connected to a new interface port at the
		/// top-most level of the block design.
		/// This command returns TCL_OK if successful, or TCL_ERROR if it fails, unless -quiet is specified.
		///
		/// The following example will select the specified block interface pin on the bd_cell axi_gpio_0,
		/// and connect it to an external interface port:
		/// make_bd_intf_pins_external [get_bd_intf_pins axi_gpio_0/S_AXI]
		/// The following example will look at all unconnected block interface pins of the bd_cell
		/// axi_gpio_0 and individually connect them to external interface ports:
		/// make_bd_intf_pins_external [get_bd_cells axi_gpio_0]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1030
		/// </summary>
		/// <param name="objects">(Required) The interface pins/cells to be made external</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Pass if successful in creating at least one interface port</returns>
		public virtual SimpleTCLCommand make_bd_intf_pins_external(string objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: make_bd_intf_pins_external [-quiet] [-verbose] <objects>...
			return
				new SimpleTCLCommand("make_bd_intf_pins_external")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Create external port for the corresponding pin. If a cell is specified, create external ports for all
		/// unconnected pins.
		///
		///
		/// TCL Syntax: make_bd_pins_external [-quiet] [-verbose] <objects>...
		///
		/// Create an external port in the current block design and connect that to the selected block pin. If
		/// a bd_cell is specified as the argument, all unconnected block pins of that cell will be made
		/// external. The created external port will have the same properties as the selected block pin.
		/// IMPORTANT! For a group of block pins, one external port will be created per block pin.
		/// The selected block pin, if unconnected, will be connected to a new port at the topmost level of
		/// the block design.
		/// This command returns TCL_OK if successful, or TCL_ERROR if it fails, unless -quiet is specified.
		///
		/// The following example will select a block pin on the bd_cell axi_gpio_0 and connect it to an
		/// external port:
		/// make_bd_pins_external [get_bd_pins axi_gpio_0/s_axi_aclk]
		/// The following example will look at all unconnected block pins of the bd_cell axi_gpio_0 and
		/// individually connect them to external ports:
		/// make_bd_pins_external [get_bd_cells axi_gpio_0]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1032
		/// </summary>
		/// <param name="objects">(Required) The pins/cells to be made external</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Pass if successful in creating at least one port</returns>
		public virtual SimpleTCLCommand make_bd_pins_external(string objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: make_bd_pins_external [-quiet] [-verbose] <objects>...
			return
				new SimpleTCLCommand("make_bd_pins_external")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Make differential pair for 2 ports
		///
		///
		/// TCL Syntax: make_diff_pair_ports [-quiet] [-verbose] <ports>...
		///
		/// Joins two existing ports to create a differential pair. The port directions, interfaces, and other
		/// properties must match in order for the specified ports to be joined as a differential pair.
		/// Otherwise an error will be returned.
		/// IMPORTANT! The two ports must first be created, either by using the create_port command or by reading
		/// in an XDC file, prior to making them into a differential pair.
		///
		/// The following example joins the two specified ports to create a differential pair:
		/// make_diff_pair_ports port_Pos1 port_Neg1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1034
		/// </summary>
		/// <param name="ports">(Required) Ports to join</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand make_diff_pair_ports(string ports, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: make_diff_pair_ports [-quiet] [-verbose] <ports>...
			return
				new SimpleTCLCommand("make_diff_pair_ports")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(ports)
			;
		}
		/// <summary>
		/// Generate HDL wrapper for the specified source
		///
		///
		/// TCL Syntax: make_wrapper [-top] [-testbench] [-inst_template] [-fileset <arg>] [-import] [-force] [-quiet] [-verbose] <files>
		///
		/// Create a Verilog or VHDL wrapper for instantiating a sub-design into the project.
		/// The make_wrapper command will create a wrapper for Embedded Processor Designs from the
		/// IP integrator of the Vivado Design Suite, or any IP integrator block design, as well as DSP
		/// modules created in System Generator or MathWorks MatLab.
		/// You can generate a wrapper to make the sub-design the top-level of a stand-alone design, or for
		/// instantiating a sub-design into an existing design. You can also generate a wrapper for a
		/// simulation test bench of System Generator sub-designs.
		/// Note: The wrapper is generated in Verilog or VHDL according to the TARGET_LANGUAGE property on the
		/// project.
		/// The command returns information related to the creation of the wrappers, or returns an error if it
		/// fails.
		///
		/// The following example creates the instantiation template to integrate the specified IP integrator
		/// block design into the design hierarchy of the current project:
		/// make_wrapper -inst_template -fileset [get_filesets sources_1] \
		/// -files [get_files C:/Data/design_1/design_1.bd]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1036
		/// </summary>
		/// <param name="files">(Required) Source file for which the wrapper needs to be generated</param>
		/// <param name="top">(Optional) Create a top-level wrapper for the specified source</param>
		/// <param name="testbench">(Optional) Create a testbench for the specified source</param>
		/// <param name="inst_template">
		/// (Optional)
		/// Create an instantiation template for the specified source.
		/// The template will not be added to the project and will be
		/// generated for reference purposes only.
		/// </param>
		/// <param name="fileset">(Optional) Fileset name</param>
		/// <param name="import">(Optional) Import generated wrapper to the project</param>
		/// <param name="force">(Optional) Overwrite existing source(s)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand make_wrapper(string files, bool? top = null, bool? testbench = null, bool? inst_template = null, string fileset = null, bool? import = null, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: make_wrapper [-top] [-testbench] [-inst_template] [-fileset <arg>] [-import] [-force] [-quiet] [-verbose] <files>
			return
				new SimpleTCLCommand("make_wrapper")
					.Flag("top", top)
					.Flag("testbench", testbench)
					.Flag("inst_template", inst_template)
					.OptionalNamedString("fileset", fileset)
					.Flag("import", import)
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(files)
			;
		}
		/// <summary>
		/// Mark objects in GUI
		///
		///
		/// TCL Syntax: mark_objects [-rgb <args>] [-color <arg>] [-quiet] [-verbose] <objects>
		///
		/// Marks specified objects in GUI mode. This command places an iconic mark to aid in the location
		/// of the specified object or objects. The mark is displayed in a color as determined by one of the
		/// color options.
		/// Objects can be unmarked with the unmark_objects command.
		/// Note: Use only one color option. If both color options are specified, -rgb takes precedence over -color.
		///
		/// The following example adds a red icon to mark the currently selected objects:
		/// mark_objects -color red [get_selected_objects]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1039
		/// </summary>
		/// <param name="objects">(Required) Objects to mark</param>
		/// <param name="rgb">(Optional) RGB color index list</param>
		/// <param name="color">(Optional) Valid values are red green blue magenta yellow cyan and orange</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand mark_objects(string objects, string rgb = null, string color = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: mark_objects [-rgb <args>] [-color <arg>] [-quiet] [-verbose] <objects>
			return
				new SimpleTCLCommand("mark_objects")
					.OptionalNamedString("rgb", rgb)
					.OptionalNamedString("color", color)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Modify routed probe connections to debug cores.
		///
		///
		/// TCL Syntax: modify_debug_ports [-probes <args>] [-quiet] [-verbose]
		///
		/// Modifies a routed design to connect nets to specified ports of debug cores. This command takes
		/// a list of connections to be made to specified debug probes. Each connection is defined as a Tcl
		/// list, enclosed in braces {}, specifying the following three elements separated by spaces:
		/// 1. The logical pin of the debug core to be connected.
		/// 2. The channel index of the specified probe.
		/// 3. The logical net of the signal to be probed.
		/// Multiple probe connections are specified as a list of lists, with each connection itself being a Tcl
		/// list as shown in the example.
		/// The command performs all of the netlist modifications to disconnect existing net connections to
		/// the specified probe ports as needed, connecting each net to be probed to the specified probe
		/// port, and automatically routing the modified connections. Nets that become disconnected during
		/// the process are left unconnected.
		///
		/// The following example modifies 3 probe connections:
		/// modify_debug_ports -probes [list {top/x_ila/probe0 0 top/inst_A/net_0} \
		/// {top/x_ila/probe1 1 top/inst_A/net_a} {top/x_ila/probe1 2 top/inst_A/
		/// net_b}]
		/// TIP: The modify_debug_ports command moves a port probe from one signal to another.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1041
		/// </summary>
		/// <param name="probes">
		/// (Required)
		/// List of probes to be connected: debug core pin, channel
		/// index, and logical net for each probe connection.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand modify_debug_ports(string probes, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: modify_debug_ports [-probes <args>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("modify_debug_ports")
					.RequiredNamedString("probes", probes)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Move cells into a hierarchy cell. The connections between these cells are maintained; the
		/// connections between these cells and other cells are maintained through crossing hierarchy cell.
		///
		///
		/// TCL Syntax: move_bd_cells [-prefix <arg>] [-quiet] [-verbose] [<parent_cell>] [<cells>...]
		///
		/// Move IP integrator cells into the specified hierarchical module within the current subsystem
		/// design. The connections between the cells being moved are maintained; connections between
		/// these cells and other cells that are not being moved are maintained automatically by IP integrator
		/// adding pins and ports to cross the hierarchical boundary.
		/// Cells in the IP subsystem design can also be copied into a hierarchical module using
		/// copy_bd_objs, and can be grouped and added to a hierarchical module using
		/// group_bd_cells.
		/// This command returns the name of the <parent_cell> module when successful, or returns an
		/// error message if it failed.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1043
		/// </summary>
		/// <param name="prefix">(Optional) Prefix name to add to cells</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="parent_cell">(Optional) Parent cell</param>
		/// <param name="cells">(Optional) Match engine names against cell names Default: *</param>
		/// <returns>0 if success.</returns>
		public virtual SimpleTCLCommand move_bd_cells(string prefix = null, bool? quiet = null, bool? verbose = null, string parent_cell = null, string cells = null)
		{
			// TCL Syntax: move_bd_cells [-prefix <arg>] [-quiet] [-verbose] [<parent_cell>] [<cells>...]
			return
				new SimpleTCLCommand("move_bd_cells")
					.OptionalNamedString("prefix", prefix)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(parent_cell)
					.OptionalString(cells)
			;
		}
		/// <summary>
		/// Reposition the Gadget for Project summary dashboard
		///
		///
		/// TCL Syntax: move_dashboard_gadget -name <arg> -row <arg> -col <arg> [-dashboard <arg>] [-quiet] [-verbose]
		///
		/// Specify the placement of a dashboard gadget into the dashboard.
		/// TIP: Currently the Project Summary is the only dashboard, so the gadget is placed into that dashboard.
		/// The arrangement of gadgets in a dashboard is by row and column. The Project Summary
		/// dashboard has two columns, 0 and 1, and has as many rows as needed to display all the gadgets.
		/// If you specify a column other than 0 or 1, or specify a row in excess of the current defined rows +
		/// 1, an error will be returned.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1045
		/// </summary>
		/// <param name="name">(Required) Name of the gadget</param>
		/// <param name="row">(Required) Target row number to which the gadget has to be moved</param>
		/// <param name="col">(Required) Target column number to which the gadget has to be moved</param>
		/// <param name="dashboard">(Optional) Name of the dashboard to which the gadget is associated</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand move_dashboard_gadget(string name, string row, string col, string dashboard = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: move_dashboard_gadget -name <arg> -row <arg> -col <arg> [-dashboard <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("move_dashboard_gadget")
					.RequiredNamedString("name", name)
					.RequiredNamedString("row", row)
					.RequiredNamedString("col", col)
					.OptionalNamedString("dashboard", dashboard)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Moves the files from one fileset to another while maintaining all of their original properties.
		///
		///
		/// TCL Syntax: move_files [-fileset <arg>] [-of_objects <args>] [-quiet] [-verbose] [<files>...]
		///
		/// Moves files returned by the get_files command from one fileset to another while maintaining
		/// the properties on the files.
		/// This command returns the list of files that were moved, or an error if the command fails.
		///
		/// The following example moves the file, top_full.xdc, to the constrs_2 fileset.
		/// move_files -fileset constrs_2 [get_files top_full.xdc]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1047
		/// </summary>
		/// <param name="fileset">(Optional) Destination fileset name</param>
		/// <param name="of_objects">(Optional) Reconfig Modules to move the files to</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="files">(Optional) Name of the files to be moved</param>
		/// <returns>list of files that were moved</returns>
		public virtual SimpleTCLCommand move_files(string fileset = null, string of_objects = null, bool? quiet = null, bool? verbose = null, string files = null)
		{
			// TCL Syntax: move_files [-fileset <arg>] [-of_objects <args>] [-quiet] [-verbose] [<files>...]
			return
				new SimpleTCLCommand("move_files")
					.OptionalNamedString("fileset", fileset)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(files)
			;
		}
		/// <summary>
		/// Moves wave objects from their current position to the specified position in the wave
		/// configuration
		///
		///
		/// TCL Syntax: move_wave [-into <args>] [-at_wave <args>] [-after_wave <args>] [-before_wave <args>] [-quiet] [-verbose] <items>...
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1049
		/// </summary>
		/// <param name="items">(Required) wave objects to move</param>
		/// <param name="into">
		/// (Optional)
		/// the wave configuration, group, or virtual bus into which the
		/// wave object(s) will be moved.
		/// </param>
		/// <param name="at_wave">
		/// (Optional)
		/// inserts the new wave object(s) into the specified wave
		/// object, or after the specified wave object if not a group or
		/// virtual bus
		/// </param>
		/// <param name="after_wave">(Optional) inserts the new wave objects(s) after the specified wave object</param>
		/// <param name="before_wave">(Optional) inserts the new wave objects(s) before the specified wave object</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand move_wave(string items, string into = null, string at_wave = null, string after_wave = null, string before_wave = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: move_wave [-into <args>] [-at_wave <args>] [-after_wave <args>] [-before_wave <args>] [-quiet] [-verbose] <items>...
			return
				new SimpleTCLCommand("move_wave")
					.OptionalNamedString("into", into)
					.OptionalNamedString("at_wave", at_wave)
					.OptionalNamedString("after_wave", after_wave)
					.OptionalNamedString("before_wave", before_wave)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(items)
			;
		}
		/// <summary>
		/// Open an existing IP subsystem design from disk file.
		///
		///
		/// TCL Syntax: open_bd_design [-quiet] [-verbose] <name>
		///
		/// Open an IP subsystem design in the IP integrator of the Vivado IDE. The IP subsystem must
		/// previously have been created using the create_bd_design command.
		/// This command returns a message with the name of the opened IP subsystem design, or returns
		/// an error if the command fails.
		///
		/// The following opens the specified IP subsystem design in the current project:
		/// open_bd_design C:/Data/project1/project1.src/sources_1/bd/design_1/
		/// design_1.bd
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1050
		/// </summary>
		/// <param name="name">(Required) Name of IP subsystem design to open</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The design object. Returns nothing if the command fails.</returns>
		public virtual SimpleTCLCommand open_bd_design(string name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: open_bd_design [-quiet] [-verbose] <name>
			return
				new SimpleTCLCommand("open_bd_design")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
			;
		}
		/// <summary>
		/// Open a design checkpoint in a new project
		///
		///
		/// TCL Syntax: open_checkpoint [-part <arg>] [-ignore_timing] [-quiet] [-verbose] <file>
		///
		/// Open a design checkpoint file (DCP), create a new in-memory project and initialize a design
		/// immediately in the new project with the contents of the checkpoint. This command can be used
		/// to open a top-level design checkpoint, or the checkpoint created for an out-of-context module.
		/// When opening a checkpoint, there is no need to create a project first. The open_checkpoint
		/// command reads the design data into memory, opening the design in Non-Project Mode. Refer to
		/// the Vivado Design Suite User Guide: Design Flows Overview (UG892) for more information on
		/// Project Mode and Non-Project Mode.
		/// Note: When multiple design checkpoints are open in the Vivado tool, you must use the
		/// current_project command to switch between the open designs. You can use current_design to
		/// check which checkpoint is the active design.
		///
		/// The following example opens the specified checkpoint file, and specifies the target part for the
		/// design:
		/// open_checkpoint C:/Data/state1/checkpoint.dcp -part xc7k325tffg900-2
		/// Note: If the specified part is not compatible with the device and package used by the specified checkpoint,
		/// the command will return an error.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1052
		/// </summary>
		/// <param name="file">(Required) Design checkpoint file</param>
		/// <param name="part">
		/// (Optional)
		/// Override the checkpoint part. Note that this may cause
		/// errors if the checkpoint contains xdef.
		/// </param>
		/// <param name="ignore_timing">
		/// (Optional)
		/// reload a checkpoint without the timing constraints. Will not
		/// work if '-time' option given.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand open_checkpoint(string file, string part = null, bool? ignore_timing = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: open_checkpoint [-part <arg>] [-ignore_timing] [-quiet] [-verbose] <file>
			return
				new SimpleTCLCommand("open_checkpoint")
					.OptionalNamedString("part", part)
					.Flag("ignore_timing", ignore_timing)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Open the example project for the indicated IP
		///
		///
		/// TCL Syntax: open_example_project [-dir <arg>] [-force] [-in_process] [-quiet] [-verbose] <objects>...
		///
		/// Open an example project for the specified IP cores. The example project can be used to explore
		/// the features of the IP core in a stand-alone project, instead of integrated into the current project.
		///
		/// The following copies the IP customization and opens the example project for the specified IP
		/// core in a new location:
		/// open_example_project -dir C:/Data/examples -force [get_ips blk_mem*]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1054
		/// </summary>
		/// <param name="objects">(Required) The objects whose example projects will be opened</param>
		/// <param name="dir">(Optional) Path to directory where example project will be created</param>
		/// <param name="force">(Optional) Overwrite an example project if it exists</param>
		/// <param name="in_process">(Optional) Open the example project in the same process</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The Project that was opened</returns>
		public virtual SimpleTCLCommand open_example_project(string objects, string dir = null, bool? force = null, bool? in_process = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: open_example_project [-dir <arg>] [-force] [-in_process] [-quiet] [-verbose] <objects>...
			return
				new SimpleTCLCommand("open_example_project")
					.OptionalNamedString("dir", dir)
					.Flag("force", force)
					.Flag("in_process", in_process)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Open the hardware tool
		///
		///
		/// TCL Syntax: open_hw_manager [-quiet] [-verbose]
		///
		/// Open the Hardware Manager in the Vivado Design Suite in either the Vivado IDE or in Tcl or
		/// batch mode. Opening the Hardware Manager is the first step in programming and/or debugging
		/// your design in Xilinx FPGA hardware. For more information refer to the Vivado Design Suite User
		/// Guide: Programming and Debugging (UG908).
		/// Hardware Manager is a feature of the Vivado Design Suite which lets you interact with FPGA
		/// devices on a board. The features of the Hardware Manager include:
		/// • Logic Debug or Logic Analyzer- Debugging FPGA programmable logic designs.
		/// • Programming/Configuration - Program FPGA devices using JTAG and configuring flash
		/// memory devices connected to FPGAs.
		/// • In-system Serial I/O debug - Adjust SERDES receive/transmit settings and measure
		/// transmission bit error rates.
		/// • System Monitor - Control on chip system monitor and read system monitor temperature and
		/// voltage values.
		/// The Hardware Manager uses a number of first class objects, like hw_server, hw_target,
		/// hw_device, and hw_ila. Each of these objects is related to other objects, and has properties that
		/// can be set or read by the set_property and get_property commands to configure or
		/// control its function in the Hardware Manager. Refer to the Vivado Design Suite Properties
		/// Reference Guide (UG912) for more information on these objects.
		/// The steps to connect to hardware and program the target FPGA are:
		/// 1. Open the hardware manager in the IDE (open_hw_manager).
		/// TIP: This step can be skipped if you are running in batch or Tcl mode.
		/// 2. Connect to a hardware server running either on the local machine, or on a remote network
		/// accessible host (connect_hw_server).
		/// 3. Open a hardware target on the connected hardware server (open_hw_target).
		/// 4. Identify the Xilinx FPGA on the open hardware target (current_hw_device,
		/// get_hw_devices).
		/// 5. Associate the bitstream data programming file (.bit), and probes file (.ltx) if one exists,
		/// with the appropriate FPGA (set_property).
		/// 6. Program or download the programming file into the hardware device
		/// (program_hw_device, refresh_hw_device).
		/// Note that you can run the Hardware Manager from within the Vivado tool without having a
		/// project or design open. You can open the Hardware Manager, connect to the hardware server,
		/// and program the device on the target by providing a bitstream file, and probes file for debugging.
		/// You can close the Hardware Manager using the close_hw_manager command.
		/// This command returns nothing if successful, and returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1056
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand open_hw_manager(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: open_hw_manager [-quiet] [-verbose]
			return
				new SimpleTCLCommand("open_hw_manager")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Open the Xilinx Shell Archive
		///
		///
		/// TCL Syntax: open_hw_platform [-auto_upgrade] [-quiet] [-verbose] [<file>]
		///
		/// Open a Xilinx support archive (XSA) file and extract the Vivado project, block design, and IP from
		/// the archive. This will create a project directory and project file (.xpr) from the XSA.
		/// Note: The project will be created in the current working directory, or the directory from which the Vivado
		/// tool was launched.
		/// This command returns a transcript of its actions, or returns an error if it fails.
		///
		/// The following example opens the specified XSA, automatically upgrading the IP as needed:
		/// open_hw_platform -auto_upgrade C:/Data/zc706.xsa
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1059
		/// </summary>
		/// <param name="file">
		/// (Required)
		/// Xilinx Shell Archive file Values: A filename with alphanumeric
		/// characters and .dsa/.xsa extension.
		/// </param>
		/// <param name="auto_upgrade">(Optional) Automatically upgrade the BD</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The name of the shell file</returns>
		public virtual SimpleTCLCommand open_hw_platform(string file, bool? auto_upgrade = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: open_hw_platform [-auto_upgrade] [-quiet] [-verbose] [<file>]
			return
				new SimpleTCLCommand("open_hw_platform")
					.Flag("auto_upgrade", auto_upgrade)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Open a connection to a hardware target on the hardware server
		///
		///
		/// TCL Syntax: open_hw_target [-jtag_mode <arg>] [-xvc_url <arg>] [-auto_calibrate] [-quiet] [-verbose] [<hw_target>]
		///
		/// Opens a connection to the specified hardware target of the connected hardware servers, or
		/// opens the current hardware target.
		/// The hardware target is a system board containing a JTAG chain of one or more Xilinx devices that
		/// you can program with a bitstream file, or use to debug your design. Connections between
		/// hardware targets on the system board and the Vivado Design Suite are managed by the Xilinx
		/// hardware server application, and the connect_hw_server command. Refer to Vivado Design
		/// Suite User Guide: Programming and Debugging (UG908) for a list of supported JTAG download
		/// cables and devices.
		/// Each hardware target can have one or more Xilinx devices to program, or to use for debugging
		/// purposes. The current device is specified or returned by the current_hw_device command.
		/// Use the open_hw_target command to open a connection to one of the available hardware
		/// targets. The open target is automatically defined as the current hardware target. Alternatively,
		/// you can define the current target with the current_hw_target command, and then open the
		/// current target. The Vivado Design Suite directs programming and debug commands to the open
		/// target through the hardware server connection.
		/// An open connection to the hardware target can be closed using the close_hw_target
		/// command.
		/// The open_hw_target command returns connection messages from the hardware server, or
		/// returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1061
		/// </summary>
		/// <param name="jtag_mode">(Optional) Open target in JTAG mode</param>
		/// <param name="xvc_url">(Optional) Open target connection to XVC server</param>
		/// <param name="auto_calibrate">(Optional) Auto-calibrate target for optimal frequency (SmartLynq cable only)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_target">(Optional) hardware target Default: current hardware target</param>
		public virtual SimpleTCLCommand open_hw_target(string jtag_mode = null, string xvc_url = null, bool? auto_calibrate = null, bool? quiet = null, bool? verbose = null, string hw_target = null)
		{
			// TCL Syntax: open_hw_target [-jtag_mode <arg>] [-xvc_url <arg>] [-auto_calibrate] [-quiet] [-verbose] [<hw_target>]
			return
				new SimpleTCLCommand("open_hw_target")
					.OptionalNamedString("jtag_mode", jtag_mode)
					.OptionalNamedString("xvc_url", xvc_url)
					.Flag("auto_calibrate", auto_calibrate)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(hw_target)
			;
		}
		/// <summary>
		/// Open an IO design
		///
		///
		/// TCL Syntax: open_io_design [-name <arg>] [-part <arg>] [-constrset <arg>] [-quiet] [-verbose]
		///
		/// Opens a new or existing I/O Pin Planning design.
		/// Note: The design_mode property for the current source fileset must be defined as PinPlanning in order to
		/// open an I/O design. If not, you will get the following error:
		/// ERROR: The design mode of 'sources_1' must be PinPlanning
		///
		/// The following creates a new I/O design called myIO:
		/// open_io_design -name myIO
		/// Note: The default source set, constraint set, and part will be used in this case.
		/// The following example opens an existing I/O design called myIO, and specifies the constraint set
		/// to be used:
		/// open_io_design -name myIO -constrset topCon
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1064
		/// </summary>
		/// <param name="name">(Optional) Design name</param>
		/// <param name="part">(Optional) Target part</param>
		/// <param name="constrset">(Optional) Constraint fileset to use</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>design object</returns>
		public virtual SimpleTCLCommand open_io_design(string name = null, string part = null, string constrset = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: open_io_design [-name <arg>] [-part <arg>] [-constrset <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("open_io_design")
					.OptionalNamedString("name", name)
					.OptionalNamedString("part", part)
					.OptionalNamedString("constrset", constrset)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Open a Vivado project file (.xpr)
		///
		///
		/// TCL Syntax: open_project [-part <arg>] [-read_only] [-quiet] [-verbose] <file>
		///
		/// Opens the specified Vivado Design Suite project file (.xpr), or the project file for the Vivado Lab
		/// Edition (.lpr).
		/// IMPORTANT! The open_project command has a different command syntax in the Vivado Lab Edition. The
		/// -part option is not supported because the Vivado Lab Edition project (.lpr) does not specify a target part.
		/// The current_hw_target and current_hw_device commands determine the target part.
		/// This command returns a transcript of its process and the name of the created project, or returns
		/// an error if it fails.
		///
		/// The following example opens the project named my_project1 located in the Designs directory.
		/// open_project C:/Designs/project1.xpr
		/// Note: The project must be specified with the .xpr extension for the tool to recognize it as a project file.
		/// The path to the file must be specified along with the project file name or the tool will return an error that it
		/// cannot find the specified file.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1066
		/// </summary>
		/// <param name="file">(Required) Project file to be read</param>
		/// <param name="part">(Optional) Open the project using this part (overrides project's part)</param>
		/// <param name="read_only">(Optional) Open the project in read-only mode</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>opened project object</returns>
		public virtual SimpleTCLCommand open_project(string file, string part = null, bool? read_only = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: open_project [-part <arg>] [-read_only] [-quiet] [-verbose] <file>
			return
				new SimpleTCLCommand("open_project")
					.OptionalNamedString("part", part)
					.Flag("read_only", read_only)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Open report from .rpx file
		///
		///
		/// TCL Syntax: open_report [-file <arg>] [-append] [-console] [-name <arg>] [-return_string] [-quiet] [-verbose] <rpx>
		///
		/// Read an RPX (protobuf) file into memory to reload report results into the Vivado Design Suite.
		/// This command requires an open implemented or synthesized design.
		/// The RPX file is written by report commands such as report_timing_summary, and
		/// report_pulse_width, that support the -rpx option, and is an interactive report file that can
		/// be reloaded into memory. Reloading the report into memory, reconnects the objects in the report
		/// to design objects so that cross-selection between the report in the Vivado IDE and the design is
		/// enabled.
		/// This command returns the report results to the Tcl console by default, or when -console is
		/// specified, or opens a report window in the Vivado IDE when -name is specified. This command
		/// returns an error if it fails.
		///
		/// The following example reads the specified RPX file an opens a named report in the Vivado IDE:
		/// open_report -name RPX1 design1_summary.rpx
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1068
		/// </summary>
		/// <param name="rpx">(Required) Report data file to be read</param>
		/// <param name="file">(Optional) Filename to output results to</param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="console">(Optional) Send output to console</param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="return_string">(Optional) Return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand open_report(string rpx, string file = null, bool? append = null, bool? console = null, string name = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: open_report [-file <arg>] [-append] [-console] [-name <arg>] [-return_string] [-quiet] [-verbose] <rpx>
			return
				new SimpleTCLCommand("open_report")
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.Flag("console", console)
					.OptionalNamedString("name", name)
					.Flag("return_string", return_string)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(rpx)
			;
		}
		/// <summary>
		/// Open a run into a netlist or implementation design
		///
		///
		/// TCL Syntax: open_run [-name <arg>] [-pr_config <arg>] [-quiet] [-verbose] <run>
		///
		/// Opens the specified synthesis run into a Netlist Design or implementation run into an
		/// Implemented Design. The run properties defining the target part and constraint set are combined
		/// with the synthesis or implementation results to create the design view in the tool.
		/// This command is intended to open a synthesized or implemented design that was created from
		/// design runs in Project Mode in the Vivado Design Suite.
		/// Use the open_checkpoint command to open a Non-Project based checkpoint into memory,
		/// opening the design in Non-Project Mode. Refer to the Vivado Design Suite User Guide: Design
		/// Flows Overview (UG892) for more information on Project Mode and Non-Project Mode.
		///
		/// The following command opens the specified synthesis run into a Netlist Design named
		/// synthPass1:
		/// open_run -name synthPass1 synth_1
		/// The following opens an Implemented Design for impl_1:
		/// open_run impl_1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1071
		/// </summary>
		/// <param name="run">(Required) Run to open into the design</param>
		/// <param name="name">(Optional) Design name</param>
		/// <param name="pr_config">
		/// (Optional)
		/// PR Configuration to apply while opening the design (only
		/// valid when opening a synthesis run)
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>design object</returns>
		public virtual SimpleTCLCommand open_run(string run, string name = null, string pr_config = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: open_run [-name <arg>] [-pr_config <arg>] [-quiet] [-verbose] <run>
			return
				new SimpleTCLCommand("open_run")
					.OptionalNamedString("name", name)
					.OptionalNamedString("pr_config", pr_config)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(run)
			;
		}
		/// <summary>
		/// Open file for storing signal switching rate for power estimation. The switching rate is written out
		/// in Switching Activity Interchange Format (SAIF) Only one SAIF is allowed to be open per
		/// simulation run.
		///
		///
		/// TCL Syntax: open_saif [-quiet] [-verbose] <file_name>
		///
		/// Create or open a Switching Activity Interchange Format (SAIF) file for storing signal switching
		/// rates in the current simulation for later use by the report_power command.
		/// The Switching Activity Interchange format (SAIF) file is an ASCII file containing header
		/// information, and toggle counts for the specified signals of the design. It also contains the timing
		/// attributes which specify time durations for signals at level 0, 1, X, or Z.
		/// The SAIF file is recommended for power analysis since it is smaller than the VCD file.
		/// When an SAIF file has been opened, you can write the switching activity from the simulation into
		/// the SAIF file using log_saif.
		/// Only one SAIF can be open at one time during simulation. To close the SAIF file, use the
		/// close_saif command.
		/// This command returns the object ID of the opened SAIF file, or returns an error if the command
		/// failed.
		///
		/// The following example opens the specified simulation:
		/// open_saif myData.saif
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1073
		/// </summary>
		/// <param name="file_name">(Required) The SAIF filename to store information</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The SAIF object that was opened</returns>
		public virtual SimpleTCLCommand open_saif(string file_name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: open_saif [-quiet] [-verbose] <file_name>
			return
				new SimpleTCLCommand("open_saif")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file_name)
			;
		}
		/// <summary>
		/// Open a Value Change Dump (VCD) file for capturing simulation output. This Tcl command models
		/// behavior of $dumpfile Verilog system task
		///
		///
		/// TCL Syntax: open_vcd [-quiet] [-verbose] [<file_name>]
		///
		/// Create or open a Value Change Dump (VCD) file to capture simulation output. This command
		/// operates like the Verilog $dumpfile simulator directive.
		/// VCD is an ASCII file containing header information, variable definitions, and value change details
		/// of a set of HDL signals. The VCD file can be used to view simulation result in a VCD viewer or to
		/// estimate the power consumption of the design.
		/// When a VCD file has been opened, you can write the value changes from the simulation into the
		/// VCD file using checkpoint_vcd, flush_vcd, or log_vcd. In addition, you can pause and
		/// resume the collection of value change data with the stop_vcd and start_vcd commands.
		/// You can limit the size of the VCD file by using the limit_vcd command.
		/// To close the VCD file, use the close_vcd command.
		/// Note: You must use the open_vcd command before using any other *_vcd commands. Only one VCD file
		/// can be open at any time.
		///
		/// The following example opens the specified VCD file (design1.vcd) so that value changes can
		/// be written to it. The log_vcd command identifies all ports in the /tb/UUT scope, and only that
		/// level of the design hierarchy, to be written to the VCD file. The simulation is run for a specified
		/// period of time, and flush_vcd writes the current values of the HDL objects to the VCD file.
		/// Then close_vcd closes the open file.
		/// open_vcd design1.vcd
		/// log_vcd -level 1 [get_objects filter { type == port } /tb/UUT/* ]
		/// run 1000
		/// flush_vcd
		/// close_vcd
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1075
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="file_name">
		/// (Optional)
		/// file name. Defaults to dump.vcd (This is LRM standard)
		/// Default: dump.vcd
		/// </param>
		/// <returns>
		/// </returns>
		public virtual SimpleTCLCommand open_vcd(bool? quiet = null, bool? verbose = null, string file_name = null)
		{
			// TCL Syntax: open_vcd [-quiet] [-verbose] [<file_name>]
			return
				new SimpleTCLCommand("open_vcd")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(file_name)
			;
		}
		/// <summary>
		/// Open a wave config
		///
		///
		/// TCL Syntax: open_wave_config [-quiet] [-verbose] [<filename>]
		///
		/// Open the specified Wave Config file (.wcfg) in the current simulation.
		/// Vivado simulator uses a simulation debug data model to allow users to debug HDL source files
		/// using source code stepping, breakpoints, conditions, and waveform viewing tools. The debug
		/// data model contains HDL object and scope names, and maps them to memory addresses to let
		/// you examine the changing values of signals, variables and constants during the simulation.
		/// The waveform database is separate from the Wave Config file that stores the waveform activity
		/// for the simulation. The Wave Config file contains just the list of wave objects (signals, dividers,
		/// groups, virtual buses) to display, and their display properties, plus markers. The waveform
		/// database (WDB) contains the event data, values changing over time, for all traced signals,
		/// whether displayed or not.
		/// A wave configuration object is created in the current simulation with the
		/// create_wave_config command. A Wave Config file is written to disk by the use of the
		/// save_wave_config command, and can be opened with the open_wave_config command.
		/// The open_wave_config command opens a Wave Config file and maps it to the data source in
		/// the current simulation.
		/// IMPORTANT! Any HDL objects that are specified in the Wave Config file that are not found in the current
		/// simulation will be ignored.
		///
		/// The following example opens the specified Wave Config file:
		/// open_wave_config testbench.wcfg
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1077
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="filename">
		/// (Optional)
		/// the name of a WCFG file from which to create a new wave
		/// configuration and corresponding wave window
		/// </param>
		/// <returns>The wave config opened</returns>
		public virtual SimpleTCLCommand open_wave_config(bool? quiet = null, bool? verbose = null, string filename = null)
		{
			// TCL Syntax: open_wave_config [-quiet] [-verbose] [<filename>]
			return
				new SimpleTCLCommand("open_wave_config")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(filename)
			;
		}
		/// <summary>
		/// Open Waveform Database (WDB) file produced by a prior simulation run and return a simulation
		/// object
		///
		///
		/// TCL Syntax: open_wave_database [-noautoloadwcfg] [-protoinst <args>] [-quiet] [-verbose] <wdb>
		///
		/// The open_wave_database command opens an existing static simulator database file (WDB)
		/// and associated wave config file (WCFG). This simulation is a static simulation, not live, and can
		/// only be used to review prior results.
		/// Note: Many of the commands for running and resetting the simulation are not available in a static
		/// simulation.
		/// Vivado simulator uses a simulation debug data model to allow users to debug HDL source files
		/// using source code stepping, breakpoints, conditions, and waveform viewing tools. The debug
		/// data model contains HDL object and scope names, and maps them to memory addresses to let
		/// you examine the changing values of signals, variables and constants during the simulation. When
		/// the simulation completes, the simulation is written to a static simulator database file (WDB).
		/// HDL objects can be added to the simulation waveform database using the log_wave command
		/// which enables logging of waveform activity for the specified objects to the Vivado simulator
		/// waveform database.
		/// The waveform database is associated with a Wave Config file that stores the waveform activity
		/// for the simulation. The Wave Config file contains just the list of wave objects (signals, dividers,
		/// groups, virtual buses) to display, and their display properties, plus markers. The waveform
		/// database (WDB) contains the event data, values changing over time, for all traced signals,
		/// whether displayed or not.
		/// A Wave Config file is written to disk by the use of the save_wave_config command, and can
		/// be opened with the open_wave_config command.
		/// Use the open_wave_database command with the open_wave_config command to open a
		/// previously completed simulation for review in the Vivado IDE.
		/// TIP: Objects that were logged in the simulation waveform database, with the log_wave command, can be
		/// added posthumously to the wave configuration in a static simulation using the add_wave command.
		///
		/// The following example opens a WDB file with the specified name, then opens an associated
		/// Wave Config file, and finally uses the current_fileset command to open the simulation
		/// database in the Vivado IDE:
		/// open_wave_database {C:/Data/project_xsim/testbench_behav.wdb}
		/// open_wave_config {C:/Data/project_xsim/testbench_behav.wcfg}
		/// current_fileset
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1079
		/// </summary>
		/// <param name="wdb">(Required) file name</param>
		/// <param name="noautoloadwcfg">(Optional) Do not automatically open associated WCFG files</param>
		/// <param name="protoinst">(Optional) Specify a .protoinst file for protocol analysis</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand open_wave_database(string wdb, bool? noautoloadwcfg = null, string protoinst = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: open_wave_database [-noautoloadwcfg] [-protoinst <args>] [-quiet] [-verbose] <wdb>
			return
				new SimpleTCLCommand("open_wave_database")
					.Flag("noautoloadwcfg", noautoloadwcfg)
					.OptionalNamedString("protoinst", protoinst)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(wdb)
			;
		}
		/// <summary>
		/// Optimize the current netlist. This will perform the retarget, propconst, sweep and
		/// bram_power_opt optimizations by default.
		///
		///
		/// TCL Syntax: opt_design [-retarget] [-propconst] [-sweep] [-bram_power_opt] [-remap] [-aggressive_remap] [-resynth_area] [-resynth_seq_area] [-directive <arg>] [-muxf_remap] [-hier_fanout_limit <arg>] [-bufg_opt] [-shift_register_opt] [-dsp_register_opt] [-srl_remap_modes <arg>] [-control_set_merge] [-merge_equivalent_drivers] [-carry_remap] [-debug_log] [-property_opt_only] [-quiet] [-verbose]
		///
		/// Optimizes a design netlist for the target part. Optimization can provide improvements to
		/// synthesized netlists from third-party tools, or for netlists that may not have been optimized
		/// during synthesis.
		/// Run this command after synthesis but prior to implementation to optimize the design and
		/// simplify the netlist before placing and routing the design. Assign the DONT_TOUCH property to
		/// prevent the optimization of individual cells.
		/// TIP: To see what actions opt_design is taking in optimizing your design, you can use the -verbose option
		/// to get a more detailed transcript of the process. This can help you in understanding and debugging some of the
		/// changes made to your design.
		/// The opt_design command performs the following optimizations by default:
		/// • Retarget
		/// • Constant Propagation
		/// • Sweep
		/// • Global Buffer (BUFG) optimizations
		/// • DSP Register optimizations
		/// • Shift-Register Logic optimizations
		/// • Block RAM Power optimizations
		/// • Implement MIG cores
		/// • Implement Debug cores
		/// IMPORTANT! Using command-line options for specific optimizations results in opt_design performing only
		/// the specified optimizations and disabling all others, even the ones that are usually performed by default.
		/// To perform LUT Remapping, you must specify -remap.
		/// To perform area-based re-synthesis, you must specify -resynth_area, or -directive
		/// ExploreArea.
		/// To perform sequential area-based re-synthesis, you must specify -resynth_seq_area, or -
		/// directive ExploreSequentialArea.
		///
		/// The following example performs all four default optimizations: retarget, constant propagation,
		/// sweep, and BRAM power optimization. The command returns detailed results with the -
		/// verbose switch:
		/// opt_design -verbose
		/// This example excludes specific BRAM cells from power optimization using the set_power_opt
		/// command, and then runs opt_design with the four default optimizations:
		/// set_power_opt -exclude_cells [get_cells \
		/// -filter {PRIMITIVE_TYPE =~ BMEM.*.*} \
		/// -of_objects [get_pins -leaf -filter {DIRECTION == IN} \
		/// -of_objects [get_nets -of_objects [get_pins clock/bufgctrl_clk_mld/
		/// O]]]]
		/// opt_design
		/// The following example performs the sweep and retarget optimizations:
		/// opt_design -sweep -retarget
		/// Note: Because -sweep and -retarget are expressly enabled in the prior example, -propconst
		/// optimization and -bram_power_opt are implicitly disabled.
		/// The following example directs the opt_design command to use various algorithms to achieve
		/// potentially better results:
		/// opt_design -directive Explore
		/// The following example directs the opt_design command to use various algorithms to achieve
		/// potentially better results, while focusing on area reduction:
		/// opt_design -directive ExploreArea
		/// This example uses the -srl_remap_modes argument with the automatic option to convert FF
		/// chains into SRLs when FF utilization is greater than 20%, or SRLs into FF chains when SRL
		/// utilization is over 50%:
		/// -srl_remap_modes {{target_ff_util 20 target_lutram_util 50}}
		/// TIP: In this case, the srl_remap is only performed if either specified utilization rate is exceeded, but NOT if both
		/// are exceeded.
		/// The following example uses the -srl_remap_modes argument with the manual option to
		/// convert FF chains with length greater than 5 to SRLs, and SRLs with depth less than or equal to 8
		/// to FF chains:
		/// -srl_remap_modes {{min_depth_ffs_to_srl 5}{max_depth_srl_to_ffs 8}}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1082
		/// </summary>
		/// <param name="retarget">(Optional) Retarget</param>
		/// <param name="propconst">(Optional) Propagate constants across leaf-level instances</param>
		/// <param name="sweep">(Optional) Remove unconnected leaf-level instances</param>
		/// <param name="bram_power_opt">(Optional) Perform Block RAM power optimizations</param>
		/// <param name="remap">(Optional) Remap logic optimally in LUTs</param>
		/// <param name="aggressive_remap">(Optional) High effort remap optimization</param>
		/// <param name="resynth_area">(Optional) Resynthesis</param>
		/// <param name="resynth_seq_area">(Optional) Resynthesis (with Sequential optimizations)</param>
		/// <param name="directive">
		/// (Optional)
		/// Mode of behavior (directive) for this command. Please refer
		/// to Arguments section of this help for values for this option
		/// Default: Default
		/// </param>
		/// <param name="muxf_remap">(Optional) Optimize all MuxFx cells to LUT3</param>
		/// <param name="hier_fanout_limit">(Optional) Replicate by module with threshold N</param>
		/// <param name="bufg_opt">(Optional) Insert, Merge and Split BUFGs</param>
		/// <param name="shift_register_opt">(Optional) Pull register stage from shift register</param>
		/// <param name="dsp_register_opt">(Optional) Push/Pull Registers out of a DSP</param>
		/// <param name="srl_remap_modes">(Optional) remap shift registers to flops or flops to shift registers</param>
		/// <param name="control_set_merge">(Optional) Merge all equivalent control set drivers to a single driver</param>
		/// <param name="merge_equivalent_drivers">(Optional) Merge all LUT,Flop equivalent driver replications</param>
		/// <param name="carry_remap">(Optional) reamp carries into luts</param>
		/// <param name="debug_log">(Optional) show debug message</param>
		/// <param name="property_opt_only">(Optional) Do targeted optimizations on tagged cells</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand opt_design(bool? retarget = null, bool? propconst = null, bool? sweep = null, bool? bram_power_opt = null, bool? remap = null, bool? aggressive_remap = null, bool? resynth_area = null, bool? resynth_seq_area = null, string directive = null, bool? muxf_remap = null, string hier_fanout_limit = null, bool? bufg_opt = null, bool? shift_register_opt = null, bool? dsp_register_opt = null, string srl_remap_modes = null, bool? control_set_merge = null, bool? merge_equivalent_drivers = null, bool? carry_remap = null, bool? debug_log = null, bool? property_opt_only = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: opt_design [-retarget] [-propconst] [-sweep] [-bram_power_opt] [-remap] [-aggressive_remap] [-resynth_area] [-resynth_seq_area] [-directive <arg>] [-muxf_remap] [-hier_fanout_limit <arg>] [-bufg_opt] [-shift_register_opt] [-dsp_register_opt] [-srl_remap_modes <arg>] [-control_set_merge] [-merge_equivalent_drivers] [-carry_remap] [-debug_log] [-property_opt_only] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("opt_design")
					.Flag("retarget", retarget)
					.Flag("propconst", propconst)
					.Flag("sweep", sweep)
					.Flag("bram_power_opt", bram_power_opt)
					.Flag("remap", remap)
					.Flag("aggressive_remap", aggressive_remap)
					.Flag("resynth_area", resynth_area)
					.Flag("resynth_seq_area", resynth_seq_area)
					.OptionalNamedString("directive", directive)
					.Flag("muxf_remap", muxf_remap)
					.OptionalNamedString("hier_fanout_limit", hier_fanout_limit)
					.Flag("bufg_opt", bufg_opt)
					.Flag("shift_register_opt", shift_register_opt)
					.Flag("dsp_register_opt", dsp_register_opt)
					.OptionalNamedString("srl_remap_modes", srl_remap_modes)
					.Flag("control_set_merge", control_set_merge)
					.Flag("merge_equivalent_drivers", merge_equivalent_drivers)
					.Flag("carry_remap", carry_remap)
					.Flag("debug_log", debug_log)
					.Flag("property_opt_only", property_opt_only)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Pause Activity Monitor runs for the specified hardware HBM(s)
		///
		///
		/// TCL Syntax: pause_hw_hbm_amon [-quiet] [-verbose] <hw_objects>
		///
		/// The pause_hw_hbm_amon command pauses a running HBM activity monitor in the Vivado
		/// hardware manager that has been previously started using the run_hw_hbm_amon command.
		/// This command returns nothing when successful, or returns an error when it fails.
		///
		/// The following example pauses the HBM activity monitor for the associated HBM core:
		/// pause_hw_hbm_amon [get_hw_hbms *HBM_2]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1089
		/// </summary>
		/// <param name="hw_objects">(Required) hardware objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand pause_hw_hbm_amon(string hw_objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: pause_hw_hbm_amon [-quiet] [-verbose] <hw_objects>
			return
				new SimpleTCLCommand("pause_hw_hbm_amon")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_objects)
			;
		}
		/// <summary>
		/// Optimize the current placed netlist.
		///
		///
		/// TCL Syntax: phys_opt_design [-fanout_opt] [-placement_opt] [-routing_opt] [-slr_crossing_opt] [-rewire] [-insert_negative_edge_ffs] [-critical_cell_opt] [-dsp_register_opt] [-bram_register_opt] [-uram_register_opt] [-bram_enable_opt] [-shift_register_opt] [-hold_fix] [-aggressive_hold_fix] [-retime] [-force_replication_on_nets <args>] [-directive <arg>] [-critical_pin_opt] [-clock_opt] [-path_groups <args>] [-tns_cleanup] [-sll_reg_hold_fix] [-quiet] [-verbose]
		///
		/// Performs timing-driven optimization on the negative-slack paths of a design. A path should have
		/// negative slack near the worst negative slack (WNS) to be considered for optimization.
		/// Optimization will not be performed on designs without negative slack.
		/// This optional command can be run for post-place or post-route optimizations.
		/// RECOMMENDED: Because physical optimization requires timing data that is only available after placement,
		/// the command cannot be run prior to placement. However, the write_iphys_opt_tcl and
		/// read_iphys_opt_tcl commands let you write out the physical optimizations performed on the post-placed
		/// design, and then apply those optimizations to the design netlist prior to placement. Refer to the Vivado Design
		/// Suite User Guide: Implementation (UG904) for more information on interactive physical optimization.
		/// Post-place phys_opt_design performs the following optimizations by default:
		/// • high-fanout optimization
		/// • placement-based optimization of critical paths
		/// • rewire
		/// • critical-cell optimization
		/// • DSP register optimization
		/// • BRAM register optimization
		/// • URAM register optimization
		/// • a final fanout optimization
		/// TIP: Using command-line options for specific optimizations results in phys_opt_design performing only the
		/// specified optimizations and disabling all others, even the ones that are usually performed by default.
		/// Post-route phys_opt_design performs the following optimizations by default:
		/// • placement-based optimization of critical paths
		/// • routing optimization
		/// • rewire
		/// • critical-cell optimization
		/// Physical optimizations involve replication, re-timing, hold fixing, and placement improvement.
		/// The phys_opt_design command automatically performs all necessary netlist and placement
		/// changes.
		/// To perform re-timing you must specify the -retime option, or the -directive AddRetime
		/// option.
		/// To perform hold fixing you must specify the -hold_fix option, or the -directive
		/// ExploreWithHoldFix option.
		/// If the phys_opt_design command is used iteratively, the subsequent run optimizes the results
		/// of the prior run.
		/// TIP: The phys_opt_design can be multi-threaded to speed the process. Refer to the set_param
		/// command for more information on setting the general.maxThreads parameter.
		/// The command reports each net processed, a summary of any optimizations performed, and the
		/// WNS before and after optimization. Replicated objects are named by appending _replica to
		/// the original object name, followed by the replicated object count.
		///
		/// The following example performs a physical optimization of the current post-placement design,
		/// and then writes the iphys_opt Tcl script for use before placement:
		/// phys_opt_design
		/// write_iphys_opt_tcl C:/Data/my_iphys_opt.tcl
		/// This example sets the LOCK_PINS property on the specified cell, then performs physical
		/// optimizations including register re-timing, optimization of registers across DSP blocks and block
		/// RAMs, and pin swapping (excluding the locked pins) to improve timing:
		/// set_property LOCK_PINS {I3:A1 I2:A4} [get_cell cpuEngine/
		/// qmem_dack_reg_i_1]
		/// phys_opt_design -retime -dsp_register_opt -bram_register_opt \
		/// -critical_pin_opt
		/// This example directs phys_opt_design to run more iterations, with hold violation fixing, to
		/// achieve potentially better results:
		/// phys_opt_design -directive ExploreWithHoldFix
		/// This example directs phys_opt_design to consider more nets for replication:
		/// phys_opt_design -directive AggressiveFanoutOpt
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1091
		/// </summary>
		/// <param name="fanout_opt">
		/// (Optional)
		/// Do cell-duplication based optimization on high-fanout
		/// timing critical nets
		/// </param>
		/// <param name="placement_opt">(Optional) Do placement based optimization on timing critical nets</param>
		/// <param name="routing_opt">(Optional) Do routing based optimization on timing critical nets</param>
		/// <param name="slr_crossing_opt">(Optional) Do placement optimization of SLR-crossing timing critical nets</param>
		/// <param name="rewire">(Optional) Do rewiring optimization</param>
		/// <param name="insert_negative_edge_ffs">(Optional) Insert negative edge triggered FFs for hold optimization</param>
		/// <param name="critical_cell_opt">(Optional) Do cell-duplication based optimization on timing critical nets</param>
		/// <param name="dsp_register_opt">(Optional) Do DSP register optimization</param>
		/// <param name="bram_register_opt">(Optional) Do BRAM register optimization</param>
		/// <param name="uram_register_opt">(Optional) Do UltraRAM register optimization</param>
		/// <param name="bram_enable_opt">(Optional) Do BRAM enable optimization</param>
		/// <param name="shift_register_opt">(Optional) Do Shift register optimization</param>
		/// <param name="hold_fix">(Optional) Attempt to improve slack of high hold violators</param>
		/// <param name="aggressive_hold_fix">(Optional) Attempt to aggressively improve slack of high hold violators</param>
		/// <param name="retime">(Optional) Do retiming optimization</param>
		/// <param name="force_replication_on_nets">(Optional) Force replication optimization on nets</param>
		/// <param name="directive">
		/// (Optional)
		/// Mode of behavior (directive) for this command. Please refer
		/// to Arguments section of this help for values for this option
		/// Default: Default
		/// </param>
		/// <param name="critical_pin_opt">(Optional) Do pin-swapping based optimization on timing critical nets</param>
		/// <param name="clock_opt">(Optional) Do clock skew optimization in post-route optimization</param>
		/// <param name="path_groups">(Optional) Work only on specified path groups</param>
		/// <param name="tns_cleanup">
		/// (Optional)
		/// Work on all nets in the design that meet criteria for the
		/// specified optimizations to improve design tns
		/// </param>
		/// <param name="sll_reg_hold_fix">(Optional) Do hold fixing on SLL Tx-Rx paths Name Description</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand phys_opt_design(bool? fanout_opt = null, bool? placement_opt = null, bool? routing_opt = null, bool? slr_crossing_opt = null, bool? rewire = null, bool? insert_negative_edge_ffs = null, bool? critical_cell_opt = null, bool? dsp_register_opt = null, bool? bram_register_opt = null, bool? uram_register_opt = null, bool? bram_enable_opt = null, bool? shift_register_opt = null, bool? hold_fix = null, bool? aggressive_hold_fix = null, bool? retime = null, string force_replication_on_nets = null, string directive = null, bool? critical_pin_opt = null, bool? clock_opt = null, string path_groups = null, bool? tns_cleanup = null, bool? sll_reg_hold_fix = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: phys_opt_design [-fanout_opt] [-placement_opt] [-routing_opt] [-slr_crossing_opt] [-rewire] [-insert_negative_edge_ffs] [-critical_cell_opt] [-dsp_register_opt] [-bram_register_opt] [-uram_register_opt] [-bram_enable_opt] [-shift_register_opt] [-hold_fix] [-aggressive_hold_fix] [-retime] [-force_replication_on_nets <args>] [-directive <arg>] [-critical_pin_opt] [-clock_opt] [-path_groups <args>] [-tns_cleanup] [-sll_reg_hold_fix] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("phys_opt_design")
					.Flag("fanout_opt", fanout_opt)
					.Flag("placement_opt", placement_opt)
					.Flag("routing_opt", routing_opt)
					.Flag("slr_crossing_opt", slr_crossing_opt)
					.Flag("rewire", rewire)
					.Flag("insert_negative_edge_ffs", insert_negative_edge_ffs)
					.Flag("critical_cell_opt", critical_cell_opt)
					.Flag("dsp_register_opt", dsp_register_opt)
					.Flag("bram_register_opt", bram_register_opt)
					.Flag("uram_register_opt", uram_register_opt)
					.Flag("bram_enable_opt", bram_enable_opt)
					.Flag("shift_register_opt", shift_register_opt)
					.Flag("hold_fix", hold_fix)
					.Flag("aggressive_hold_fix", aggressive_hold_fix)
					.Flag("retime", retime)
					.OptionalNamedString("force_replication_on_nets", force_replication_on_nets)
					.OptionalNamedString("directive", directive)
					.Flag("critical_pin_opt", critical_pin_opt)
					.Flag("clock_opt", clock_opt)
					.OptionalNamedString("path_groups", path_groups)
					.Flag("tns_cleanup", tns_cleanup)
					.Flag("sll_reg_hold_fix", sll_reg_hold_fix)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Move or place one or more instances to new locations. Sites and cells are required to be listed in
		/// the right order and there should be same number of sites as number of cells.
		///
		///
		/// TCL Syntax: place_cell [-quiet] [-verbose] <cell_site_list>...
		///
		/// Places cells onto device resources of the target part. Cells can be placed onto specific BEL sites
		/// (e.g. SLICE_X49Y60/A6LUT), or into available SLICE resources (e.g. SLICE_X49Y60). If you
		/// specify the SLICE but not the BEL the tool will determine an appropriate BEL within the specified
		/// SLICE if one is available.
		/// When placing a cell onto a specified site, the site must not be currently occupied, or an error will
		/// be returned: Cannot set site and bel property of instances. Site
		/// SLICE_X49Y61 is already occupied.
		/// You can test if a site is occupied by querying the IS_OCCUPIED property of a BEL site:
		/// get_property IS_OCCUPIED [get_bels SLICE_X48Y60/D6LUT]
		/// Note: The IS_OCCUPIED property of a SLICE only tells you if some of the BELs within the SLICE are
		/// occupied; not whether or not the SLICE is fully occupied.
		/// This command can be used to place cells, or to move placed cells from one site on the device to
		/// another site. The command syntax is the same for placing an unplaced cell, or moving a placed
		/// cell.
		/// When moving a placed cell, if you specify only the SLICE for the site, the tool will attempt to
		/// place the cell onto the same BEL site in the new SLICE as it currently is placed. For instance
		/// moving a cell from the B6LUT, by specifying a new SLICE, will cause the tool to attempt to place
		/// the cell onto the B6LUT in the new SLICE. If this BEL site is currently occupied, an error is
		/// returned.
		/// Note: This command returns nothing if successful, or returns an error if it fails.
		///
		/// The following example places the specified cell onto the specified BEL site:
		/// place_cell div_cntr_reg_inferredi_4810_15889 SLICE_X49Y60/D6LUT
		/// The following example places the specified cell into the specified SLICE:
		/// place_cell div_cntr_reg_inferredi_4810_15889 SLICE_X49Y61
		/// Note: The tool will select an appropriate BEL site if one is available. If no BEL is available, and error will be
		/// returned.
		/// The following example places multiple cells onto multiple sites:
		/// place_cell { \
		/// cpuEngine/cpu_iwb_adr_o/buffer_fifo/i_4810_17734 SLICE_X49Y60/A6LUT \
		/// cpuEngine/or1200_cpu/or1200_mult_mac/i_4775_15857 SLICE_X49Y60/B6LUT \
		/// cpuEngine/cpu_iwb_adr_o/buffer_fifo/xlnx_opt_LUT_i_4810_18807_2 \
		/// SLICE_X49Y60/C6LUT }
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1098
		/// </summary>
		/// <param name="cell_site_list">(Required) a list of cells and sites in the interleaved order</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand place_cell(string cell_site_list, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: place_cell [-quiet] [-verbose] <cell_site_list>...
			return
				new SimpleTCLCommand("place_cell")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(cell_site_list)
			;
		}
		/// <summary>
		/// Automatically place ports and leaf-level instances
		///
		///
		/// TCL Syntax: place_design [-directive <arg>] [-no_timing_driven] [-timing_summary] [-unplace] [-post_place_opt] [-no_psip] [-no_bufg_opt] [-quiet] [-verbose]
		///
		/// Place the specified ports and logic cells in the current design, or all ports and logic cells, onto
		/// device resources on the target part. The tool optimizes placement to minimize negative timing
		/// slack and reduce overall wire length, while also attempting to spread out placement to reduce
		/// routing congestion.
		/// Placement is one step of the complete design implementation process, which can be run
		/// automatically through the use of the launch_runs command when running the Vivado tools in
		/// Project Mode.
		/// In Non-Project Mode, the implementation process must be run manually with the individual
		/// commands: opt_design, place_design, phys_opt_design, power_opt_design, and
		/// route_design. Refer to the Vivado Design Suite User Guide: Design Flows Overview (UG892) for
		/// a complete description of Project Mode and Non-Project Mode.
		/// Both placement and routing can be completed incrementally, based on prior results stored in a
		/// Design Checkpoint file (DCP), using the incremental implementation flow. Refer to the
		/// read_checkpoint command, or to Vivado Design Suite User Guide: Implementation (UG904) for
		/// more information on incremental place and route.
		/// TIP: The place_design can be multi-threaded to speed the process. Refer to the set_param command for
		/// more information on setting the general.maxThreads parameter.
		/// You can also manually place some elements of the design using place_ports, or by setting
		/// LOC properties on the cell, and then automatically place the remainder of the design using
		/// place_design.
		/// This command requires an open synthesized design, and it is recommended that you run the
		/// opt_design command prior to running place_design to avoid placing a suboptimal netlist.
		///
		/// The following example places the current design, runs optimization, routes the design, runs post
		/// placement optimization, and then reroutes the design to cleanup any unconnected nets as a
		/// result of post placement optimization:
		/// place_design
		/// phys_opt_design
		/// route_design
		/// place_design -post_place_opt
		/// phys_opt_design
		/// route_design
		/// The following example directs the Vivado placer to try different placement algorithms to achieve
		/// a better placement result:
		/// place_design -directive Explore
		/// This example unplaces the current design:
		/// place_design -unplace
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1101
		/// </summary>
		/// <param name="directive">
		/// (Optional)
		/// Mode of behavior (directive) for this command. Please refer
		/// to Arguments section of this help for values for this option.
		/// Default: Default
		/// </param>
		/// <param name="no_timing_driven">(Optional) Do not run in timing driven mode</param>
		/// <param name="timing_summary">(Optional) Enable accurate post-placement timing summary.</param>
		/// <param name="unplace">(Optional) Unplace all the instances which are not locked by Constraints.</param>
		/// <param name="post_place_opt">(Optional) Run only the post commit optimizer</param>
		/// <param name="no_psip">
		/// (Optional)
		/// Disable PSIP (Physical Synthesis In Placer) optimization
		/// during placement.
		/// </param>
		/// <param name="no_bufg_opt">(Optional) Disable global buffer insertion during placement</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand place_design(string directive = null, bool? no_timing_driven = null, bool? timing_summary = null, bool? unplace = null, bool? post_place_opt = null, bool? no_psip = null, bool? no_bufg_opt = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: place_design [-directive <arg>] [-no_timing_driven] [-timing_summary] [-unplace] [-post_place_opt] [-no_psip] [-no_bufg_opt] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("place_design")
					.OptionalNamedString("directive", directive)
					.Flag("no_timing_driven", no_timing_driven)
					.Flag("timing_summary", timing_summary)
					.Flag("unplace", unplace)
					.Flag("post_place_opt", post_place_opt)
					.Flag("no_psip", no_psip)
					.Flag("no_bufg_opt", no_bufg_opt)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Resize Pblocks according to SLICE demand and re-position them according to connectivity
		///
		///
		/// TCL Syntax: place_pblocks [-effort <arg>] [-utilization <arg>] [-quiet] [-verbose] <pblocks>...
		///
		/// Places Pblocks onto the fabric of the FPGA. Pblocks must be created using the create_pblock
		/// command, and should be populated with assigned logic using the add_cells_to_pblock
		/// command.
		/// Note: An empty Pblock will be placed as directed, but results in a Pblock covering a single CLB tile (two
		/// SLICEs).
		///
		/// The following example places the specified Pblocks with a utilization of 75%:
		/// place_pblocks -effort LOW -utilization 75 block1 block2 block3 block4
		/// block5
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1106
		/// </summary>
		/// <param name="pblocks">(Required) List of Pblocks to place</param>
		/// <param name="effort">
		/// (Optional)
		/// Placer effort level (per Pblock) Values: LOW, MEDIUM, HIGH
		/// Default: HIGH
		/// </param>
		/// <param name="utilization">(Optional) Placer utilization (per Pblock)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand place_pblocks(string pblocks, string effort = null, string utilization = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: place_pblocks [-effort <arg>] [-utilization <arg>] [-quiet] [-verbose] <pblocks>...
			return
				new SimpleTCLCommand("place_pblocks")
					.OptionalNamedString("effort", effort)
					.OptionalNamedString("utilization", utilization)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(pblocks)
			;
		}
		/// <summary>
		/// Automatically place a set of ports
		///
		///
		/// TCL Syntax: place_ports [-skip_unconnected_ports] [-check_only] [-iobank <args>] [-quiet] [-verbose] [<ports>...]
		///
		/// Assign ports to the pins of the Xilinx FPGA package, by automatically or manually placing ports.
		/// • Automatically places ports on an available I/O or clocking site, or into the specified I/O banks.
		/// • Manually assigns ports to the specified package_pin when both the port and pin are specified.
		/// The place_ports command will not replace ports that are currently placed by the user, or
		/// ports that are placed and fixed.
		/// Note: This command operates silently and does not return direct feedback of its operation.
		///
		/// The following example places the port objects returned by the get_ports command, onto I/O
		/// bank 13 of the device, as returned by get_iobanks:
		/// place_ports -iobank [get_iobanks 13] [get_ports DataOut_pad_1_o]
		/// The follow example uses port_name package_pin pairs to manually place multiple ports:
		/// place_ports {LEDS_n[2] AA11 LEDS_n[3] AA10 LEDS_n[0] Y11 LEDS_n[1] Y10}
		/// The following example places all input ports onto I/O banks 12, 13, 14 and 15 of the device:
		/// place_ports -iobank [get_iobanks {12 13 14 15}] [all_inputs]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1108
		/// </summary>
		/// <param name="skip_unconnected_ports">(Optional) Do not place unconnected ports</param>
		/// <param name="check_only">(Optional) Only check IO/Clock placement DRCs</param>
		/// <param name="iobank">(Optional) Limit placement to the following banks</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="ports">
		/// (Optional)
		/// Ports to place (if omitted, all ports will be placed). If the
		/// arguments are interleaved objects of ports and package
		/// pins, then manual placement is performed
		/// </param>
		public virtual SimpleTCLCommand place_ports(bool? skip_unconnected_ports = null, bool? check_only = null, string iobank = null, bool? quiet = null, bool? verbose = null, string ports = null)
		{
			// TCL Syntax: place_ports [-skip_unconnected_ports] [-check_only] [-iobank <args>] [-quiet] [-verbose] [<ports>...]
			return
				new SimpleTCLCommand("place_ports")
					.Flag("skip_unconnected_ports", skip_unconnected_ports)
					.Flag("check_only", check_only)
					.OptionalNamedString("iobank", iobank)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(ports)
			;
		}
		/// <summary>
		/// Optimize dynamic power using intelligent clock gating
		///
		///
		/// TCL Syntax: power_opt_design [-quiet] [-verbose]
		///
		/// Optimizes the dynamic power consumption of the design by changing clock gating to take
		/// advantage of clock enable on a flop. Clock gating optimizations are automatically performed on
		/// the entire design to improve power consumption while making no changes to the existing logic
		/// or the clocks that would alter the behavior of the design.
		/// You can configure the power optimization to include or exclude specific cells using the
		/// set_power_opt command.
		/// Note: Block RAM power optimizations are performed by default with the opt_design command. You can
		/// disable BRAM optimization by changing the defaults of opt_design, or by excluding specific cells from
		/// optimization using the set_power_opt command.
		/// You can also use the read_saif command prior to optimization, and power_opt_design will
		/// consider the activity data while optimizing the design.
		/// You can run power optimization after synthesis, or after placement. When run before placement,
		/// this command optimizes the design to save power. When run after placement, this command
		/// optimizes the design to save power while preserving timing. Running after placement limits the
		/// optimizations available to the power_opt_design command. To achieve the best results, the
		/// command should be run prior to placement.
		///
		/// The following example performs power optimization of the open design:
		/// power_opt_design
		/// This example optimizes the design, excluding the BRAM power optimization by specifying the
		/// optimizations to run, and then runs power optimization on the design:
		/// opt_design -retarget -propconst -sweep
		/// power_opt_design
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1113
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand power_opt_design(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: power_opt_design [-quiet] [-verbose]
			return
				new SimpleTCLCommand("power_opt_design")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Re-establish a parent cell as a Reconfigurable Partition while removing a lower-level
		/// Reconfigurable Partition when using the Hierarchical Partial Reconfiguration solution.
		///
		///
		/// TCL Syntax: pr_recombine [-cell <arg>] [-quiet] [-verbose]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1115
		/// </summary>
		/// <param name="cell">(Optional) (Required) Specify reconfigurable container module name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand pr_recombine(string cell = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: pr_recombine [-cell <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("pr_recombine")
					.OptionalNamedString("cell", cell)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Subdivide a Reconfigurable Partition into one or more lower-level Reconfigurable Partitions when
		/// using the Hierarchical Partial Reconfiguration solution.
		///
		///
		/// TCL Syntax: pr_subdivide [-cell <arg>] [-subcells <arg>] [-quiet] [-verbose] [<from_dcp>]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1116
		/// </summary>
		/// <param name="cell">(Optional) (Required) Specify parent reconfigurable partition module name</param>
		/// <param name="subcells">(Optional) (Required) Specify child reconfigurable partition module names</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="from_dcp">
		/// (Optional)
		/// (Required) Specify OOC synthesized checkpoint path for the
		/// reconfigurable module specified by option -cell
		/// </param>
		public virtual SimpleTCLCommand pr_subdivide(string cell = null, string subcells = null, bool? quiet = null, bool? verbose = null, string from_dcp = null)
		{
			// TCL Syntax: pr_subdivide [-cell <arg>] [-subcells <arg>] [-quiet] [-verbose] [<from_dcp>]
			return
				new SimpleTCLCommand("pr_subdivide")
					.OptionalNamedString("cell", cell)
					.OptionalNamedString("subcells", subcells)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(from_dcp)
			;
		}
		/// <summary>
		/// Verify whether the design check points are replaceable on board. This command supports these
		/// formats: (1) 'pr_verify DCP1 DCP2 -full_check'; (2) 'pr_verify -initial DCP1 -additional {DCP2
		/// DCP3 DCP4 ...}'; (3) 'pr_verify -in_memory -additional {DCP2 DCP3 ...}'; For format (3), it must
		/// have an in-memory design opened.
		///
		///
		/// TCL Syntax: pr_verify [-full_check] [-file <arg>] [-initial <arg>] [-additional <arg>] [-in_memory] [-quiet] [-verbose] [<file1>] [<file2>]
		///
		/// This command is used to compare design checkpoint files for use in the Partial Reconfiguration
		/// flow.
		/// For Partial Reconfigurable designs to work in hardware, the placement and routing of static logic
		/// must be consistent between all configurations. In addition, proxy logic must be placed in the
		/// same locations and clock spine routing must match. The pr_verify command compares routed
		/// design checkpoint files (DCP) created for a Partial Reconfiguration design to verify that all
		/// imported resources match. For more information refer to the Vivado Design Suite User Guide:
		/// Dynamic Function eXchange (UG909).
		/// The two modes for pr_verify let you specify two DCP files to compare, or multiple DCP files
		/// to compare against the first DCP file. The syntax for the two modes is:
		/// • pr_verify DCP1 DCP2
		/// • pr_verify -initial DCP1 -additional {DCP2 DCP3 DCP4}
		/// The second mode is the same as repeating the pr_verify command to compare each
		/// additional DCP with the initial DCP, but keeps the initial DCP open to speed the additional
		/// comparisons:
		/// pr_verify DCP1 DCP2
		/// pr_verify DCP1 DCP3
		/// pr_verify DCP1 DCP4
		/// This command returns the results of the comparison, or returns an error if it fails.
		///
		/// The following example compares the two corner DCPs, specified with the -additional option,
		/// against the inital DCP, running a full check on the designs:
		/// pr_verify -full_check -initial FastConfig.dcp \
		/// -additional {corner1.dcp corner2.dcp}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1117
		/// </summary>
		/// <param name="full_check">
		/// (Optional)
		/// Default behavior is to report the first difference only; if this
		/// option is set to true, pr_verify will report complete
		/// difference in placement or routing
		/// </param>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. Send output to console if -file
		/// is not used.
		/// </param>
		/// <param name="initial">(Optional) Initial checkpoint (.dcp)</param>
		/// <param name="additional">(Optional) Additional checkpoints (.dcp)</param>
		/// <param name="in_memory">(Optional) use in-memory design for comparison, combined with - additional option</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="file1">(Optional) Design checkpoint (.dcp) file one</param>
		/// <param name="file2">(Optional) Design checkpoint (.dcp) file two</param>
		public virtual SimpleTCLCommand pr_verify(bool? full_check = null, string file = null, string initial = null, string additional = null, bool? in_memory = null, bool? quiet = null, bool? verbose = null, string file1 = null, string file2 = null)
		{
			// TCL Syntax: pr_verify [-full_check] [-file <arg>] [-initial <arg>] [-additional <arg>] [-in_memory] [-quiet] [-verbose] [<file1>] [<file2>]
			return
				new SimpleTCLCommand("pr_verify")
					.Flag("full_check", full_check)
					.OptionalNamedString("file", file)
					.OptionalNamedString("initial", initial)
					.OptionalNamedString("additional", additional)
					.Flag("in_memory", in_memory)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(file1)
					.OptionalString(file2)
			;
		}
		/// <summary>
		/// Program Cfgmem object
		///
		///
		/// TCL Syntax: program_hw_cfgmem [-svf_file <arg>] [-force] [-append] [-quiet] [-verbose] [<hw_cfgmem>...]
		///
		/// Erase, blank check, program, and/or verify the specified hw_cfgmem object with the memory
		/// configuration file defined in the object's PROGRAM.FILE property. The memory configuration file
		/// is created with the write_cfgmem command, and associated with the hw_cfgmem object using
		/// the set_property command as shown in the example.
		/// The process whereby the design specific data is loaded or programmed into the Xilinx FPGA is
		/// called configuration. The create_hw_cfgmem command defines a flash memory device used
		/// for configuring and booting the FPGA device.
		/// After the hw_cfgmem object is created, and associated with the hw_device, the configuration
		/// memory can be programmed with the bitstream and other data from a memory configuration file
		/// created with the write_cfgmem command. The hw_cfgmem object is programmed using the
		/// program_hw_cfgmem command.
		/// The program_hw_cfgmem command will run a multi-step process to erase the configuration
		/// memory device, perform a blank check to validate that the device is empty, program the device
		/// with the memory configuration file, and verify the programming on the device. Properties on the
		/// hw_cfgmem object determine which steps of the programming process are performed. These
		/// properties include:
		/// • PROGRAM.FILES - Specifies the memory configuration files to use for programming the
		/// device. The memory configuration files are created with the write_cfgmem command.
		/// • PROGRAM.ADDRESS_RANGE - Specifies the address range of the configuration memory
		/// device to program. The address range values can be:
		/// ○ {use_file} - Use only the address space required by the memory configuration file to
		/// erase, blank check, program, and verify.
		/// ○ {entire_device} - Erase, blank check, program, and verify the entire device.
		/// • PROGRAM.ERASE - Erases the contents of the flash memory when true. This is a boolean
		/// property with a value of 0 (false) or 1 (true).
		/// • PROGRAM.BLANK_CHECK - Checks the device to make sure the device is void of data prior
		/// to programming. This is a boolean property with a value of 0 (false) or 1 (true).
		/// • PROGRAM.CFG_PROGRAM - Program the device with the specified PROGRAM.FILE. This is
		/// a boolean property with a value of 0 (false) or 1 (true).
		/// • PROGRAM.VERIFY - Verify the device after programming. This is a boolean property with a
		/// value of 0 (false) or 1 (true).
		/// The program_hw_cfgmem command can also generate an SVF file for in-system and remote
		/// programming of Xilinx devices. SVF is an industry standard file format that is used to describe
		/// JTAG chain operations by describing the information that needs to be shifted into the device
		/// chain. SVF files are ASCII files that can be written and modified in any text editor. Many third￾party programming utilities can use the SVF file to program Xilinx devices in a JTAG chain.
		/// This command returns a transcript of its process when successful, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1120
		/// </summary>
		/// <param name="hw_cfgmem">(Required) list of hardware cfgmems Default: current hardware cfgmem</param>
		/// <param name="svf_file">(Optional) svf file to be generated</param>
		/// <param name="force">(Optional) overwrite svf_file if it already exists</param>
		/// <param name="append">(Optional) append to svf file</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand program_hw_cfgmem(string hw_cfgmem, string svf_file = null, bool? force = null, bool? append = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: program_hw_cfgmem [-svf_file <arg>] [-force] [-append] [-quiet] [-verbose] [<hw_cfgmem>...]
			return
				new SimpleTCLCommand("program_hw_cfgmem")
					.OptionalNamedString("svf_file", svf_file)
					.Flag("force", force)
					.Flag("append", append)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_cfgmem)
			;
		}
		/// <summary>
		/// Program hardware devices
		///
		///
		/// TCL Syntax: program_hw_devices [-key <arg>] [-clear] [-skip_program_keys] [-skip_program_rsa] [-user_efuse <arg>] [-user_efuse_128 <arg>] [-control_efuse <arg>] [-security_efuse <arg>] [-only_export_efuse] [-svf_file <arg>] [-efuse_export_file <arg>] [-disable_eos_check] [-skip_reset] [-force] [-append] [-type <arg>] [-quiet] [-verbose] [<hw_device>...]
		///
		/// Program the specified hardware device object or objects on the open hardware target of the
		/// current hardware server.
		/// To access a Xilinx FPGA through the Hardware Manager, you must use the following Tcl
		/// command sequence:
		/// 1. open_hw - Opens the Hardware Manager in the Vivado Design Suite.
		/// 2. connect_hw_server - Makes a connection to a local or remote Vivado hardware server
		/// application.
		/// 3. current_hw_target - Defines the hardware target of the connected server.
		/// 4. open_hw_target - Opens a connection to the hardware target.
		/// 5. current_hw_device - Specifies the Xilinx FPGA to use for programming and debugging.
		/// After connecting to the target hardware device, you must associate the bitstream file
		/// (.bit, .rbt, .bin) from the design with the device, using the set_property command:
		/// set_property PROGRAM.FILE {C:/Data/design.bit} [current_hw_device]
		/// For debug purposes, you can also associate a probes file (.ltx) with the device using the
		/// PROBES.FILE property:
		/// set_property PROBES.FILE {C:/Data/debug_nets.ltx} [current_hw_device]
		/// Once the programming file has been associated with the hardware device, you can program the
		/// hardware device using the program_hw_devices command, and debug the device using any
		/// of a number of Hardware Manager Tcl commands. To interactively debug the device open the
		/// Hardware Manager in the Vivado Design Suite IDE.
		/// You can also program an encrypted bitstream into the specified hw_device. This requires the
		/// implemented design to have encryption properties assigned prior to generating the bitstream
		/// with the write_bitstream command. You can add ENCRYPTION properties to the design
		/// most easily using the Encryption page of the Edit Device Properties dialog box in the Vivado IDE.
		/// Refer to the Vivado Design Suite User Guide: Programming and Debugging (UG908) for more
		/// information on the Edit Device Properties dialog box.
		/// Programming a device for an encrypted bitstream is a two-step process that requires running
		/// program_hw_devices once to program the encryption key into the BBR or eFUSE registers,
		/// and a second time to program the encrypted bitstream into the device:
		/// program_hw_devices -key bbr [current_hw_device]
		/// program_hw_device [current_hw_device]
		/// CAUTION! eFUSEs are one-time programmable cells on the hardware device, used to store the factory￾programmed Device DNA, AES-GCM encryption key, and user specified values. Refer to the UltraScale
		/// Architecture Configuration (UG570) or 7 Series FPGAs Configuration User Guide (UG470) for more information
		/// on eFUSE registers.
		/// The program_hw_devices command can also generate a Serial Vector Format (SVF) file for in￾system and remote programming of Xilinx devices. SVF is an industry standard file format that is
		/// used to describe JTAG chain operations by describing the information that needs to be shifted
		/// into the device chain. SVF files are ASCII files that can be written and modified in any text editor.
		/// Many third-party programming utilities can use the SVF file to program Xilinx devices in a JTAG
		/// chain.
		/// This command returns a transcript of its actions, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1123
		/// </summary>
		/// <param name="key">(Optional) key option value for encryption programming: efuse,bbr,none</param>
		/// <param name="clear">(Optional) clear bbr registers, only valid for bbr</param>
		/// <param name="skip_program_keys">(Optional) skip programming keys specified in NKY file, if any</param>
		/// <param name="skip_program_rsa">(Optional) skip programming RSA key specified in NKY file, if any</param>
		/// <param name="user_efuse">(Optional) hex user fuse value for encryption programming</param>
		/// <param name="user_efuse_128">(Optional) hex user fuse 128 bit value for encryption programming</param>
		/// <param name="control_efuse">(Optional) hex control fuse value for encryption programming</param>
		/// <param name="security_efuse">(Optional) hex security fuse value for encryption programming</param>
		/// <param name="only_export_efuse">(Optional) do not program eFUSE; just export settings to efuse_export_file</param>
		/// <param name="svf_file">(Optional) svf file used to program device</param>
		/// <param name="efuse_export_file">(Optional) output file to store programmed eFUSE settings</param>
		/// <param name="disable_eos_check">(Optional) Disables End of Startup check after programming</param>
		/// <param name="skip_reset">(Optional) Skips resetting the device before programming</param>
		/// <param name="force">(Optional) overwrites svf file and creates empty file</param>
		/// <param name="append">(Optional) append to svf file</param>
		/// <param name="type">(Optional) bitstream file type to be used for programming: bit,bin,rbt</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_device">(Optional) list of hardware devices Default: current hardware device</param>
		/// <returns>hardware devices</returns>
		public virtual SimpleTCLCommand program_hw_devices(string key = null, bool? clear = null, bool? skip_program_keys = null, bool? skip_program_rsa = null, string user_efuse = null, string user_efuse_128 = null, string control_efuse = null, string security_efuse = null, bool? only_export_efuse = null, string svf_file = null, string efuse_export_file = null, bool? disable_eos_check = null, bool? skip_reset = null, bool? force = null, bool? append = null, string type = null, bool? quiet = null, bool? verbose = null, string hw_device = null)
		{
			// TCL Syntax: program_hw_devices [-key <arg>] [-clear] [-skip_program_keys] [-skip_program_rsa] [-user_efuse <arg>] [-user_efuse_128 <arg>] [-control_efuse <arg>] [-security_efuse <arg>] [-only_export_efuse] [-svf_file <arg>] [-efuse_export_file <arg>] [-disable_eos_check] [-skip_reset] [-force] [-append] [-type <arg>] [-quiet] [-verbose] [<hw_device>...]
			return
				new SimpleTCLCommand("program_hw_devices")
					.OptionalNamedString("key", key)
					.Flag("clear", clear)
					.Flag("skip_program_keys", skip_program_keys)
					.Flag("skip_program_rsa", skip_program_rsa)
					.OptionalNamedString("user_efuse", user_efuse)
					.OptionalNamedString("user_efuse_128", user_efuse_128)
					.OptionalNamedString("control_efuse", control_efuse)
					.OptionalNamedString("security_efuse", security_efuse)
					.Flag("only_export_efuse", only_export_efuse)
					.OptionalNamedString("svf_file", svf_file)
					.OptionalNamedString("efuse_export_file", efuse_export_file)
					.Flag("disable_eos_check", disable_eos_check)
					.Flag("skip_reset", skip_reset)
					.Flag("force", force)
					.Flag("append", append)
					.OptionalNamedString("type", type)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(hw_device)
			;
		}
		/// <summary>
		/// Turns on or off printing of name of the hdl process being simulated
		///
		///
		/// TCL Syntax: ptrace [-quiet] [-verbose] <value>
		///
		/// Enables process tracing for simulation debugging purposes.
		/// During simulation the name of the HDL process that is evaluated will be written to the Tcl
		/// console, as well as the simulation source file and line number associated with the process.
		/// TIP: Process tracing provides more detailed information than is available with line tracing and the ltrace
		/// command.
		/// This feature can also be enabled using the PROCESS_TRACING property on the current
		/// simulation object:
		/// set_property PROCESS_TRACING on [current_sim]
		/// The command returns the state of process tracing, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1128
		/// </summary>
		/// <param name="value">(Required) value: on, true, yes. Otherwise set to off, false, no</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand ptrace(string value, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: ptrace [-quiet] [-verbose] <value>
			return
				new SimpleTCLCommand("ptrace")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(value)
			;
		}
		/// <summary>
		/// Read one or more IPIntegrator design files
		///
		///
		/// TCL Syntax: read_bd [-quiet] [-verbose] <files>...
		///
		/// Read the specified IP subsystem design files, or block designs, into the current project or the in￾memory design. This command is similar to the add_files command. The block design file is
		/// added to the source fileset as it is read.
		/// RECOMMENDED: Files are read and referenced from their current location, and are not moved into the local
		/// project directories. To bring the file into the local project, use the import_files command instead.
		/// You can use this command to read block designs into the in-memory design, when running the
		/// Vivado tool in Non Project mode, in which there is no project file to maintain and manage the
		/// various project source files. Refer to the Vivado Design Suite User Guide: Design Flows Overview
		/// (UG892) for more information on Non Project mode.
		/// This command returns the name of the IP subsystem design files read, or returns an error if it
		/// fails.
		///
		/// The following example reads the specified IP subsystem design into the current project:
		/// read_bd C:/Data/block_designs/design1.bd
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1130
		/// </summary>
		/// <param name="files">(Required) IPIntegrator design file name(s)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of IPIntegrator design file objects that were added</returns>
		public virtual SimpleTCLCommand read_bd(string files, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_bd [-quiet] [-verbose] <files>...
			return
				new SimpleTCLCommand("read_bd")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(files)
			;
		}
		/// <summary>
		/// Read a design checkpoint
		///
		///
		/// TCL Syntax: read_checkpoint [-cell <arg>] [-incremental] [-directive <arg>] [-reuse_objects <args>] [-fix_objects <args>] [-dcp_cell_list <args>] [-quiet] [-verbose] [<file>]
		///
		/// Reads a design checkpoint file (DCP) that contains the netlist, constraints, and may optionally
		/// have the placement and routing information of an implemented design. You can save design
		/// checkpoints at any stage in the design using the write_checkpoint command.
		/// The read_checkpoint command simply reads the associated checkpoint file, without opening
		/// a design or project in-memory. To create a project from the imported checkpoint, use the
		/// open_checkpoint command instead of read_checkpoint, or use the link_design
		/// command after read_checkpoint to open the in-memory design from the checkpoint or
		/// checkpoint files currently read.
		/// Note: When multiple design checkpoints are open in the Vivado tool, you must use the
		/// current_project command to switch between the open designs. You can use current_design to
		/// check which checkpoint is the active design.
		///
		/// The following example imports the specified checkpoint file into the tool, and then links the
		/// various design elements to create an in-memory design of the specified name:
		/// read_checkpoint C:/Data/checkpoint.dcp
		/// link_design -name Test1
		/// This example reads a design checkpoint on top of the current design for incremental place and
		/// route of the design:
		/// read_checkpoint -incremental C:/Data/routed.dcp
		/// Reuse and fix the placement and routing associated with the DSPs and Block RAMs:
		/// read_checkpoint -incremental C:/Data/routed.dcp \
		/// -reuse_objects [all_rams] -reuse_objects [all_dsps] -fix_objects
		/// [current_design]
		/// TIP: The -reuse_objects option could also be written as:
		/// -reuse_objects [get_cells -hier -filter {PRIMITIVE_TYPE =~ BMEM.*.* ||
		/// PRIMITIVE_TYPE =~ MULT.dsp.* }]
		/// The following example reuses the placement and routing of the cells inside the hierarchical
		/// cpuEngine cell, and fixes the placement of the DSP cells:
		/// read_checkpoint -incremental C:/Data/routed.dcp -reuse_objects [get_cells
		/// cpuEngine] -fix_objects [all_dsps]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1132
		/// </summary>
		/// <param name="file">(Required) Design checkpoint file</param>
		/// <param name="cell">(Optional) Replace this cell with the checkpoint. The cell must be a black box.</param>
		/// <param name="incremental">(Optional) Input design checkpoint file to be used for re-using implementation.</param>
		/// <param name="directive">
		/// (Optional)
		/// Mode of behavior (directive) for this command. Please refer
		/// to Arguments section of this help for values for this option.
		/// Default: RuntimeOptimized
		/// </param>
		/// <param name="reuse_objects">(Optional) Reuse only given list of cells, clock regions, SLRs and Designs</param>
		/// <param name="fix_objects">(Optional) Fix only given list of cells, clock regions, SLRs or Design</param>
		/// <param name="dcp_cell_list">
		/// (Optional)
		/// A list of cell/dcp pairs, e.g. {<cell1> <dcp1> <cell2> <dcp2>}.
		/// The option value should be in curly braces.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand read_checkpoint(string file, string cell = null, bool? incremental = null, string directive = null, string reuse_objects = null, string fix_objects = null, string dcp_cell_list = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_checkpoint [-cell <arg>] [-incremental] [-directive <arg>] [-reuse_objects <args>] [-fix_objects <args>] [-dcp_cell_list <args>] [-quiet] [-verbose] [<file>]
			return
				new SimpleTCLCommand("read_checkpoint")
					.OptionalNamedString("cell", cell)
					.Flag("incremental", incremental)
					.OptionalNamedString("directive", directive)
					.OptionalNamedString("reuse_objects", reuse_objects)
					.OptionalNamedString("fix_objects", fix_objects)
					.OptionalNamedString("dcp_cell_list", dcp_cell_list)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Import package pin and port placement information
		///
		///
		/// TCL Syntax: read_csv [-quiet_diff_pairs] [-quiet] [-verbose] <file>
		///
		/// Imports port definition and package pin placement information from a comma separated value
		/// (CSV) file.
		/// The port definitions in a CSV file can be imported into an I/O Pin Planning project. In a Pin
		/// Planning project, importing a CSV file replaces the current port definitions. Any ports in the
		/// design that are not found in the imported CSV file will be removed.
		/// In all other projects the port definitions are defined in the source design data, however package
		/// pin assignments and port attributes can be read from the specified CSV file.
		/// The ports read from the CSV file can not have spaces in the name, or the tool will return an error.
		/// The specific format and requirements of the CSV file are described in the Vivado Design Suite User
		/// Guide: I/O and Clock Planning (UG899).
		///
		/// The following example imports a CSV file into an open project:
		/// read_csv C/Data/pinList.csv
		/// The following example sets up a new IO Pin Planning project, and then imports the specified CSV
		/// file into it, and infers any differential pairs in the CSV file:
		/// create_project myPinPlan C:/Data/myPinPlan -part xc7v285tffg1157-1
		/// set_property design_mode PinPlanning [current_fileset]
		/// open_io_design -name io_1
		/// read_csv C:/Data/import.csv
		/// infer_diff_pairs -filetype csv C:/Data/import.csv
		/// Note: The design_mode property on the source fileset is what determines the nature of the project.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1136
		/// </summary>
		/// <param name="file">(Required) Pin Planning CSV file</param>
		/// <param name="quiet_diff_pairs">
		/// (Optional)
		/// Suppress warnings about differential pair inference when
		/// importing I/O ports
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand read_csv(string file, bool? quiet_diff_pairs = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_csv [-quiet_diff_pairs] [-quiet] [-verbose] <file>
			return
				new SimpleTCLCommand("read_csv")
					.Flag("quiet_diff_pairs", quiet_diff_pairs)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Read one or more EDIF or NGC files
		///
		///
		/// TCL Syntax: read_edif [-quiet] [-verbose] <files>
		///
		/// Imports an EDIF or NGC netlist file into the Design Source fileset of the current project.
		/// IMPORTANT! NGC format files are not supported in the Vivado Design Suite for UltraScale devices. It is
		/// recommended that you regenerate the IP using the Vivado Design Suite IP customization tools with native
		/// output products. Alternatively, you can use the NGC2EDIF command to migrate the NGC file to EDIF format
		/// for importing. For more information refer to the ISE to Vivado Design Suite Migration Guide (UG911).
		///
		/// The following example imports an EDIF file into the open project:
		/// read_edif C/Data/bft_top.edf
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1138
		/// </summary>
		/// <param name="files">(Required) EDIF or NGC file name(s)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of file objects that were added</returns>
		public virtual SimpleTCLCommand read_edif(string files, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_edif [-quiet] [-verbose] <files>
			return
				new SimpleTCLCommand("read_edif")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(files)
			;
		}
		/// <summary>
		/// Read hardware ILA data from a file
		///
		///
		/// TCL Syntax: read_hw_ila_data [-quiet] [-verbose] <file>
		///
		/// Read ILA debug core data from the specified file, and create an hw_ila_data object.
		/// The ILA debug sample data is acquired from a running device using the upload_hw_ila_data
		/// command. This creates a hw_ila_data object that can be written to a file on disk using the
		/// write_hw_ila_data command. This command reads that ILA data file.
		/// The hw_ila_data object that is created by read_hw_ila_data is named after the <file> it is
		/// read from. If a hw_ila_data object of the same name already exists, the name of the object is
		/// assigned a number extension starting at 1: <file>_1.
		/// The new hw_ila_data object is not connected with, or associated with, any ILA debug cores in the
		/// design.
		/// After being read from disk, the ILA debug data can be viewed in the waveform viewer of the
		/// Vivado logic analyzer by using the display_hw_ila_data command.
		/// This command returns an ILA data object, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1140
		/// </summary>
		/// <param name="file">(Required) hardware ILA data file name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Name of the output file</returns>
		public virtual SimpleTCLCommand read_hw_ila_data(string file, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_hw_ila_data [-quiet] [-verbose] <file>
			return
				new SimpleTCLCommand("read_hw_ila_data")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Read hardware SIO scan data from a file. A hardware SIO scan object will be created if not
		/// provided.
		///
		///
		/// TCL Syntax: read_hw_sio_scan [-quiet] [-verbose] <file> [<hw_sio_scan>]
		///
		/// Read a hardware SIO scan data file and create a hw_sio_scan object in the Hardware Manager
		/// feature of the Vivado Design Suite.
		/// The SIO scan data can be written to disk using the write_hw_sio_scan command, after
		/// running the scan using the run_hw_sio_scan command. This command reads that data file.
		/// If no hw_sio_scan object is specified, a new hw_sio_scan object is created and is named
		/// sequentially following any existing hw_sio_scan objects. After being read from disk, the SIO scan
		/// data can be plotted and viewed in the Vivado serial I/O analyzer by using the
		/// display_hw_sio_scan command.
		/// This command returns a hw_sio_scan object, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1142
		/// </summary>
		/// <param name="file">(Required) hardware SIO scan file name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_sio_scan">(Optional) hardware SIO scan data object Default: None</param>
		/// <returns>hardware SIO scan object</returns>
		public virtual SimpleTCLCommand read_hw_sio_scan(string file, bool? quiet = null, bool? verbose = null, string hw_sio_scan = null)
		{
			// TCL Syntax: read_hw_sio_scan [-quiet] [-verbose] <file> [<hw_sio_scan>]
			return
				new SimpleTCLCommand("read_hw_sio_scan")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
					.OptionalString(hw_sio_scan)
			;
		}
		/// <summary>
		/// Read hardware SIO sweep data from a directory. A hardware SIO sweep object will be created if
		/// not provided.
		///
		///
		/// TCL Syntax: read_hw_sio_sweep [-quiet] [-verbose] <directory> [<hw_sio_sweep>]
		///
		/// Read a hardware SIO sweep data directory and create a hw_sio_sweep object in the Hardware
		/// Manager feature of the Vivado Design Suite.
		/// The SIO sweep data can be written to disk using the write_hw_sio_sweep command, after
		/// running the sweep using the run_hw_sio_sweep command. This command reads the sweep
		/// directory containing multiple SIO scan data files.
		/// If no hw_sio_sweep object is specified, a new hw_sio_sweep object is created and is named
		/// sequentially following any existing hw_sio_sweep objects. After being read from disk, any of the
		/// SIO scans in the sweep can be plotted and viewed in the Vivado serial I/O analyzer by using the
		/// display_hw_sio_scan command.
		/// This command returns a hw_sio_sweep object, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1144
		/// </summary>
		/// <param name="directory">(Required) hardware SIO sweep directory name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_sio_sweep">(Optional) hardware SIO sweep data object Default: None</param>
		/// <returns>hardware SIO sweep object</returns>
		public virtual SimpleTCLCommand read_hw_sio_sweep(string directory, bool? quiet = null, bool? verbose = null, string hw_sio_sweep = null)
		{
			// TCL Syntax: read_hw_sio_sweep [-quiet] [-verbose] <directory> [<hw_sio_sweep>]
			return
				new SimpleTCLCommand("read_hw_sio_sweep")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(directory)
					.OptionalString(hw_sio_sweep)
			;
		}
		/// <summary>
		/// Read one or more IP files
		///
		///
		/// TCL Syntax: read_ip [-quiet] [-verbose] <files>
		///
		/// Read the specified list of IP files (XCI) and add them to the design and the current fileset. Files are
		/// added by reference into the current project, just as in the add_files command.
		/// You can use this command to read the contents of source files into the in-memory design, when
		/// running the Vivado tool in Non Project mode, in which there is no project file to maintain and
		/// manage the various project source files. Refer to the Vivado Design Suite User Guide: Design Flows
		/// Overview (UG892) for more information on Non Project mode.
		/// When using the read_ip command all output products associated with the IP core, including
		/// the design checkpoint file (DCP) will be read into the in-memory design.
		/// TIP: In the project-based design flow, the Vivado tool will automatically generate the necessary output products
		/// associated with an IP core. However, in a non-project flow you must generate the necessary output products
		/// using the synth_ip or generate_target commands. For more information on working with IP refer to the
		/// Vivado Design Suite User Guide: Designing with IP (UG896).
		/// Use the import_ip command to add the IP cores and import the files into the local project
		/// directory.
		/// This command returns the list of files read.
		///
		/// The following example reads the specified IP files:
		/// read_ip C:/test_ip/char_fifo.xci
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1146
		/// </summary>
		/// <param name="files">(Required) IP file name(s)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of IP file objects that were added</returns>
		public virtual SimpleTCLCommand read_ip(string files, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_ip [-quiet] [-verbose] <files>
			return
				new SimpleTCLCommand("read_ip")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(files)
			;
		}
		/// <summary>
		/// load iPhysOpt script and run it.
		///
		///
		/// TCL Syntax: read_iphys_opt_tcl [-fanout_opt] [-critical_cell_opt] [-placement_opt] [-rewire] [-dsp_register_opt] [-bram_register_opt] [-uram_register_opt] [-shift_register_opt] [-auto_pipeline] [-critical_pin_opt] [-include_skipped_optimizations] [-place] [-insert_negative_edge_ffs] [-hold_fix] [-slr_crossing_opt] [-quiet] [-verbose] [<input>]
		///
		/// Interactive physical optimization can be used in two ways:
		/// • Applying post-placement physical optimizations to the pre-placement netlist to improve the
		/// overall placement result and improve design performance.
		/// • Saving the physical optimizations in a Tcl script to be repeated as needed.
		/// To apply post-placement optimizations to the pre-placement netlist, you can reset the
		/// implementation run and open the synthesized design, or open the opt_design checkpoint, and
		/// read the iphys_opt Tcl script to apply the physical optimizations.
		/// You can apply all optimizations from the iphys_opt Tcl script, or apply specific optimizations using
		/// the options of the read_iphys_opt_tcl command. You can also include any optimizations
		/// that were defined but skipped during physical optimization.
		/// If the iphys_opt Tcl script includes placement data, you can use that data to place the optimized
		/// cells in the design.
		/// After reading the iphys_opt Tcl script, and placing the optimized cells, you can rerun placement
		/// for the overall design. The design now incorporates the benefits of the phys_opt_design
		/// optimizations before placement, such as fewer high-fanout nets due to replication, and fewer
		/// long distance paths from block RAM outputs. The results should be a better placement, and
		/// improved design performance, due to the early application of netlist optimizations.
		/// This command returns a transcript of its processes, or returns an error if it fails.
		///
		/// The following example applies the BRAM optimizations that are defined in the specified
		/// interactive physical optimization Tcl script, and applies any placement data for the optimized
		/// cells:
		/// open_checkpoint C:/Data/opt_design.dcp
		/// read_iphys_opt_tcl -shift_register_opt -place C:/Data/my_iphys_opt.tcl
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1148
		/// </summary>
		/// <param name="input">(Required) iPhysOpt.tcl file</param>
		/// <param name="fanout_opt">(Optional) Fanout optimization including very high fanout optimizations</param>
		/// <param name="critical_cell_opt">(Optional) Do cell-duplication based optimization on timing critical nets</param>
		/// <param name="placement_opt">(Optional) Move cells to reduce delay on timing-critical nets</param>
		/// <param name="rewire">(Optional) Do rewiring optimization</param>
		/// <param name="dsp_register_opt">(Optional) DSP register optimization</param>
		/// <param name="bram_register_opt">(Optional) BRAM register optimization</param>
		/// <param name="uram_register_opt">(Optional) UltraRAM register optimization</param>
		/// <param name="shift_register_opt">(Optional) Shift register optimization</param>
		/// <param name="auto_pipeline">(Optional) Auto pipeline</param>
		/// <param name="critical_pin_opt">(Optional) Pin Swap optimization</param>
		/// <param name="include_skipped_optimizations">(Optional) Apply undo changes</param>
		/// <param name="place">(Optional) Replay placement of the transformation</param>
		/// <param name="insert_negative_edge_ffs">(Optional) Inserting negative edge triggered FFs for high hold mitigation</param>
		/// <param name="hold_fix">(Optional) Inserting buffers for hold fix optimization</param>
		/// <param name="slr_crossing_opt">(Optional) Optimize slr crossing nets</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand read_iphys_opt_tcl(string input, bool? fanout_opt = null, bool? critical_cell_opt = null, bool? placement_opt = null, bool? rewire = null, bool? dsp_register_opt = null, bool? bram_register_opt = null, bool? uram_register_opt = null, bool? shift_register_opt = null, bool? auto_pipeline = null, bool? critical_pin_opt = null, bool? include_skipped_optimizations = null, bool? place = null, bool? insert_negative_edge_ffs = null, bool? hold_fix = null, bool? slr_crossing_opt = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_iphys_opt_tcl [-fanout_opt] [-critical_cell_opt] [-placement_opt] [-rewire] [-dsp_register_opt] [-bram_register_opt] [-uram_register_opt] [-shift_register_opt] [-auto_pipeline] [-critical_pin_opt] [-include_skipped_optimizations] [-place] [-insert_negative_edge_ffs] [-hold_fix] [-slr_crossing_opt] [-quiet] [-verbose] [<input>]
			return
				new SimpleTCLCommand("read_iphys_opt_tcl")
					.Flag("fanout_opt", fanout_opt)
					.Flag("critical_cell_opt", critical_cell_opt)
					.Flag("placement_opt", placement_opt)
					.Flag("rewire", rewire)
					.Flag("dsp_register_opt", dsp_register_opt)
					.Flag("bram_register_opt", bram_register_opt)
					.Flag("uram_register_opt", uram_register_opt)
					.Flag("shift_register_opt", shift_register_opt)
					.Flag("auto_pipeline", auto_pipeline)
					.Flag("critical_pin_opt", critical_pin_opt)
					.Flag("include_skipped_optimizations", include_skipped_optimizations)
					.Flag("place", place)
					.Flag("insert_negative_edge_ffs", insert_negative_edge_ffs)
					.Flag("hold_fix", hold_fix)
					.Flag("slr_crossing_opt", slr_crossing_opt)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(input)
			;
		}
		/// <summary>
		/// Read one or more data files (.mem .mif .dat).
		///
		///
		/// TCL Syntax: read_mem [-quiet] [-verbose] <files>...
		///
		/// This command reads memory files of type MEM, DAT, or COE, and adds the files to the in￾memory design, or the current project, to initialize BRAM memory for behavioral simulation,
		/// synthesis and post-synthesis simulation.
		/// If the memory is not initialized in the design, then it will be initialized to all 0s.
		/// This command returns the name of the files read, or returns an error if it fails.
		///
		/// The following example:
		/// read_mem C:/Data/design1.mem
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1151
		/// </summary>
		/// <param name="files">(Required) Data (.mem .coe .dat) file name(s)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of file objects that were added</returns>
		public virtual SimpleTCLCommand read_mem(string files, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_mem [-quiet] [-verbose] <files>...
			return
				new SimpleTCLCommand("read_mem")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(files)
			;
		}
		/// <summary>
		/// Read QoR Suggestions from the given file
		///
		///
		/// TCL Syntax: read_qor_suggestions [-quiet] [-verbose] <file>
		///
		/// Read the specified file and extract the QoR suggestions from the file.
		/// This command returns the name of the QoR file read, or returns an error if it fails.
		///
		/// The following example reads the QoR suggestions from the specified file, and then reports the
		/// QoR suggestions in the open design:
		/// read_qor_suggestions C:/Data/qor_results.rqs
		/// report_qor_suggestions -of_objects [get_qor_suggestions]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1153
		/// </summary>
		/// <param name="file">
		/// (Required)
		/// QoR suggestions file Values: Path to the QoR suggestions
		/// file, typically ending with .rqs.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand read_qor_suggestions(string file, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_qor_suggestions [-quiet] [-verbose] <file>
			return
				new SimpleTCLCommand("read_qor_suggestions")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Import simulation data in saif format
		///
		///
		/// TCL Syntax: read_saif [-strip_path <arg>] [-no_strip] [-out_file <arg>] [-quiet] [-verbose] <file>
		///
		/// Reads a Switching Activity Interchange Format (SAIF) file for use during power analysis by the
		/// report_power command, or power optimization by power_opt_design. The read_saif
		/// command will annotate the design nodes with activity from the SAIF file and estimate power
		/// appropriately.
		/// Running report_power or power_opt_design after reading the SAIF file will use the activity
		/// rates from the specified file during optimization and analysis.
		///
		/// The following example:
		/// read_saif -strip_path design/top/F1 C:/Data/design1.saif
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1155
		/// </summary>
		/// <param name="file">(Required) Specifies the name of the SAIF file to be read</param>
		/// <param name="strip_path">
		/// (Optional)
		/// Specifies the name of the instance of the current design as
		/// it appears in the SAIF file
		/// </param>
		/// <param name="no_strip">(Optional) Do not strip first two levels of hierarchy from SAIF file</param>
		/// <param name="out_file">
		/// (Optional)
		/// Specifies the name of the output file that contains nets that
		/// could not be matched
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand read_saif(string file, string strip_path = null, bool? no_strip = null, string out_file = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_saif [-strip_path <arg>] [-no_strip] [-out_file <arg>] [-quiet] [-verbose] <file>
			return
				new SimpleTCLCommand("read_saif")
					.OptionalNamedString("strip_path", strip_path)
					.Flag("no_strip", no_strip)
					.OptionalNamedString("out_file", out_file)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Import schematic
		///
		///
		/// TCL Syntax: read_schematic [-name <arg>] [-quiet] [-verbose] <file>
		///
		/// Import a native schematic file that was previously exported from the Vivado Design Suite using
		/// the write_schematic command.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1157
		/// </summary>
		/// <param name="file">(Required) Input file</param>
		/// <param name="name">(Optional) Schematic window title</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>name of the file previously exported</returns>
		public virtual SimpleTCLCommand read_schematic(string file, string name = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_schematic [-name <arg>] [-quiet] [-verbose] <file>
			return
				new SimpleTCLCommand("read_schematic")
					.OptionalNamedString("name", name)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Read timing results from Trace STA tool
		///
		///
		/// TCL Syntax: read_twx [-cell <arg>] [-pblock <arg>] [-quiet] [-verbose] <name> <file>
		///
		/// Imports timing results in the TWX format timing report files generated by the Xilinx Timing
		/// Reporter And Circuit Evaluator (TRACE) tool. The TWX file can be imported at the top-level,
		/// which is the default, or at a specific cell-level or relative to a specific Pblock.
		/// After the TWX files are imported, the timing results display in the Timing Results view in GUI
		/// mode.
		///
		/// The following example reads the specified TWX file into the top-level of the design:
		/// read_twx C:/Data/timing_files/bft.twx
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1159
		/// </summary>
		/// <param name="name">(Required) Name for the set of results</param>
		/// <param name="file">(Required) Name of the Trace import file</param>
		/// <param name="cell">(Optional) Interpret names in the report file as relative to the specified cell</param>
		/// <param name="pblock">(Optional) Interpret names in the report file as relative to the specified pblock</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand read_twx(string name, string file, string cell = null, string pblock = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_twx [-cell <arg>] [-pblock <arg>] [-quiet] [-verbose] <name> <file>
			return
				new SimpleTCLCommand("read_twx")
					.OptionalNamedString("cell", cell)
					.OptionalNamedString("pblock", pblock)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Read one or more Verilog files
		///
		///
		/// TCL Syntax: read_verilog [-library <arg>] [-sv] [-quiet] [-verbose] <files>...
		///
		/// Reads Verilog or SystemVerilog source files. This command is similar to the add_files
		/// command. The Verilog file is added to the source fileset as it is read. If the -library argument
		/// is specified, the file is added with the Library property defined appropriately.
		/// You can use this command to read the contents of source files into the in-memory design, when
		/// running the Vivado tool in Non Project mode, in which there is no project file to maintain and
		/// manage the various project source files. Refer to the Vivado Design Suite User Guide: Design Flows
		/// Overview (UG892) for more information on Non Project mode.
		/// Because SystemVerilog is a superset of the Verilog language, the read_verilog command can
		/// read both file types. However, for SystemVerilog files, the -sv option needs to be specified for
		/// read_verilog to enable compilation in the SystemVerilog mode. In this mode, the tool
		/// recognizes and honors the SystemVerilog keywords and constructs.
		/// You can have a mixture of both Verilog files (.v files), and SystemVerilog files (.sv files), as well as
		/// VHDL (using read_vhdl). When the tool compiles these files for synthesis, it creates separate
		/// "compilation units" for each file type. All files of the same type are compiled together.
		///
		/// The following example reads the specified Verilog file and adds it to the source fileset:
		/// read_verilog C:/Data/FPGA_Design/new_module.v
		/// The following example creates two compilation units, one for SystemVerilog files and one for
		/// Verilog files:
		/// read_verilog -sv { file1.sv file2.sv file3.sv }
		/// read_verilog { file1.v file2.v file3.v}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1161
		/// </summary>
		/// <param name="files">(Required) Verilog file name(s)</param>
		/// <param name="library">(Optional) Library name (ignored by Vivado synthesis) Default: default lib</param>
		/// <param name="sv">(Optional) Enable system verilog compilation</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of file objects that were added</returns>
		public virtual SimpleTCLCommand read_verilog(string files, string library = null, bool? sv = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_verilog [-library <arg>] [-sv] [-quiet] [-verbose] <files>...
			return
				new SimpleTCLCommand("read_verilog")
					.OptionalNamedString("library", library)
					.Flag("sv", sv)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(files)
			;
		}
		/// <summary>
		/// Read one or more VHDL files
		///
		///
		/// TCL Syntax: read_vhdl -library <arg> [-vhdl2008] [-quiet] [-verbose] <files>
		///
		/// Reads VHDL source files. This command is similar to the add_files command. The VHDL files
		/// are added to the source fileset as the file is read. If the -library argument is specified, the file
		/// is added with the Library property defined.
		/// You can use this command to read the contents of source files into the in-memory design, when
		/// running the Vivado tool in Non Project mode, in which there is no project file to maintain and
		/// manage the various project source files. Refer to the Vivado Design Suite User Guide: Design Flows
		/// Overview (UG892) for more information on Non Project mode.
		///
		/// The following example reads the specified VHDL file and adds it to the source fileset:
		/// read_vhdl C:/Data/FPGA_Design/new_module.vhdl
		/// This example reads multiple specified VHDL 2008 files:
		/// read_vhdl -vhdl2008 {file1.vhd file2.vhd file3.vhd}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1163
		/// </summary>
		/// <param name="library">(Required) VHDL library</param>
		/// <param name="files">(Required) VHDL file name(s)</param>
		/// <param name="vhdl2008">(Optional) VHDL file is version 2008.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of file objects that were added</returns>
		public virtual SimpleTCLCommand read_vhdl(string library, string files, bool? vhdl2008 = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_vhdl -library <arg> [-vhdl2008] [-quiet] [-verbose] <files>
			return
				new SimpleTCLCommand("read_vhdl")
					.RequiredNamedString("library", library)
					.Flag("vhdl2008", vhdl2008)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(files)
			;
		}
		/// <summary>
		/// read physical and timing constraints from one of more files.
		///
		///
		/// TCL Syntax: read_xdc [-cells <args>] [-ref <arg>] [-quiet_diff_pairs] [-mode <arg>] [-unmanaged] [-no_add] [-quiet] [-verbose] <files>
		///
		/// Imports physical and timing constraints from a Xilinx Design Constraints file (XDC). The XDC is
		/// imported into the current_instance level of the design hierarchy, which defaults to the top￾level of the design, or can be imported into specified cells. When imported at the top-level, the
		/// specified XDC file is added to the active constraint fileset.
		/// IMPORTANT! Constraints from the XDC file will overwrite any current constraints of the same name.
		/// Therefore, exercise some caution when reading a XDC file to be sure you will not overwrite important
		/// constraints.
		/// This command is similar to the add_files command in that the XDC file is added by reference
		/// rather than imported into the local project directory.
		/// You can use this command to read the contents of source files into the in-memory design, when
		/// running the Vivado tool in Non Project mode, in which there is no project file to maintain and
		/// manage the various project source files. Refer to the Vivado Design Suite User Guide: Design Flows
		/// Overview (UG892) for more information on Non Project mode.
		///
		/// The following example reads the XDC file and applies it to the current design:
		/// read_xdc file_1.xdc
		/// The following example reads the XDC file and applies it ALL instances of the referenced module
		/// found in the current design:
		/// read_xdc -ref hex2led file_2.xdc
		/// The following example reads the XDC file and applies it ONLY to the specified instance within
		/// the referenced module:
		/// read_xdc -ref sixty -cells lsbcount file_3.xdc
		/// The following example reads the XDC file and applies it to the specified instances in the current
		/// design, even though they are instances of different modules:
		/// read_xdc -cells {one_decode sixty/msbcount} file_4.xdc
		/// Note: Multiple cells must be enclosed in quotes, "", or braces, {}.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1165
		/// </summary>
		/// <param name="files">(Required) Input file(s) to read</param>
		/// <param name="cells">(Optional) Import constraints for these cells</param>
		/// <param name="@ref">(Optional) Import constraints for this ref</param>
		/// <param name="quiet_diff_pairs">
		/// (Optional)
		/// Suppress warnings about differential pair inference when
		/// importing I/O ports
		/// </param>
		/// <param name="mode">
		/// (Optional)
		/// Import constraints as out_of_context. Values: default,
		/// out_of_context Default: default
		/// </param>
		/// <param name="unmanaged">(Optional) treat this file as unmanaged constraints file</param>
		/// <param name="no_add">(Optional) don't add this file to constraints fileset</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of files</returns>
		public virtual SimpleTCLCommand read_xdc(string files, string cells = null, string @ref = null, bool? quiet_diff_pairs = null, string mode = null, bool? unmanaged = null, bool? no_add = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_xdc [-cells <args>] [-ref <arg>] [-quiet_diff_pairs] [-mode <arg>] [-unmanaged] [-no_add] [-quiet] [-verbose] <files>
			return
				new SimpleTCLCommand("read_xdc")
					.OptionalNamedString("cells", cells)
					.OptionalNamedString("ref", @ref)
					.Flag("quiet_diff_pairs", quiet_diff_pairs)
					.OptionalNamedString("mode", mode)
					.Flag("unmanaged", unmanaged)
					.Flag("no_add", no_add)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(files)
			;
		}
		/// <summary>
		/// Readback data from the hw_cfgmem object
		///
		///
		/// TCL Syntax: readback_hw_cfgmem [-checksum] [-force] [-all] [-offset <arg>] -file <arg> [-format <arg>] [-datacount <arg>] [-quiet] [-verbose] [<hw_cfgmem>...]
		///
		/// Read programming data off of the hardware configuration memory device, specified as a
		/// hw_cfgmem object.
		/// This command reads back the memory configuration file data programmed into a flash memory
		/// device by the program_hw_cfgmem command and writes it to the specified file. The memory
		/// configuration file is created by the write_cfgmem command and combines the bitstream
		/// (.bit) file, and any specified data files, into the memory configuration file format.
		/// Readback is the process of reading data from the configuration memory device to verify that the
		/// bitstream and any additional data files were properly programmed into the flash memory device.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1168
		/// </summary>
		/// <param name="file">(Required) File to write readback to</param>
		/// <param name="checksum">(Optional) readback and calculate checksum; cannot be used with -file option</param>
		/// <param name="force">(Optional) force write of file</param>
		/// <param name="all">(Optional) specify readback of all memory locations</param>
		/// <param name="offset">(Optional) memory offset value Default: 0x0</param>
		/// <param name="format">(Optional) File format of readback file</param>
		/// <param name="datacount">(Optional) number of data units to readback Default: 0x0</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_cfgmem">(Optional) list of hardware cfgmems Default: current hardware cfgmem</param>
		public virtual SimpleTCLCommand readback_hw_cfgmem(string file, bool? checksum = null, bool? force = null, bool? all = null, string offset = null, string format = null, string datacount = null, bool? quiet = null, bool? verbose = null, string hw_cfgmem = null)
		{
			// TCL Syntax: readback_hw_cfgmem [-checksum] [-force] [-all] [-offset <arg>] -file <arg> [-format <arg>] [-datacount <arg>] [-quiet] [-verbose] [<hw_cfgmem>...]
			return
				new SimpleTCLCommand("readback_hw_cfgmem")
					.Flag("checksum", checksum)
					.Flag("force", force)
					.Flag("all", all)
					.OptionalNamedString("offset", offset)
					.RequiredNamedString("file", file)
					.OptionalNamedString("format", format)
					.OptionalNamedString("datacount", datacount)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(hw_cfgmem)
			;
		}
		/// <summary>
		/// Readback hardware devices
		///
		///
		/// TCL Syntax: readback_hw_device [-force] [-capture] [-readback_file <arg>] [-bin_file <arg>] [-quiet] [-verbose] [<hw_device>...]
		///
		/// Read bitstream data from the current hardware device and write it to the specified readback or
		/// binary file.
		/// The Vivado device programmer will readback bitstream data from the Xilinx device through the
		/// open target.
		/// IMPORTANT! If the bitstream on the hw_device is encrypted, readback is not permitted.
		/// This command returns the name of the readback file created, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1172
		/// </summary>
		/// <param name="force">(Optional) force write of file</param>
		/// <param name="capture">(Optional) capture configuration readback data (ultrascale only)</param>
		/// <param name="readback_file">(Optional) readback file for rbd file output</param>
		/// <param name="bin_file">(Optional) bin file for bin file output</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_device">(Optional) list of hardware devices Default: current hardware device</param>
		/// <returns>hardware devices</returns>
		public virtual SimpleTCLCommand readback_hw_device(bool? force = null, bool? capture = null, string readback_file = null, string bin_file = null, bool? quiet = null, bool? verbose = null, string hw_device = null)
		{
			// TCL Syntax: readback_hw_device [-force] [-capture] [-readback_file <arg>] [-bin_file <arg>] [-quiet] [-verbose] [<hw_device>...]
			return
				new SimpleTCLCommand("readback_hw_device")
					.Flag("force", force)
					.Flag("capture", capture)
					.OptionalNamedString("readback_file", readback_file)
					.OptionalNamedString("bin_file", bin_file)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(hw_device)
			;
		}
		/// <summary>
		/// Re-do previous command
		///
		///
		/// TCL Syntax: redo [-list] [-quiet] [-verbose]
		///
		/// IMPORTANT! The UNDO and REDO commands are intended for use in the Vivado IDE, and are not
		/// recommended for use in Tcl scripts to restore designs to a former state. To restore a design to a specific
		/// condition, you must write a design checkpoint using the write_checkpoint command, to be restored using
		/// read_checkpoint.
		/// Redo a command that has been previously undone. This command can be used repeatedly to
		/// redo a series of commands.
		/// If a command group has been created using the startgroup and endgroup commands, the
		/// redo command will redo the group of commands as a sequence.
		///
		/// The following example returns a list of commands that can be redone:
		/// redo -list
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1175
		/// </summary>
		/// <param name="list">(Optional) Show a list of redoable tasks</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>with -list, the list of redoable tasks</returns>
		public virtual SimpleTCLCommand redo(bool? list = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: redo [-list] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("redo")
					.Flag("list", list)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Refresh the current design
		///
		///
		/// TCL Syntax: refresh_design [-part <arg>] [-quiet] [-verbose]
		///
		/// Reloads the current design from the project data on the hard drive. This overwrites the in￾memory view of the design to undo any recent design changes.
		///
		/// The following command reloads the current design from the project data on hard disk. This will
		/// overwrite the unsaved changes of the design which are in memory.
		/// refresh_design
		/// Note: You can use the command to undo a series of changes to the design and revert to the previously
		/// saved design.
		/// The following example refreshes the current design using the specified V6 part as the target
		/// device. The second command is required to make the selected part the target device for the
		/// active implementation run.
		/// refresh_design -part xc6vcx75tff784-1
		/// set_property part xc6vcx75tff784-1 [get_runs impl_6]
		/// Note: The second command is not required if the target part is not changed.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1177
		/// </summary>
		/// <param name="part">(Optional) Target part</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand refresh_design(string part = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: refresh_design [-part <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("refresh_design")
					.OptionalNamedString("part", part)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Refresh hardware AXI object status.
		///
		///
		/// TCL Syntax: refresh_hw_axi [-quiet] [-verbose] [<hw_axis>...]
		///
		/// Refresh the STATUS properties of the hw_axi object with the values from the current hw_device.
		/// The refresh command takes the values from the status registers of the JTAG to AXI MASTER on
		/// the hardware device, and populates them into the appropriate properties of the hw_axi object in
		/// the hardware manager.
		/// Refresh the STATUS properties of the specified hw_axi objects. THE STATUS properties include:
		/// STATUS.AXI_READ_BUSY, STATUS.AXI_READ_DONE, STATUS.AXI_WRITE_BUSY,
		/// STATUS.AXI_WRITE_DONE, STATUS.BRESP, and STATUS.RRESP.
		/// This command updates the properties on the hw_axi object, but otherwise returns nothing if
		/// successful. The command returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1179
		/// </summary>
		/// <param name="hw_axis">(Required) List of hardware AXI objects.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand refresh_hw_axi(string hw_axis, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: refresh_hw_axi [-quiet] [-verbose] [<hw_axis>...]
			return
				new SimpleTCLCommand("refresh_hw_axi")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_axis)
			;
		}
		/// <summary>
		/// Refresh the status of the current hardware object. Inputs need to be any DDRMC object. At least
		/// one object is required. If properties are specified, but do not exist in the object, those properties
		/// will not be refreshed.
		///
		///
		/// TCL Syntax: refresh_hw_ddrmc [-regexp] [-properties <args>] [-quiet] [-verbose] <hw_objects>
		///
		/// Refreshes the in-memory contents of all of the properties, or specified properties, of the
		/// specified Versal DDR Memory Controller (DDRMC) objects with values read from the current
		/// hardware device.
		/// The refresh command takes the values from the DDRMC object implemented on the hardware
		/// device, and populates them into the appropriate properties of the hw_ddrmc object in the Vivado
		/// hardware manager. If only certain properties are specified, then those properties are updated
		/// from the hw device.
		/// At least one object is required. If properties are specified that do not exist in the object, that
		/// property will not be refreshed.
		/// This command updates the properties on the hw_ddrmc object, but otherwise returns nothing if
		/// successful. The command returns an error if it fails.
		///
		/// The following example refreshes all of the properties of the DDRMC objects in the Vivado
		/// hardware manager with the properties from the current hw_device:
		/// refresh_hw_ddrmc -properties {PHY_RANKS} [lindex [get_hw_ddrmcs] 3]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1181
		/// </summary>
		/// <param name="hw_objects">(Required) hardware DDRMC objects</param>
		/// <param name="regexp">(Optional) Properties list contains full regular expressions</param>
		/// <param name="properties">(Optional) List of properties to refresh Default: All properties in object</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand refresh_hw_ddrmc(string hw_objects, bool? regexp = null, string properties = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: refresh_hw_ddrmc [-regexp] [-properties <args>] [-quiet] [-verbose] <hw_objects>
			return
				new SimpleTCLCommand("refresh_hw_ddrmc")
					.Flag("regexp", regexp)
					.OptionalNamedString("properties", properties)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_objects)
			;
		}
		/// <summary>
		/// Refresh a hardware device. Read device and core information from device.
		///
		///
		/// TCL Syntax: refresh_hw_device [-update_hw_probes <arg>] [-disable_done_check] [-force_poll] [-quiet] [-verbose] [<hw_device>]
		///
		/// Refreshes the in-memory view of the device by scanning for debug and IBERT cores on the
		/// specified hw_device object, and also reads a probe file when directed.
		/// The Hardware Manager in the Vivado Design Suite creates, deletes, or updates the hw_ila,
		/// hw_vio, hw_sio*, and hw_axi objects based on the core information found in the device, and also
		/// what is read from the probes file in the case of ILA and VIO debug cores.
		/// Use the refresh_hw_device after the program_hw_devices to keep the in-memory
		/// hardware debug objects in sync with the state of the actual cores on the physical device.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1183
		/// </summary>
		/// <param name="update_hw_probes">(Optional) Update hardware probe information, read from probes file</param>
		/// <param name="disable_done_check">(Optional) Disable done check for refresh device</param>
		/// <param name="force_poll">(Optional) Force poll of all targets</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_device">(Optional) hardware device Default: current hardware device</param>
		public virtual SimpleTCLCommand refresh_hw_device(string update_hw_probes = null, bool? disable_done_check = null, bool? force_poll = null, bool? quiet = null, bool? verbose = null, string hw_device = null)
		{
			// TCL Syntax: refresh_hw_device [-update_hw_probes <arg>] [-disable_done_check] [-force_poll] [-quiet] [-verbose] [<hw_device>]
			return
				new SimpleTCLCommand("refresh_hw_device")
					.OptionalNamedString("update_hw_probes", update_hw_probes)
					.Flag("disable_done_check", disable_done_check)
					.Flag("force_poll", force_poll)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(hw_device)
			;
		}
		/// <summary>
		/// Refresh the status of the current hardware object. Inputs can be HBM or device hardware object.
		/// At least one object is required. If properties are specified that do not exist in the object, that
		/// property will not be refreshed.
		///
		///
		/// TCL Syntax: refresh_hw_hbm [-regexp] [-properties <args>] [-quiet] [-verbose] <hw_objects>
		///
		/// Refreshes the in-memory view of all of the properties, or specified properties, of the specified
		/// HBM controller objects with values read from the current hardware device.
		/// The refresh command takes the values from the HBM controller implemented on the hardware
		/// device, and populates them into the appropriate properties of the hw_hbm object in the Vivado
		/// hardware manager. If only certain properties are specified, then those properties are updated
		/// from the hw device.
		/// At least one object is required. If properties are specified that do not exist in the object, that
		/// property will not be refreshed.
		/// This command updates the properties on the hw_hbm object, but otherwise returns nothing if
		/// successful. The command returns an error if it fails.
		///
		/// The following example refreshes all of the properties of the HBM controller in the Vivado
		/// hardware manager with the properties from the current hw_device:
		/// refresh_hw_hbm [lindex [get_hw_hbms] 1]
		/// The following example refreshes the specified property of the HBM controller from the current
		/// hw_device:
		/// refresh_hw_hbm -properties {MC2.INIT.AM_REPEAT_EN} [get_hw_hbms *HBM_2]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1185
		/// </summary>
		/// <param name="hw_objects">(Required) hardware objects</param>
		/// <param name="regexp">(Optional) Properties list contains full regular expressions</param>
		/// <param name="properties">(Optional) List of properties to refresh Default: All properties in object</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand refresh_hw_hbm(string hw_objects, bool? regexp = null, string properties = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: refresh_hw_hbm [-regexp] [-properties <args>] [-quiet] [-verbose] <hw_objects>
			return
				new SimpleTCLCommand("refresh_hw_hbm")
					.Flag("regexp", regexp)
					.OptionalNamedString("properties", properties)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_objects)
			;
		}
		/// <summary>
		/// Refresh the status of the current hardware object. Inputs can be any mig, device, target, or server
		/// hardware object. At least one object is required. If properties are specified that do not exist in the
		/// object, that property will not be refreshed.
		///
		///
		/// TCL Syntax: refresh_hw_mig [-regexp] [-properties <args>] [-quiet] [-verbose] <hw_objects>
		///
		/// Refreshes the in-memory view of all of the properties, or specified properties, of the specified
		/// hw_mig objects with values read from the current hardware device.
		/// The refresh command takes the values from the memory controller implemented on the
		/// hardware device, and populates them into the appropriate properties of the hw_mig debug core
		/// in the Vivado logic analyzer, or standalone Vivado Lab Edition.
		/// At least one object is required. If properties are specified that do not exist in the object, that
		/// property will not be refreshed.
		/// This command updates the properties on the hw_mig object, but otherwise returns nothing if
		/// successful. The command returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1187
		/// </summary>
		/// <param name="hw_objects">(Required) hardware objects</param>
		/// <param name="regexp">(Optional) Properties list contains full regular expressions</param>
		/// <param name="properties">(Optional) List of properties to refresh Default: All properties in object</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand refresh_hw_mig(string hw_objects, bool? regexp = null, string properties = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: refresh_hw_mig [-regexp] [-properties <args>] [-quiet] [-verbose] <hw_objects>
			return
				new SimpleTCLCommand("refresh_hw_mig")
					.Flag("regexp", regexp)
					.OptionalNamedString("properties", properties)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_objects)
			;
		}
		/// <summary>
		/// Refresh a connection to a hardware server
		///
		///
		/// TCL Syntax: refresh_hw_server [-force_poll] [-quiet] [-verbose] [<hw_server>]
		///
		/// Refresh or reopen the connection to the current or specified hardware server.
		/// This command returns the connection messages from the hardware server, or returns an error if
		/// it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1189
		/// </summary>
		/// <param name="force_poll">(Optional) Force poll of all targets</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_server">(Optional) hardware server</param>
		public virtual SimpleTCLCommand refresh_hw_server(bool? force_poll = null, bool? quiet = null, bool? verbose = null, string hw_server = null)
		{
			// TCL Syntax: refresh_hw_server [-force_poll] [-quiet] [-verbose] [<hw_server>]
			return
				new SimpleTCLCommand("refresh_hw_server")
					.Flag("force_poll", force_poll)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(hw_server)
			;
		}
		/// <summary>
		/// Refresh the status of the specified hardware objects. Inputs can be any serial I/O (except scan
		/// and sweep), device, target, or server hardware object. At least one object is required. If properties
		/// are specified that do not exist in the object, that property will not be refreshed.
		///
		///
		/// TCL Syntax: refresh_hw_sio [-regexp] [-properties <args>] [-quiet] [-verbose] <hw_objects>
		///
		/// Refreshes the in-memory view of all of the properties, or specified properties, of the specified
		/// hw_sio objects with values read from the actual object on the hardware device.
		/// Specified objects can include any serial I/O object such as GTs, RXs, TXs, PLLs, or Commons,
		/// excluding hw_sio_scan and hw_sio_sweep objects. SIO objects also include device, target, or
		/// server hardware objects.
		/// The refresh_hw_sio command reads the values of the specified objects on the hardware
		/// device, and applies the value to the associated property of the IBERT core in the Hardware
		/// Manager.
		/// This command returns no feedback of its operation if successful, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1191
		/// </summary>
		/// <param name="hw_objects">(Required) hardware objects</param>
		/// <param name="regexp">(Optional) Properties list contains full regular expressions</param>
		/// <param name="properties">(Optional) List of properties to refresh Default: All properties in object</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand refresh_hw_sio(string hw_objects, bool? regexp = null, string properties = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: refresh_hw_sio [-regexp] [-properties <args>] [-quiet] [-verbose] <hw_objects>
			return
				new SimpleTCLCommand("refresh_hw_sio")
					.Flag("regexp", regexp)
					.OptionalNamedString("properties", properties)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_objects)
			;
		}
		/// <summary>
		/// Refresh the status of the current hardware object. Inputs can be hw_server, hw_target,
		/// hw_device or hw_sysmon objects. At least one object is required. If properties are specified that
		/// do not exist in the object, that property will not be refreshed.
		///
		///
		/// TCL Syntax: refresh_hw_sysmon [-regexp] [-properties <args>] [-quiet] [-verbose] <hw_objects>
		///
		/// Refresh the properties of the hw_sysmon object with the values on the system monitor (XADC)
		/// from the current hw_device.
		/// The refresh command takes the values from the status registers of the system monitor on the
		/// hardware device, and populates them into the appropriate properties of the hw_sysmon object in
		/// the hardware manager.
		/// TIP: The hw_sysmon object is automatically refreshed at the rate specified by the
		/// SYSMON_REFRESH_RATE_MS on the object.
		/// This command updates the properties on the hw_sysmon object, but otherwise returns nothing if
		/// successful. The command returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1193
		/// </summary>
		/// <param name="hw_objects">(Required) hardware objects</param>
		/// <param name="regexp">(Optional) Properties list contains full regular expressions</param>
		/// <param name="properties">(Optional) List of properties to refresh Default: All properties in object</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand refresh_hw_sysmon(string hw_objects, bool? regexp = null, string properties = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: refresh_hw_sysmon [-regexp] [-properties <args>] [-quiet] [-verbose] <hw_objects>
			return
				new SimpleTCLCommand("refresh_hw_sysmon")
					.Flag("regexp", regexp)
					.OptionalNamedString("properties", properties)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_objects)
			;
		}
		/// <summary>
		/// Refresh a hardware target
		///
		///
		/// TCL Syntax: refresh_hw_target [-force_poll] [-quiet] [-verbose] [<hw_target>]
		///
		/// Refresh the connection to the specified hardware target on the current hardware server, and
		/// reload the hw_target object in the Hardware Manager of the Vivado Design Suite. If no
		/// hw_target object is specified, the current_hw_target will be refreshed.
		/// The hardware target is a system board containing a JTAG chain of one or more Xilinx devices that
		/// you can program with a bitstream file, or use to debug your design. Connections between
		/// hardware targets on the system board and the Vivado Design Suite are managed by the Xilinx
		/// hardware server application, and the connect_hw_server command. Refer to Vivado Design
		/// Suite User Guide: Programming and Debugging (UG908) for a list of supported JTAG download
		/// cables and devices.
		/// Each hardware target can have one or more Xilinx devices to program, or to use for debugging
		/// purposes. The current device is specified or returned by the current_hw_device command.
		/// After specifying the current hardware target, you can open the connection through the hardware
		/// target, to the Xilinx FPGA using the open_hw_target command.
		/// refresh_hw_target scans the devices on the hardware target and creates, deletes, or
		/// updates the hw_device objects available through the target. Available devices are returned using
		/// the get_hw_devices command.
		/// This command returns a transcript of the refresh process, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1195
		/// </summary>
		/// <param name="force_poll">(Optional) Force poll of all targets</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_target">(Optional) hardware target</param>
		public virtual SimpleTCLCommand refresh_hw_target(bool? force_poll = null, bool? quiet = null, bool? verbose = null, string hw_target = null)
		{
			// TCL Syntax: refresh_hw_target [-force_poll] [-quiet] [-verbose] [<hw_target>]
			return
				new SimpleTCLCommand("refresh_hw_target")
					.Flag("force_poll", force_poll)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(hw_target)
			;
		}
		/// <summary>
		/// Update hardware probe INPUT_VALUE and ACTIVITY_VALUE properties with values read from
		/// hardware VIO core(s).
		///
		///
		/// TCL Syntax: refresh_hw_vio [-update_output_values] [-quiet] [-verbose] <hw_vios>...
		///
		/// Update the INPUT_VALUE and ACTIVITY_VALUE properties of the input probes of the specified
		/// VIO debug cores with values read from the hw_vio core on the hardware device.
		/// The Virtual Input/Output (VIO) debug core can both monitor and drive internal signals on a
		/// programmed Xilinx device in real time. The VIO core uses hardware probes, hw_probe objects, to
		/// monitor and drive signals on the device. Input probes monitor signals as inputs to the VIO core.
		/// Output probes drive signals to specified values from the VIO core.
		/// The refresh_hw_vio command reads the signal values at the input probes of the VIO debug
		/// core on the device, and applies the value to the INPUT_VALUE property of the hw_probe, and
		/// updates the ACTIVITY_VALUE property on the probe as well.
		/// This command returns nothing if successful, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1197
		/// </summary>
		/// <param name="hw_vios">(Required) List of hardware VIO objects.</param>
		/// <param name="update_output_values">
		/// (Optional)
		/// Update hardware probe OUTPUT_VALUE property with
		/// values read from VIO core(s).
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand refresh_hw_vio(string hw_vios, bool? update_output_values = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: refresh_hw_vio [-update_output_values] [-quiet] [-verbose] <hw_vios>...
			return
				new SimpleTCLCommand("refresh_hw_vio")
					.Flag("update_output_values", update_output_values)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_vios)
			;
		}
		/// <summary>
		/// Update and initialize the BRAM initialization strings with contents of elf files.
		///
		///
		/// TCL Syntax: refresh_meminit [-quiet] [-verbose]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1199
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand refresh_meminit(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: refresh_meminit [-quiet] [-verbose]
			return
				new SimpleTCLCommand("refresh_meminit")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Regenerate layout.
		///
		///
		/// TCL Syntax: regenerate_bd_layout [-hierarchy <arg>] [-layout_file <arg>] [-routing] [-quiet] [-verbose]
		///
		/// Regenerate the layout of the current IP integrator subsystem design in the open canvas. This
		/// command updates and redraws the graphical elements of the subsystem design in the Vivado
		/// IDE.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1200
		/// </summary>
		/// <param name="hierarchy">(Optional) Hierarchy path to the window</param>
		/// <param name="layout_file">(Optional) layout file previously exported by write_bd_layout using native format</param>
		/// <param name="routing">(Optional) Preserve placement of blocks and regenerate routing</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand regenerate_bd_layout(string hierarchy = null, string layout_file = null, bool? routing = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: regenerate_bd_layout [-hierarchy <arg>] [-layout_file <arg>] [-routing] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("regenerate_bd_layout")
					.OptionalNamedString("hierarchy", hierarchy)
					.OptionalNamedString("layout_file", layout_file)
					.Flag("routing", routing)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Register a Tcl proc with Vivado.
		///
		///
		/// TCL Syntax: register_proc [-quiet] [-verbose] <proc> [<tasknm>]
		///
		/// Register a Tcl procedure (proc) with the Vivado Tcl command interpretor to register the command
		/// with the Vivado Design Suite help system.
		/// The following is an example Tcl proc defined for use with the Vivado Design Suite:
		/// proc findCommand {option} {
		/// # Summary:
		/// # Searches through all Vivado Tcl commands for commands implementing
		/// # the specified argument.
		/// # Argument Usage:
		/// # option: Specifies the argument to search for.
		/// # Return Value:
		/// # Returns a list of Tcl commands that implement the option.
		/// # Categories: personal
		/// foreach cmd [lsort [info commands *]]
		/// {
		/// catch {
		/// if {[regexp "$option" [help -syntax $cmd]]}
		/// {
		/// puts $cmd
		/// }
		/// }
		/// }
		/// } ;
		/// # End
		/// The commented lines beginning with '#' are used to define the help text for the registered
		/// command in the Vivado Design Suite help system.
		/// • # Summary: provides a brief description of the command.
		/// • # Argument Usage: provides a list and description of the various arguments for the proc.
		/// • # Return Value: provides a description of what is returned by the proc.
		/// • # Categories: provides an ability to define categories for registered procedures.
		/// After registering the procedure as a Tcl command, the Vivado help system will return this text
		/// when queried with:
		/// tasknm -help
		/// -or￾help tasknm
		/// This command returns the name of the registered proc.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1202
		/// </summary>
		/// <param name="proc">(Required) Name of proc to register. Proc must be known to Tcl</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="tasknm">
		/// (Optional)
		/// Name of Tcl task that wraps the proc. Default: Register the
		/// proc using the root name proc (no namespaces).
		/// </param>
		/// <returns>Nothing</returns>
		public virtual SimpleTCLCommand register_proc(string proc, bool? quiet = null, bool? verbose = null, string tasknm = null)
		{
			// TCL Syntax: register_proc [-quiet] [-verbose] <proc> [<tasknm>]
			return
				new SimpleTCLCommand("register_proc")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(proc)
					.OptionalString(tasknm)
			;
		}
		/// <summary>
		/// Reimport files when they are found out-of-date
		///
		///
		/// TCL Syntax: reimport_files [-force] [-quiet] [-verbose] [<files>...]
		///
		/// Reimports project files. This updates the local project files from the original referenced source
		/// files.
		///
		/// The following example reimports all project files regardless of whether they are out of date, or
		/// the local files are newer than the referenced source file:
		/// reimport_files -force
		/// Note: No warnings will be issued for newer local files that will be overwritten.
		/// The following example reimports the specified files to the project, but only if the original source
		/// file is newer than the local project file:
		/// reimport_files C:/Data/FPGA_Design/source1.v \
		/// C:/Data/FPGA_Design/source2.vhdl
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1205
		/// </summary>
		/// <param name="force">(Optional) Force a reimport to happen even when the local files may be newer</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="files">
		/// (Optional)
		/// List of files to reimport. If no files are specified, all files in
		/// the project that are out-of-date, will be reimported
		/// </param>
		/// <returns>list of file objects that were imported</returns>
		public virtual SimpleTCLCommand reimport_files(bool? force = null, bool? quiet = null, bool? verbose = null, string files = null)
		{
			// TCL Syntax: reimport_files [-force] [-quiet] [-verbose] [<files>...]
			return
				new SimpleTCLCommand("reimport_files")
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(files)
			;
		}
		/// <summary>
		/// Recompile the design without changing compilation options and restart the current simulation
		///
		///
		/// TCL Syntax: relaunch_sim [-quiet] [-verbose]
		///
		/// Relaunch the simulator to perform analysis and verification of an updated design.
		/// The relaunch_sim command suspends the current simulation, recompiles the current design
		/// into a new simulation snapshot, then connects the current simulation to the new snapshot, and
		/// restarts the simulation.
		/// In the typical HDL debug cycle you will compile a design into a simulation snapshot and launch a
		/// simulation, configuring the Vivado simulator IDE to display the signals of interest in the
		/// waveform viewer, as well as the scopes and objects of interest. During the debug process you
		/// may discover issues with your code or test bench, make corrections to your design, recompile
		/// and relaunch the simulator.
		/// This command lets you recompile the design, and relaunch the simulator while preserving the
		/// current Vivado simulator configuration, such as open waveform and code windows, Scopes and
		/// Objects window settings.
		/// IMPORTANT! The relaunch_sim command applies only to simulations running in the Vivado Design Suite
		/// IDE, not stand-alone or batch Vivado simulator runs.
		/// This command returns a transcript of its process, or returns an error if it fails.
		///
		/// The following command relaunches the current simulation:
		/// relaunch_sim
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1207
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Current simulation object</returns>
		public virtual SimpleTCLCommand relaunch_sim(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: relaunch_sim [-quiet] [-verbose]
			return
				new SimpleTCLCommand("relaunch_sim")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Remove breakpoints from a simulation
		///
		///
		/// TCL Syntax: remove_bps [-all] [-file <arg>] [-line <arg>] [-quiet] [-verbose] [<BreakPointObjsOrIds>...]
		///
		/// Remove specified breakpoints from the current simulation. You must have an open simulation to
		/// use this command.
		/// A breakpoint is a user-determined stopping point in the source code used for debugging the
		/// design. When simulating a design with breakpoints, simulation of the design stops at each
		/// breakpoint to let you examine values and verify the design behavior.
		/// The breakpoints in the current simulation can be reported using the report_bps command.
		/// This command returns nothing, or an error if the command fails.
		///
		/// The following example removes all the breakpoints in the current simulation:
		/// remove_bps -all
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1209
		/// </summary>
		/// <param name="all">(Optional) Remove all breakpoints</param>
		/// <param name="file">(Optional) The specific file to remove the breakpoint from given a line number</param>
		/// <param name="line">
		/// (Optional)
		/// The specific line number to remove the breakpoint given a
		/// filename Default: -1
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="BreakPointObjsOrIds">
		/// (Optional)
		/// A list of one or more breakpoint objects and/or breakpoint
		/// object ID's to be removed
		/// </param>
		public virtual SimpleTCLCommand remove_bps(bool? all = null, string file = null, string line = null, bool? quiet = null, bool? verbose = null, string BreakPointObjsOrIds = null)
		{
			// TCL Syntax: remove_bps [-all] [-file <arg>] [-line <arg>] [-quiet] [-verbose] [<BreakPointObjsOrIds>...]
			return
				new SimpleTCLCommand("remove_bps")
					.Flag("all", all)
					.OptionalNamedString("file", file)
					.OptionalNamedString("line", line)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(BreakPointObjsOrIds)
			;
		}
		/// <summary>
		/// Remove cells from the current design
		///
		///
		/// TCL Syntax: remove_cell [-quiet] [-verbose] <cells>...
		///
		/// Remove cells from the current netlist in either an open Synthesized or Implemented design.
		/// Note: You cannot remove cells from library macros, also called macro-primitives.
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*
		/// command.
		/// Note: Netlist editing is not allowed on the elaborated RTL design.
		///
		/// The following example removes the fftEngine from the in-memory netlist of the current design:
		/// remove_cell fftEngine
		/// remove_cell usbEngine0/usb_out
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1211
		/// </summary>
		/// <param name="cells">(Required) List of cells to remove</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand remove_cell(string cells, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_cell [-quiet] [-verbose] <cells>...
			return
				new SimpleTCLCommand("remove_cell")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(cells)
			;
		}
		/// <summary>
		/// Remove cells from a Pblock
		///
		///
		/// TCL Syntax: remove_cells_from_pblock [-quiet] [-verbose] <pblock> <cells>...
		///
		/// Removes the specified logic instances from a Pblock. Cells are added to a Pblock with the
		/// add_cells_to_pblock command.
		/// Note: Cells that have been placed will not be unplaced as they are removed from a Pblock. Any current
		/// LOC assignments are left intact.
		///
		/// The following example removes the specified cells from the pb_cpuEngine Pblock:
		/// remove_cells_from_pblock pb_cpuEngine [get_cells cpuEngine/cpu_dwb_dat_o/*]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1213
		/// </summary>
		/// <param name="pblock">(Required) Pblock to remove cells from</param>
		/// <param name="cells">(Required) Cells to remove</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand remove_cells_from_pblock(string pblock, string cells, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_cells_from_pblock [-quiet] [-verbose] <pblock> <cells>...
			return
				new SimpleTCLCommand("remove_cells_from_pblock")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(pblock)
					.RequiredString(cells)
			;
		}
		/// <summary>
		/// Remove conditions from a simulation. The names can be specified as Tcl glob pattern
		///
		///
		/// TCL Syntax: remove_conditions [-all] [-quiet] [-verbose] [<ConditionObjs>]
		///
		/// Remove specified conditions from the current simulation. You must have an open simulation to
		/// use this command.
		/// Conditions can be defined prior to starting the simulation. When a condition is added, the
		/// simulator evaluates the condition expression anytime a signal change is detected. When a
		/// specified condition expression becomes TRUE, the condition commands are run.
		/// The conditions in the current simulation can be reported using the report_conditions
		/// command.
		/// This command returns nothing, or an error if the command fails.
		///
		/// The following example removes the specified condition from the current simulation:
		/// remove_conditions condition3
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1215
		/// </summary>
		/// <param name="all">(Optional) Remove all conditions</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="ConditionObjs">(Optional) ConditionObjs, id's or names</param>
		public virtual SimpleTCLCommand remove_conditions(bool? all = null, bool? quiet = null, bool? verbose = null, string ConditionObjs = null)
		{
			// TCL Syntax: remove_conditions [-all] [-quiet] [-verbose] [<ConditionObjs>]
			return
				new SimpleTCLCommand("remove_conditions")
					.Flag("all", all)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(ConditionObjs)
			;
		}
		/// <summary>
		/// Remove DRC rule check objects from a user rule deck
		///
		///
		/// TCL Syntax: remove_drc_checks [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] -ruledeck <arg> [-quiet] [-verbose] [<patterns>]
		///
		/// Remove the specified design rule checks from a drc_ruledeck object.
		/// A rule deck is a collection of design rule checks grouped for convenience, to be run with the
		/// report_drc command at different stages of the FPGA design flow, such as during I/O planning
		/// or placement. The tool comes with a set of factory defined rule decks, but you can also create
		/// new user-defined rule decks with the create_drc_ruledeck command.
		/// Checks are added to a rule deck using the add_drc_checks command.
		/// The DRC rule check object features the IS_ENABLED property that can be set to true or false
		/// using the set_property command. When a new rule check is created, the IS_ENABLED
		/// property is set to true as a default. Set the IS_ENABLED property to false to disable the rule
		/// check from being used by report_drc without having to remove the rule from the rule deck.
		/// TIP: Use the reset_drc_check command to restore the DRC rule, and its properties, to the default settings.
		/// This command returns the list of design rule checks that were removed from the specified rule
		/// deck.
		///
		/// The following example removes the rule checks matching the specified filter pattern from the
		/// my_rules rule deck:
		/// remove_drc_checks -filter {GROUP == AVAL} -ruledeck my_rules
		/// The following example disables the specified DRC check without removing it from the rule deck:
		/// set_property IS_ENABLED FALSE [get_drc_checks RAMW-1]
		/// The following example removes all rule checks from the specified rule deck:
		/// remove_drc_checks -ruledeck my_rules
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1217
		/// </summary>
		/// <param name="ruledeck">(Required) DRC rule deck to modify</param>
		/// <param name="of_objects">(Optional) Get 'rule_check' objects of these types: 'drc_ruledeck'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'rule_check' objects against patterns. Default: *</param>
		/// <returns>drc_check</returns>
		public virtual SimpleTCLCommand remove_drc_checks(string ruledeck, string of_objects = null, bool? regexp = null, bool? nocase = null, string filter = null, bool? quiet = null, bool? verbose = null, string patterns = null)
		{
			// TCL Syntax: remove_drc_checks [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] -ruledeck <arg> [-quiet] [-verbose] [<patterns>]
			return
				new SimpleTCLCommand("remove_drc_checks")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("regexp", regexp)
					.Flag("nocase", nocase)
					.OptionalNamedString("filter", filter)
					.RequiredNamedString("ruledeck", ruledeck)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(patterns)
			;
		}
		/// <summary>
		/// Remove files or directories from a fileset
		///
		///
		/// TCL Syntax: remove_files [-fileset <arg>] [-quiet] [-verbose] <files>...
		///
		/// Removes the specified file objects from the current or specified fileset. The file is removed from
		/// the current project, but is not removed from the disk.
		/// Files can be specified as file name strings, or as file objects returned by the get_files
		/// command. When specified as strings, the file is looked for in the current or specified fileset.
		/// When the file object is specified by get_files, the fileset is defined by the object, and -
		/// fileset is ignored.
		/// When successful, this command returns nothing. If the specified file is not found, an error is
		/// returned.
		///
		/// The following example removes the file named C:/Design/top.xdc from the constraint set
		/// constrs_1:
		/// remove_files -fileset constrs_1 C:/Design/top.xdc
		/// Multiple files can be specified as follows:
		/// remove_files -fileset sim_1 top_tb1.vhdl top_tb2.vhdl
		/// The following example gets all the file objects in the current project, and removes them:
		/// remove_files [get_files]
		/// CAUTION! This will remove ALL files from your design.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1221
		/// </summary>
		/// <param name="files">(Required) Name of the file(s) to be removed</param>
		/// <param name="fileset">(Optional) Fileset name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of files that were removed</returns>
		public virtual SimpleTCLCommand remove_files(string files, string fileset = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_files [-fileset <arg>] [-quiet] [-verbose] <files>...
			return
				new SimpleTCLCommand("remove_files")
					.OptionalNamedString("fileset", fileset)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(files)
			;
		}
		/// <summary>
		/// Release force on signal, wire, or reg applied using 'add_force' command
		///
		///
		/// TCL Syntax: remove_forces [-all] [-quiet] [-verbose] [<ForceObj>...]
		///
		/// Remove the specified force objects, or force IDs from the current simulation.
		/// Forces are applied to specific HDL objects using the add_forces command. This command
		/// removes those forces from the current simulation.
		/// IMPORTANT! If there are force/release statements on an HDL object in the test bench or module, these
		/// statements are overridden by the add_force command. When the remove_force command releases these
		/// objects to resume their normal operation, the Verilog force/release statements resume their effect.
		/// This command returns nothing if successful, or returns an error if it fails.
		///
		/// The following example creates a force object using the add_force command, and captures the
		/// force ID in a Tcl variable, then removes that force object:
		/// set f10 [ add_force reset 1 300 ]
		/// remove_forces $f10
		/// The following example removes all force objects from the current simulation:
		/// remove_forces -all
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1223
		/// </summary>
		/// <param name="all">(Optional) Remove all forces</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="ForceObj">(Optional) ForceObj or id's</param>
		public virtual SimpleTCLCommand remove_forces(bool? all = null, bool? quiet = null, bool? verbose = null, string ForceObj = null)
		{
			// TCL Syntax: remove_forces [-all] [-quiet] [-verbose] [<ForceObj>...]
			return
				new SimpleTCLCommand("remove_forces")
					.Flag("all", all)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(ForceObj)
			;
		}
		/// <summary>
		/// Remove one or more custom command arguments
		///
		///
		/// TCL Syntax: remove_gui_custom_command_args -command_name <arg> [-quiet] [-verbose] <names>...
		///
		/// Remove one or more GUI custom command arguments of a particular GUI custom command.
		/// You can use the get_gui_custom_commands to determine the list of defined custom
		/// commands. You can use the get_gui_custom_command_args to determine the list of
		/// defined GUI custom command arguments for a particular GUI custom command.
		///
		/// Remove GUI custom command arguments with name 'arg1' and 'arg2' of a GUI custom command
		/// with name 'cmd_1' :
		/// remove_gui_custom_command_args -command_name cmd_1 {arg1 arg2}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1225
		/// </summary>
		/// <param name="command_name">(Required) name of custom command whose arguments are being removed.</param>
		/// <param name="names">(Required) name of one or more custom command arguments to remove.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand remove_gui_custom_command_args(string command_name, string names, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_gui_custom_command_args -command_name <arg> [-quiet] [-verbose] <names>...
			return
				new SimpleTCLCommand("remove_gui_custom_command_args")
					.RequiredNamedString("command_name", command_name)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(names)
			;
		}
		/// <summary>
		/// Remove one or more custom commands
		///
		///
		/// TCL Syntax: remove_gui_custom_commands [-quiet] [-verbose] <names>...
		///
		/// Remove one or more GUI custom commands.
		/// You can use the get_gui_custom_commands to determine the list of defined custom
		/// commands.
		///
		/// The following example removes the GUI custom commands with names 'abc' and 'xyz':
		/// remove_gui_custom_commands {abc xyz}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1227
		/// </summary>
		/// <param name="names">(Required) name of one or more custom commands to remove</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand remove_gui_custom_commands(string names, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_gui_custom_commands [-quiet] [-verbose] <names>...
			return
				new SimpleTCLCommand("remove_gui_custom_commands")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(names)
			;
		}
		/// <summary>
		/// De-select Pseudo Channel from Activity Monitor on the specified hardware HBM(s). Must
		/// specify the Memory Controller number first, follow by Pseudo Channel number.
		///
		///
		/// TCL Syntax: remove_hw_hbm_pc [-quiet] [-verbose] <mc_num> <pc_num> <hw_objects>
		///
		/// The remove_hw_hbm_pc command removes a memory channel (mc)/psuedo channel (pc) that
		/// has been previously added to an HBM activity monitor using the add_hw_hbm_pc command.
		/// TIP: The HBM activity monitor must not be running when adding or removing psuedo channels.
		/// This command returns nothing if successful, or returns an error if it fails.
		///
		/// The following example removes the previously added psuedo channel from the HBM activity
		/// monitor, and then runs the activity monitor:
		/// remove_hw_hbm_pc 2 0 [get_hw_hbms *HBM_2]
		/// run_hw_hbm_amon [get_hw_hbms *HBM_2]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1229
		/// </summary>
		/// <param name="mc_num">(Required) Memory Controller number to de-select: 0 to 7</param>
		/// <param name="pc_num">(Required) Pseudo Channel number to de-select: 0 or 1</param>
		/// <param name="hw_objects">(Required) hardware objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand remove_hw_hbm_pc(string mc_num, string pc_num, string hw_objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_hw_hbm_pc [-quiet] [-verbose] <mc_num> <pc_num> <hw_objects>
			return
				new SimpleTCLCommand("remove_hw_hbm_pc")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(mc_num)
					.RequiredString(pc_num)
					.RequiredString(hw_objects)
			;
		}
		/// <summary>
		/// Remove enumerated name-value pairs from a hw_probe enumeration.
		///
		///
		/// TCL Syntax: remove_hw_probe_enum [-no_gui_update] [-list <args>] [-remove_all] [-quiet] [-verbose] <hw_probe>
		///
		/// Remove the enumerated name/value pairs defined on a specified hw_probe object.
		/// The enumerated names (ENUM property) are added to a hw_probe object using the
		/// add_hw_probe_enum command. This command removes those defined properties.
		/// This command returns nothing if successful, or returns an error if it fails.
		///
		/// The following example removes the list of enumerated names from the specified hw_probe
		/// object:
		/// remove_hw_probe_enum -list {WHITE YELLOW GREY} \
		/// [get_hw_probes op1 -of_objects [current_hw_ila]]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1231
		/// </summary>
		/// <param name="hw_probe">(Required) ILA hardware probe object.</param>
		/// <param name="no_gui_update">(Optional) Defer GUI update.</param>
		/// <param name="list">(Optional) List of enumerated names to remove.</param>
		/// <param name="remove_all">(Optional) Remove the whole enumeration for a hardware probe. Default: 0</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand remove_hw_probe_enum(string hw_probe, bool? no_gui_update = null, string list = null, bool? remove_all = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_hw_probe_enum [-no_gui_update] [-list <args>] [-remove_all] [-quiet] [-verbose] <hw_probe>
			return
				new SimpleTCLCommand("remove_hw_probe_enum")
					.Flag("no_gui_update", no_gui_update)
					.OptionalNamedString("list", list)
					.Flag("remove_all", remove_all)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_probe)
			;
		}
		/// <summary>
		/// Remove an existing hardware SIO link.
		///
		///
		/// TCL Syntax: remove_hw_sio_link [-quiet] [-verbose] <hw_sio_links>
		///
		/// Removes the specified communication links between TX and RX objects on the GTs of the IBERT
		/// debug core defined on the current hardware device.
		/// Vivado Serial I/O analyzer is a link-based analyzer, which lets you link between any transmitter
		/// and receiver within the IBERT design. The links define the communication paths and protocols
		/// between transmitters and receivers of the GigaBit transceivers on the device. This command
		/// removes those links.
		/// This command returns a list of link objects on the IBERT debug core, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1233
		/// </summary>
		/// <param name="hw_sio_links">(Required) hardware SIO links</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand remove_hw_sio_link(string hw_sio_links, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_hw_sio_link [-quiet] [-verbose] <hw_sio_links>
			return
				new SimpleTCLCommand("remove_hw_sio_link")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_sio_links)
			;
		}
		/// <summary>
		/// Remove an existing hardware SIO link group.
		///
		///
		/// TCL Syntax: remove_hw_sio_linkgroup [-quiet] [-verbose] <hw_sio_linkgroups>
		///
		/// Removes the specified group that associates communication links between TX and RX objects on
		/// the GTs of the IBERT debug core defined on the current hardware device.
		/// Vivado Serial I/O analyzer is a link-based analyzer. The links define the communication paths and
		/// protocols between transmitters and receivers of the GigaBit transceivers on the device. Link
		/// groups, or hw_sio_linkgroup objects, let you associate links into related groups, to collectively
		/// configure properties and run scans.
		/// TIP: The remove_hw_sio_linkgroup command removes the specified association, but does not remove
		/// the underlying communication links. Us the remove_hw_sio_link command to remove those objects.
		/// This command returns nothing if successful, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1235
		/// </summary>
		/// <param name="hw_sio_linkgroups">(Required) hardware SIO linkgroups</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand remove_hw_sio_linkgroup(string hw_sio_linkgroups, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_hw_sio_linkgroup [-quiet] [-verbose] <hw_sio_linkgroups>
			return
				new SimpleTCLCommand("remove_hw_sio_linkgroup")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_sio_linkgroups)
			;
		}
		/// <summary>
		/// Remove an existing hardware SIO scan.
		///
		///
		/// TCL Syntax: remove_hw_sio_scan [-quiet] [-verbose] <hw_sio_scans>
		///
		/// Remove the specified serial I/O analyzer scan object.
		/// This command returns nothing if successful, or returns an error if the command fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1237
		/// </summary>
		/// <param name="hw_sio_scans">(Required) hardware SIO scans</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand remove_hw_sio_scan(string hw_sio_scans, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_hw_sio_scan [-quiet] [-verbose] <hw_sio_scans>
			return
				new SimpleTCLCommand("remove_hw_sio_scan")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_sio_scans)
			;
		}
		/// <summary>
		/// Remove an existing hardware SIO sweep.
		///
		///
		/// TCL Syntax: remove_hw_sio_sweep [-quiet] [-verbose] <hw_sio_sweeps>
		///
		/// Remove the specified serial I/O analyzer sweep scan object.
		/// This command returns nothing if successful, or returns an error if the command fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1239
		/// </summary>
		/// <param name="hw_sio_sweeps">(Required) hardware SIO sweeps</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand remove_hw_sio_sweep(string hw_sio_sweeps, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_hw_sio_sweep [-quiet] [-verbose] <hw_sio_sweeps>
			return
				new SimpleTCLCommand("remove_hw_sio_sweep")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_sio_sweeps)
			;
		}
		/// <summary>
		/// Remove nets from the current design
		///
		///
		/// TCL Syntax: remove_net [-prune] [-quiet] [-verbose] <nets>...
		///
		/// Remove the specified net from the netlist of an open Synthesized or Implemented Design.
		/// Note: You cannot remove nets from library macros, also called macro-primitives.
		/// To remove a bus, you must specify the primary bus name, and not specify a bus index. This
		/// ensures that the entire bus is removed, and not just a portion of the bits associated with the bus.
		/// You can resize a bus, eliminating bits of the bus, using the resize_net_bus command.
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*
		/// command.
		/// Note: Netlist editing is not allowed on the elaborated RTL design.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1241
		/// </summary>
		/// <param name="nets">(Required) List of nets to remove</param>
		/// <param name="prune">
		/// (Optional)
		/// When performing net removal, remove pins and ports which
		/// are left unconnected as a result of the remove_net
		/// operation.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand remove_net(string nets, bool? prune = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_net [-prune] [-quiet] [-verbose] <nets>...
			return
				new SimpleTCLCommand("remove_net")
					.Flag("prune", prune)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(nets)
			;
		}
		/// <summary>
		/// Remove pins from the current design
		///
		///
		/// TCL Syntax: remove_pin [-quiet] [-verbose] <pins>...
		///
		/// Remove pins from the current netlist in either an open Synthesized or Implemented design.
		/// Note: You cannot remove pins from library macros, or macro-primitives.
		/// To remove a bus pin, you must specify the primary pin name, and not specify a bus index. This
		/// ensures that the entire bus pin is removed, and not just a portion of the bits associated with the
		/// bus. You can resize a bus pin, eliminating bits, using the resize_pin_bus command.
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*
		/// command.
		/// Note: Netlist editing is not allowed on the elaborated RTL design.
		///
		/// The following example removes the specified pin from the cpuEngine in the in-memory netlist of
		/// the current design:
		/// remove_pin cpuEngine/inPin
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1243
		/// </summary>
		/// <param name="pins">(Required) List of pins to remove</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand remove_pin(string pins, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_pin [-quiet] [-verbose] <pins>...
			return
				new SimpleTCLCommand("remove_pin")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(pins)
			;
		}
		/// <summary>
		/// Remove the given list of top ports from the netlist.
		///
		///
		/// TCL Syntax: remove_port [-quiet] [-verbose] <ports>...
		///
		/// Removes the specified ports or buses.
		/// To remove a bus port, you must specify the primary port name, and not specify a bus index. This
		/// ensures that the entire bus port is removed, and not just a portion of the bits associated with the
		/// bus. You can resize a bus port, eliminating bits, using the resize_port_bus command.
		/// The remove_port command will remove ports that have been added with the create_port
		/// command, but cannot delete ports that are defined in the RTL or netlist design.
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*
		/// command.
		/// Note: Netlist editing is not allowed on the elaborated RTL design.
		///
		/// The following example deletes the specified port:
		/// remove_port PORT0
		/// The following example deletes the two specified ports of a bus:
		/// remove_port BUS[1] BUS[2]
		/// The following example deletes both the N and P sides of a differential pair port:
		/// remove_port D_BUS_P[0]
		/// Note: Deleting either the N or the P side of a differential pair will also delete the other side of the pair.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1245
		/// </summary>
		/// <param name="ports">(Required) Ports and/or bus ports to remove</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand remove_port(string ports, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_port [-quiet] [-verbose] <ports>...
			return
				new SimpleTCLCommand("remove_port")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(ports)
			;
		}
		/// <summary>
		/// Removes wave objects from the current wave configuration
		///
		///
		/// TCL Syntax: remove_wave [-of <args>] [-quiet] [-verbose] <items>...
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1247
		/// </summary>
		/// <param name="items">(Required) wave objects to remove</param>
		/// <param name="of">
		/// (Optional)
		/// the wave configuration, group, or virtual bus to search
		/// Default: the current wave configuration
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand remove_wave(string items, string of = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_wave [-of <args>] [-quiet] [-verbose] <items>...
			return
				new SimpleTCLCommand("remove_wave")
					.OptionalNamedString("of", of)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(items)
			;
		}
		/// <summary>
		/// rename a cell
		///
		///
		/// TCL Syntax: rename_cell -to <arg> [-quiet] [-verbose] <cell>...
		///
		/// Rename a single hierarchical or leaf-level cell in the current synthesized or implemented design.
		/// TIP: You cannot rename cells with DONT_TOUCH property set to TRUE.
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*
		/// command.
		/// Note: Netlist editing is not allowed on the elaborated RTL design.
		/// Changes to the names of cells, nets, pins, and ports, will also affect the design constraints defined
		/// in the in-memory design. Constraints are automatically modified to target the new object name,
		/// however these are not written back to the source XDC file. Saving the modified in-memory
		/// design using write_checkpoint will save both the renamed objects and modified constraints.
		/// This command returns nothing if successful, or an error if it fails.
		///
		/// The following example changes the name of the hierarchical or1200_cpu cell as specified:
		/// rename_cell -to or1200_gpu or1200_cpu
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1248
		/// </summary>
		/// <param name="to">(Required) New name</param>
		/// <param name="cell">(Required) Cell to rename</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand rename_cell(string to, string cell, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: rename_cell -to <arg> [-quiet] [-verbose] <cell>...
			return
				new SimpleTCLCommand("rename_cell")
					.RequiredNamedString("to", to)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(cell)
			;
		}
		/// <summary>
		/// rename a net
		///
		///
		/// TCL Syntax: rename_net -to <arg> [-quiet] [-verbose] <net>...
		///
		/// Rename a net in the current synthesized or implemented design.
		/// The following are limitations with regard to renaming nets:
		/// • You cannot rename nets that have DONT_TOUCH or MARK_DEBUG properties set to TRUE.
		/// • You cannot rename individual bits of a bus net, but you can collectively rename the whole bus.
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*
		/// command.
		/// Note: Netlist editing is not allowed on the elaborated RTL design.
		/// Changes to the names of cells, nets, pins, and ports, will also affect the design constraints defined
		/// in the in-memory design. Constraints are automatically modified to target the new object name,
		/// however these are not written back to the source XDC file. Saving the modified in-memory
		/// design using write_checkpoint will save both the renamed objects and modified constraints.
		/// This command returns nothing if successful, or an error if it fails.
		///
		/// The following example renames the specified bus signal:
		/// rename_net -to dataOut dout
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1250
		/// </summary>
		/// <param name="to">(Required) New name</param>
		/// <param name="net">(Required) Net to rename</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand rename_net(string to, string net, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: rename_net -to <arg> [-quiet] [-verbose] <net>...
			return
				new SimpleTCLCommand("rename_net")
					.RequiredNamedString("to", to)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(net)
			;
		}
		/// <summary>
		/// rename a pin
		///
		///
		/// TCL Syntax: rename_pin -to <arg> [-quiet] [-verbose] <pin>...
		///
		/// Rename the specified pin on a hierarchical cell in the current synthesized or implemented design.
		/// The following are limitations with regard to renaming pins:
		/// • Pins on primitive cells cannot be renamed.
		/// • A pin on a hierarchical cell that has the DONT_TOUCH property can be renamed, but a pin on
		/// an hierarchical cell inside a DON'T_TOUCH cell cannot be renamed.
		/// • You cannot rename individual bits of a bus pin, but you can collectively rename the whole bus.
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*
		/// command.
		/// Note: Netlist editing is not allowed on the elaborated RTL design.
		/// Changes to the names of cells, nets, pins, and ports, will also affect the design constraints defined
		/// in the in-memory design. Constraints are automatically modified to target the new object name,
		/// however these are not written back to the source XDC file. Saving the modified in-memory
		/// design using write_checkpoint will save both the renamed objects and modified constraints.
		/// This command returns nothing if successful, or an error if it fails.
		///
		/// The following example renames the specified pin:
		/// rename_pin -to in1 egressLoop[0].egressFifo/I1
		/// The following example shows the error that is returned when you try to rename a single bit of a
		/// bus, and then renames the whole bus pin:
		/// rename_pin -to din[0] egressLoop[0].egressFifo/buffer_fifo/dataInput[0]
		/// WARNING: [Coretcl 2-1480] rename_pin can not rename bits of a bus, \
		/// use resize_pin_bus instead.
		/// rename_pin -to dataInput egressLoop[0].egressFifo/buffer_fifo/din
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1252
		/// </summary>
		/// <param name="to">(Required) New name</param>
		/// <param name="pin">(Required) Pin to rename</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand rename_pin(string to, string pin, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: rename_pin -to <arg> [-quiet] [-verbose] <pin>...
			return
				new SimpleTCLCommand("rename_pin")
					.RequiredNamedString("to", to)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(pin)
			;
		}
		/// <summary>
		/// rename a port
		///
		///
		/// TCL Syntax: rename_port -to <arg> [-quiet] [-verbose] <port>...
		///
		/// Rename a single port in the current synthesized or implemented design.
		/// TIP: You cannot rename individual bits of a bus port, but you can collectively rename the whole bus.
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*
		/// command.
		/// Note: Netlist editing is not allowed on the elaborated RTL design.
		/// Changes to the names of cells, nets, pins, and ports, will also affect the design constraints defined
		/// in the in-memory design. Constraints are automatically modified to target the new object name,
		/// however these are not written back to the source XDC file. Saving the modified in-memory
		/// design using write_checkpoint will save both the renamed objects and modified constraints.
		/// This command returns nothing if successful, or an error if it fails.
		///
		/// The following example renames the specified bus port:
		/// rename_port -to wbInputData wbInDat
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1255
		/// </summary>
		/// <param name="to">(Required) New name</param>
		/// <param name="port">(Required) Port to rename</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand rename_port(string to, string port, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: rename_port -to <arg> [-quiet] [-verbose] <port>...
			return
				new SimpleTCLCommand("rename_port")
					.RequiredNamedString("to", to)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(port)
			;
		}
		/// <summary>
		/// rename a cell ref
		///
		///
		/// TCL Syntax: rename_ref [-ref <arg>] [-to <arg>] [-prefix_all <arg>] [-quiet] [-verbose]
		///
		/// Rename the reference name of a single non-primitive cell, or apply a reference prefix to all non￾primitive cells in the current synthesized or implemented design.
		/// This command provides a mechanism to change the non-primitive reference names in the current
		/// design so that they do not collide with the reference names in another design. This lets two
		/// modules or designs be synthesized or simulated together, while avoiding any name collisions
		/// between the two designs.
		/// This command returns nothing when renaming the reference a single cell, and returns the
		/// number of cells renamed when used with -prefix_all. If the command fails, an error is
		/// returned.
		///
		/// The following example changes the specified reference name to the value indicated:
		/// rename_ref -ref usbf_top -to MOD1_usbf_top
		/// The following example applies the specified reference name prefix to all non-primitive cells in the
		/// current design:
		/// rename_ref -prefix_all MOD1_
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1257
		/// </summary>
		/// <param name="@ref">(Optional) Cell ref to rename</param>
		/// <param name="to">(Optional) New name</param>
		/// <param name="prefix_all">
		/// (Optional)
		/// Rename all eligible hierarchical cell refs in the current
		/// design. Construct the new name using the given prefix plus
		/// the original name
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand rename_ref(string @ref = null, string to = null, string prefix_all = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: rename_ref [-ref <arg>] [-to <arg>] [-prefix_all <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("rename_ref")
					.OptionalNamedString("ref", @ref)
					.OptionalNamedString("to", to)
					.OptionalNamedString("prefix_all", prefix_all)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Change the order of source files in the active fileset
		///
		///
		/// TCL Syntax: reorder_files [-fileset <arg>] [-before <arg>] [-after <arg>] [-front] [-back] [-auto] [-disable_unused] [-quiet] [-verbose] <files>...
		///
		/// Reorders source files in the specified fileset. Takes the files indicated and places them at the front
		/// of, the back of, or before or after other files within the fileset. This command also has an auto
		/// reorder feature that reorders the files based on the requirements of the current top module in
		/// the design.
		///
		/// The following example takes the specified files and moves them to the front of the source fileset:
		/// reorder_files -front {C:/Data/FPGA/file1.vhdl C:/Data/FPGA/file2.vhdl}
		/// Note: The default source fileset is used in the preceding example since the -fileset argument is not
		/// specified.
		/// The following example sets a new top_module in the design, and then automatically reorders and
		/// disables unused files based on the hierarchy of the new top-module:
		/// set_property top block1 [current_fileset]
		/// reorder_files -auto -disable_unused
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1259
		/// </summary>
		/// <param name="files">(Required) Files to move</param>
		/// <param name="fileset">(Optional) Fileset to reorder</param>
		/// <param name="before">(Optional) Move the listed files before this file</param>
		/// <param name="after">(Optional) Move the listed files after this file</param>
		/// <param name="front">(Optional) Move the listed files to the front (default)</param>
		/// <param name="back">(Optional) Move the listed files to the back</param>
		/// <param name="auto">(Optional) Automatically re-orders the given fileset</param>
		/// <param name="disable_unused">(Optional) Disables all files not associated with the TOP design unit</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand reorder_files(string files, string fileset = null, string before = null, string after = null, bool? front = null, bool? back = null, bool? auto = null, bool? disable_unused = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reorder_files [-fileset <arg>] [-before <arg>] [-after <arg>] [-front] [-back] [-auto] [-disable_unused] [-quiet] [-verbose] <files>...
			return
				new SimpleTCLCommand("reorder_files")
					.OptionalNamedString("fileset", fileset)
					.OptionalNamedString("before", before)
					.OptionalNamedString("after", after)
					.Flag("front", front)
					.Flag("back", back)
					.Flag("auto", auto)
					.Flag("disable_unused", disable_unused)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(files)
			;
		}
		/// <summary>
		/// Replace cell1 with cell2 by disconnecting connections to cell1 and connecting those connections
		/// to cell2.
		///
		///
		/// TCL Syntax: replace_bd_cell [-preserve_name] [-preserve_configuration] [-quiet] [-verbose] [<cell1>] [<cell2>...]
		///
		/// Move the connections currently assigned to one IP integrator cell to another IP integrator cell in
		/// the current design. This is intended to help you quickly replace one cell with another by moving
		/// connections from the source cell to the target cell.
		/// The current, or existing cell, will be relocated from its current position in the block design, and
		/// the new replacing cell will be placed at that location. Connections to the pins and interface pins
		/// on the cell are preserved where possible, and result in a Critical Warning when connections must
		/// be removed.
		/// IMPORTANT! This command is not supported by the UNDO command.
		/// This command returns TCL_OK if successful, or returns TCL_ERROR if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1261
		/// </summary>
		/// <param name="cell1">(Required) Cell with connections that are to be disconnected.</param>
		/// <param name="preserve_name">(Optional) cell2 will rename as cell1's name, cell1 rename as cell1name_old</param>
		/// <param name="preserve_configuration">(Optional) preserve configuration of cell1 on cell2</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="cell2">(Optional) Cell to be connected to connections that were disconnected from cell1.</param>
		/// <returns>TCL_OK, TCL_ERROR if failed.</returns>
		public virtual SimpleTCLCommand replace_bd_cell(string cell1, bool? preserve_name = null, bool? preserve_configuration = null, bool? quiet = null, bool? verbose = null, string cell2 = null)
		{
			// TCL Syntax: replace_bd_cell [-preserve_name] [-preserve_configuration] [-quiet] [-verbose] [<cell1>] [<cell2>...]
			return
				new SimpleTCLCommand("replace_bd_cell")
					.Flag("preserve_name", preserve_name)
					.Flag("preserve_configuration", preserve_configuration)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(cell1)
					.OptionalString(cell2)
			;
		}
		/// <summary>
		/// Report differences between two block designs. Note this TCL command may compare bus￾interface parameters from IP .xit files that are not reported in the stand-alone diffbd executable.
		///
		///
		/// TCL Syntax: report_bd_diffs [-format <arg>] [-file <arg>] [-open_html] [-brief] [-strict] [-fast] [-return_string] [-depth <arg>] [-crossprobe] [-repository <arg>] [-take_snapshot] [-diff_snapshot] [-quiet] [-verbose] <design1> <design2>
		///
		/// Analyze and report the difference between two block design files (.bd).
		/// TIP: There is also a standalone version of this command, diffbd, that can be run from the command line. You
		/// can find out more information about this command by typing diffbd -h from the command line. Refer to the
		/// Vivado Design Suite User Guide: Designing IP Subsystems using IP Integrator (UG994) for more informaiton.
		/// This command performs a non-graphical comparison of two block designs to let you compare
		/// revisions of a block design from within revision control systems. Block designs must be specified
		/// as BD objects, as returned by current_bd_design, or get_bd_designs commands. The
		/// design objects can have the same name, but be returned from different .bd files. An error will be
		/// returned if the BD objects refer to the same design.
		/// The differences reported include additions, or changes to the IP in use in the block diagram,
		/// changes to design properties or parameters, changes to the design hierarchy, changes to
		/// connectivity, and changes memory addressing.
		/// This command returns the difference report for the two block designs specified, or returns an
		/// error if it fails.
		///
		/// The following example compares the two specified block designs, one from a file path, the
		/// second from the current open block design, and creates and opens an HTML report format with
		/// the specified depth:
		/// report_bd_diffs C:/Data/Base_Zynq_MPSoC.bd [current_bd_design] \
		/// -file C:/Data/diffs5.htm -open_html -depth 5
		/// The following example takes a snapshot of the current open block design:
		/// report_bd_diffs -take_snapshot
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1264
		/// </summary>
		/// <param name="design1">(Required) Name or file path of first block design to compare</param>
		/// <param name="design2">(Required) Name or file path of second block design to compare</param>
		/// <param name="format">(Optional) Format: html or text Default: text</param>
		/// <param name="file">(Optional) Optional output file name. *.htm* implies HTML format</param>
		/// <param name="open_html">(Optional) Open HTML report in a browser. Sets format to HTML</param>
		/// <param name="brief">(Optional) Output only whether files differ. Don't write report</param>
		/// <param name="strict">(Optional) Non-functional changes are treated as functional changes</param>
		/// <param name="fast">
		/// (Optional)
		/// Read BD JSON directly instead of creating in-memory BDs
		/// when possible. Will not compare Bus-Interface parameters
		/// from .XIT files (same as stand-alone diffbd)
		/// </param>
		/// <param name="return_string">(Optional) (Text only) Return the report as a string</param>
		/// <param name="depth">
		/// (Optional)
		/// HTML Display Depth for equal items. Used to limit HTML file
		/// size. Does not affect not-equal items. Implies HTML format.
		/// Default: 4
		/// </param>
		/// <param name="crossprobe">
		/// (Optional)
		/// Enable links on HTML report to select Vivado objects.
		/// Implies open_html
		/// </param>
		/// <param name="repository">(Optional) User repository for designs on disk</param>
		/// <param name="take_snapshot">(Optional) Take a snapshot of the current block design</param>
		/// <param name="diff_snapshot">(Optional) Compare the current block design against a snapshot</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>0 if no functional differences, >0 if different, -1 on error</returns>
		public virtual SimpleTCLCommand report_bd_diffs(string design1, string design2, string format = null, string file = null, bool? open_html = null, bool? brief = null, bool? strict = null, bool? fast = null, bool? return_string = null, string depth = null, bool? crossprobe = null, string repository = null, bool? take_snapshot = null, bool? diff_snapshot = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_bd_diffs [-format <arg>] [-file <arg>] [-open_html] [-brief] [-strict] [-fast] [-return_string] [-depth <arg>] [-crossprobe] [-repository <arg>] [-take_snapshot] [-diff_snapshot] [-quiet] [-verbose] <design1> <design2>
			return
				new SimpleTCLCommand("report_bd_diffs")
					.OptionalNamedString("format", format)
					.OptionalNamedString("file", file)
					.Flag("open_html", open_html)
					.Flag("brief", brief)
					.Flag("strict", strict)
					.Flag("fast", fast)
					.Flag("return_string", return_string)
					.OptionalNamedString("depth", depth)
					.Flag("crossprobe", crossprobe)
					.OptionalNamedString("repository", repository)
					.Flag("take_snapshot", take_snapshot)
					.Flag("diff_snapshot", diff_snapshot)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(design1)
					.RequiredString(design2)
			;
		}
		/// <summary>
		/// Print details of the given breakpoint objects
		///
		///
		/// TCL Syntax: report_bps [-quiet] [-verbose] [<BreakPointObjs>...]
		///
		/// Report a specific breakpoint object, or report all breakpoints in the current simulation. You must
		/// have an open simulation for this command to return anything.
		/// A breakpoint is a user-determined stopping point in the source code used for debugging the
		/// design. When simulating a design with breakpoints, simulation of the design stops at each
		/// breakpoint to let you examine values and verify the design behavior.
		/// This command returns the filename and line number of the specified breakpoints, or of all
		/// breakpoints in the current simulation, or returns an error if the command fails.
		///
		/// The following example reports all breakpoints in the current simulation:
		/// report_bps
		/// This example reports the specified breakpoints in the current simulation:
		/// report_bps bp1 bp2 bp5
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1268
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="BreakPointObjs">(Optional) List of breakpoint objects to report</param>
		/// <returns>Print the breakpoints id, file_name and line_number to the console in textual format</returns>
		public virtual SimpleTCLCommand report_bps(bool? quiet = null, bool? verbose = null, string BreakPointObjs = null)
		{
			// TCL Syntax: report_bps [-quiet] [-verbose] [<BreakPointObjs>...]
			return
				new SimpleTCLCommand("report_bps")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(BreakPointObjs)
			;
		}
		/// <summary>
		/// Report timing paths
		///
		///
		/// TCL Syntax: report_bus_skew [-delay_type <arg>] [-setup] [-hold] [-no_detailed_paths] [-max_paths <arg>] [-nworst <arg>] [-unique_pins] [-path_type <arg>] [-sort_by_slack] [-input_pins] [-no_header] [-significant_digits <arg>] [-file <arg>] [-append] [-return_string] [-warn_on_violation] [-rpx <arg>] [-cells <args>] [-quiet] [-verbose]
		///
		/// Report the calculated bus skew among the signals constrained by set_bus_skew.
		/// The bus skew requirement applies to both the slow and fast corners. The Vivado tool determines
		/// the earliest and the latest arrival among all the signals of the bus and calculates the bus skew for
		/// both the Slow and Fast process corner, and reports the worst case skew. Each signal of the bus is
		/// reported relative to a reference signal from the same bus. Note that the reference signal can be
		/// different for each signal of the bus, which ever results in the worst bus skew for that signal.
		/// The bus skew report can be written to the Tcl console or command shell, assigned to a return
		/// string, or saved to a file.
		/// This command returns the bus skew report as specified, or returns an error if it fails.
		///
		/// The following example reports the bus skew for the 32 worst signals of each bus skew
		/// constraints in the design, reporting 1 path per bit of the bus with the full timing path, including
		/// input pins, with timing values:
		/// report_bus_skew -max 32 -nworst 1 -path_type full -input_pins
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1270
		/// </summary>
		/// <param name="delay_type">(Optional) Type of path delay: Values: max, min, min_max Default: min_max</param>
		/// <param name="setup">
		/// (Optional)
		/// Report max delay endpoint timing paths (equivalent to -
		/// delay_type max)
		/// </param>
		/// <param name="hold">
		/// (Optional)
		/// Report min delay endpoint timing paths (equivalent to -
		/// delay_type min)
		/// </param>
		/// <param name="no_detailed_paths">(Optional) Only report top level summary table</param>
		/// <param name="max_paths">
		/// (Optional)
		/// Maximum number of paths to output per bus skew
		/// constraint: Value >=1 Default: 1
		/// </param>
		/// <param name="nworst">
		/// (Optional)
		/// List up to N worst paths per endpoint per constraint: Value
		/// >=1 Default: 1
		/// </param>
		/// <param name="unique_pins">
		/// (Optional)
		/// For each unique set of pins, show at most 1 path per bus
		/// skew constraint
		/// </param>
		/// <param name="path_type">
		/// (Optional)
		/// Format for path report: Values: short, full, full_clock,
		/// full_clock_expanded Default: full_clock_expanded
		/// </param>
		/// <param name="sort_by_slack">(Optional) Sort summary and per-constraint sections by slack</param>
		/// <param name="input_pins">(Optional) Show input pins in path</param>
		/// <param name="no_header">(Optional) Do not generate a report header</param>
		/// <param name="significant_digits">(Optional) Number of digits to display: Range: 0 to 3 Default: 3</param>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="return_string">(Optional) Return report as string</param>
		/// <param name="warn_on_violation">(Optional) Issue a critical warning when the report contains a timing violation</param>
		/// <param name="rpx">(Optional) Filename to output interactive results to.</param>
		/// <param name="cells">(Optional) run report_bus_skew on the specified hierarchical cell(s)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_bus_skew(string delay_type = null, bool? setup = null, bool? hold = null, bool? no_detailed_paths = null, string max_paths = null, string nworst = null, bool? unique_pins = null, string path_type = null, bool? sort_by_slack = null, bool? input_pins = null, bool? no_header = null, string significant_digits = null, string file = null, bool? append = null, bool? return_string = null, bool? warn_on_violation = null, string rpx = null, string cells = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_bus_skew [-delay_type <arg>] [-setup] [-hold] [-no_detailed_paths] [-max_paths <arg>] [-nworst <arg>] [-unique_pins] [-path_type <arg>] [-sort_by_slack] [-input_pins] [-no_header] [-significant_digits <arg>] [-file <arg>] [-append] [-return_string] [-warn_on_violation] [-rpx <arg>] [-cells <args>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_bus_skew")
					.OptionalNamedString("delay_type", delay_type)
					.Flag("setup", setup)
					.Flag("hold", hold)
					.Flag("no_detailed_paths", no_detailed_paths)
					.OptionalNamedString("max_paths", max_paths)
					.OptionalNamedString("nworst", nworst)
					.Flag("unique_pins", unique_pins)
					.OptionalNamedString("path_type", path_type)
					.Flag("sort_by_slack", sort_by_slack)
					.Flag("input_pins", input_pins)
					.Flag("no_header", no_header)
					.OptionalNamedString("significant_digits", significant_digits)
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.Flag("return_string", return_string)
					.Flag("warn_on_violation", warn_on_violation)
					.OptionalNamedString("rpx", rpx)
					.OptionalNamedString("cells", cells)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Report carry chains
		///
		///
		/// TCL Syntax: report_carry_chains [-file <arg>] [-append] [-return_string] [-cell <args>] [-max_chains <arg>] [-quiet] [-verbose]
		///
		/// Report the details of the carry chains used by the current open design. The report includes the
		/// average depth of all carry chains, as well as the specific depth of each carry chain reported.
		/// By default, the longest carry chain is reported, but the number of chains reported can be
		/// specified.
		/// The command returns the carry chain report.
		///
		/// The following example returns the 10 longest carry chains in the design:
		/// report_carry_chains -max_chains 10
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1274
		/// </summary>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="append">(Optional) Append to existing file</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="cell">(Optional) Report Carry Chains only for given cell</param>
		/// <param name="max_chains">(Optional) Number of chains for which report is to be generated Default: 1</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Report</returns>
		public virtual SimpleTCLCommand report_carry_chains(string file = null, bool? append = null, bool? return_string = null, string cell = null, string max_chains = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_carry_chains [-file <arg>] [-append] [-return_string] [-cell <args>] [-max_chains <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_carry_chains")
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.Flag("return_string", return_string)
					.OptionalNamedString("cell", cell)
					.OptionalNamedString("max_chains", max_chains)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Report the clock domain crossing (CDC) paths in the current design.
		///
		///
		/// TCL Syntax: report_cdc [-from <args>] [-to <args>] [-cells <args>] [-details] [-summary] [-all_checks_per_endpoint] [-severity <arg>] [-no_header] [-show_waiver] [-no_waiver] [-waived] [-file <arg>] [-append] [-return_string] [-name <arg>] [-quiet] [-verbose]
		///
		/// This report shows in detail the clock domain crossing (CDC) paths in the current synthesized or
		/// implemented design. The command analyzes paths between asynchronous clocks, or clocks with
		/// no common period, as well as synchronous paths ignored by the user due to false path or max
		/// delay datapath_only exceptions.
		/// By default the report_cdc command reports domain crossing between all clocks in the design.
		/// However, you can limit the clocks of interest using the -from and -to options to specify the
		/// clock domains of interest.
		/// The report_cdc command only reports on paths where both source and destination clocks are
		/// defined. You should run the check_timing command prior to report_cdc to ensure that
		/// there are no unconstrained clocks in the design. I/O paths are only covered by report_cdc
		/// when input or output delay constraints have been specified on the I/O ports.
		/// The severity of the path report could be Critical, Warning or Info depending on the CDC
		/// topology identified. An unknown synchronization topology is Critical and needs to be reviewed.
		/// A double register synchronizer with missing ASYNC_REG property is a Warning. Clock Enable,
		/// MUX, and MUX Hold CDC structures are categorized as Warnings because you should check to
		/// ensure that the structure is safe. Other CDC paths are of severity Info.
		/// The report_cdc command returns the following information:
		/// • Severity
		/// • Source Clock
		/// • Destination Clock
		/// • CDC Type
		/// • Exceptions
		/// • Endpoints
		/// • Safe
		/// • Unknown
		/// • No ASYNC_REG property
		/// IMPORTANT! You cannot use the set_msg_config command to configure the severity of messages
		/// returned by the report_cdc command. This command does not generate messages through the message
		/// manager.
		///
		/// The following example reports the clock domain crossings in the current design, including any
		/// waived paths, using a verbose report form, and saving the results to a file:
		/// report_cdc -details -show_waiver -file C:/Data/cdc_report.txt
		/// The following example reports the clock domain crossings from a clock specified by name, to
		/// another specified as a clock object:
		/// report_cdc -from clk_pin_p -to [get_clocks clk_rx_clk_core]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1276
		/// </summary>
		/// <param name="from">(Optional) From clocks</param>
		/// <param name="to">(Optional) To clocks</param>
		/// <param name="cells">(Optional) run report_cdc on the cells</param>
		/// <param name="details">(Optional) report the detail of the CDC timing paths not safely timed</param>
		/// <param name="summary">(Optional) report a summary by clocks of the CDC</param>
		/// <param name="all_checks_per_endpoint">(Optional) report all checks per endpoint</param>
		/// <param name="severity">(Optional) report only the severity specified (Info, Warning or Critical)</param>
		/// <param name="no_header">(Optional) Do not generate a report header</param>
		/// <param name="show_waiver">(Optional) Show the waived paths</param>
		/// <param name="no_waiver">(Optional) Ignore the waiver</param>
		/// <param name="waived">(Optional) Show only the waived paths</param>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_cdc(string from = null, string to = null, string cells = null, bool? details = null, bool? summary = null, bool? all_checks_per_endpoint = null, string severity = null, bool? no_header = null, bool? show_waiver = null, bool? no_waiver = null, bool? waived = null, string file = null, bool? append = null, bool? return_string = null, string name = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_cdc [-from <args>] [-to <args>] [-cells <args>] [-details] [-summary] [-all_checks_per_endpoint] [-severity <arg>] [-no_header] [-show_waiver] [-no_waiver] [-waived] [-file <arg>] [-append] [-return_string] [-name <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_cdc")
					.OptionalNamedString("from", from)
					.OptionalNamedString("to", to)
					.OptionalNamedString("cells", cells)
					.Flag("details", details)
					.Flag("summary", summary)
					.Flag("all_checks_per_endpoint", all_checks_per_endpoint)
					.OptionalNamedString("severity", severity)
					.Flag("no_header", no_header)
					.Flag("show_waiver", show_waiver)
					.Flag("no_waiver", no_waiver)
					.Flag("waived", waived)
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.Flag("return_string", return_string)
					.OptionalNamedString("name", name)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Report on clock timing paths and unclocked registers
		///
		///
		/// TCL Syntax: report_clock_interaction [-delay_type <arg>] [-setup] [-hold] [-significant_digits <arg>] [-no_header] [-file <arg>] [-append] [-name <arg>] [-return_string] [-cells <args>] [-quiet] [-verbose]
		///
		/// Reports clock interactions and signals that cross clock domains to identify potential problems
		/// such a metastability, or data loss, or incoherency, where some visibility into the paths that cross
		/// clock domains is beneficial. This command requires an open synthesized or implemented design.
		/// Note: By default the report is written to the Tcl console or STD output. However, the results can also be
		/// written to a file or returned as a string if desired.
		///
		/// The following example sets the model for interconnect delay, selects a device speed grade, and
		/// then runs report_clock_interaction:
		/// set_delay_model -interconnect none
		/// set_speed_grade -3
		/// report_clock_interaction -delay_type min_max \
		/// -significant_digits 3 -name "results_1"
		/// The following example returns the clock interactions, writing the report to the GUI, to the
		/// specified file, and returns a string which is assigned to the specified variable:
		/// set clk_int [report_clock_interaction -file clk_int.txt -name clk_int1 \
		/// -return_string]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1280
		/// </summary>
		/// <param name="delay_type">(Optional) Type of path delay: Values: max, min, min_max Default: max</param>
		/// <param name="setup">(Optional) Consider max delay timing paths (equivalent to -delay_type max)</param>
		/// <param name="hold">(Optional) Consider min delay timing paths (equivalent to -delay_type min)</param>
		/// <param name="significant_digits">(Optional) Number of digits to display: Range: 0 to 3 Default: 2</param>
		/// <param name="no_header">(Optional) do not generate a report header</param>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="return_string">(Optional) Return report as string</param>
		/// <param name="cells">(Optional) run report_clock_interaction on the specified cell(s)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_clock_interaction(string delay_type = null, bool? setup = null, bool? hold = null, string significant_digits = null, bool? no_header = null, string file = null, bool? append = null, string name = null, bool? return_string = null, string cells = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_clock_interaction [-delay_type <arg>] [-setup] [-hold] [-significant_digits <arg>] [-no_header] [-file <arg>] [-append] [-name <arg>] [-return_string] [-cells <args>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_clock_interaction")
					.OptionalNamedString("delay_type", delay_type)
					.Flag("setup", setup)
					.Flag("hold", hold)
					.OptionalNamedString("significant_digits", significant_digits)
					.Flag("no_header", no_header)
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.OptionalNamedString("name", name)
					.Flag("return_string", return_string)
					.OptionalNamedString("cells", cells)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Report clock networks
		///
		///
		/// TCL Syntax: report_clock_networks [-file <arg>] [-append] [-name <arg>] [-return_string] [-endpoints_only] [-levels <arg>] [-expand_buckets] [-suppress_endpoints <arg>] [-clocks <args>] [-unconstrained_roots <args>] [-quiet] [-verbose]
		///
		/// Reports the network fanout of each clock net in the open synthesized or implemented design.
		/// The graphical form of the report, returned when the -name argument is specified, provides a
		/// hierarchical tree view of the clock network.
		/// The default report simply specifies the clock net names and the instance pins that are the
		/// startpoint of the clock.
		/// The report is returned to the standard output unless the -file, -return_string, or -name
		/// arguments are specified.
		///
		/// The following example reports the clock network names and startpoints to the specified file:
		/// report_clock_networks -file C:/Data/ClkNets.txt
		/// The following example reports the endpoints of the specified clock:
		/// report_clock_networks -endpoints_only -clocks wbClk
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1283
		/// </summary>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="endpoints_only">
		/// (Optional)
		/// dump clock network endpoints only; Not to be used in
		/// conjunction with -levels option
		/// </param>
		/// <param name="levels">
		/// (Optional)
		/// expands clock network upto n levels of instances, Value: n >
		/// 0; Not to be used in conjunction with -endpoints_only option
		/// Default: 0
		/// </param>
		/// <param name="expand_buckets">
		/// (Optional)
		/// expands bucketed endpoints and displays pins; By default,
		/// endpoint pins are bucketed by celltype; This option only
		/// works in conjunction with -levels option or -endpoints_only
		/// option
		/// </param>
		/// <param name="suppress_endpoints">
		/// (Optional)
		/// suppress paths to clock or nonclock endpoint pins; Values:
		/// clock, nonclock
		/// </param>
		/// <param name="clocks">
		/// (Optional)
		/// List of clocks for clock network dump; if not specified, all
		/// clock networks are dumped
		/// </param>
		/// <param name="unconstrained_roots">
		/// (Optional)
		/// List of unconstrained root pins/ports for clock network
		/// dump; if not specified, all unconstrained clock roots are
		/// dumped
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_clock_networks(string file = null, bool? append = null, string name = null, bool? return_string = null, bool? endpoints_only = null, string levels = null, bool? expand_buckets = null, string suppress_endpoints = null, string clocks = null, string unconstrained_roots = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_clock_networks [-file <arg>] [-append] [-name <arg>] [-return_string] [-endpoints_only] [-levels <arg>] [-expand_buckets] [-suppress_endpoints <arg>] [-clocks <args>] [-unconstrained_roots <args>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_clock_networks")
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.OptionalNamedString("name", name)
					.Flag("return_string", return_string)
					.Flag("endpoints_only", endpoints_only)
					.OptionalNamedString("levels", levels)
					.Flag("expand_buckets", expand_buckets)
					.OptionalNamedString("suppress_endpoints", suppress_endpoints)
					.OptionalNamedString("clocks", clocks)
					.OptionalNamedString("unconstrained_roots", unconstrained_roots)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Report information about clock nets in design
		///
		///
		/// TCL Syntax: report_clock_utilization [-file <arg>] [-append] [-write_xdc <arg>] [-cells <args>] [-clock_roots_only] [-return_string] [-name <arg>] [-quiet] [-verbose]
		///
		/// Returns information related to clock nets in the design and clock resource usage on the target
		/// device.
		/// The generated clock utilization report can generate placement constraints for the currently
		/// placed clock resources. You can use these constraints to preserve the placement of clock
		/// resources for future iterations of the design, by using the -write_xdc option.
		/// IMPORTANT! For Ultrascale devices, if the intent is to recreate the current clock placement then use the
		/// BUFGCE LOC properties from the written XDC file. However, if the intent is to use the constraints as a starting
		/// point for the clocking architecture, while allowing the Vivado Design Suite some flexibility in placing clock
		/// resources, use the equivalent CLOCK_REGION properties instead of the BUFGCE LOC properties.
		/// By default the report is written to the Tcl console or STD output. However, the results can also
		/// be written to a file or returned as a string if desired.
		///
		/// The following example returns information about the clock nets in the design and the clock
		/// resources utilized on the target device, and writes it to the specified file:
		/// report_clock_utilization -file C:/Data/FPGA_Design/clock_util.txt
		/// The following example reports the clock nets and clock resource utilization to the standard
		/// output, but writes the XDC location constraints to the specified file:
		/// report_clock_utilization -write_xdc clock_util_xdc.txt
		/// Note: Because the path is not specified as part of the XDC file name, the file will be created in the current
		/// working directory, or the directory from which the tool was launched.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1286
		/// </summary>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="append">(Optional) Append to existing file</param>
		/// <param name="write_xdc">(Optional) file to output clock constraint. File name must be given.</param>
		/// <param name="cells">(Optional) Cells/bel_instances for which to report clock utilization</param>
		/// <param name="clock_roots_only">(Optional) Report only the Clock Root Assignments</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Report</returns>
		public virtual SimpleTCLCommand report_clock_utilization(string file = null, bool? append = null, string write_xdc = null, string cells = null, bool? clock_roots_only = null, bool? return_string = null, string name = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_clock_utilization [-file <arg>] [-append] [-write_xdc <arg>] [-cells <args>] [-clock_roots_only] [-return_string] [-name <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_clock_utilization")
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.OptionalNamedString("write_xdc", write_xdc)
					.OptionalNamedString("cells", cells)
					.Flag("clock_roots_only", clock_roots_only)
					.Flag("return_string", return_string)
					.OptionalNamedString("name", name)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Report clocks
		///
		///
		/// TCL Syntax: report_clocks [-file <arg>] [-append] [-return_string] [-quiet] [-verbose] [<clocks>]
		///
		/// Returns a table showing all the clocks in a design, including propagated clocks, generated and
		/// auto-generated clocks, virtual clocks, and inverted clocks in the current synthesized or
		/// implemented design. More detailed information about each clock net can be obtained with the
		/// report_clock_utilization command.
		/// Note: By default the report is written to the Tcl console or STD output. However, the results can also be
		/// written to a file or returned as a string if desired.
		///
		/// The following example returns the name, period, waveform, and sources of the clocks in the
		/// current design:
		/// report_clocks -file C:/Data/FPGA_Design/clock_out.txt
		/// The following example reports the clocks in the design with "Clock" in the name:
		/// report_clocks *Clock*
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1289
		/// </summary>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="clocks">(Optional) List of clocks Default: *</param>
		public virtual SimpleTCLCommand report_clocks(string file = null, bool? append = null, bool? return_string = null, bool? quiet = null, bool? verbose = null, string clocks = null)
		{
			// TCL Syntax: report_clocks [-file <arg>] [-append] [-return_string] [-quiet] [-verbose] [<clocks>]
			return
				new SimpleTCLCommand("report_clocks")
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.Flag("return_string", return_string)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(clocks)
			;
		}
		/// <summary>
		/// Report the compile order by analyzing files and constructing a hierarchy.
		///
		///
		/// TCL Syntax: report_compile_order [-fileset <arg>] [-missing_instances] [-constraints] [-sources] [-used_in <arg>] [-file <arg>] [-append] [-of_objects <args>] [-quiet] [-verbose]
		///
		/// Report the compilation order of files in the various active filesets: constraints, design sources,
		/// and simulation sources.
		/// This command returns the order of file processing for synthesis, implementation, and simulation.
		/// The report can be limited by specifying the fileset of interest with -fileset, or using the -
		/// constraints option or -sources option.
		/// The -used_in option lets you report the processing order of files used in Synthesis, Simulation, or
		/// one of the implementation steps, according to the value of the USED_IN property.
		/// By default the report is returned to the Tcl console, or standard output, but it can also be written
		/// to a file.
		///
		/// The following example reports the compilation order of the active filesets in the current design:
		/// report_compile_order
		/// The following returns a list of cells with missing source files in the current design, and appends
		/// the report to the specified file:
		/// report_compile_order -missing_instances -file C:/Data/report1.txt -append
		/// The following command lists the compile order of the files in the active constraint set:
		/// report_compile_order -constraints
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1291
		/// </summary>
		/// <param name="fileset">(Optional) FileSet to parse to determine compile order</param>
		/// <param name="missing_instances">(Optional) Report missing instances in the design hierarchy</param>
		/// <param name="constraints">(Optional) Report the constraint compile order</param>
		/// <param name="sources">(Optional) Report the source compile order</param>
		/// <param name="used_in">(Optional) Specify the used in filter.</param>
		/// <param name="file">(Optional) Filename to output results to.</param>
		/// <param name="append">(Optional) Append output to existing file</param>
		/// <param name="of_objects">(Optional) Get 'file' objects of these types: 'file fileset ip reconfig_module'.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_compile_order(string fileset = null, bool? missing_instances = null, bool? constraints = null, bool? sources = null, string used_in = null, string file = null, bool? append = null, string of_objects = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_compile_order [-fileset <arg>] [-missing_instances] [-constraints] [-sources] [-used_in <arg>] [-file <arg>] [-append] [-of_objects <args>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_compile_order")
					.OptionalNamedString("fileset", fileset)
					.Flag("missing_instances", missing_instances)
					.Flag("constraints", constraints)
					.Flag("sources", sources)
					.OptionalNamedString("used_in", used_in)
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Print details of the given condition objects
		///
		///
		/// TCL Syntax: report_conditions [-quiet] [-verbose] [<ConditionObjs>...]
		///
		/// Report a specific simulation condition, or report all conditions in the current simulation. You must
		/// have an open simulation for this command to return anything.
		/// Conditions can be defined prior to starting the simulation. When a condition is added, the
		/// simulator evaluates the condition expression anytime a signal change is detected. When a
		/// specified condition expression becomes TRUE, the condition commands are run.
		/// This command returns the condition identifier, expression, commands, and names of conditions,
		/// or returns an error if the command fails.
		///
		/// The following example reports conditions in the current simulation. The condition identifier,
		/// expression, commands, and names are reported:
		/// report_conditions
		/// #2: condition2
		/// Expression: {/testbench/reset == 0 }
		/// Command: {
		/// puts "Condition Reset was encountered at [current_time]. \
		/// Stopping simulation."
		/// stop }
		/// Name: resetLow
		/// #3: condition3
		/// Expression: {/testbench/leds_n == X000 }
		/// Command: {
		/// puts "Condition LED Unknown was encountered at [current_time]. \
		/// Stopping simulation."
		/// stop }
		/// Name: ledUnknown
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1294
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="ConditionObjs">(Optional) ConditionObjs, id's or names</param>
		/// <returns>Prints name, id, condition_expression and commands of each condition object on the console</returns>
		public virtual SimpleTCLCommand report_conditions(bool? quiet = null, bool? verbose = null, string ConditionObjs = null)
		{
			// TCL Syntax: report_conditions [-quiet] [-verbose] [<ConditionObjs>...]
			return
				new SimpleTCLCommand("report_conditions")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(ConditionObjs)
			;
		}
		/// <summary>
		/// Report Implementation flow Config param
		///
		///
		/// TCL Syntax: report_config_implementation [-file <arg>] [-force] [-append] [-return_string] [-quiet] [-verbose]
		///
		/// Report the user-definable implementation flow configuration parameters for the implementation
		/// processes. These are parameters that can be modified using the config_implementation
		/// command.
		/// This command returns the selected report or the name of the output file, or returns an error if it
		/// fails.
		///
		/// This example reports the user-configurable implementation parameters to the Tcl console:
		/// report_config_implementation
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1296
		/// </summary>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. Send output to console if -file
		/// is not used.
		/// </param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="append">(Optional) Append to existing file</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Report</returns>
		public virtual SimpleTCLCommand report_config_implementation(string file = null, bool? force = null, bool? append = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_config_implementation [-file <arg>] [-force] [-append] [-return_string] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_config_implementation")
					.OptionalNamedString("file", file)
					.Flag("force", force)
					.Flag("append", append)
					.Flag("return_string", return_string)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Report settings affecting timing analysis
		///
		///
		/// TCL Syntax: report_config_timing [-file <arg>] [-append] [-name <arg>] [-return_string] [-all] [-no_header] [-rpx <arg>] [-quiet] [-verbose]
		///
		/// Report the configuration of timing constraints of the current design.
		/// By default the report is abbreviated, containing only a few key timing constraints. Use the -all
		/// argument to return all timing related configuration.
		///
		/// The following example reports the current timing configuration, returns the information as a
		/// string, and sets that string into the specified Tcl variable:
		/// set timeConfig [report_config_timing -all -no_header -return_string]
		/// puts $timeConfig
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1298
		/// </summary>
		/// <param name="file">(Optional) Output the results to file</param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="all">
		/// (Optional)
		/// report all configuration settings (by default, only the
		/// typically important settings are reported
		/// </param>
		/// <param name="no_header">(Optional) do not generate a report header</param>
		/// <param name="rpx">(Optional) Filename to output interactive results to.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_config_timing(string file = null, bool? append = null, string name = null, bool? return_string = null, bool? all = null, bool? no_header = null, string rpx = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_config_timing [-file <arg>] [-append] [-name <arg>] [-return_string] [-all] [-no_header] [-rpx <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_config_timing")
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.OptionalNamedString("name", name)
					.Flag("return_string", return_string)
					.Flag("all", all)
					.Flag("no_header", no_header)
					.OptionalNamedString("rpx", rpx)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Report the unique control sets in design
		///
		///
		/// TCL Syntax: report_control_sets [-file <arg>] [-append] [-hierarchical] [-hierarchical_depth <arg>] [-sort_by <args>] [-cells <args>] [-return_string] [-quiet] [-verbose]
		///
		/// Report the control sets of the current design.
		/// Control sets are the list of control signals (Clock, CE, SR) for SLICE registers and LUTs. Registers
		/// must belong to the same control set in order to be packed into the same device resource.
		/// Registers without a control signal cannot be packed into devices with registers having control
		/// signals. A high number of control sets can cause difficulty fitting the device and can cause routing
		/// congestion and timing issues.
		/// By default the report_control_sets command returns an abbreviated report indicating only
		/// the number of unique control sets. However, the -verbose arguments returns a detailed report
		/// of all control sets, for either the whole design or for the specified cells.
		///
		/// The following example reports the control sets of the current design, sorted by the clk and clkEn
		/// signals:
		/// report_control_sets -verbose -sort_by {clk clkEn}
		/// The following example reports the control sets of the specified cells, sorted by clk and set:
		/// report_control_sets -verbose -sort_by {clk set} -cells [get_cells usb*]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1301
		/// </summary>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="append">(Optional) Append to existing file</param>
		/// <param name="hierarchical">(Optional) Generates text-based hierarchical report.</param>
		/// <param name="hierarchical_depth">(Optional) Specifies the depth level for textual hierarchical report Default: 0</param>
		/// <param name="sort_by">
		/// (Optional)
		/// Sort criterion: can be used only when -verbose is used.
		/// Options are clk, clkEn, set. Ex: report_control_sets -verbose -
		/// sort_by {clk clkEn}
		/// </param>
		/// <param name="cells">(Optional) Cells/bel_instances for which to report control sets</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Report</returns>
		public virtual SimpleTCLCommand report_control_sets(string file = null, bool? append = null, bool? hierarchical = null, string hierarchical_depth = null, string sort_by = null, string cells = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_control_sets [-file <arg>] [-append] [-hierarchical] [-hierarchical_depth <arg>] [-sort_by <args>] [-cells <args>] [-return_string] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_control_sets")
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.Flag("hierarchical", hierarchical)
					.OptionalNamedString("hierarchical_depth", hierarchical_depth)
					.OptionalNamedString("sort_by", sort_by)
					.OptionalNamedString("cells", cells)
					.Flag("return_string", return_string)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Report data sheet
		///
		///
		/// TCL Syntax: report_datasheet [-significant_digits <arg>] [-file <arg>] [-append] [-return_string] [-sort_by <arg>] [-name <arg>] [-show_all_corners] [-show_oe_timing] [-group <args>] [-rpx <arg>] [-quiet] [-verbose]
		///
		/// Create a "datasheet" report for the current design. Reports setup and hold times of input I/Os in
		/// relation to clocks, max/min delays from clocks to output pads, skews of input/ output buses.
		/// The datasheet report has the timing characteristics of a design at the package balls/pads,
		/// including the package trace flight times. To disable flight times use the following command:
		/// config_timing_analysis -disable_flight_delays true
		/// The source synchronous output skew can be automatically calculated by the Vivado Design Suite
		/// by using the -group switch for report_datasheet and grouping together all the ports of the
		/// data bus including the sourced clock output port. The sourced clock output port must be first in
		/// the group list. For example:
		/// report_datasheet -file output_filename -group [get_ports \
		/// {clock_port data_bit[0] data_bit[1] data_bit[2]}]
		///
		/// The following example returns the datasheet sorted by ports, for all process corners:
		/// report_datasheet -sort_by port -show_all_corners
		/// The following example reports the datasheet with the skew calculation for two groups of ports,
		/// with the first port of each group providing the reference for the skew calculation for that group.
		/// In this example, CLK0OUT is the forwarded clock for DATA0-4 and CLK1OUT is the forwarded
		/// clock for DATA4-7:
		/// report_datasheet -file ds.txt -group [get_ports \
		/// {CLK0OUT DATA0 DATA1 DATA2 DATA3}] \
		/// -group [get_ports {CLK1OUT DATA4 DATA5 DATA6 DATA7}]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1304
		/// </summary>
		/// <param name="significant_digits">(Optional) Number of digits to display: Range: 0 to 3 Default: 3</param>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="sort_by">(Optional) Sorting order: Values: clock, port Default: clock</param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="show_all_corners">(Optional) provide all corners</param>
		/// <param name="show_oe_timing">(Optional) show output enable (tristate) timing</param>
		/// <param name="group">(Optional) List of output ports for skew calculation</param>
		/// <param name="rpx">(Optional) Filename to output interactive results to.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_datasheet(string significant_digits = null, string file = null, bool? append = null, bool? return_string = null, string sort_by = null, string name = null, bool? show_all_corners = null, bool? show_oe_timing = null, string group = null, string rpx = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_datasheet [-significant_digits <arg>] [-file <arg>] [-append] [-return_string] [-sort_by <arg>] [-name <arg>] [-show_all_corners] [-show_oe_timing] [-group <args>] [-rpx <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_datasheet")
					.OptionalNamedString("significant_digits", significant_digits)
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.Flag("return_string", return_string)
					.OptionalNamedString("sort_by", sort_by)
					.OptionalNamedString("name", name)
					.Flag("show_all_corners", show_all_corners)
					.Flag("show_oe_timing", show_oe_timing)
					.OptionalNamedString("group", group)
					.OptionalNamedString("rpx", rpx)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Report details on debug cores
		///
		///
		/// TCL Syntax: report_debug_core [-file <arg>] [-append] [-return_string] [-full_path] [-quiet] [-verbose]
		///
		/// Writes a report of the various Vivado device tool debug cores in the current project, and the
		/// parameters of those cores. Debug cores can be added to a project using the
		/// create_debug_core command.
		/// Note: By default the report is written to the Tcl console or STD output. However, the results can also be
		/// written to a file or returned as a string if desired.
		///
		/// The following example writes the debug core report to the specified file name at the specified
		/// location:
		/// report_debug_core -file C:/Data/FPGA_Design/project_1_cores.txt
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1307
		/// </summary>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="return_string">(Optional) Return report as a string</param>
		/// <param name="full_path">(Optional) Display full hierarchical net path in report</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_debug_core(string file = null, bool? append = null, bool? return_string = null, bool? full_path = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_debug_core [-file <arg>] [-append] [-return_string] [-full_path] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_debug_core")
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.Flag("return_string", return_string)
					.Flag("full_path", full_path)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Report Design Analysis
		///
		///
		/// TCL Syntax: report_design_analysis [-file <arg>] [-append] [-return_string] [-complexity] [-cells <args>] [-bounding_boxes <args>] [-hierarchical_depth <arg>] [-congestion] [-min_congestion_level <arg>] [-timing] [-setup] [-hold] [-show_all] [-full_logical_pin] [-routed_vs_estimated] [-logic_level_distribution] [-logic_level_dist_paths <arg>] [-min_level <arg>] [-max_level <arg>] [-return_timing_paths] [-of_timing_paths <args>] [-max_paths <arg>] [-extend] [-routes] [-end_point_clock <arg>] [-logic_levels <arg>] [-qor_summary] [-name <arg>] [-no_pr_attribute] [-quiet] [-verbose]
		///
		/// Provides timing data on critical path characteristics and complexity of the design to help identify
		/// and analyze problem areas that are subject to timing closure issues and routing congestion. For
		/// more information on this command refer to the Vivado Design Suite User Guide: Design Analysis
		/// and Closure Techniques (UG906).
		/// The report_design_analysis command currently has three modes of operation:
		/// • Timing: reports timing and physical characteristics of timing paths.
		/// • Complexity: analyzes the design for routing complexity and LUT distribution.
		/// • Congestion: analyzes the design for routing congestion.
		/// In timing mode, the command calls the static timing engine to analyze critical path data and
		/// report the characteristics of each path. The path characteristics include important elements such
		/// as clock skew, placement obstacles such as crossing clock regions, and physical constraints such
		/// as Pblocks and LOCs. The list of paths can be extended to include a number of top critical paths
		/// or specific paths can be analyzed by providing timing path objects to the command. The reports
		/// can also be extended to show the paths preceding and following the critical path.
		/// The following are definitions of the characteristics of the paths reported in timing mode:
		/// • PATH_TYPE: either SETUP or HOLD.
		/// • REQUIREMENT: delay requirement from static timing analysis.
		/// • PATH DELAY: data path delay from static timing analysis.
		/// • LOGIC DELAY: the portion of the PATH DELAY attributed to logic on the path.
		/// • NET DELAY: the portion of the PATH DELAY attributed to wires on the path. Note that the
		/// net delay is based on the estimated or actual routing delay as specified by the
		/// set_delay_model command.
		/// • CLOCK SKEW: difference in delay between the source and destination clocks.
		/// • SLACK: path timing slack from static timing analysis.
		/// • CLOCK RELATIONSHIP: SAME_CLOCK or RELATED_CLOCK. Helps identify potentially
		/// missed inter-clock constraints.
		/// • TIMING EXCEPTION: the timing exceptions, like set_false_path or
		/// set_multicycle_path, that are assigned to the path.
		/// • LOGIC LEVELS: number of logic levels between the source and destination, reported when
		/// the -logic_level_distribution is specified.
		/// • LOGICAL PATH: shorthand notation showing the ordered list of cells in the path including the
		/// start point and end point.
		/// Note: For Partial Reconfiguration (PR) designs, the logical path is appended to identify the cell as
		/// belonging to a reconfigurable partition (:RP#), or to the static region of the design (:S). A translation
		/// table at the bottom of the report maps :RP# to a specific reconfigurable partition.
		/// • START POINT CLOCK: the clock domain of the start point of the path.
		/// • END POINT CLOCK: the clock domain of the end point of the path.
		/// • START POINT PIN PRIMITIVE: the library cell and pin of the start point of the path.
		/// • END POINT PIN PRIMITIVE: the library cell and pin of the end point of the path.
		/// • START POINT PIN: the instance and pin name of the start point.
		/// • END POINT PIN: the instance and pin name of the end point.
		/// • COMB DSP: number of combinational DSP blocks in the path.
		/// • DOA REG: the number of DOA registers on the path.
		/// • DOB REG: the number of DOB registers on the path.
		/// • MREG: the number of MREG registers on the path.
		/// • PREG: the number of PREG registers on the path.
		/// • BRAM CROSSINGS: number of block RAM columns traversed by the path.
		/// • DSP CROSSINGS: number of DSP block columns traversed by the path.
		/// • IO CROSSINGS: number of IO columns traversed by the path.
		/// • CONFIG CROSSINGS: the number of CONFIG tile traversed by the path.
		/// • SLR CROSSINGS: number of SLRs traversed by the path.
		/// • BOUNDING BOX SIZE: the rectangular area covered by the critical path, measured in RPM
		/// GRID units which are based on the device RPM_X (horizontal) and RPM_Y (vertical) site
		/// coordinates. Since different sites (slices, DSP, block RAM, etc.) have different sizes, each site
		/// has unique RPM_X and RPM_Y properties to pinpoint its location within the device.
		/// • CLOCK REGION DISTANCE: An ordered pair showing the number of clock regions traversed
		/// in the horizontal and vertical directions from path startpoint to endpoint. Minimizing clock
		/// region crossings can improve critical path delay and clock skew.
		/// ○ Example 1: A critical path begins in clock region X1Y1 and ends in clock region X3Y3,
		/// resulting in a CLOCK_REGION_DISTANCE of (2, 2).
		/// ○ Example 2: a critical path begins in clock region X2Y1 and ends in X0Y0, resulting in a
		/// CLOCK_REGION_DISTANCE of (-2, -1).
		/// • PBLOCKS: number of Pblocks traversed by the path.
		/// • HIGH FANOUT: the greatest fanout of a net in the path.
		/// • CUMULATIVE FANOUT: the total fanout on the path.
		/// • DONT TOUCH: number of cells in the path with DONT_TOUCH value of TRUE. A value of
		/// TRUE for DONT_TOUCH on a cell prevents it from being optimized, disabling potentially
		/// beneficial optimizations such as phys_opt_design replication.
		/// • MARK DEBUG: number of cells in the path with a MARK_DEBUG value of TRUE. By default a
		/// net with MARK_DEBUG has DONT_TOUCH set to TRUE which disables optimization on that
		/// net. The DONT_TOUCH can be set to FALSE to enable optimization and potentially improve
		/// timing.
		/// • FIXED LOC: number of placed cells in the path with an IS_LOC_FIXED value of TRUE. FIXED
		/// cells cannot be moved by either place_design or phys_opt_design.
		/// • FIXED ROUTE: number of routed nets in the path with IS_ROUTE_FIXED value of TRUE.
		/// FIXED routes cannot be ripped up and rerouted by route_design.
		/// • HOLD FIX DETOUR: the amount of routing detour provided to fix hold timing to post-route
		/// critical paths.
		/// • COMBINED LUT PAIRS: number of LUT cells in the path that have been combined with other
		/// LUT cells into the same LUT BEL to use both the O6 and O5 outputs. LUT cells that have been
		/// combined with LUTNM, HLUTNM, or SOFT_HLUTNM can be uncombined and re-placed by
		/// setting their HLUTNM properties to an empty string. This allows exploring LUT combining and
		/// un-combining effects on timing and congestion reduction.
		/// • The following fields are reported for Partial Reconfiguration (PR) designs. Refer to the Vivado
		/// Design Suite User Guide: Dynamic Function eXchange (UG909) for more information.
		/// ○ PR PATH TYPE: Specifies the path as being completely in the static region, completely in a
		/// reconfigurable partition (RP), or as crossing the boundary between regions. The delay
		/// elements for the timing path are also broken down between the regions .
		/// ○ STATIC CROSSINGS: Reports the number of times a reconfigurable partition (RP) path
		/// crosses into the static region.
		/// ○ RP CROSSINGS: Reports the number of times a static region path crosses into a
		/// reconfigurable partition (RP) region.
		/// ○ BOUNDARY FANOUT: Reports the fanout of a boundary path at the PPLOC to its
		/// downstream loads .
		/// In complexity mode, the command performs complexity analysis of the current design and
		/// reports the Rent Exponent which is a measure of complexity, the Average Fanout, and a Primitive
		/// Histogram. The analysis can be performed on the top-level design or recursively on hierarchical
		/// levels of the design, with the ability to control the level of recursion.
		/// The following are definitions of the characteristics reported in complexity mode:
		/// • Rent: The Rent exponent, as defined by Rent's rule, is a measure of interconnect complexity in
		/// a netlist. Higher Rent indicates higher complexity and greater difficulty to avoid routing
		/// congestion. Most designs have a Rent in the 0.5 to 0.6 range. A Rent value of 0.65 is
		/// considered high and 0.85 is considered very high.
		/// • Average Fanout: This is the average fanout of a logic cell in the design, excluding global
		/// buffers. Higher average fanout may result in more difficulty for placement and routing. While
		/// absolute values may not predict difficultly, relative values between designs or between
		/// hierarchical levels may be more indicative.
		/// • Primitive Histogram: This displays the totals of certain primitive types used in the design. A
		/// high Rent may be caused by a predominance of LUT6 cells. If there are many more LUT6 than
		/// other size LUTs, the Rent may be reduced by adopting a more area-focused synthesis strategy.
		/// TIP: The complexity characteristics may not always predict routing congestion but can be used to pinpoint
		/// problem areas when congestion issues occur.
		/// In congestion mode the command analyzes the design and provides metrics to help you alleviate
		/// routing congestion. Using the results from the report_design_analysis command, you can
		/// change placement to avoid specific routing hot spots.
		/// The command returns the file created, or returns the analysis results to the Tcl console, or returns
		/// an error if it fails.
		///
		/// The following example performs complexity analysis of the two specified cells:
		/// report_design_analysis -complexity -cells {cpuEngine fftEngine}
		/// The following example performs complexity analysis of the specified bounding boxes:
		/// report_design_analysis -complexity \
		/// -bounding_boxes { "CLE_M_X21Y239:CLEL_R_X28Y254"
		/// "CLEL_R_X18Y171:CLE_M_X26Y186" }
		/// The following example provides an extended analysis of the worst critical path from the Block
		/// RAMs in the design:
		/// report_design_analysis -timing -of_timing_paths \
		/// [get_timing_paths -from [all_rams]]
		/// The following example performs complexity analysis for the specified cell, to a depth of two
		/// hierarchical levels, and performs timing and congestion analysis on the design:
		/// report_design_analysis -complexity -hierarchical_depth 2 -timing -setup \
		/// -hold -max_paths 10 -logic_level_distribution -logic_level_dist_paths 20 -
		/// congestion
		/// The following example uses the report_design_analysis command to return the timing
		/// paths with the specified end point clock and logic levels, and passes those paths to the
		/// report_timing command for analysis:
		/// report_timing -of_objects [report_design_analysis -end_point_clock cpuClk \
		/// -logic_levels 10 -timing -return_timing_paths]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1309
		/// </summary>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="return_string">(Optional) Return report as string</param>
		/// <param name="complexity">(Optional) Finds the interconnection complexity (Rent) of the design</param>
		/// <param name="cells">(Optional) Report analysis information for given list of cells</param>
		/// <param name="bounding_boxes">
		/// (Optional)
		/// Report interconnection complexity (Rent) for given list of
		/// bounding boxes Default: empty
		/// </param>
		/// <param name="hierarchical_depth">(Optional) Hierarchical depth option for -complexity Default: 1</param>
		/// <param name="congestion">(Optional) Reports congestion of the design</param>
		/// <param name="min_congestion_level">
		/// (Optional)
		/// Minimum congestion level for reporting router congestion,
		/// integer value between 3 and 8 Default: 5
		/// </param>
		/// <param name="timing">(Optional) Reports characteristics of critical path</param>
		/// <param name="setup">(Optional) Reports characteristics of critical SETUP path</param>
		/// <param name="hold">(Optional) Reports characteristics of critical HOLD path</param>
		/// <param name="show_all">(Optional) Adds more characteristics to the timing characteristics report</param>
		/// <param name="full_logical_pin">(Optional) Display hierarchical pin names in the report</param>
		/// <param name="routed_vs_estimated">(Optional) Reports relevant characteristics of critical path in estimated mode</param>
		/// <param name="logic_level_distribution">(Optional) Reports logic level distribution</param>
		/// <param name="logic_level_dist_paths">
		/// (Optional)
		/// Number of critical paths for analyzing logic level distribution
		/// used along with -logic_level_distribution Default: 1000
		/// </param>
		/// <param name="min_level">
		/// (Optional)
		/// Group all paths with logic levels <min_level-1> and below
		/// into a single bin, value passed must be at least 1 Default:
		/// Not Used
		/// Name Description
		/// </param>
		/// <param name="max_level">
		/// (Optional)
		/// Group all paths with logic levels <max_level+1> and above
		/// into a single bin, where <max_level> must be the greater of
		/// zero or <min_level + 1> if -min_level is used Default: Not
		/// Used
		/// </param>
		/// <param name="return_timing_paths">(Optional) Returns timing path objects</param>
		/// <param name="of_timing_paths">(Optional) Reports characteristics for these paths</param>
		/// <param name="max_paths">(Optional) Number of paths to consider for -timing option Default: 1</param>
		/// <param name="extend">
		/// (Optional)
		/// Reports characteristics of worst path before the start point
		/// of critical path and worst path after the end of the critical
		/// path
		/// </param>
		/// <param name="routes">(Optional) Reports distribution with respect to Routes instead of logic levels</param>
		/// <param name="end_point_clock">
		/// (Optional)
		/// Returns timing path objects filtered by a particular endpoint
		/// clock name as passed to this option
		/// </param>
		/// <param name="logic_levels">
		/// (Optional)
		/// Returns timing path objects bucketed under the bin name
		/// as passed to this option
		/// </param>
		/// <param name="qor_summary">(Optional) Design Flow summary</param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="no_pr_attribute">(Optional) Report without PR attributes</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_design_analysis(string file = null, bool? append = null, bool? return_string = null, bool? complexity = null, string cells = null, string bounding_boxes = null, string hierarchical_depth = null, bool? congestion = null, string min_congestion_level = null, bool? timing = null, bool? setup = null, bool? hold = null, bool? show_all = null, bool? full_logical_pin = null, bool? routed_vs_estimated = null, bool? logic_level_distribution = null, string logic_level_dist_paths = null, string min_level = null, string max_level = null, bool? return_timing_paths = null, string of_timing_paths = null, string max_paths = null, bool? extend = null, bool? routes = null, string end_point_clock = null, string logic_levels = null, bool? qor_summary = null, string name = null, bool? no_pr_attribute = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_design_analysis [-file <arg>] [-append] [-return_string] [-complexity] [-cells <args>] [-bounding_boxes <args>] [-hierarchical_depth <arg>] [-congestion] [-min_congestion_level <arg>] [-timing] [-setup] [-hold] [-show_all] [-full_logical_pin] [-routed_vs_estimated] [-logic_level_distribution] [-logic_level_dist_paths <arg>] [-min_level <arg>] [-max_level <arg>] [-return_timing_paths] [-of_timing_paths <args>] [-max_paths <arg>] [-extend] [-routes] [-end_point_clock <arg>] [-logic_levels <arg>] [-qor_summary] [-name <arg>] [-no_pr_attribute] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_design_analysis")
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.Flag("return_string", return_string)
					.Flag("complexity", complexity)
					.OptionalNamedString("cells", cells)
					.OptionalNamedString("bounding_boxes", bounding_boxes)
					.OptionalNamedString("hierarchical_depth", hierarchical_depth)
					.Flag("congestion", congestion)
					.OptionalNamedString("min_congestion_level", min_congestion_level)
					.Flag("timing", timing)
					.Flag("setup", setup)
					.Flag("hold", hold)
					.Flag("show_all", show_all)
					.Flag("full_logical_pin", full_logical_pin)
					.Flag("routed_vs_estimated", routed_vs_estimated)
					.Flag("logic_level_distribution", logic_level_distribution)
					.OptionalNamedString("logic_level_dist_paths", logic_level_dist_paths)
					.OptionalNamedString("min_level", min_level)
					.OptionalNamedString("max_level", max_level)
					.Flag("return_timing_paths", return_timing_paths)
					.OptionalNamedString("of_timing_paths", of_timing_paths)
					.OptionalNamedString("max_paths", max_paths)
					.Flag("extend", extend)
					.Flag("routes", routes)
					.OptionalNamedString("end_point_clock", end_point_clock)
					.OptionalNamedString("logic_levels", logic_levels)
					.Flag("qor_summary", qor_summary)
					.OptionalNamedString("name", name)
					.Flag("no_pr_attribute", no_pr_attribute)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Report disabled timing arcs
		///
		///
		/// TCL Syntax: report_disable_timing [-user_disabled] [-column_style <arg>] [-file <arg>] [-append] [-cells <args>] [-return_string] [-quiet] [-verbose]
		///
		/// Displays a report of timing paths that will be excluded from timing analysis in the current
		/// synthesized or implemented design.
		/// The format of the report is organized into columns for "Cell or Port" to define the object
		/// associated with the timing path, "From" and "To" to define the timing path, the condition, and the
		/// reason for excluding the path from timing. The various reasons for exclusion are as follows:
		/// • constraint - set_disable_timing constraint is specified
		/// • constant - Logic constant
		/// • loop - Breaks a logic loop
		/// • bidirect instance path - Feedback path through bidirectional instances
		/// • bidirect net path - Feedback path on nets with bidirectional pins
		/// Note: By default the report is written to the Tcl console or STD output. However, the results can also be
		/// written to a file or returned as a string if desired.
		///
		/// The following example reports all timing paths that will not be included in timing analysis:
		/// report_disable_timing
		/// The following example outputs the disable timing report as a string, stores it in a variable, and
		/// then puts it to the display:
		/// set bad_time [report_disable_timing -return_string]
		/// puts $bad_time
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1319
		/// </summary>
		/// <param name="user_disabled">(Optional) report only user disabled arcs</param>
		/// <param name="column_style">
		/// (Optional)
		/// style for path report columns: Values: variable_width,
		/// anchor_left Default: variable_width
		/// </param>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="cells">(Optional) run report_disable_timing on the specified cell(s)</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_disable_timing(bool? user_disabled = null, string column_style = null, string file = null, bool? append = null, string cells = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_disable_timing [-user_disabled] [-column_style <arg>] [-file <arg>] [-append] [-cells <args>] [-return_string] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_disable_timing")
					.Flag("user_disabled", user_disabled)
					.OptionalNamedString("column_style", column_style)
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.OptionalNamedString("cells", cells)
					.Flag("return_string", return_string)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Run DRC
		///
		///
		/// TCL Syntax: report_drc [-name <arg>] [-upgrade_cw] [-checks <args>] [-ruledecks <args>] [-file <arg>] [-rpx <arg>] [-append] [-waived] [-no_waivers] [-return_string] [-quiet] [-verbose]
		///
		/// Check the current design against a specified set of design rule checks, or rule decks, and report
		/// any errors or violations that are found.
		/// The report_drc command requires an open design to check the design rules against. The
		/// command returns a report with the results of violations found by the design rule checks.
		/// Violations are returned as Vivado objects that can be listed with the get_drc_violations
		/// command, and are associated with cells, pins, ports, nets, and sites in the current design. You can
		/// get the cells, nets, and other design objects that are associated with DRC violation objects, using
		/// the -of_objects option of the get_cells command for instance.
		/// TIP: The report_drc can be multi-threaded to speed the process. Refer to the set_param command for
		/// more information on setting the general.maxThreads parameter.
		/// The Vivado tools include a large number of predefined design rule checks to be used by the
		/// report_drc command. Use the get_drc_checks command to list the currently defined
		/// design rule checks. You can also create new custom design rule checks using the
		/// create_drc_check command.
		/// A rule deck is a collection of design rule checks grouped for convenience, to be run at different
		/// stages of the FPGA design flow, such as during I/O planning or placement. The tool comes with a
		/// set of factory defined rule decks, but you can also create new user-defined rule decks with the
		/// create_drc_ruledeck command. Use the get_drc_ruledecks command to return a list
		/// of the currently defined rule decks available for use in the report_drc command.
		/// The report_drc command runs a default rule deck when the -checks or -ruledeck options
		/// are not specified. Creating a user-defined DRC automatically adds the new design rule check to
		/// the default rule deck.
		/// DRC rules can be enabled or disabled using the IS_ENABLED property on the rule check object.
		/// If a rule IS_ENABLED false, the rule will not be run by the report_drc command, whether it is
		/// specified directly using -checks, or indirectly with -ruledeck.
		/// TIP: You can reset the properties of a DRC rule to the factory default settings using the reset_drc_check
		/// command.
		/// You can reset the current results of the report_drc command, clearing any found violations,
		/// using the reset_drc command.
		///
		/// The following example lists the available rule decks. The results include all factory rule decks and
		/// all user-defined rule decks.
		/// get_drc_ruledecks
		/// The following example returns the list of DRC rules defined in the specified rule deck:
		/// get_drc_checks -of_objects [get_drc_ruledecks placer_checks]
		/// The following examples run the specified DRC rule deck and rules against the current design, and
		/// writes the results to the specified file:
		/// report_drc -ruledecks placer_checks -file C:/Data/DRC_Rpt1.txt
		/// report_drc -checks {IOCNT-1 IOPCPR-1 IOPCMGT-1 IOCTMGT-1 IODIR-1} \
		/// -file C:/Data/DRC_Rpt1.txt -append
		/// Note: The -append option adds the result of the second report_drc command to the specified file.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1322
		/// </summary>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="upgrade_cw">
		/// (Optional)
		/// Specifies if report_drc should upgrade all
		/// CRITICAL_WARNING violations to ERROR.
		/// </param>
		/// <param name="checks">(Optional) DRC checks (see get_drc_checks for available checks)</param>
		/// <param name="ruledecks">(Optional) Containers of DRC rule checks Default: default</param>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="rpx">(Optional) Report filename for persisted results.</param>
		/// <param name="append">(Optional) Append the results to file, do not overwrite the results file</param>
		/// <param name="waived">(Optional) Output result is Waived checks</param>
		/// <param name="no_waivers">(Optional) Disable waivers for checks</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_drc(string name = null, bool? upgrade_cw = null, string checks = null, string ruledecks = null, string file = null, string rpx = null, bool? append = null, bool? waived = null, bool? no_waivers = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_drc [-name <arg>] [-upgrade_cw] [-checks <args>] [-ruledecks <args>] [-file <arg>] [-rpx <arg>] [-append] [-waived] [-no_waivers] [-return_string] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_drc")
					.OptionalNamedString("name", name)
					.Flag("upgrade_cw", upgrade_cw)
					.OptionalNamedString("checks", checks)
					.OptionalNamedString("ruledecks", ruledecks)
					.OptionalNamedString("file", file)
					.OptionalNamedString("rpx", rpx)
					.Flag("append", append)
					.Flag("waived", waived)
					.Flag("no_waivers", no_waivers)
					.Flag("return_string", return_string)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Print drivers along with current driving values for an HDL wire or signal object
		///
		///
		/// TCL Syntax: report_drivers [-quiet] [-verbose] <hdl_object>
		///
		/// The report_drivers command prints the name and value of the driving signal, as well as the
		/// current value of a signal type HDL object.
		/// Use this command to determine what signal or process is driving the value on a specific HDL
		/// signal, or net object. A driver of a signal is the statement in the HDL source file that is performing
		/// assignment to the signal.
		/// The output format of report_drivers is as follows:
		/// Drivers for <hdl_object>
		/// <Value of HDL Object>: Net <Hierarchical name of the probed signal>
		/// [ Declared Net : <The declared signal to which the probed signal is
		/// connected>]
		/// <Value of Driver> : Driver <Hierarchical name of the HDL process
		/// containing
		/// the driver> at <file_name>:<line number>
		/// Note: The Declared Net is returned when the probed signal name is different from the hierarchical name of
		/// the actual declared signal due to the current scope of the simulation. Each bit of the declared net is printed
		/// for the probed signal.
		/// The values of signals returned by the report_drivers command depend on the state of the
		/// simulation. In the following example, the report is run before and after simulation:
		/// current_scope /testbench/dut
		/// report_drivers leds_n[3:0]
		/// Drivers for /testbench/dut/LEDS_n[3:0]
		/// 0 : Net /testbench/dut/LEDS_n[0]
		/// Declared Net : /testbench/leds_n[3]
		/// 0 : Driver /testbench/dut/line__187 at C:/Data/sources/sinegen_demo.vhd:187
		/// 0 : Driver /testbench/dut/line__186 at C:/Data/sources/sinegen_demo.vhd:186
		/// 0 : Driver /testbench/dut/line__185 at C:/Data/sources/sinegen_demo.vhd:185
		/// 0 : Driver /testbench/dut/line__184 at C:/Data/sources/sinegen_demo.vhd:184
		/// 0 : Net /testbench/dut/LEDS_n[1]
		/// Declared Net : /testbench/leds_n[2]
		/// 0 : Driver /testbench/dut/line__187 at C:/Data/sources/sinegen_demo.vhd:187
		/// 0 : Driver /testbench/dut/line__186 at C:/Data/sources/sinegen_demo.vhd:186
		/// 0 : Driver /testbench/dut/line__185 at C:/Data/sources/sinegen_demo.vhd:185
		/// 0 : Driver /testbench/dut/line__184 at C:/Data/sources/sinegen_demo.vhd:184
		/// 0 : Net /testbench/dut/LEDS_n[2]
		/// Declared Net : /testbench/leds_n[1]
		/// 0 : Driver /testbench/dut/line__187 at C:/Data/sources/sinegen_demo.vhd:187
		/// 1 : Driver /testbench/dut/line__186 at C:/Data/sources/sinegen_demo.vhd:186
		/// 1 : Driver /testbench/dut/line__185 at C:/Data/sources/sinegen_demo.vhd:185
		/// 1 : Driver /testbench/dut/line__184 at C:/Data/sources/sinegen_demo.vhd:184
		/// X : Net /testbench/dut/LEDS_n[3]
		/// Declared Net : /testbench/leds_n[0]
		/// 0 : Driver /testbench/dut/line__187 at C:/Data/sources/sinegen_demo.vhd:187
		/// 0 : Driver /testbench/dut/line__186 at C:/Data/sources/sinegen_demo.vhd:186
		/// 0 : Driver /testbench/dut/line__185 at C:/Data/sources/sinegen_demo.vhd:185
		/// 0 : Driver /testbench/dut/line__184 at C:/Data/sources/sinegen_demo.vhd:184
		/// run all
		/// report_drivers leds_n[3:0]
		/// Drivers for /testbench/dut/LEDS_n[3:0]
		/// 0 : Net /testbench/dut/LEDS_n[0]
		/// Declared Net : /testbench/leds_n[3]
		/// 0 : Driver /testbench/dut/line__187 at C:/Data/sources/sinegen_demo.vhd:187
		/// 0 : Driver /testbench/dut/line__186 at C:/Data/sources/sinegen_demo.vhd:186
		/// 0 : Driver /testbench/dut/line__185 at C:/Data/sources/sinegen_demo.vhd:185
		/// 0 : Driver /testbench/dut/line__184 at C:/Data/sources/sinegen_demo.vhd:184
		/// 1 : Net /testbench/dut/LEDS_n[1]
		/// Declared Net : /testbench/leds_n[2]
		/// 0 : Driver /testbench/dut/line__187 at C:/Data/sources/sinegen_demo.vhd:187
		/// 0 : Driver /testbench/dut/line__186 at C:/Data/sources/sinegen_demo.vhd:186
		/// 0 : Driver /testbench/dut/line__185 at C:/Data/sources/sinegen_demo.vhd:185
		/// 0 : Driver /testbench/dut/line__184 at C:/Data/sources/sinegen_demo.vhd:184
		/// 0 : Net /testbench/dut/LEDS_n[2]
		/// Declared Net : /testbench/leds_n[1]
		/// 1 : Driver /testbench/dut/line__187 at C:/Data/sources/sinegen_demo.vhd:187
		/// 1 : Driver /testbench/dut/line__186 at C:/Data/sources/sinegen_demo.vhd:186
		/// 1 : Driver /testbench/dut/line__185 at C:/Data/sources/sinegen_demo.vhd:185
		/// 1 : Driver /testbench/dut/line__184 at C:/Data/sources/sinegen_demo.vhd:184
		/// 0 : Net /testbench/dut/LEDS_n[3]
		/// Declared Net : /testbench/leds_n[0]
		/// 0 : Driver /testbench/dut/line__187 at C:/Data/sources/sinegen_demo.vhd:187
		/// 0 : Driver /testbench/dut/line__186 at C:/Data/sources/sinegen_demo.vhd:186
		/// 1 : Driver /testbench/dut/line__185 at C:/Data/sources/sinegen_demo.vhd:185
		/// 0 : Driver /testbench/dut/line__184 at C:/Data/sources/sinegen_demo.vhd:184
		/// Note: Notice the declared net is reported, because the current scope of the simulation is set to a different
		/// level than the top-level of the test bench.
		/// This command returns a report of the drivers on the specified objects, or returns an error if it
		/// fails.
		///
		/// The following example reports the drivers for the HDL objects returned by the get_objects
		/// command:
		/// report_drivers [get_objects leds_n]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1326
		/// </summary>
		/// <param name="hdl_object">(Required) Which hdl_object to report</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_drivers(string hdl_object, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_drivers [-quiet] [-verbose] <hdl_object>
			return
				new SimpleTCLCommand("report_drivers")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hdl_object)
			;
		}
		/// <summary>
		/// Report system information.
		///
		///
		/// TCL Syntax: report_environment [-file <arg>] [-format <arg>] [-append] [-return_string] [-quiet] [-verbose]
		///
		/// Report the details of the system environment that the tool is running under. The details of the
		/// environment report include: operating system version, CPU, memory, available disk space, and
		/// specific settings of various environment variables.
		/// The default is to write the report to the standard output. However, the report can be written to a
		/// file instead.
		///
		/// The following example reports the current environment to the specified file:
		/// report_environment -file C:/Data/toolEnv.txt
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1329
		/// </summary>
		/// <param name="file">(Optional) Write system information to specified file.</param>
		/// <param name="format">
		/// (Optional)
		/// Specifies how to format the report. Default is 'text', another
		/// option is 'xml'. Only applies if -file is used. If xml output is
		/// used, -append is not allowed. Default: text
		/// </param>
		/// <param name="append">(Optional) Append report to existing file</param>
		/// <param name="return_string">(Optional) Return report content as a string value</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_environment(string file = null, string format = null, bool? append = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_environment [-file <arg>] [-format <arg>] [-append] [-return_string] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_environment")
					.OptionalNamedString("file", file)
					.OptionalNamedString("format", format)
					.Flag("append", append)
					.Flag("return_string", return_string)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Report timing exceptions
		///
		///
		/// TCL Syntax: report_exceptions [-from <args>] [-rise_from <args>] [-fall_from <args>] [-to <args>] [-rise_to <args>] [-fall_to <args>] [-through <args>] [-rise_through <args>] [-fall_through <args>] [-ignored] [-summary] [-coverage] [-ignored_objects] [-count_objects] [-write_merged_exceptions] [-write_valid_exceptions] [-no_header] [-file <arg>] [-append] [-return_string] [-name <arg>] [-quiet] [-verbose]
		///
		/// Report all timing exceptions applied to setup and hold checks defined by timing constraints in the
		/// current design, or report the exceptions on the specified timing paths.
		/// Timing exceptions can be defined by timing constraints such as set_false_path or
		/// set_multicycle_path that change the default assumptions for timing paths in the design.
		/// The exceptions are reported to the standard output by default, but can be redirected to a file or
		/// to a Tcl string variable.
		///
		/// This example reports all timing exceptions in the current design:
		/// report_exceptions
		/// This example reports all timing exceptions ignored or overridden in the current design:
		/// report_exceptions -ignored
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1331
		/// </summary>
		/// <param name="from">(Optional) From pins, ports, cells or clocks</param>
		/// <param name="rise_from">(Optional) Rising from pins, ports, cells or clocks</param>
		/// <param name="fall_from">(Optional) Falling from pins, ports, cells or clocks</param>
		/// <param name="to">(Optional) To pins, ports, cells or clocks</param>
		/// <param name="rise_to">(Optional) Rising to pins, ports, cells or clocks</param>
		/// <param name="fall_to">(Optional) Falling to pins, ports, cells or clocks</param>
		/// <param name="through">(Optional) Through pins, ports, cells or nets</param>
		/// <param name="rise_through">(Optional) Rising through pins, ports, cells or nets</param>
		/// <param name="fall_through">(Optional) Falling through pins, ports, cells or nets</param>
		/// <param name="ignored">(Optional) Only report exceptions which are ignored</param>
		/// <param name="summary">(Optional) Report a summary of all exceptions</param>
		/// <param name="coverage">(Optional) Report the coverage of all timing exceptions</param>
		/// <param name="ignored_objects">(Optional) Report the list of ignored startpoints and endpoints</param>
		/// <param name="count_objects">(Optional) Report the number of objects in the timing exceptions</param>
		/// <param name="write_merged_exceptions">(Optional) Write merged timing exceptions</param>
		/// <param name="write_valid_exceptions">(Optional) Write timing exceptions with the valid objects only</param>
		/// <param name="no_header">(Optional) Do not generate a report header</param>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="return_string">(Optional) Return report as string</param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_exceptions(string from = null, string rise_from = null, string fall_from = null, string to = null, string rise_to = null, string fall_to = null, string through = null, string rise_through = null, string fall_through = null, bool? ignored = null, bool? summary = null, bool? coverage = null, bool? ignored_objects = null, bool? count_objects = null, bool? write_merged_exceptions = null, bool? write_valid_exceptions = null, bool? no_header = null, string file = null, bool? append = null, bool? return_string = null, string name = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_exceptions [-from <args>] [-rise_from <args>] [-fall_from <args>] [-to <args>] [-rise_to <args>] [-fall_to <args>] [-through <args>] [-rise_through <args>] [-fall_through <args>] [-ignored] [-summary] [-coverage] [-ignored_objects] [-count_objects] [-write_merged_exceptions] [-write_valid_exceptions] [-no_header] [-file <arg>] [-append] [-return_string] [-name <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_exceptions")
					.OptionalNamedString("from", from)
					.OptionalNamedString("rise_from", rise_from)
					.OptionalNamedString("fall_from", fall_from)
					.OptionalNamedString("to", to)
					.OptionalNamedString("rise_to", rise_to)
					.OptionalNamedString("fall_to", fall_to)
					.OptionalNamedString("through", through)
					.OptionalNamedString("rise_through", rise_through)
					.OptionalNamedString("fall_through", fall_through)
					.Flag("ignored", ignored)
					.Flag("summary", summary)
					.Flag("coverage", coverage)
					.Flag("ignored_objects", ignored_objects)
					.Flag("count_objects", count_objects)
					.Flag("write_merged_exceptions", write_merged_exceptions)
					.Flag("write_valid_exceptions", write_valid_exceptions)
					.Flag("no_header", no_header)
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.Flag("return_string", return_string)
					.OptionalNamedString("name", name)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Print, in textual format, stack frames when current_scope is a process waiting inside subprogram
		///
		///
		/// TCL Syntax: report_frames [-quiet] [-verbose]
		///
		/// Returns a list of strings of sub-program names, and the calling HDL process in the sub-program
		/// call hierarchy for the current HDL process scope, or current_scope. The list starts with the
		/// HDL process till the most recent sub-program in the hierarchy. Each frame has an associated
		/// frame-index. The most recent sub-program is shown at the top, and has an index "0". The symbol
		/// (->) is used to indicate the current_frame.
		/// By default, the most recently called sub-program frame is the current_frame. Other frames
		/// can be selected using current_frame command. In verbose mode, output gives the source
		/// line-file information for each and every call.
		/// IMPORTANT! report_frames strictly follows the current_scope. If the current_scope is not an
		/// HDL process scope waiting inside a sub-program, the command returns an empty list.
		/// This command returns the name of the design object of the current_instance, or returns nothing
		/// when set to the top of current design.
		///
		/// Example design:
		/// module top;
		/// int i;
		/// function void f(input int in1);
		/// automatic int a;
		/// a = in1 + 7;
		/// $display($time, " in f :: a %d in1 %d ", a, in1);
		/// endfunction
		/// task automatic t(input int in2);
		/// int b;
		/// b = in2 + 10;
		/// $display($time, " in t :: in2 %d b %d ", in2, b);
		/// #5;
		/// f(b); // Case C
		/// $display($time, " Back in t : after wait and f(%d) ", b);
		/// endtask
		/// initial begin // "/top/Initial18_0"
		/// $display($time, " in initial 1 ");
		/// i = 200;
		/// t(i); // Case B
		/// $display($time, " Back in initial 1 after t(%d) ", i);
		/// end
		/// initial begin // "/top/Initial25_1"
		/// $display($time, " in initial 2 ");
		/// #2;
		/// f(50); // Case A
		/// $display($time, " Back in initial 2 after f(50) ");
		/// end
		/// endmodule
		/// When simulation is stopped inside function "f" for its call at 'Case C', function "f" is called from
		/// task "t" at 'Case C', which itself is called from process "/top/Initial18_0" at 'Case B':
		/// > current_scope
		/// /top/Initial18_0
		/// 1. > report_frames
		/// -> 0 : f
		/// 1 : t
		/// 2: /top/Initial18_0
		/// 2. > report_frames -verbose
		/// -> 0 : f @top.v:6
		/// 1 : t @top.v:15
		/// 2 : /top/Initial18_0 @top.v:21
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1335
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Returns string</returns>
		public virtual SimpleTCLCommand report_frames(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_frames [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_frames")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Report high fanout nets
		///
		///
		/// TCL Syntax: report_high_fanout_nets [-file <arg>] [-format <arg>] [-append] [-ascending] [-timing] [-histogram] [-load_types] [-clock_regions] [-slr] [-max_nets <arg>] [-fanout_greater_than <arg>] [-fanout_lesser_than <arg>] [-name <arg>] [-cells <args>] [-clocks <args>] [-return_string] [-quiet] [-verbose]
		///
		/// Report the fanout of nets in the design, starting with the highest fanout nets, and working down.
		/// Options allow you to control various aspects of the report.
		/// This command can be run on an implemented design, or on the synthesized netlist. However, the
		/// results will be more complete on the implemented design.
		/// The command returns the fanout report of nets in the design, or returns an error if it fails.
		///
		/// The following example reports the top 100 nets with fanouts greater than 50 loads, returning a
		/// histogram of the results:
		/// report_high_fanout_nets -fanout_greater_than 50 -max_nets 100 -histogram
		/// The following example reports the fanout of nets for the specified clocks:
		/// report_high_fanout_nets -clocks [get_clocks gt*]
		/// This example reports the nets with fanouts less than 10 loads, and returns the results to a string
		/// stored as a Tcl variable:
		/// set myRep [report_high_fanout_nets -fanout_lesser_than 10 -return_string]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1338
		/// </summary>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="format">
		/// (Optional)
		/// Specifies how to format the report: text, xml. Default is
		/// 'text'. Only applies if -file is used. If xml output is used, -
		/// append is not allowed. Default: text
		/// </param>
		/// <param name="append">(Optional) Append to existing file</param>
		/// <param name="ascending">(Optional) Report nets in ascending order</param>
		/// <param name="timing">(Optional) Report worst slack and worst delay values on nets</param>
		/// <param name="histogram">(Optional) Report histogram for high fanout nets</param>
		/// <param name="load_types">(Optional) Report load details</param>
		/// <param name="clock_regions">(Optional) Report clock region wise load distribution</param>
		/// <param name="slr">(Optional) Report SLR wise load distribution</param>
		/// <param name="max_nets">(Optional) Number of nets for which report is to be generated Default: 10</param>
		/// <param name="fanout_greater_than">
		/// (Optional)
		/// Report nets that have fanout greater than the specified
		/// integer, default 0 Default: 0
		/// </param>
		/// <param name="fanout_lesser_than">
		/// (Optional)
		/// Report nets that have fanout less than the specified integer,
		/// default INT_MAX Default: INT_MAX
		/// </param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="cells">(Optional) Report the nets of the specified cells</param>
		/// <param name="clocks">(Optional) Report the nets of the specified clocks</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Report</returns>
		public virtual SimpleTCLCommand report_high_fanout_nets(string file = null, string format = null, bool? append = null, bool? ascending = null, bool? timing = null, bool? histogram = null, bool? load_types = null, bool? clock_regions = null, bool? slr = null, string max_nets = null, string fanout_greater_than = null, string fanout_lesser_than = null, string name = null, string cells = null, string clocks = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_high_fanout_nets [-file <arg>] [-format <arg>] [-append] [-ascending] [-timing] [-histogram] [-load_types] [-clock_regions] [-slr] [-max_nets <arg>] [-fanout_greater_than <arg>] [-fanout_lesser_than <arg>] [-name <arg>] [-cells <args>] [-clocks <args>] [-return_string] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_high_fanout_nets")
					.OptionalNamedString("file", file)
					.OptionalNamedString("format", format)
					.Flag("append", append)
					.Flag("ascending", ascending)
					.Flag("timing", timing)
					.Flag("histogram", histogram)
					.Flag("load_types", load_types)
					.Flag("clock_regions", clock_regions)
					.Flag("slr", slr)
					.OptionalNamedString("max_nets", max_nets)
					.OptionalNamedString("fanout_greater_than", fanout_greater_than)
					.OptionalNamedString("fanout_lesser_than", fanout_lesser_than)
					.OptionalNamedString("name", name)
					.OptionalNamedString("cells", cells)
					.OptionalNamedString("clocks", clocks)
					.Flag("return_string", return_string)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Report formatted hardware AXI Transaction data
		///
		///
		/// TCL Syntax: report_hw_axi_txn [-w <arg>] [-t <arg>] [-quiet] [-verbose] <hw_axi_txns>...
		///
		/// Report the results of the specified AXI transactions on the JTAG to AXI Master, hw_axi.
		/// You can use this command after creating hw_axi_txn objects on existing hw_axi objects, and
		/// then running the hw_axi to exercise the defined transaction.
		/// The JTAG to AXI Master core can only be controlled using Tcl commands. You can issue AXI read
		/// and write transactions using the create_hw_axi_txns command. However, before issuing
		/// these commands, it is important to reset the JTAG to AXI Master core using the reset_hw_axi
		/// command.
		/// This command reports the transaction data in the specified format, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1342
		/// </summary>
		/// <param name="hw_axi_txns">(Required) hardware AXI Transaction object to report</param>
		/// <param name="w">(Optional) Output data bytes per output line. Default: 8</param>
		/// <param name="t">
		/// (Optional)
		/// d[SIZE] signed decimal, SIZE bytes per integer, b[SIZE]
		/// binary, SIZE bytes per integer, o[SIZE] octal, SIZE bytes per
		/// integer, u[SIZE] unsigned decimal, SIZE bytes per integer,
		/// x[SIZE] hexadecimal, SIZE bytes per integer Default: x4 (4-
		/// bytes in hex)
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_hw_axi_txn(string hw_axi_txns, string w = null, string t = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_hw_axi_txn [-w <arg>] [-t <arg>] [-quiet] [-verbose] <hw_axi_txns>...
			return
				new SimpleTCLCommand("report_hw_axi_txn")
					.OptionalNamedString("w", w)
					.OptionalNamedString("t", t)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_axi_txns)
			;
		}
		/// <summary>
		/// Formatted report on Versal integrated and soft Memory Controllers' (DDRMCs) memory
		/// configurations, calibration status, stages, and window margins data.
		///
		///
		/// TCL Syntax: report_hw_ddrmc [-file <arg>] [-append] [-return_string] [-quiet] [-verbose] <hw_objects>
		///
		/// Report formatted information on memory IP hardware configuration, calibration, and margin.
		/// Does not include the graphical margin scan plots that are available within the Vivado logic
		/// analyzer, or Vivado Lab Edition.
		/// In the Vivado tools, Versal memory controllers implemented into a design are associated with
		/// hw_ddrmc objects. These hw_ddrmc objects let you verify the calibration, read, and write
		/// window margins in your memory interface design. You can use the hardware manager GUI to
		/// check the calibration status, verify the read margin for both rising and falling edges of the clock,
		/// and write margin for both simple and complex patterns. You can also use an ILA and VIO core to
		/// verify the data integrity for the read and write operations.
		/// This command returns the reported data, or returns an error if it fails.
		///
		/// The following example generates the report on the hw_ddrmc objects and outputs them to the
		/// text file specified:
		/// report_hw_ddrmc -file C:/Data/ddrmc_report.txt [get_hw_ddrmcs]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1345
		/// </summary>
		/// <param name="hw_objects">(Required) hardware DDRMC objects</param>
		/// <param name="file">(Optional) file name (including full path) to output the report results to</param>
		/// <param name="append">(Optional) set this option to append the report results to a file</param>
		/// <param name="return_string">(Optional) set this option to have report results returned as a string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_hw_ddrmc(string hw_objects, string file = null, bool? append = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_hw_ddrmc [-file <arg>] [-append] [-return_string] [-quiet] [-verbose] <hw_objects>
			return
				new SimpleTCLCommand("report_hw_ddrmc")
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.Flag("return_string", return_string)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_objects)
			;
		}
		/// <summary>
		/// Report formatted hardware MIG calibration status and margin data
		///
		///
		/// TCL Syntax: report_hw_mig [-file <arg>] [-append] [-return_string] [-quiet] [-verbose] <hw_objects>
		///
		/// Report formatted information on memory IP hardware configuration, calibration, and margin.
		/// Does not include the graphical margin scan plots that are available within the Vivado logic
		/// analyzer, or Vivado Lab Edition.
		/// In the Vivado tools, memory controllers implemented into a design are associated with hw_mig
		/// objects. These hw_mig objects let you verify the calibration, read, and write window margins in
		/// your memory interface design. You can use the hardware manager GUI to check the calibration
		/// status, verify the read margin for both rising and falling edges of the clock, and write margin for
		/// both simple and complex patterns, or DQS. You can also use an ILA core to verify the data
		/// integrity for the read and write operations.
		/// This command returns the reported data, or returns an error if it fails.
		///
		/// The following example generates the report on the hw_mig objects and outputs to the text file
		/// specified:
		/// report_hw_mig -file C:/Data/hw_mig_report.txt [get_hw_migs]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1347
		/// </summary>
		/// <param name="hw_objects">(Required) hardware mig objects</param>
		/// <param name="file">(Optional) file name (including full path) to output the report results to</param>
		/// <param name="append">(Optional) set this option to append the report results to a file</param>
		/// <param name="return_string">(Optional) set this option to have report results return as a string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_hw_mig(string hw_objects, string file = null, bool? append = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_hw_mig [-file <arg>] [-append] [-return_string] [-quiet] [-verbose] <hw_objects>
			return
				new SimpleTCLCommand("report_hw_mig")
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.Flag("return_string", return_string)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_objects)
			;
		}
		/// <summary>
		/// Report properties on hardware objects
		///
		///
		/// TCL Syntax: report_hw_targets [-quiet] [-verbose]
		///
		/// This command returns properties related to the configuration of all hw_targets on the
		/// current_hw_server object. The information reported by this command includes:
		/// • Server Property Information: The properties of the current_hw_server, including HOST and
		/// PORT.
		/// • Target Property Information: Reported for each target on the hw_server, including NAME,
		/// FREQUENCY, DEVICE_COUNT, and SVF.
		/// • Device Property Information: Reported for each device on a specific hw_target, including
		/// PART, ID CODE, IR LENGTH, MASK, PROGRAMMING and PROBES FILE.
		/// This command returns the requested information if successful, or returns an error if it fails.
		///
		/// The following example reports the property information for all targets on the connected
		/// hw_server:
		/// report_hw_targets
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1349
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>hardware objects</returns>
		public virtual SimpleTCLCommand report_hw_targets(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_hw_targets [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_hw_targets")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Compute achievable incremental reuse for the given design-checkpoint and report
		///
		///
		/// TCL Syntax: report_incremental_reuse [-file <arg>] [-append] [-cells <args>] [-hierarchical] [-hierarchical_depth <arg>] [-return_string] [-quiet] [-verbose]
		///
		/// For use with the incremental implementation flow, this command reports on the amount of
		/// design overlap between the current design and an incremental checkpoint loaded using the
		/// read_checkpoint -incremental command.
		/// This report analyzes the loaded incremental checkpoint against the current design to see if the
		/// two are sufficiently correlated to drive incremental placement and routing. A low correlation
		/// between the current design and the checkpoint should discourage using the checkpoint as a
		/// basis for incremental place and route. Refer to the Vivado Design Suite User Guide: Implementation
		/// (UG904) for more information on incremental place and route.
		/// If there is a low correlation of reuse between the current design and the loaded incremental
		/// checkpoint, you will need to restore the original design using open_run or read_checkpoint.
		/// Alternatively, you can overload the incremental checkpoint in the current design by issuing the
		/// read_checkpoint -incremental command again to specify a new incremental checkpoint.
		/// For Partial Reconfiguration (PR) designs, the % of cells matching in Reconfigurable Modules (RM)
		/// are reported, the % of cells reused in RMs, and the % of cells fixed in RMs are also reported.
		/// There is also a Reconfigurable Modules Summary table added to the report.
		///
		/// The following example loads an incremental checkpoint into the current design, and then reports
		/// the correlation of the loaded incremental checkpoint to the current design:
		/// read_checkpoint -incremental C:/Data/reuse_checkpoint1.dcp
		/// report_incremental_reuse
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1351
		/// </summary>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="append">(Optional) Append to existing file</param>
		/// <param name="cells">(Optional) Report incremental reuse of given list of cells</param>
		/// <param name="hierarchical">(Optional) Generates text-based hierarchical incremental reuse report.</param>
		/// <param name="hierarchical_depth">
		/// (Optional)
		/// Specifies the depth level for textual hierachical incremental
		/// reuse report Default: 0
		/// </param>
		/// <param name="return_string">(Optional) Return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_incremental_reuse(string file = null, bool? append = null, string cells = null, bool? hierarchical = null, string hierarchical_depth = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_incremental_reuse [-file <arg>] [-append] [-cells <args>] [-hierarchical] [-hierarchical_depth <arg>] [-return_string] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_incremental_reuse")
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.OptionalNamedString("cells", cells)
					.Flag("hierarchical", hierarchical)
					.OptionalNamedString("hierarchical_depth", hierarchical_depth)
					.Flag("return_string", return_string)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Display information about all the IO sites on the device
		///
		///
		/// TCL Syntax: report_io [-file <arg>] [-name <arg>] [-append] [-format <arg>] [-return_string] [-quiet] [-verbose]
		///
		/// Report details of the IO banks of the current design. Details include device specific information
		/// such as target part, package, and speed grade, and also provides information related to each pin
		/// on the device.
		/// This command returns the requested report, or returns an error if it fails.
		///
		/// The following example reports the IO blocks of the current design:
		/// report_io
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1354
		/// </summary>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. Send output to console if -file
		/// is not used.
		/// </param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="append">(Optional) Append to existing file</param>
		/// <param name="format">
		/// (Optional)
		/// Specifies how to format the report: text, xml. Default is
		/// 'text'. Only applies if -file is used. If xml output is used, -
		/// append is not allowed. Default: text
		/// </param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Report</returns>
		public virtual SimpleTCLCommand report_io(string file = null, string name = null, bool? append = null, string format = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_io [-file <arg>] [-name <arg>] [-append] [-format <arg>] [-return_string] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_io")
					.OptionalNamedString("file", file)
					.OptionalNamedString("name", name)
					.Flag("append", append)
					.OptionalNamedString("format", format)
					.Flag("return_string", return_string)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Report on the status of the IP instances in the project.
		///
		///
		/// TCL Syntax: report_ip_status [-name <arg>] [-file <arg>] [-append] [-return_string] [-license_status] [-resource_data] [-quiet] [-verbose]
		///
		/// This command examines the IP cores in the current project, and reports the state of the IP with
		/// regard to the latest IP catalog. The following information is included in the IP Status report:
		/// • Instance Name - The name of the IP core in the current project.
		/// • IP Status - A description of the state of the IP in the current project.
		/// • Recommendation - A recommended action based on the status.
		/// • Lock Status - An explanation of the lock status of the IP in the current project.
		/// • Change Log - A reference to the change log for the IP update in the catalog. This will provide a
		/// description of the changes in the latest IP.
		/// • IP Name - The name of the IP core in the catalog.
		/// • IP Version - The version of the IP in use in the current project.
		/// • New Version - The latest version of the IP in the catalog.
		/// • New license - The license status for the new IP version.
		/// • Original Part - The original part associated with the IP in the catalog.
		/// IP cores that are out of date, or locked, may need to be upgraded and the output products
		/// regenerated. Refer to the Vivado Design Suite User Guide: Designing with IP (UG896) for more
		/// information.
		/// The report_ip_status command checks the available licenses on the local machine, or on the
		/// license server, for all IP cores in the current project. If a license can be found, the license
		/// information is printed. If the license cannot be found, this information is also printed.
		/// This command returns the IP status report, or returns an error if it fails.
		///
		/// The following example reports the IP status to the specified file, appending the results if the file
		/// already exists:
		/// report_ip_status -file C:/Data/reports/ip_status.txt -append
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1356
		/// </summary>
		/// <param name="name">
		/// (Optional)
		/// Output the results to GUI panel with this name Values: The
		/// name of the GUI dialog
		/// </param>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to (send output to console if -file
		/// is not used) Values: The report filename
		/// </param>
		/// <param name="append">(Optional) Append to existing file</param>
		/// <param name="return_string">(Optional) Return report as string</param>
		/// <param name="license_status">(Optional) Report the license status of the generated outputs for each IP</param>
		/// <param name="resource_data">(Optional) Report the resource data usage for each IP instance</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>True for success</returns>
		public virtual SimpleTCLCommand report_ip_status(string name = null, string file = null, bool? append = null, bool? return_string = null, bool? license_status = null, bool? resource_data = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_ip_status [-name <arg>] [-file <arg>] [-append] [-return_string] [-license_status] [-resource_data] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_ip_status")
					.OptionalNamedString("name", name)
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.Flag("return_string", return_string)
					.Flag("license_status", license_status)
					.Flag("resource_data", resource_data)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Methodology Checks
		///
		///
		/// TCL Syntax: report_methodology [-name <arg>] [-cells <args>] [-checks <args>] [-file <arg>] [-rpx <arg>] [-append] [-waived] [-no_waivers] [-slack_lesser_than <arg>] [-return_string] [-quiet] [-verbose]
		///
		/// Check the current design against a specified set of methodology checks and report any errors or
		/// violations that are found.
		/// Methodology checks are a special class of design rule checks (DRC) that are accessible through
		/// this separate Tcl command. The methodology checks are a necessary part of the design flow, and
		/// should be considered mandatory after implementation and prior to generating the bitstream.
		/// TIP: Other than their availability through the separate report_methodology command, the checks are
		/// standard design rule checks in every other way.
		/// The report_methodology command requires an open design to check the design rules
		/// against. The command returns a report with the results of violations found by the design rule
		/// checks. Violations are returned as Vivado objects that can be listed with the
		/// get_methodology_violations command, and are associated with cells, pins, ports, nets,
		/// and sites in the current design. You can get the cells, nets, and other design objects that are
		/// associated with methodology violation objects, using the -of_objects option of the
		/// get_cells command for instance.
		/// The report_methodology command runs the methodology rule deck, or you can use the -
		/// checks option to specify the set of checks to run. Methodology checks can also be enabled or
		/// disabled in the default rule decks using the IS_ENABLED property on the rule check object:
		/// set_property IS_ENABLED FALSE [get_methodology_checks PDRC-190]
		/// If a rule IS_ENABLED false, the rule will not be run by the report_methodology command.
		/// TIP: You can reset the properties of a methodology rule to the factory default settings using the
		/// reset_methodology_check command.
		/// You can reset the current results of the report_methodology command, clearing any found
		/// violations, using the reset_methodology command.
		///
		/// The following examples run the default methodology checks against the current design, and
		/// writes the results to the specified file:
		/// report_methodology -file C:/Data/methodology_Rpt1.txt -append
		/// Note: The -append option adds the result to the specified file.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1359
		/// </summary>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="cells">(Optional) Run report_methodology on the specified cell(s).</param>
		/// <param name="checks">
		/// (Optional)
		/// Report Methodology checks (see get_methodology_checks
		/// for available checks)
		/// </param>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="rpx">(Optional) Report filename for persisted results.</param>
		/// <param name="append">(Optional) Append the results to file, do not overwrite the results file</param>
		/// <param name="waived">(Optional) Output result is Waived checks</param>
		/// <param name="no_waivers">(Optional) Disable waivers for checks</param>
		/// <param name="slack_lesser_than">(Optional) Set SYNTH rules Slack Threshold value in 'ns' (float) Default: 2.0</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_methodology(string name = null, string cells = null, string checks = null, string file = null, string rpx = null, bool? append = null, bool? waived = null, bool? no_waivers = null, string slack_lesser_than = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_methodology [-name <arg>] [-cells <args>] [-checks <args>] [-file <arg>] [-rpx <arg>] [-append] [-waived] [-no_waivers] [-slack_lesser_than <arg>] [-return_string] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_methodology")
					.OptionalNamedString("name", name)
					.OptionalNamedString("cells", cells)
					.OptionalNamedString("checks", checks)
					.OptionalNamedString("file", file)
					.OptionalNamedString("rpx", rpx)
					.Flag("append", append)
					.Flag("waived", waived)
					.Flag("no_waivers", no_waivers)
					.OptionalNamedString("slack_lesser_than", slack_lesser_than)
					.Flag("return_string", return_string)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Print details of the given hdl objects (variable, signal, wire, or reg)
		///
		///
		/// TCL Syntax: report_objects [-quiet] [-verbose] [<hdl_objects>...]
		///
		/// The report_objects command reports the type, name, and language of the specified HDL
		/// objects to the Tcl Console or Tcl shell. You must have an open simulation to use this command.
		/// This command returns a brief description of the specified objects. Use the describe command
		/// to return more detailed information.
		/// HDL objects include HDL signals, variables, or constants as defined in the Verilog or VHDL test
		/// bench and source files. An HDL signal includes Verilog wire or reg entities, and VHDL signals.
		/// Examples of HDL variables include Verilog real, realtime, time, and event. HDL constants include
		/// Verilog parameters and localparams, and VHDL generic and constants.
		/// The command returns the HDL object type, the name, and the code type (Verilog/VHDL) for
		/// each object, or returns an error if it fails.
		///
		/// Verilog parameters and localparams, and VHDL generic and constants.
		/// The command returns the HDL object type, the name, and the code type (Verilog/VHDL) for
		/// each object, or returns an error if it fails.
		/// Arguments
		/// -quiet - (Optional) Execute the command quietly, returning no messages from the command.
		/// The command also returns TCL_OK regardless of any errors encountered during execution.
		/// Note: Any errors encountered on the command-line, while launching the command, will be returned. Only
		/// errors occurring inside the command will be trapped.
		/// -verbose - (Optional) Temporarily override any message limits and return all messages from this
		/// command.
		/// Note: Message limits can be defined with the set_msg_config command.
		/// <hdl_objects> - (Optional) Specifies the objects to report. The default command reports all
		/// objects found in the current scope of the simulation, or current_scope.
		/// Note: Objects can be specified by name, or returned as objects by the get_objects command.
		/// Examples
		/// The following example shows how the specified objects reported depend upon the current scope
		/// of the simulation:
		/// current_scope testbench
		/// /testbench
		/// report_objects [get_objects leds_n]
		/// Declared: {leds_n[3:0]} Verilog
		/// current_scope dut
		/// /testbench/dut
		/// report_objects leds_n
		/// Out: {LEDS_n[3:0]} VHDL
		/// This example reports the specified HDL objects of the current simulation scope:
		/// report_objects [get_objects GPIO*]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1363
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hdl_objects">(Optional) The hdl_objects to report. Default is report_objects [get_objects *]</param>
		/// <returns>Print name, type, data_type of the HDL objects on console in textual format</returns>
		public virtual SimpleTCLCommand report_objects(bool? quiet = null, bool? verbose = null, string hdl_objects = null)
		{
			// TCL Syntax: report_objects [-quiet] [-verbose] [<hdl_objects>...]
			return
				new SimpleTCLCommand("report_objects")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(hdl_objects)
			;
		}
		/// <summary>
		/// Get operating conditions values for power estimation
		///
		///
		/// TCL Syntax: report_operating_conditions [-voltage <args>] [-grade] [-process] [-junction_temp] [-ambient_temp] [-thetaja] [-thetasa] [-airflow] [-heatsink] [-thetajb] [-board] [-board_temp] [-board_layers] [-design_power_budget] [-all] [-file <arg>] [-return_string] [-append] [-quiet] [-verbose]
		///
		/// Displays the real-world operating conditions that are used when performing analysis of the
		/// design. The reported values of operating conditions can be defined by the
		/// set_operating_conditions command.
		/// The environmental operating conditions of the device are used for power analysis when running
		/// the report_power command, but are not used during timing analysis.
		/// Note: By default the report is written to the Tcl console or STD output. However, the results can also be
		/// written to a file or returned as a string if desired.
		///
		/// Specify an industrial temperature grade device with an ambient temperature of 75 degrees C and
		/// then write those settings to a file on disk.
		/// set_operating_conditions -grade industrial -junction_temp 75
		/// report_operating_conditions -grade -junction_temp -return_string -file \
		/// ~/conditions.txt
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1365
		/// </summary>
		/// <param name="voltage">(Optional) Gets voltage value. Supported voltage supplies vary by family.</param>
		/// <param name="grade">(Optional) Temperature grade. Supported values vary by family.</param>
		/// <param name="process">(Optional) Gets process</param>
		/// <param name="junction_temp">(Optional) Junction Temperature (C): auto|degC</param>
		/// <param name="ambient_temp">(Optional) Ambient Temperature (C): default|degC</param>
		/// <param name="thetaja">(Optional) ThetaJA (C/W): auto|degC/W</param>
		/// <param name="thetasa">(Optional) Gets ThetaSA</param>
		/// <param name="airflow">(Optional) Airflow (LFM): 0 to 750</param>
		/// <param name="heatsink">(Optional) Gets dimensions of heatsink</param>
		/// <param name="thetajb">(Optional) Gets ThetaJB</param>
		/// <param name="board">(Optional) Board type: jedec, small, medium, large, custom</param>
		/// <param name="board_temp">(Optional) Board Temperature degC</param>
		/// <param name="board_layers">(Optional) Board layers: 4to7, 8to11, 12to15, 16+</param>
		/// <param name="design_power_budget">(Optional) Design Power Budget (W)</param>
		/// <param name="all">(Optional) Gets all operating conditions listed in this help message</param>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="return_string">(Optional) return operating conditions as string</param>
		/// <param name="append">(Optional) append operating conditions to end of file</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_operating_conditions(string voltage = null, bool? grade = null, bool? process = null, bool? junction_temp = null, bool? ambient_temp = null, bool? thetaja = null, bool? thetasa = null, bool? airflow = null, bool? heatsink = null, bool? thetajb = null, bool? board = null, bool? board_temp = null, bool? board_layers = null, bool? design_power_budget = null, bool? all = null, string file = null, bool? return_string = null, bool? append = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_operating_conditions [-voltage <args>] [-grade] [-process] [-junction_temp] [-ambient_temp] [-thetaja] [-thetasa] [-airflow] [-heatsink] [-thetajb] [-board] [-board_temp] [-board_layers] [-design_power_budget] [-all] [-file <arg>] [-return_string] [-append] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_operating_conditions")
					.OptionalNamedString("voltage", voltage)
					.Flag("grade", grade)
					.Flag("process", process)
					.Flag("junction_temp", junction_temp)
					.Flag("ambient_temp", ambient_temp)
					.Flag("thetaja", thetaja)
					.Flag("thetasa", thetasa)
					.Flag("airflow", airflow)
					.Flag("heatsink", heatsink)
					.Flag("thetajb", thetajb)
					.Flag("board", board)
					.Flag("board_temp", board_temp)
					.Flag("board_layers", board_layers)
					.Flag("design_power_budget", design_power_budget)
					.Flag("all", all)
					.OptionalNamedString("file", file)
					.Flag("return_string", return_string)
					.Flag("append", append)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Get information about all parameters
		///
		///
		/// TCL Syntax: report_param [-file <arg>] [-append] [-non_default] [-return_string] [-quiet] [-verbose] [<pattern>]
		///
		/// Gets a list of all user-definable parameters, the current value, and a description of what the
		/// parameter configures or controls.
		///
		/// The following example returns the name, value, and description of all user-definable parameters:
		/// report_param
		/// The following example returns the name, value, and description of user-definable parameters
		/// that match the specified search pattern:
		/// report_param *coll*
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1368
		/// </summary>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="non_default">(Optional) Report only params that are set to a non default value</param>
		/// <param name="return_string">(Optional) Return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="pattern">(Optional) Display params matching pattern Default: *</param>
		/// <returns>param report</returns>
		public virtual SimpleTCLCommand report_param(string file = null, bool? append = null, bool? non_default = null, bool? return_string = null, bool? quiet = null, bool? verbose = null, string pattern = null)
		{
			// TCL Syntax: report_param [-file <arg>] [-append] [-non_default] [-return_string] [-quiet] [-verbose] [<pattern>]
			return
				new SimpleTCLCommand("report_param")
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.Flag("non_default", non_default)
					.Flag("return_string", return_string)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(pattern)
			;
		}
		/// <summary>
		/// Report details of Physical Synthesis transformations.
		///
		///
		/// TCL Syntax: report_phys_opt [-file <arg>] [-append] [-return_string] [-quiet] [-verbose]
		///
		/// Reports the results of the fanout driver replication and load redistribution optimizations
		/// performed by the phys_opt_design command.
		///
		/// The following example reports the physical optimizations performed in the current design by the
		/// phys_opt_design command:
		/// report_phys_opt -file C:/Data/physOpt_Report.txt
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1370
		/// </summary>
		/// <param name="file">(Optional) Output file</param>
		/// <param name="append">(Optional) Append the results to file</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_phys_opt(string file = null, bool? append = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_phys_opt [-file <arg>] [-append] [-return_string] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_phys_opt")
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.Flag("return_string", return_string)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Perform pipeline register insertion analysis and display report.
		///
		///
		/// TCL Syntax: report_pipeline_analysis [-cells <args>] [-verbose] [-clocks <args>] [-file <arg>] [-include_paths_to_pipeline] [-append] [-max_added_latency <arg>] [-report_loops] [-return_string] [-quiet]
		///
		/// This command performs an analysis of a synthesized design, hypothetically inserting pipeline
		/// stages in the design and reports the potential frequency (Fmax) increase of each clock domain.
		/// The analysis includes a search for loops in the design, which may not be improved by pipelining,
		/// and determines if such loops are critical paths in the design.
		/// Returns a table showing the pipeline stages and the Fmax improvement. The report begins with
		/// the original design and adds stages of latency (1, 2, ... ) until there is no further improvement in
		/// Fmax. This reports a theoretical upper limit to the frequency performance of the design.
		/// The analysis is typically run on the un-placed synthesized netlist where the logical netlist
		/// structure determines the performance. The report can be run on the top-level design, or on out￾of-context (OOC) sub-modules. This report confirms whether the design frequency can be
		/// increased, as well as how many pipeline registers must be added to the design to achieve the
		/// Fmax improvement.
		/// Note: By default the report is written to the Tcl console or STD output. However, the results can also be
		/// written to a file.
		///
		/// The following example returns the name, period, waveform, and sources of the clocks in the
		/// current design:
		/// report_pipeline_analysis -file C:/Data/FPGA_Design/pipeline_report.txt
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1372
		/// </summary>
		/// <param name="cells">
		/// (Optional)
		/// Analyze each of the specified hierarchical cells separately
		/// and ignore feedback loops external to the cells.
		/// </param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="clocks">(Optional) Filter report output to show only the specified clocks</param>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="include_paths_to_pipeline">(Optional) Report paths to cut. (only available if -file is used)</param>
		/// <param name="append">(Optional) Append to existing file</param>
		/// <param name="max_added_latency">
		/// (Optional)
		/// Maximum extra latency that can be inserted into the system
		/// (0 = unlimited). Default: 100
		/// </param>
		/// <param name="report_loops">(Optional) Report loop information as well</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		public virtual SimpleTCLCommand report_pipeline_analysis(string cells = null, bool? verbose = null, string clocks = null, string file = null, bool? include_paths_to_pipeline = null, bool? append = null, string max_added_latency = null, bool? report_loops = null, bool? return_string = null, bool? quiet = null)
		{
			// TCL Syntax: report_pipeline_analysis [-cells <args>] [-verbose] [-clocks <args>] [-file <arg>] [-include_paths_to_pipeline] [-append] [-max_added_latency <arg>] [-report_loops] [-return_string] [-quiet]
			return
				new SimpleTCLCommand("report_pipeline_analysis")
					.OptionalNamedString("cells", cells)
					.Flag("verbose", verbose)
					.OptionalNamedString("clocks", clocks)
					.OptionalNamedString("file", file)
					.Flag("include_paths_to_pipeline", include_paths_to_pipeline)
					.Flag("append", append)
					.OptionalNamedString("max_added_latency", max_added_latency)
					.Flag("report_loops", report_loops)
					.Flag("return_string", return_string)
					.Flag("quiet", quiet)
			;
		}
		/// <summary>
		/// Run power estimation and display report
		///
		///
		/// TCL Syntax: report_power [-no_propagation] [-hier <arg>] [-hierarchical_depth <arg>] [-vid] [-advisory] [-file <arg>] [-name <arg>] [-format <arg>] [-xpe <arg>] [-l <arg>] [-return_string] [-append] [-rpx <arg>] [-quiet] [-verbose]
		///
		/// Run power analysis on the current design, and report details of power consumption based on the
		/// current operating conditions of the device, and the switching rates of the design. The operating
		/// conditions can be set using the set_operating_conditions command. The switching
		/// activity can be defined using the set_switching_activity command.
		/// Switching activity can also be read in from an SAIF file with the read_saif command. The
		/// Vivado tool will annotate the design nodes with activity from the SAIF file and estimate power
		/// appropriately.
		/// Power analysis requires an open synthesized design, or implemented design.
		/// Note: By default the report is written to the Tcl console or STD output. However, the results can also be
		/// written to a file or returned as a string if desired.
		///
		/// The following example performs power analysis, without net propagation, and writes the results
		/// to an XML file for use in XPE:
		/// report_power -no_propagation -xpe C:/Data/design1.xpe
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1375
		/// </summary>
		/// <param name="no_propagation">
		/// (Optional)
		/// Disables the propagation engine to estimate the switching
		/// activity of nets.
		/// </param>
		/// <param name="hier">(Optional) Hierarchy report style (logic, power, or all) Default: power</param>
		/// <param name="hierarchical_depth">(Optional) Specifies the depth level for textual hierarchical report Default: 4</param>
		/// <param name="vid">(Optional) Voltage ID (VID) of device is used</param>
		/// <param name="advisory">(Optional) Dump power advisory text report</param>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="format">(Optional) Format for the power estimation report: text, xml Default: text</param>
		/// <param name="xpe">(Optional) Output the results to XML file for importing into XPE</param>
		/// <param name="l">
		/// (Optional)
		/// Maximum number of lines to report in detailed reports (l >=
		/// 0) Default: 10
		/// </param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="append">(Optional) append power report to end of file</param>
		/// <param name="rpx">(Optional) Filename to output interactive results to.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_power(bool? no_propagation = null, string hier = null, string hierarchical_depth = null, bool? vid = null, bool? advisory = null, string file = null, string name = null, string format = null, string xpe = null, string l = null, bool? return_string = null, bool? append = null, string rpx = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_power [-no_propagation] [-hier <arg>] [-hierarchical_depth <arg>] [-vid] [-advisory] [-file <arg>] [-name <arg>] [-format <arg>] [-xpe <arg>] [-l <arg>] [-return_string] [-append] [-rpx <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_power")
					.Flag("no_propagation", no_propagation)
					.OptionalNamedString("hier", hier)
					.OptionalNamedString("hierarchical_depth", hierarchical_depth)
					.Flag("vid", vid)
					.Flag("advisory", advisory)
					.OptionalNamedString("file", file)
					.OptionalNamedString("name", name)
					.OptionalNamedString("format", format)
					.OptionalNamedString("xpe", xpe)
					.OptionalNamedString("l", l)
					.Flag("return_string", return_string)
					.Flag("append", append)
					.OptionalNamedString("rpx", rpx)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Report power optimizations
		///
		///
		/// TCL Syntax: report_power_opt [-cell <args>] [-file <arg>] [-format <arg>] [-name <arg>] [-append] [-return_string] [-quiet] [-verbose]
		///
		/// Report power optimizations that have been performed on the design with the
		/// power_opt_design command.
		/// Note: By default the report is written to the Tcl console or STD output. However, the results can also be
		/// written to a file or returned as a string if desired.
		///
		/// The following example reports the power optimizations performed on the current design, writing
		/// them to the specified file in an XML format:
		/// report_power_opt -format xml -file C:/Data/power_opt.xml
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1379
		/// </summary>
		/// <param name="cell">(Optional) list of instance names Default: empty</param>
		/// <param name="file">(Optional) output file</param>
		/// <param name="format">
		/// (Optional)
		/// Specifies how to format the report. Default is 'text', another
		/// option is 'xml'. Only applies if -file is used. If xml output is
		/// used, -append is not allowed. Default: text
		/// </param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="append">(Optional) append if existing file. Otherwise overwrite existing file.</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_power_opt(string cell = null, string file = null, string format = null, string name = null, bool? append = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_power_opt [-cell <args>] [-file <arg>] [-format <arg>] [-name <arg>] [-append] [-return_string] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_power_opt")
					.OptionalNamedString("cell", cell)
					.OptionalNamedString("file", file)
					.OptionalNamedString("format", format)
					.OptionalNamedString("name", name)
					.Flag("append", append)
					.Flag("return_string", return_string)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Report reconfigurable partition analysis across multiple configurations
		///
		///
		/// TCL Syntax: report_pr_configuration_analysis [-complexity] [-clocking] [-timing] [-cells <args>] [-dcps <args>] [-rent] [-nworst <arg>] [-file <arg>] [-quiet] [-verbose]
		///
		/// IMPORTANT! You must first define the project as a Partial Reconfiguration (PR) project by setting the
		/// PR_FLOW property on the project to TRUE, or by using the Tools > Enable Partial Reconfiguration command.
		/// Report reconfigurable partition analysis across multiple configurations as defined by
		/// create_pr_configuration. This report compares each Reconfigurable Module that you
		/// select to give you input on your PR design. It examines resource usage, floorplanning, clocking,
		/// and timing metrics to help you manage the overall PR design. For more information on this
		/// command refer to the Vivado Design Suite User Guide: Dynamic Function eXchange (UG909).
		/// When this analysis is done, each RM is examined based on information in the checkpoints
		/// provided. While post-synthesis checkpoints can be supplied, the most complete information is
		/// not available until after opt_design when all the linking and expansion has been done.
		///
		/// The following example performs complexity analysis of the design:
		/// report_pr_configuration_analysis -complexity
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1381
		/// </summary>
		/// <param name="complexity">(Optional) Run complexity analysis</param>
		/// <param name="clocking">(Optional) Run clocking analysis</param>
		/// <param name="timing">(Optional) Run boundary net timing analysis</param>
		/// <param name="cells">(Optional) List of reconfigurable cell names</param>
		/// <param name="dcps">
		/// (Optional)
		/// List of design checkpoints for each reconfigurable cell. The
		/// order of dcps must match that of the -cells option.
		/// </param>
		/// <param name="rent">
		/// (Optional)
		/// Compute Rents component as part of complexity analysis.
		/// Runtime intensive for large designs.
		/// </param>
		/// <param name="nworst">(Optional) Specifies the N worst boundary paths. Default: 10</param>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_pr_configuration_analysis(bool? complexity = null, bool? clocking = null, bool? timing = null, string cells = null, string dcps = null, bool? rent = null, string nworst = null, string file = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_pr_configuration_analysis [-complexity] [-clocking] [-timing] [-cells <args>] [-dcps <args>] [-rent] [-nworst <arg>] [-file <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_pr_configuration_analysis")
					.Flag("complexity", complexity)
					.Flag("clocking", clocking)
					.Flag("timing", timing)
					.OptionalNamedString("cells", cells)
					.OptionalNamedString("dcps", dcps)
					.Flag("rent", rent)
					.OptionalNamedString("nworst", nworst)
					.OptionalNamedString("file", file)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Report properties of object
		///
		///
		/// TCL Syntax: report_property [-all] [-class <arg>] [-return_string] [-file <arg>] [-append] [-regexp] [-quiet] [-verbose] [<object>] [<pattern>]
		///
		/// Gets the property name, property type, and property value for all of the properties on a specified
		/// object, or class of objects.
		/// Note: list_property also returns a list of all properties on an object, but does not include the property
		/// type or value.
		/// You can specify objects for report_property using the get_* series of commands to get a
		/// specific object. You can use the lindex command to return a specific object from a list of
		/// objects:
		/// report_property [lindex [get_cells] 0]
		/// However, if you are looking for the properties on a class of objects, you should use the -
		/// classoption instead of an actual object.
		/// This command returns a report of properties on the object, or returns an error if it fails.
		///
		/// The following example returns all properties of the specified object:
		/// report_property -all [get_cells cpuEngine]
		/// The following example returns the properties of the specified class of objects, rather than an
		/// actual object:
		/// report_property -class bel
		/// The following example returns properties on the current hw_device that match the specified
		/// pattern, specified as a regular expression:
		/// report_property [current_hw_device] -regexp .*PROG.*
		/// To determine which properties are available for the different design objects supported by the
		/// tool, you can use multiple report_property commands in sequence. The following example
		/// returns all properties of the specified current objects:
		/// report_property -all [current_project]
		/// report_property -all [current_fileset]
		/// report_property -all [current_design]
		/// report_property -all [current_run]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1384
		/// </summary>
		/// <param name="all">(Optional) Report all properties of object even if not set</param>
		/// <param name="@class">(Optional) Object type to query for properties. Not valid with <object></param>
		/// <param name="return_string">
		/// (Optional)
		/// Set the result of running report_property in the Tcl
		/// interpreter's result variable
		/// </param>
		/// <param name="file">
		/// (Optional)
		/// Filename to output result to. Send output to console if -file
		/// is not used
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="regexp">(Optional) Pattern is treated as a regular expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="@object">(Optional) Object to query for properties</param>
		/// <param name="pattern">(Optional) Pattern to match properties against Default: *</param>
		/// <returns>property report</returns>
		public virtual SimpleTCLCommand report_property(bool? all = null, string @class = null, bool? return_string = null, string file = null, bool? append = null, bool? regexp = null, bool? quiet = null, bool? verbose = null, string @object = null, string pattern = null)
		{
			// TCL Syntax: report_property [-all] [-class <arg>] [-return_string] [-file <arg>] [-append] [-regexp] [-quiet] [-verbose] [<object>] [<pattern>]
			return
				new SimpleTCLCommand("report_property")
					.Flag("all", all)
					.OptionalNamedString("class", @class)
					.Flag("return_string", return_string)
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.Flag("regexp", regexp)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(@object)
					.OptionalString(pattern)
			;
		}
		/// <summary>
		/// Report pulse width check
		///
		///
		/// TCL Syntax: report_pulse_width [-file <arg>] [-append] [-name <arg>] [-return_string] [-warn_on_violation] [-all_violators] [-significant_digits <arg>] [-limit <arg>] [-min_period] [-max_period] [-low_pulse] [-high_pulse] [-max_skew] [-clocks <args>] [-no_header] [-cells <args>] [-rpx <arg>] [-quiet] [-verbose] [<objects>]
		///
		/// Reports the pulse width of the specified clock signals in the clock network and upon reaching the
		/// flip-flop. This command also performs high pulse width checking, using maximum delay for the
		/// rising edge and minimum delay for the falling edge of the clock. Performs low pulse width
		/// checking using minimum delay for the rising edge, and maximum delay for the falling edge. This
		/// results in a worst case analysis for the current Synthesis or Implemented Design because it
		/// assumes worst-case delays for both rising and falling edges. This command also reports the
		/// maximum skew, or maximum timing separation allowed between clock signals.
		/// The report includes minimum pulse width, maximum pulse width, low pulse width, high pulse
		/// width, and max skew checks by default. However, selecting a specific check will disable the other
		/// checks unless they are also specified.
		/// The default report is returned to the standard output, but can be redirected to a file, or to a Tcl
		/// string variable for further processing. The report is returned to the standard output by default,
		/// unless the -file, -return_string, or -name arguments are specified.
		///
		/// The following example performs the minimum period and low pulse width check, returning the
		/// results to a named results set in the GUI:
		/// report_pulse_width -min_period -low_pulse -name timing_1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1388
		/// </summary>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="name">(Optional) Results name in which to store output</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="warn_on_violation">(Optional) issue a critical warning when the report contains a timing violation</param>
		/// <param name="all_violators">(Optional) Only report pins/ports where check violations occur</param>
		/// <param name="significant_digits">(Optional) Number of digits to display: Range: 0 to 3 Default: 3</param>
		/// <param name="limit">
		/// (Optional)
		/// Number of checks of a particular type to report per clock:
		/// Default is 1 Default: 1
		/// </param>
		/// <param name="min_period">(Optional) Only report min period checks</param>
		/// <param name="max_period">(Optional) Only report max period checks</param>
		/// <param name="low_pulse">(Optional) Only report min low pulse width checks</param>
		/// <param name="high_pulse">(Optional) Only report min high pulse width checks</param>
		/// <param name="max_skew">(Optional) Only report max skew checks</param>
		/// <param name="clocks">(Optional) List of clocks for which to report min pulse width/min period checks</param>
		/// <param name="no_header">(Optional) </param>
		/// <param name="cells">(Optional) run report_pulse_width on the specified cell(s)</param>
		/// <param name="rpx">(Optional) Filename to output interactive results to.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">(Optional) List of objects to check min pulse width with</param>
		public virtual SimpleTCLCommand report_pulse_width(string file = null, bool? append = null, string name = null, bool? return_string = null, bool? warn_on_violation = null, bool? all_violators = null, string significant_digits = null, string limit = null, bool? min_period = null, bool? max_period = null, bool? low_pulse = null, bool? high_pulse = null, bool? max_skew = null, string clocks = null, bool? no_header = null, string cells = null, string rpx = null, bool? quiet = null, bool? verbose = null, string objects = null)
		{
			// TCL Syntax: report_pulse_width [-file <arg>] [-append] [-name <arg>] [-return_string] [-warn_on_violation] [-all_violators] [-significant_digits <arg>] [-limit <arg>] [-min_period] [-max_period] [-low_pulse] [-high_pulse] [-max_skew] [-clocks <args>] [-no_header] [-cells <args>] [-rpx <arg>] [-quiet] [-verbose] [<objects>]
			return
				new SimpleTCLCommand("report_pulse_width")
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.OptionalNamedString("name", name)
					.Flag("return_string", return_string)
					.Flag("warn_on_violation", warn_on_violation)
					.Flag("all_violators", all_violators)
					.OptionalNamedString("significant_digits", significant_digits)
					.OptionalNamedString("limit", limit)
					.Flag("min_period", min_period)
					.Flag("max_period", max_period)
					.Flag("low_pulse", low_pulse)
					.Flag("high_pulse", high_pulse)
					.Flag("max_skew", max_skew)
					.OptionalNamedString("clocks", clocks)
					.Flag("no_header", no_header)
					.OptionalNamedString("cells", cells)
					.OptionalNamedString("rpx", rpx)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(objects)
			;
		}
		/// <summary>
		/// Feasibility Checks
		///
		///
		/// TCL Syntax: report_qor_assessment [-file <arg>] [-max_paths <arg>] [-append] [-quiet] [-verbose]
		///
		/// This command look for trouble spots in the design and assesses the likelihood of a design
		/// meeting design goals. This command requires an open elaborated, synthesized or implemented
		/// design for analysis.
		/// The Report QoR Assessment covers multiple categories:
		/// • Design Methodology
		/// • Synthesis
		/// • Implementation
		/// • Design Hierarchy
		/// • Partial Reconfiguration
		/// • Floorplanning
		/// The report_qor_assessment command includes a subset of report_methodology checks
		/// identifying bad practices that can lead to an expected problem. Yet, report_qor_assessment
		/// is also more comprehensive than report_methodology, because it includes other checks that
		/// are not necessarily bad practices but may have low success due to the structure, style, size, or
		/// complexity of the current design.
		/// A key feature of Report QOR Assessment is the ability to predict certain conditions that lead to
		/// congestion and performance degradation. This command can be run at any stage of the
		/// implementation flow after synthesis. The report_qor_assessment command will return a
		/// score from 1 - 5, where 1 is a failing grade, and 5 means the design will likely pass
		/// implementation and meet timing.
		/// For violations found by Report QOR Assessment, the Report QOR Suggestions command will
		/// make recommendations on how to avoid issues, or modify the design to improve results.
		///
		/// The following example reports suggestions after analyzing the worst 10 paths:
		/// report_qor_assessment -max_paths 10
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1392
		/// </summary>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="max_paths">(Optional) Number of paths to consider for suggestion analysis Default: 100</param>
		/// <param name="append">(Optional) Append the results to file, do not overwrite the results file</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_qor_assessment(string file = null, string max_paths = null, bool? append = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_qor_assessment [-file <arg>] [-max_paths <arg>] [-append] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_qor_assessment")
					.OptionalNamedString("file", file)
					.OptionalNamedString("max_paths", max_paths)
					.Flag("append", append)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Recommend QoR Suggestions
		///
		///
		/// TCL Syntax: report_qor_suggestions [-file <arg>] [-name <arg>] [-append] [-return_string] [-max_strategies <arg>] [-max_paths <arg>] [-evaluate_pipelining] [-no_split] [-models_dir <arg>] [-cell <args>] [-of_objects <args>] [-quiet] [-verbose]
		///
		/// Report design and tool option recommendations related to improving the quality of results (QoR).
		/// The report looks at timing constraints, netlist characteristics, failing timing paths, and congestion
		/// information to determine suggestions that can enhance the QoR. The report can be generated
		/// after synthesis, or after any implementation step, but requires a design to be open.
		/// The report_qor_suggestions command creates QoR suggestion objects related to the
		/// suggestions identified. These suggestion objects can be enabled for use by the Vivado tools to
		/// improve the quality of synthesis and implementation results. Some of these suggestions can be
		/// automatically applied, and some may require more manual intervention to implement design
		/// changes, or write Tcl design constraints.
		/// Suggestion objects can be obtained using the get_qor_suggestions command. The QoR
		/// objects have properties that define what step they are APPLICABLE_FOR, if they are ENABLED
		/// to be used, if they can be automatically applied (AUTO), or what step the suggestions was
		/// GENERATED_AT. A suggestion must be ENABLED and the APPLICABLE_FOR synthesis or
		/// implementation step run in order for a suggestion to be applied to the design.
		/// You can write the suggestions from the design into an RQS file using the
		/// write_qor_suggestions command. After resetting the design flow to the appropriate step,
		/// you can read suggestions back into the design using the read_qor_suggestions command,
		/// and then run the synthesis or implementation step to apply the enabled suggestions.
		/// The recommended method for working with QoR suggestions is:
		/// 1. Run the report to create recommendations (report_qor_suggestions)
		/// 2. Look at and ENABLE the suggestions you want to use (get_qor_suggestions)
		/// 3. Write the suggestions to an RQS file on disk (write_qor_suggestions).
		/// 4. Reset the design to the appropriate step.
		/// 5. Read the RQS file into the design to restore the suggestions (read_qor_suggestions).
		/// 6. Run the synthesis or implementation step to apply the suggestion (synth_design,
		/// opt_design...).
		///
		/// The following example reports suggestions after analyzing the worst 10 paths:
		/// report_qor_suggestions -max_paths 10
		/// This example reports existing suggestions in the design from a prior run of
		/// report_qor_suggestions:
		/// report_qor_suggestions -of_objects [get_qor_suggestions]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1395
		/// </summary>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="return_string">(Optional) Return report as string</param>
		/// <param name="max_strategies">(Optional) Number of strategies to suggest Default: 3</param>
		/// <param name="max_paths">(Optional) Number of paths to consider for suggestion analysis Default: 100</param>
		/// <param name="evaluate_pipelining">(Optional) Generate DSP/BRAM pipelining xdc file</param>
		/// <param name="no_split">(Optional) Report without spliting the lines in tables</param>
		/// <param name="models_dir">
		/// (Optional)
		/// Path to the directory which consists of the models Default: /
		/// proj/rdi-xco/builds/HEAD/nightly/RUNNING_ BUILD/
		/// packages/customer/vivado/data/deca/models_dir
		/// </param>
		/// <param name="cell">(Optional) Report QOR suggestions for a given cell</param>
		/// <param name="of_objects">(Optional) List of QoR suggestion objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_qor_suggestions(string file = null, string name = null, bool? append = null, bool? return_string = null, string max_strategies = null, string max_paths = null, bool? evaluate_pipelining = null, bool? no_split = null, string models_dir = null, string cell = null, string of_objects = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_qor_suggestions [-file <arg>] [-name <arg>] [-append] [-return_string] [-max_strategies <arg>] [-max_paths <arg>] [-evaluate_pipelining] [-no_split] [-models_dir <arg>] [-cell <args>] [-of_objects <args>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_qor_suggestions")
					.OptionalNamedString("file", file)
					.OptionalNamedString("name", name)
					.Flag("append", append)
					.Flag("return_string", return_string)
					.OptionalNamedString("max_strategies", max_strategies)
					.OptionalNamedString("max_paths", max_paths)
					.Flag("evaluate_pipelining", evaluate_pipelining)
					.Flag("no_split", no_split)
					.OptionalNamedString("models_dir", models_dir)
					.OptionalNamedString("cell", cell)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Report configuration about RAMs in design
		///
		///
		/// TCL Syntax: report_ram_utilization [-append] [-file <arg>] [-return_string] [-cells <args>] [-include_path_info] [-detail] [-quiet] [-verbose]
		///
		/// Report RAM resource usage on the target part in the current synthesized or implemented design.
		/// The report is returned to the standard output, unless the -file or -return_string
		/// arguments are used.
		/// The report details the following tables:
		/// • Summary: The Summary table shows the utilization by RAM type, broken down into URAM,
		/// Block RAM and Distributed RAM. For each RAM type, it is broken down into the individual
		/// primitives. Also detailed is the inferred primitives. The inferred primitive % is important as the
		/// remaining tables are dependent on information provided by Vivado Synthesis during
		/// inference.
		/// Primitives that are directly inferred or inferred by use of XPMs, will be grouped by their RTL
		/// description. The report details how the RTL description of the array has been mapped to the
		/// primitives in the part, the key performance aspects of each port and connection information
		/// that can be used to determine if it is efficiently implemented from a power perspective.
		/// If using a different synthesis tool or instantiation of primitives is prevalent in the design then
		/// the -detail switch can be used to provide some more information but it will not group RAM
		/// together into larger arrays and some information will be lost. Only the Summary and Non￾Inferred primitives table are available.
		/// This information in the summary can be used to determine if there are imbalances in the
		/// utilization of different types of rams. The accuracy of the information increase after
		/// place_design. Based on the summary, a design might benefit from retargeting heavily used
		/// primitives to lesser used ones at the cost of being less efficient.
		/// Additionally Distributed RAM implementation can be evaluated. Distributed RAM primitives
		/// vary in their efficiency of Bits/LUT. For example, a RAM32M16 uses 8 LUTs and can have up
		/// to 14 data bits. Using RAM32X1D primitives, 8 LUTs yields a maximum of 8 bits when LUT
		/// combined.
		/// • Memory Description: The Memory Description table gives an RTL look at the inferred
		/// memories. It looks at depth, width, memory type and timing requirement. The table is ordered
		/// by the total number of bits in the memory array. The array name is repeated in the other
		/// tables so it can be used as a search term when the report is large.
		/// Note: For distributed RAMs, the read/write port is mapped to Port A and read port information is
		/// mapped to Port B regardless of the primitive port naming.
		/// • Memory Utilization: The Memory Utilization table details how each memory array is mapped
		/// to primitives. Also provided is information on how efficient the mapping is and whether the
		/// mapping is limited by depth or width.
		/// • Memory Performance: The Memory Performance table details performance aspects of the
		/// RAM. It includes information whether the output register is used, cascading has been used. If
		/// the -include_path_info switch is specified there is extra information on the worst path
		/// from each pin listed.
		/// • Memory Power: The Memory Power table details what power aspects of the RAM have been
		/// used. It includes information on cascading and whether the enable pin is tied to POWER or a
		/// signal.
		/// • Non-Inferred Memory Primitives: This table is reported when the -details option is
		/// specified. This will collate as much information as is possible for each primitive that is not
		/// inferred, and list it here. Due to the size of this part of the report, distributed RAM is not
		/// included.
		/// This command returns the requested report to the Tcl console, to a file, or as a string; or returns
		/// an error if it fails.
		///
		/// The following example provides a full report of the inferred and non-inferred RAM resources and
		/// writes the results to the specified file:
		/// report_ram_utilization -file C:/Data/ram_util.txt
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1399
		/// </summary>
		/// <param name="append">(Optional) Append to existing file</param>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="cells">
		/// (Optional)
		/// Limits the reporting to only those memory arrays that are
		/// contained within the specified cells.
		/// </param>
		/// <param name="include_path_info">(Optional) Adds path info to the RAM inputs/outputs</param>
		/// <param name="detail">
		/// (Optional)
		/// When specified, the report will include information on
		/// primitives that are either not inferred or have been inferred
		/// with prior versions of Vivado Synthesis.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Report</returns>
		public virtual SimpleTCLCommand report_ram_utilization(bool? append = null, string file = null, bool? return_string = null, string cells = null, bool? include_path_info = null, bool? detail = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_ram_utilization [-append] [-file <arg>] [-return_string] [-cells <args>] [-include_path_info] [-detail] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_ram_utilization")
					.Flag("append", append)
					.OptionalNamedString("file", file)
					.Flag("return_string", return_string)
					.OptionalNamedString("cells", cells)
					.Flag("include_path_info", include_path_info)
					.Flag("detail", detail)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Report on status of the routing.
		///
		///
		/// TCL Syntax: report_route_status [-return_string] [-file <arg>] [-append] [-of_objects <args>] [-route_type <arg>] [-list_all_nets] [-show_all] [-dump_routes] [-has_routing] [-boolean_check <arg>] [-ignore_cache] [-quiet] [-verbose]
		///
		/// Reports the state of routing in the current design.
		/// The route status report can include a wide range of information, from a simple 1 if the design has
		/// routing, to a complete route tree for each net in the design.
		///
		/// The following example reports the route status for the specified nets:
		/// report_route_status -of_objects [get_nets u4*]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1402
		/// </summary>
		/// <param name="return_string">
		/// (Optional)
		/// Set the result of running the report in the Tcl interpreter's
		/// result variable
		/// </param>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="of_objects">(Optional) Report detailed routing for these routes</param>
		/// <param name="route_type">
		/// (Optional)
		/// Only show routes with the given status: UNPLACED|
		/// NOLOADS|NODRIVER|UNROUTED|ANTENNAS|
		/// CONFLICTS|PAR TIAL|INTRASITE|HIERPORT|ROUTED
		/// (ignored if -of_objects is used)
		/// </param>
		/// <param name="list_all_nets">
		/// (Optional)
		/// list full route information for every net in the design
		/// (ignored if -of_objects is used)
		/// </param>
		/// <param name="show_all">
		/// (Optional)
		/// list all relevant pins for routes marked as UNPLACED or
		/// PARTIAL routes and list all relevant nodes for routes marked
		/// as ANTENNAS or CONFLICTS routes (by default only the first
		/// 15 pins or nodes are listed for a route)
		/// </param>
		/// <param name="dump_routes">
		/// (Optional)
		/// show the full routing tree for every routed net in the design.
		/// This is VERY VERBOSE.
		/// </param>
		/// <param name="has_routing">
		/// (Optional)
		/// returns 0 if there is no routing currently stored for this
		/// design and 1 if there is. All other options are ignored.
		/// </param>
		/// <param name="boolean_check">
		/// (Optional)
		/// returns 1 if the given flag is true and 0 if it is not. Value flags
		/// that can be checked are: PLACED_FULLY|
		/// PARTIALLY_ROUTED|ROUTED_FULLY|ERRORS_IN_ROUT ES.
		/// All other options are ignored (cannot be used with -
		/// has_routing).
		/// </param>
		/// <param name="ignore_cache">
		/// (Optional)
		/// throw away all cached information and recalculate the route
		/// status for the entire design (slow)
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_route_status(bool? return_string = null, string file = null, bool? append = null, string of_objects = null, string route_type = null, bool? list_all_nets = null, bool? show_all = null, bool? dump_routes = null, bool? has_routing = null, string boolean_check = null, bool? ignore_cache = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_route_status [-return_string] [-file <arg>] [-append] [-of_objects <args>] [-route_type <arg>] [-list_all_nets] [-show_all] [-dump_routes] [-has_routing] [-boolean_check <arg>] [-ignore_cache] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_route_status")
					.Flag("return_string", return_string)
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.OptionalNamedString("of_objects", of_objects)
					.OptionalNamedString("route_type", route_type)
					.Flag("list_all_nets", list_all_nets)
					.Flag("show_all", show_all)
					.Flag("dump_routes", dump_routes)
					.Flag("has_routing", has_routing)
					.OptionalNamedString("boolean_check", boolean_check)
					.Flag("ignore_cache", ignore_cache)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Print names of the children scopes (declarative regions) of given scope(s) or the current scope
		///
		///
		/// TCL Syntax: report_scopes [-quiet] [-verbose] [<hdl_scopes>...]
		///
		/// Reports the names and types of HDL Scopes in the current scope of the current simulation, or of
		/// specified scopes.
		/// An HDL Scope is a declarative region of an HDL file, where objects are declared. The following
		/// are examples of HDL Scopes in Verilog and VHDL:
		/// • Verilog scopes: module, function, task, process, other begin-end blocks
		/// • VHDL scopes: entity/architecture pair, block, function, procedure, process
		/// You must have an open simulation to use this command.
		///
		/// The following example reports the children scopes of /tb/UUT:
		/// report_scopes [get_scopes /tb/UUT/* filter {type==module}
		/// The following example reports the children scopes of the current scope:
		/// report_scopes
		/// VHDL Instance: {U_DEBOUNCE_0}
		/// VHDL Instance: {U_DEBOUNCE_1}
		/// VHDL Instance: {U_SINEGEN}
		/// VHDL Instance: {U_FSM}
		/// VHDL Process: {line__138}
		/// VHDL Process: {line__184}
		/// VHDL Process: {line__185}
		/// VHDL Process: {line__186}
		/// VHDL Process: {line__187}
		/// VHDL Process: {line__191}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1406
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hdl_scopes">(Optional) The hdl_objects to report. Default is report_scopes [get_scopes *]</param>
		/// <returns>report_scopes prints a subset of properties of the HDL scope on console in textual format</returns>
		public virtual SimpleTCLCommand report_scopes(bool? quiet = null, bool? verbose = null, string hdl_scopes = null)
		{
			// TCL Syntax: report_scopes [-quiet] [-verbose] [<hdl_scopes>...]
			return
				new SimpleTCLCommand("report_scopes")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(hdl_scopes)
			;
		}
		/// <summary>
		/// Report the list of correct SIM_DEVICE attribute values for cell types in the target part
		///
		///
		/// TCL Syntax: report_sim_device [-part <arg>] [-file <arg>] [-append] [-return_string] [-quiet] [-verbose]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1408
		/// </summary>
		/// <param name="part">(Optional) Part</param>
		/// <param name="file">(Optional) Output file</param>
		/// <param name="append">(Optional) Append the results to file</param>
		/// <param name="return_string">(Optional) Return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Report</returns>
		public virtual SimpleTCLCommand report_sim_device(string part = null, string file = null, bool? append = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_sim_device [-part <arg>] [-file <arg>] [-append] [-return_string] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_sim_device")
					.OptionalNamedString("part", part)
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.Flag("return_string", return_string)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Report info of simulation libraries
		///
		///
		/// TCL Syntax: report_simlib_info [-file <arg>] [-append] [-quiet] [-verbose] <path>
		///
		/// Report information on libraries compiled by the compile_simlib command.
		///
		/// The following example reports information related to the compiled simulation library at the
		/// specified path:
		/// report_simlib_info C:/Data/compiled_simlib
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1409
		/// </summary>
		/// <param name="path">(Required) Specify the path for pre-compiled libraries</param>
		/// <param name="file">(Optional) Output file Default: report_simlib_info.log</param>
		/// <param name="append">(Optional) Append mode</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_simlib_info(string path, string file = null, bool? append = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_simlib_info [-file <arg>] [-append] [-quiet] [-verbose] <path>
			return
				new SimpleTCLCommand("report_simlib_info")
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(path)
			;
		}
		/// <summary>
		/// Run SSN analysis on the current package and pinout
		///
		///
		/// TCL Syntax: report_ssn [-name <arg>] [-return_string] [-format <arg>] [-file <arg>] [-append] [-phase] [-quiet] [-verbose]
		///
		/// Perform a simultaneous switching noise (SSN) analysis of the current design. The SSN analysis is
		/// an accurate method for predicting how output switching affects interface noise margins. The
		/// calculation and estimates are based on a range of variables intended to identify potential noise￾related issues in your design and should not be used as final design "sign off" criteria.
		/// SSN analysis provides estimates of the disruption that simultaneously switching outputs can
		/// cause on other output ports in the I/O bank. The SSN predictor incorporates I/O bank-specific
		/// electrical characteristics into the prediction to better model package effects on SSN.
		/// The report_ssn command can be affected by the temperature grade of the selected device as
		/// defined by the -grade option of the set_operating_condition command. Setting the
		/// temperature grade prior to running noise analysis lets you see how noisy signals can be on
		/// Commercial, Extended, Industrial, Q-Grade, or Military grade devices.
		/// By default, report_ssn assumes that every port toggles asynchronously. This results in a
		/// worst-case noise analysis, which may be overly pessimistic. The -phase option lets you consider
		/// clocking information available in the design to more accurately report SSN noise. Clocks must be
		/// defined using the create_clock and create_generated_clock commands. The period,
		/// phase shift and duty cycle of the generated clocks have significant impact on SSN analysis.
		/// The report_ssn command provides a detailed SSN analysis for Xilinx UltraScale architecture
		/// devices, Virtex-7, Kintex-7, and Artix-7 devices. The report is returned to the standard output,
		/// unless the -file, -return_string, or -name arguments are specified.
		/// TIP: Not all parts support the report_ssn command. The Vivado Design Suite will return an error if you run
		/// report_ssn on a target part that does not support SSN analysis. You can query the SSN_REPORT property of
		/// a part to see if it supports the command. Refer to the Examples for more information.
		///
		/// The following example performs an SSN analysis on the current design, formats the output as
		/// HTML, and writes the output to the specified file:
		/// report_ssn -format html -file C:/Data/devSSN.html
		/// The following example performs an SSN analysis, with phase analysis, and returns the output to a
		/// string which is stored in the specified variable:
		/// set devSSN [report_ssn -phase -format html -return_string]
		/// Note: The -format argument in the preceding example is ignored in the absence of -file.
		/// The following example queries the part in the current project to see if it supports the
		/// report_ssn command, and then gets a list of parts from the same part family that support the
		/// command:
		/// get_property SSN_REPORT [get_property PART [current_project]]
		/// get_parts -filter "FAMILY == [get_property FAMILY [get_property PART \
		/// [current_project]]] && SSN_REPORT"
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1411
		/// </summary>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="return_string">(Optional) Return report as string</param>
		/// <param name="format">(Optional) Report format. Valid arguments are CSV, HTML, TXT Default: csv</param>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="append">(Optional) Append the report to the specified file</param>
		/// <param name="phase">(Optional) Account for multi-clock phase in the analysis</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>ssn report</returns>
		public virtual SimpleTCLCommand report_ssn(string name = null, bool? return_string = null, string format = null, string file = null, bool? append = null, bool? phase = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_ssn [-name <arg>] [-return_string] [-format <arg>] [-file <arg>] [-append] [-phase] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_ssn")
					.OptionalNamedString("name", name)
					.Flag("return_string", return_string)
					.OptionalNamedString("format", format)
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.Flag("phase", phase)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Print names of processes in a design, which are waiting inside a subprogram, in textual format
		///
		///
		/// TCL Syntax: report_stacks [-of_instance <arg>] [-quiet] [-verbose]
		///
		/// Print name of the HDL process scopes waiting inside a subprogram in textual format.
		///
		/// Example design:
		/// module top;
		/// int i;
		/// function void f(input int in1);
		/// automatic int a;
		/// a = in1 + 7;
		/// $display($time, " in f :: a %d in1 %d ", a, in1);
		/// endfunction
		/// task automatic t(input int in2);
		/// int b;
		/// b = in2 + 10;
		/// $display($time, " in t :: in2 %d b %d ", in2, b);
		/// #5;
		/// f(b); // Case C
		/// $display($time, " Back in t : after wait and f(%d) ", b);
		/// endtask
		/// initial begin // "/top/Initial18_0"
		/// $display($time, " in initial 1 ");
		/// i = 200;
		/// t(i); // Case B
		/// $display($time, " Back in initial 1 after t(%d) ", i);
		/// end
		/// initial begin // "/top/Initial25_1"
		/// $display($time, " in initial 2 ");
		/// #2;
		/// f(50); // Case A
		/// $display($time, " Back in initial 2 after f(50) ");
		/// end
		/// endmodule
		/// When simulation is stopped inside function "f" for its call at 'Case A' , the two processes /top/
		/// Initial18_0 and /top/Initial25_1, are waiting inside task "t" (call at 'CaseB') and
		/// function "f" (call at 'CaseA') respectively.
		/// 1. > report_stacks
		/// Verilog Process: {/top/Initial18_0}
		/// Verilog Process: {/top/Initial25_1}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1414
		/// </summary>
		/// <param name="of_instance">(Optional) Default: NULL</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Returns string</returns>
		public virtual SimpleTCLCommand report_stacks(string of_instance = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_stacks [-of_instance <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_stacks")
					.OptionalNamedString("of_instance", of_instance)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Get switching activity on specified objects
		///
		///
		/// TCL Syntax: report_switching_activity [-static_probability] [-signal_rate] [-toggle_rate] [-default_static_probability] [-default_toggle_rate] [-file <arg>] [-return_string] [-append] [-hier] [-all] [-type <args>] [-quiet] [-verbose] [<objects>...]
		///
		/// This command is used to report different kinds of switching activity on design nets, ports, pins,
		/// and cells in the current synthesized or implemented design. These include simple signal rate and
		/// simple static probability on nets, ports, and pins; and state dependent static probabilities on cells.
		/// The reported values are defined using the set_switching_activity command.
		/// Note: This command returns the switching activity for the specified objects, or the current design.
		/// By default the report is written to the Tcl console or STD output. However, the results can also
		/// be written to a file or returned as a string if desired.
		///
		/// The following example reports the signal_rate and static probability value on all output ports:
		/// report_switching_activity -signal_rate -static_probability [all_outputs]
		/// The following example reports the signal_rate and static probability value on all LUT objects in
		/// the design:
		/// report_switching_activity -signal_rate -static_probability -type lut -all
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1416
		/// </summary>
		/// <param name="static_probability">(Optional) report static probability</param>
		/// <param name="signal_rate">(Optional) report signal rate</param>
		/// <param name="toggle_rate">(Optional) report toggle rate</param>
		/// <param name="default_static_probability">(Optional) report default static probability</param>
		/// <param name="default_toggle_rate">(Optional) report default toggle rate</param>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="return_string">(Optional) return switching activity as string</param>
		/// <param name="append">(Optional) append switching activity to end of file</param>
		/// <param name="hier">
		/// (Optional)
		/// Hierarchically reports the switching activity on nets within a
		/// hierarchical instance provided via <objects> option.
		/// </param>
		/// <param name="all">(Optional) Report switching activities for all nets for the design.</param>
		/// <param name="type">
		/// (Optional)
		/// Specify nodes in a specific category. List of valid type values:
		/// io_output, io_bidir_enable, register, lut_ram, lut, dsp,
		/// bram_enable, bram_wr_enable, gt_txdata, gt_rxdata.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">(Optional) objects</param>
		public virtual SimpleTCLCommand report_switching_activity(bool? static_probability = null, bool? signal_rate = null, bool? toggle_rate = null, bool? default_static_probability = null, bool? default_toggle_rate = null, string file = null, bool? return_string = null, bool? append = null, bool? hier = null, bool? all = null, string type = null, bool? quiet = null, bool? verbose = null, string objects = null)
		{
			// TCL Syntax: report_switching_activity [-static_probability] [-signal_rate] [-toggle_rate] [-default_static_probability] [-default_toggle_rate] [-file <arg>] [-return_string] [-append] [-hier] [-all] [-type <args>] [-quiet] [-verbose] [<objects>...]
			return
				new SimpleTCLCommand("report_switching_activity")
					.Flag("static_probability", static_probability)
					.Flag("signal_rate", signal_rate)
					.Flag("toggle_rate", toggle_rate)
					.Flag("default_static_probability", default_static_probability)
					.Flag("default_toggle_rate", default_toggle_rate)
					.OptionalNamedString("file", file)
					.Flag("return_string", return_string)
					.Flag("append", append)
					.Flag("hier", hier)
					.Flag("all", all)
					.OptionalNamedString("type", type)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(objects)
			;
		}
		/// <summary>
		/// Compute mean time between failures and display report
		///
		///
		/// TCL Syntax: report_synchronizer_mtbf [-file <arg>] [-append] [-return_string] [-warn_if_mtbf_below <arg>] [-quiet] [-no_header] [-report_endpoints] [-verbose]
		///
		/// RECOMMENDED: This command is supported for Xilinx UltraScale devices only, and does not support 7 series
		/// devices.
		/// The report_synchronizer_mtbf command reports mean time between failures (MTBF) of
		/// each clock domain crossing (CDC) synchronizer chain in a design, and provides an overall MTBF
		/// covering all synchronizers. Synchronizer registers must have ASYNC_REG properties with value
		/// TRUE to be properly identified as synchronizers for reporting.
		/// Asynchronous clock domain crossings (CDCs) can fail due to metastability as data is captured
		/// asynchronously and may settle to different values on different loads in the circuit. Synchronizer
		/// registers are used to improve overall circuit reliability for designs which contain multiple clock
		/// domains, in which asynchronous data transfers occur, or in which external asynchronous signals
		/// are captured with an internal clock. A synchronizer chain consists of two or more registers
		/// connected sequentially with the first stage capturing the data signal from the asynchronous clock
		/// domain. The successive register stages provide additional settling time for metastable events and
		/// increase MTBF. The synchronizer registers must have ASYNC_REG properties with values of
		/// TRUE. Besides reporting MTBF, the ASYNC_REG properties instruct synthesis, simulation and
		/// implementation tools to optimize for increased MTBF and improve overall behavior of the
		/// synchronizer circuit.
		/// TIP: Avoid using different set/reset or clock enable control signals on registers within a synchronizer chain.
		/// This command returns the MTBF report, or returns an error if it fails. The command issues a
		/// warning message when the MTBF cannot be calculated correctly, for example when a CDC is
		/// improperly constrained. The following conditions result in an UNDEFINED synchronizer MTBF
		/// value:
		/// • One or both clocks of the CDC are unconstrained.
		/// • There is a timing violation involving registers in the synchronizer chain.
		/// • There is a zero toggle rate detected for the CDC data.
		/// In the case of a zero toggle rate, it may be necessary to use the set_switching_activity
		/// command to manually override the toggle rate on the CDC net with a realistic value. This
		/// involves assigning the Toggle Rate and the Static Probability:
		/// • Toggle Rate: The number of CDC data signal transitions measured in Million Transitions per
		/// Second.
		/// • Static Probability: The percentage of time during which the CDC data signal is driven at a high
		/// logic level.
		/// Example: to assign a toggle rate of 12.5% with 0.5 static probability on a CDC net named
		/// resync[0]:
		/// set_switching_activity -toggle_rate 12.5 -static_probability 0.5 \
		/// [get_nets resync[0]]
		/// The report contents include the following data for each synchronizer chain in the design:
		/// • MTBF: The Mean Time Between Failures for the CDC synchronizer reported in dynamic time
		/// units, from seconds to years. An invalid MTBF value is reported as UNDEFINED.
		/// • Data Toggle Rate: The rate at which the CDC data switches, based on the default switching
		/// activity for the design as reported by report_switching_activity. Measured in (Mts)
		/// Millions of Transitions per Second. The rate can be overridden using the
		/// set_switching_activity command targeting the CDC net object.
		/// • Data Sample Rate: The rate at which the CDC data is sampled, equivalent to the synchronizer
		/// chain frequency, measured in MHz.
		/// • Settling Time: The total amount of positive slack in nanoseconds on the timing paths from
		/// synchronizer register outputs. Higher Settling Time increases MTBF.
		/// • Sending Domain: The clock domain of the source of the CDC data. A value of
		/// UNCONSTRAINED is reported if the source clock is not defined.
		/// • Receiving Domain: The clock domain of the destination of the CDC data. A value of
		/// UNCONSTRAINED is reported if the destination clock is not defined.
		/// • Number of Stages: This is the length of the synchronizer chain, which equals the number of
		/// registers with ASYNC_REG value of TRUE. The MTBF calculation will determine the likelihood
		/// that the output register or registers (should the fanout be greater than 1) will experience a
		/// metastable event. For example in a typical synchronizer containing 2 registers with the
		/// ASYNC_REG property set, the MTBF calculation indicates the probability that the output
		/// register(s) following the last ASYNC_REG register will capture an incorrect value resulting from
		/// the metastable event. When a synchronizer is connected to more than 1 output register, the
		/// minimum slack from all the paths will be used in the MTBF calculation to ensure that all
		/// registers capture the same logic level.
		/// • CDC Net Name: This is the logical net name of the CDC data, the data that is captured
		/// asynchronously.
		/// This command returns the MTBF report, or returns an error if it fails.
		/// The report also includes an overall MTBF calculated using the MTBF of all synchronizers in the
		/// design, calculated as the inverse of the sum of the reciprocals of the individual synchronizer
		/// MTBF values: (1 / (1/MTBF_1 + 1/MTBF_2 + … + 1/MTBF_N) ) for N synchronizers.
		///
		/// The following example writes the MTBF report to the specified file:
		/// report_synchronizer_mtbf -file C:/Data/mtbf_report.txt
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1420
		/// </summary>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="return_string">(Optional) Return the report output as a string</param>
		/// <param name="warn_if_mtbf_below">(Optional) Default: 1e+12</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="no_header">(Optional) Report without the header</param>
		/// <param name="report_endpoints">(Optional) Report cdc path end points</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Report</returns>
		public virtual SimpleTCLCommand report_synchronizer_mtbf(string file = null, bool? append = null, bool? return_string = null, string warn_if_mtbf_below = null, bool? quiet = null, bool? no_header = null, bool? report_endpoints = null, bool? verbose = null)
		{
			// TCL Syntax: report_synchronizer_mtbf [-file <arg>] [-append] [-return_string] [-warn_if_mtbf_below <arg>] [-quiet] [-no_header] [-report_endpoints] [-verbose]
			return
				new SimpleTCLCommand("report_synchronizer_mtbf")
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.Flag("return_string", return_string)
					.OptionalNamedString("warn_if_mtbf_below", warn_if_mtbf_below)
					.Flag("quiet", quiet)
					.Flag("no_header", no_header)
					.Flag("report_endpoints", report_endpoints)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Report timing paths
		///
		///
		/// TCL Syntax: report_timing [-from <args>] [-rise_from <args>] [-fall_from <args>] [-to <args>] [-rise_to <args>] [-fall_to <args>] [-through <args>] [-rise_through <args>] [-fall_through <args>] [-delay_type <arg>] [-setup] [-hold] [-max_paths <arg>] [-nworst <arg>] [-unique_pins] [-path_type <arg>] [-input_pins] [-no_header] [-no_reused_label] [-slack_lesser_than <arg>] [-slack_greater_than <arg>] [-group <args>] [-sort_by <arg>] [-no_report_unconstrained] [-user_ignored] [-of_objects <args>] [-significant_digits <arg>] [-column_style <arg>] [-file <arg>] [-append] [-name <arg>] [-no_pr_attribute] [-routable_nets] [-return_string] [-warn_on_violation] [-cells <args>] [-rpx <arg>] [-quiet] [-verbose]
		///
		/// IMPORTANT! If the design has no timing constraints, report_timing reports on unconstrained paths in the
		/// design. However, if even one path has timing constraints then report_timing only reports on the
		/// constrained paths in the design, unless unconstrained timing paths are specified by the -from/-to options.
		/// This command performs timing analysis on the specified timing paths of the current Synthesized
		/// or Implemented Design. By default the tool reports the timing path with the worst calculated
		/// slack within each path group. However, you can optionally increase the number of paths and
		/// delays reported with the use of the -nworst or -max_paths arguments.
		/// TIP: The report_timing can be multi-threaded to speed the process. Refer to the set_param command
		/// for more information on setting the general.maxThreads parameter.
		/// The timing engine runs in "quad" timing mode, analyzing min and max delays for both slow and
		/// fast corners. You can configure the type of analysis performed by the
		/// config_timing_corners command. However, it is not recommended to change the default
		/// because this reduces the timing analysis coverage.
		/// Note: By default the report is written to the Tcl console or STD output. However, the results can also be
		/// written to the GUI, to a file, or returned as a string if desired.
		///
		/// The following example reports the timing for the 5 worst paths in the design, reporting the full
		/// timing path, including input pins, with timing values:
		/// report_timing -nworst 5 -path_type full -input_pins
		/// The following example shows the use of the multiple through points to define both a specific
		/// path (through state_reg1) and alternate paths (through count_3 or count_4), and writes the
		/// timing results to the specified file:
		/// report_timing -from go -through {state_reg1} \
		/// -through { count_3 count_4 } \
		/// -to done -path_type summary -file C:/Data/timing1.txt
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1424
		/// </summary>
		/// <param name="from">(Optional) From pins, ports, cells or clocks</param>
		/// <param name="rise_from">(Optional) Rising from pins, ports, cells or clocks</param>
		/// <param name="fall_from">(Optional) Falling from pins, ports, cells or clocks</param>
		/// <param name="to">(Optional) To pins, ports, cells or clocks</param>
		/// <param name="rise_to">(Optional) Rising to pins, ports, cells or clocks</param>
		/// <param name="fall_to">(Optional) Falling to pins, ports, cells or clocks</param>
		/// <param name="through">(Optional) Through pins, ports, cells or nets</param>
		/// <param name="rise_through">(Optional) Rising through pins, ports, cells or nets</param>
		/// <param name="fall_through">(Optional) Falling through pins, ports, cells or nets</param>
		/// <param name="delay_type">
		/// (Optional)
		/// Type of path delay: Values: max, min, min_max, max_rise,
		/// max_fall, min_rise, min_fall Default: max
		/// </param>
		/// <param name="setup">(Optional) Report max delay timing paths (equivalent to -delay_type max)</param>
		/// <param name="hold">(Optional) Report min delay timing paths (equivalent to -delay_type min)</param>
		/// <param name="max_paths">
		/// (Optional)
		/// Maximum number of paths to output when sorted by slack,
		/// or per path group when sorted by group: Value >=1 Default:
		/// 1
		/// </param>
		/// <param name="nworst">(Optional) List up to N worst paths to endpoint: Value >=1 Default: 1</param>
		/// <param name="unique_pins">(Optional) for each unique set of pins, show at most 1 path per path group</param>
		/// <param name="path_type">
		/// (Optional)
		/// Format for path report: Values: end, summary, short, full,
		/// full_clock, full_clock_expanded Default: full_clock_expanded
		/// </param>
		/// <param name="input_pins">(Optional) Show input pins in path</param>
		/// <param name="no_header">(Optional) Do not generate a report header</param>
		/// <param name="no_reused_label">(Optional) Do not label reuse status on pins in the report Name Description</param>
		/// <param name="slack_lesser_than">(Optional) Display paths with slack less than this Default: 1e+30</param>
		/// <param name="slack_greater_than">(Optional) Display paths with slack greater than this Default: -1e+30</param>
		/// <param name="group">(Optional) Limit report to paths in this group(s)</param>
		/// <param name="sort_by">(Optional) Sorting order of paths: Values: group, slack Default: slack</param>
		/// <param name="no_report_unconstrained">(Optional) Do not report infinite slack paths</param>
		/// <param name="user_ignored">
		/// (Optional)
		/// Only report paths which have infinite slack because of
		/// set_false_path or set_clock_groups timing constraints
		/// </param>
		/// <param name="of_objects">(Optional) Report timing for these paths</param>
		/// <param name="significant_digits">(Optional) Number of digits to display: Range: 0 to 3 Default: 3</param>
		/// <param name="column_style">
		/// (Optional)
		/// style for path report columns: Values: variable_width,
		/// anchor_left, fixed_width Default: anchor_left
		/// </param>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="no_pr_attribute">
		/// (Optional)
		/// for partial reconfiguration designs, do not report whether
		/// netlist resources are in the static or reconfigurable regions
		/// </param>
		/// <param name="routable_nets">
		/// (Optional)
		/// store the number of routable nets traversed as a property
		/// on timing paths.
		/// </param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="warn_on_violation">(Optional) issue a critical warning when the report contains a timing violation</param>
		/// <param name="cells">(Optional) run report_timing on the specified cell(s)</param>
		/// <param name="rpx">(Optional) Filename to output interactive results to.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_timing(string from = null, string rise_from = null, string fall_from = null, string to = null, string rise_to = null, string fall_to = null, string through = null, string rise_through = null, string fall_through = null, string delay_type = null, bool? setup = null, bool? hold = null, string max_paths = null, string nworst = null, bool? unique_pins = null, string path_type = null, bool? input_pins = null, bool? no_header = null, bool? no_reused_label = null, string slack_lesser_than = null, string slack_greater_than = null, string group = null, string sort_by = null, bool? no_report_unconstrained = null, bool? user_ignored = null, string of_objects = null, string significant_digits = null, string column_style = null, string file = null, bool? append = null, string name = null, bool? no_pr_attribute = null, bool? routable_nets = null, bool? return_string = null, bool? warn_on_violation = null, string cells = null, string rpx = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_timing [-from <args>] [-rise_from <args>] [-fall_from <args>] [-to <args>] [-rise_to <args>] [-fall_to <args>] [-through <args>] [-rise_through <args>] [-fall_through <args>] [-delay_type <arg>] [-setup] [-hold] [-max_paths <arg>] [-nworst <arg>] [-unique_pins] [-path_type <arg>] [-input_pins] [-no_header] [-no_reused_label] [-slack_lesser_than <arg>] [-slack_greater_than <arg>] [-group <args>] [-sort_by <arg>] [-no_report_unconstrained] [-user_ignored] [-of_objects <args>] [-significant_digits <arg>] [-column_style <arg>] [-file <arg>] [-append] [-name <arg>] [-no_pr_attribute] [-routable_nets] [-return_string] [-warn_on_violation] [-cells <args>] [-rpx <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_timing")
					.OptionalNamedString("from", from)
					.OptionalNamedString("rise_from", rise_from)
					.OptionalNamedString("fall_from", fall_from)
					.OptionalNamedString("to", to)
					.OptionalNamedString("rise_to", rise_to)
					.OptionalNamedString("fall_to", fall_to)
					.OptionalNamedString("through", through)
					.OptionalNamedString("rise_through", rise_through)
					.OptionalNamedString("fall_through", fall_through)
					.OptionalNamedString("delay_type", delay_type)
					.Flag("setup", setup)
					.Flag("hold", hold)
					.OptionalNamedString("max_paths", max_paths)
					.OptionalNamedString("nworst", nworst)
					.Flag("unique_pins", unique_pins)
					.OptionalNamedString("path_type", path_type)
					.Flag("input_pins", input_pins)
					.Flag("no_header", no_header)
					.Flag("no_reused_label", no_reused_label)
					.OptionalNamedString("slack_lesser_than", slack_lesser_than)
					.OptionalNamedString("slack_greater_than", slack_greater_than)
					.OptionalNamedString("group", group)
					.OptionalNamedString("sort_by", sort_by)
					.Flag("no_report_unconstrained", no_report_unconstrained)
					.Flag("user_ignored", user_ignored)
					.OptionalNamedString("of_objects", of_objects)
					.OptionalNamedString("significant_digits", significant_digits)
					.OptionalNamedString("column_style", column_style)
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.OptionalNamedString("name", name)
					.Flag("no_pr_attribute", no_pr_attribute)
					.Flag("routable_nets", routable_nets)
					.Flag("return_string", return_string)
					.Flag("warn_on_violation", warn_on_violation)
					.OptionalNamedString("cells", cells)
					.OptionalNamedString("rpx", rpx)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Report timing summary
		///
		///
		/// TCL Syntax: report_timing_summary [-check_timing_verbose] [-delay_type <arg>] [-no_detailed_paths] [-setup] [-hold] [-max_paths <arg>] [-nworst <arg>] [-unique_pins] [-path_type <arg>] [-no_reused_label] [-input_pins] [-no_pr_attribute] [-routable_nets] [-slack_lesser_than <arg>] [-report_unconstrained] [-significant_digits <arg>] [-no_header] [-file <arg>] [-append] [-name <arg>] [-return_string] [-warn_on_violation] [-datasheet] [-cells <args>] [-rpx <arg>] [-quiet] [-verbose]
		///
		/// TIP: The report_timing_summary can be multi-threaded to speed the process. Refer to the set_param
		/// command for more information on setting the general.maxThreads parameter.
		/// Generate a timing summary to help understand if the design has met timing requirements. The
		/// timing summary can be run on an open Synthesized or Implemented Design.
		/// The timing summary report includes the following information:
		/// • Timer Settings - Details the timing engine settings used to generate the timing information in
		/// the report.
		/// • Check Timing - Contains the same information that is produced by the check_timing
		/// command, which summarizes potential timing issues.
		/// • Design Timing Summary - Provides a summary of the timing of the design, including values for
		/// worst and total negative slack (WNS/TNS), worst and total hold slack (WHS/THS), and
		/// component switching limits (CSL).
		/// • Clock Definitions - Contains the same information that is produced by the report_clocks
		/// command, showing all the clocks that were created for the design, either by create_clock,
		/// create_generated_clock, or automatically by the tool.
		/// • Intra-Clock Table - Summarizes timing paths with the same source and destination clocks.
		/// • Inter-Clock Table - Summarizes timing paths with different source and destination clocks.
		/// • Path Group Table - Shows default path groups and user-defined path groups created by the
		/// group_path command.
		/// • Timing Details - Contains detailed timing paths, both max delay and min delay, as well as
		/// component switching limits for each clock defined, similar to the report_timing command.
		/// • Data sheet - Contains the same information that is produced by the report_datasheet
		/// command. It contains the timing characteristics of a design at the I/O ports. The data sheet
		/// information is added to the summary report only when the -datasheet option is specified.
		/// This command is automatically run during implementation as part of the launch_runs
		/// command.
		/// Note: By default the report is written to the Tcl console or STD output. However, the results can also be
		/// written to a file or returned as a string if desired.
		///
		/// The following example reports the timing summary of the current design:
		/// report_timing_summary
		/// The following example reports the hold timing summary of the current design, including
		/// unconstrained paths, with the specified options:
		/// report_timing_summary -delay_type min -path_type full_clock_expanded \
		/// -report_unconstrained -max_paths 2 -nworst 1 -significant_digits 2 \
		/// -input_pins -name {timing_6}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1431
		/// </summary>
		/// <param name="check_timing_verbose">
		/// (Optional)
		/// produce a verbose report when checking the design for
		/// potential timing problems
		/// </param>
		/// <param name="delay_type">(Optional) Type of path delay: Values: max, min, min_max Default: min_max</param>
		/// <param name="no_detailed_paths">(Optional) do not report timing paths for each clock and path group analyzed</param>
		/// <param name="setup">(Optional) Report max delay timing paths (equivalent to -delay_type max)</param>
		/// <param name="hold">(Optional) Report min delay timing paths (equivalent to -delay_type min)</param>
		/// <param name="max_paths">
		/// (Optional)
		/// Maximum number of paths to report per clock or path
		/// group: Value >=1 Default: 1
		/// </param>
		/// <param name="nworst">(Optional) List up to N worst paths to endpoint: Value >=1 Default: 1</param>
		/// <param name="unique_pins">(Optional) for each unique set of pins, show at most 1 path per path group</param>
		/// <param name="path_type">
		/// (Optional)
		/// Format for path report: Values: end summary short full
		/// full_clock full_clock_expanded Default: full_clock_expanded
		/// </param>
		/// <param name="no_reused_label">(Optional) Do not label reuse status on pins in the report</param>
		/// <param name="input_pins">(Optional) Show input pins in path</param>
		/// <param name="no_pr_attribute">
		/// (Optional)
		/// for partial reconfiguration designs, do not report whether
		/// netlist resources are in the static or reconfigurable regions
		/// </param>
		/// <param name="routable_nets">
		/// (Optional)
		/// store the number of routable nets traversed as a property
		/// on timing paths.
		/// </param>
		/// <param name="slack_lesser_than">(Optional) Display paths with slack less than this Default: 1e+30</param>
		/// <param name="report_unconstrained">(Optional) report unconstrained and user ignored paths</param>
		/// <param name="significant_digits">(Optional) Number of digits to display: Range: 0 to 3 Default: 3</param>
		/// <param name="no_header">(Optional) do not generate a report header</param>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="append">
		/// (Optional)
		/// Append the results to file, don't overwrite the results file
		/// Name Description
		/// </param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="warn_on_violation">(Optional) issue a critical warning when the report contains a timing violation</param>
		/// <param name="datasheet">(Optional) Include data sheet report</param>
		/// <param name="cells">(Optional) run report_timing_summary on the specified cell(s)</param>
		/// <param name="rpx">(Optional) Filename to output interactive results to.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_timing_summary(bool? check_timing_verbose = null, string delay_type = null, bool? no_detailed_paths = null, bool? setup = null, bool? hold = null, string max_paths = null, string nworst = null, bool? unique_pins = null, string path_type = null, bool? no_reused_label = null, bool? input_pins = null, bool? no_pr_attribute = null, bool? routable_nets = null, string slack_lesser_than = null, bool? report_unconstrained = null, string significant_digits = null, bool? no_header = null, string file = null, bool? append = null, string name = null, bool? return_string = null, bool? warn_on_violation = null, bool? datasheet = null, string cells = null, string rpx = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_timing_summary [-check_timing_verbose] [-delay_type <arg>] [-no_detailed_paths] [-setup] [-hold] [-max_paths <arg>] [-nworst <arg>] [-unique_pins] [-path_type <arg>] [-no_reused_label] [-input_pins] [-no_pr_attribute] [-routable_nets] [-slack_lesser_than <arg>] [-report_unconstrained] [-significant_digits <arg>] [-no_header] [-file <arg>] [-append] [-name <arg>] [-return_string] [-warn_on_violation] [-datasheet] [-cells <args>] [-rpx <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_timing_summary")
					.Flag("check_timing_verbose", check_timing_verbose)
					.OptionalNamedString("delay_type", delay_type)
					.Flag("no_detailed_paths", no_detailed_paths)
					.Flag("setup", setup)
					.Flag("hold", hold)
					.OptionalNamedString("max_paths", max_paths)
					.OptionalNamedString("nworst", nworst)
					.Flag("unique_pins", unique_pins)
					.OptionalNamedString("path_type", path_type)
					.Flag("no_reused_label", no_reused_label)
					.Flag("input_pins", input_pins)
					.Flag("no_pr_attribute", no_pr_attribute)
					.Flag("routable_nets", routable_nets)
					.OptionalNamedString("slack_lesser_than", slack_lesser_than)
					.Flag("report_unconstrained", report_unconstrained)
					.OptionalNamedString("significant_digits", significant_digits)
					.Flag("no_header", no_header)
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.OptionalNamedString("name", name)
					.Flag("return_string", return_string)
					.Flag("warn_on_violation", warn_on_violation)
					.Flag("datasheet", datasheet)
					.OptionalNamedString("cells", cells)
					.OptionalNamedString("rpx", rpx)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Report details of Unisim primitive transformations.
		///
		///
		/// TCL Syntax: report_transformed_primitives [-file <arg>] [-append] [-return_string] [-quiet] [-verbose]
		///
		/// Report the transformed primitives in the current design.
		/// As part of the process of opening the Synthesized design, and loading it into memory, the tool
		/// will transform legacy netlist primitives to the supported subset of Unisim primitives.
		/// As a default this report will be written to the standard output. However, the report can also be
		/// written to a file or returned to a Tcl string variable for further processing.
		///
		/// The following example reports the transformed primitives in the current design, and returns the
		/// result to the specified Tcl variable:
		/// set transPrim [ report_transformed_primitives -return_string ]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1437
		/// </summary>
		/// <param name="file">(Optional) Output file</param>
		/// <param name="append">(Optional) Append the results to file</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_transformed_primitives(string file = null, bool? append = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_transformed_primitives [-file <arg>] [-append] [-return_string] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_transformed_primitives")
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.Flag("return_string", return_string)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Compute utilization of device and display report
		///
		///
		/// TCL Syntax: report_utilization [-file <arg>] [-append] [-pblocks <args>] [-evaluate_pblock] [-exclude_child_pblocks] [-exclude_non_assigned] [-cells <args>] [-return_string] [-slr] [-packthru] [-name <arg>] [-no_primitives] [-omit_locs] [-hierarchical] [-spreadsheet_file <arg>] [-spreadsheet_table <arg>] [-spreadsheet_depth <arg>] [-hierarchical_depth <arg>] [-hierarchical_percentages] [-quiet] [-verbose]
		///
		/// Report resource usage on the target part by the current synthesized or implemented design. The
		/// report is returned to the standard output, unless the -file, -return_string, or -name
		/// arguments are specified.
		/// TIP: Though resource usage can be reported early in the design process, the report will be more accurate as the
		/// design progresses from synthesis through implementation.
		/// This command returns the requested information, or returns an error if it fails.
		///
		/// The following example reports the resources collectively utilized by all the Pblocks in the design,
		/// and writes the results to the specified file:
		/// report_utilization -pblocks [get_pblocks] -file C:/Data/pblocks_util.txt
		/// This example reports the utilization for the whole design to the named report in the GUI, but
		/// exports the "Clocking - BUFGCTRL" table to the specified spreadsheet file:
		/// report_utilization -name utilization_1 -spreadsheet_file util_table.xlsx \
		/// -spreadsheet_table "Clocking - BUFGCTRL"
		/// The following example reports the resources utilized by each Pblock in the design, appending the
		/// report for each Pblock to a single specified file:
		/// foreach x [get_pblocks] {
		/// puts "Reporting Pblock: $x ----------------------------------"
		/// report_utilization -append -file C:/Data/pblocks_util.txt -pblocks $x
		/// }
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1439
		/// </summary>
		/// <param name="file">
		/// (Optional)
		/// Filename to output results to. (send output to console if -file
		/// is not used)
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="pblocks">(Optional) Report utilization of given list of pblocks</param>
		/// <param name="evaluate_pblock">
		/// (Optional)
		/// Report utilization with demand as specified cells and supply
		/// as specified pblock area
		/// </param>
		/// <param name="exclude_child_pblocks">(Optional) Report utilization with out child pblocks</param>
		/// <param name="exclude_non_assigned">(Optional) Pblock utilization with out Non-assigned Cells</param>
		/// <param name="cells">(Optional) Report utilization of given list of cells</param>
		/// <param name="return_string">(Optional) Return report as string</param>
		/// <param name="slr">(Optional) SLR wise utilization of resources</param>
		/// <param name="packthru">(Optional) Reports LUTs used exclusively as pack-thru</param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="no_primitives">(Optional) Removes "Primitives Section" from report_utilization o/p.</param>
		/// <param name="omit_locs">(Optional) Removes "Loced" column from report_utilization o/p.</param>
		/// <param name="hierarchical">(Optional) Generates text-based hierarchical report.</param>
		/// <param name="spreadsheet_file">
		/// (Optional)
		/// Specify file for exporting utilization tables as spreadsheets.
		/// This feature is available only in GUI mode.
		/// </param>
		/// <param name="spreadsheet_table">
		/// (Optional)
		/// Choose a particular utilization table to export as
		/// spreadsheet file. Default value : Hierarchy
		/// </param>
		/// <param name="spreadsheet_depth">
		/// (Optional)
		/// Specifies the depth level for spreadsheet. Default value : 8
		/// Default: 8
		/// </param>
		/// <param name="hierarchical_depth">(Optional) Specifies the depth level for textual hierarchical report Default: 0</param>
		/// <param name="hierarchical_percentages">(Optional) Report percentages in textual hierarchical report Name Description</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Report</returns>
		public virtual SimpleTCLCommand report_utilization(string file = null, bool? append = null, string pblocks = null, bool? evaluate_pblock = null, bool? exclude_child_pblocks = null, bool? exclude_non_assigned = null, string cells = null, bool? return_string = null, bool? slr = null, bool? packthru = null, string name = null, bool? no_primitives = null, bool? omit_locs = null, bool? hierarchical = null, string spreadsheet_file = null, string spreadsheet_table = null, string spreadsheet_depth = null, string hierarchical_depth = null, bool? hierarchical_percentages = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_utilization [-file <arg>] [-append] [-pblocks <args>] [-evaluate_pblock] [-exclude_child_pblocks] [-exclude_non_assigned] [-cells <args>] [-return_string] [-slr] [-packthru] [-name <arg>] [-no_primitives] [-omit_locs] [-hierarchical] [-spreadsheet_file <arg>] [-spreadsheet_table <arg>] [-spreadsheet_depth <arg>] [-hierarchical_depth <arg>] [-hierarchical_percentages] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_utilization")
					.OptionalNamedString("file", file)
					.Flag("append", append)
					.OptionalNamedString("pblocks", pblocks)
					.Flag("evaluate_pblock", evaluate_pblock)
					.Flag("exclude_child_pblocks", exclude_child_pblocks)
					.Flag("exclude_non_assigned", exclude_non_assigned)
					.OptionalNamedString("cells", cells)
					.Flag("return_string", return_string)
					.Flag("slr", slr)
					.Flag("packthru", packthru)
					.OptionalNamedString("name", name)
					.Flag("no_primitives", no_primitives)
					.Flag("omit_locs", omit_locs)
					.Flag("hierarchical", hierarchical)
					.OptionalNamedString("spreadsheet_file", spreadsheet_file)
					.OptionalNamedString("spreadsheet_table", spreadsheet_table)
					.OptionalNamedString("spreadsheet_depth", spreadsheet_depth)
					.OptionalNamedString("hierarchical_depth", hierarchical_depth)
					.Flag("hierarchical_percentages", hierarchical_percentages)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Print current simulated value of given HDL objects (variable, signal, wire, or reg)
		///
		///
		/// TCL Syntax: report_values [-radix <arg>] [-quiet] [-verbose] [<hdl_objects>...]
		///
		/// Report the values of the specified HDL objects at the current simulation run time.
		/// HDL objects include HDL signals, variables, or constants as defined in the Verilog or VHDL test
		/// bench and source files. An HDL signal includes Verilog wire or reg entities, and VHDL signals.
		/// Examples of HDL variables include Verilog real, realtime, time, and event.
		/// HDL constants include Verilog parameters and localparams, and VHDL generic and constants.
		/// The HDL scope, or scope, is defined by a declarative region in the HDL code such as a module,
		/// function, task, process, or begin-end blocks in Verilog. VHDL scopes include entity/architecture
		/// definitions, block, function, procedure, and process blocks.
		///
		/// HDL constants include Verilog parameters and localparams, and VHDL generic and constants.
		/// The HDL scope, or scope, is defined by a declarative region in the HDL code such as a module,
		/// function, task, process, or begin-end blocks in Verilog. VHDL scopes include entity/architecture
		/// definitions, block, function, procedure, and process blocks.
		/// Arguments
		/// -radix <arg> - (Optional) Specifies the radix to use when returning the value of the specified
		/// objects. Allowed values are: default, dec, bin, oct, hex, unsigned, ascii, or smag.
		/// Note: The radix dec indicates a signed decimal. Specify the radix unsigned when dealing with unsigned
		/// data.
		/// -quiet - (Optional) Execute the command quietly, returning no messages from the command.
		/// The command also returns TCL_OK regardless of any errors encountered during execution.
		/// Note: Any errors encountered on the command-line, while launching the command, will be returned. Only
		/// errors occurring inside the command will be trapped.
		/// -verbose - (Optional) Temporarily override any message limits and return all messages from this
		/// command.
		/// Note: Message limits can be defined with the set_msg_config command.
		/// <hdl_objects> - (Required) Specifies one or more HDL objects to return the values of. The object
		/// can be specified by name, or can be returned as an object from the get_objects command.
		/// Examples
		/// The following example reports the value of all objects at the current time:
		/// report_values [get_objects]
		/// This example shows the difference between the bin, dec, and unsigned radix on the value
		/// returned from the specified bus:
		/// report_values -radix bin /test/bench_VStatus_pad_0_i[7:0]
		/// Declared: {/test/bench_VStatus_pad_0_i[7:0]} Verilog 10100101
		/// report_values -radix unsigned /test/bench_VStatus_pad_0_i[7:0]
		/// Declared: {/test/bench_VStatus_pad_0_i[7:0]} Verilog 165
		/// report_values -radix dec /test/bench_VStatus_pad_0_i[7:0]
		/// Declared: {/test/bench_VStatus_pad_0_i[7:0]} Verilog -91
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1444
		/// </summary>
		/// <param name="hdl_objects">(Required) The hdl_objects to report. Default is report_objects [get_objects *]</param>
		/// <param name="radix">
		/// (Optional)
		/// The radix specifies the radix to use for printing the values of
		/// the hdl_objects. Allowed values are: default, dec, bin, oct,
		/// hex, unsigned, ascii, smag.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Print name and value of HDL objects on the console in textual format</returns>
		public virtual SimpleTCLCommand report_values(string hdl_objects, string radix = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_values [-radix <arg>] [-quiet] [-verbose] [<hdl_objects>...]
			return
				new SimpleTCLCommand("report_values")
					.OptionalNamedString("radix", radix)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hdl_objects)
			;
		}
		/// <summary>
		/// Report status of DRC/METHODOLOGY/CDC message waivers
		///
		///
		/// TCL Syntax: report_waivers [-file <arg>] [-type <arg>] [-write_valid_waivers] [-write_ignored_waivers] [-append] [-return_string] [-show_msgs_with_no_waivers] [-quiet] [-verbose]
		///
		/// Reports DRC, METHODOLOGY, and CDC violation messages and displays what waivers are in
		/// place in the current design.
		/// In addition, the report_drc, report_methodology, and report_cdc commands have
		/// options to run the reports on waived violations or checks.
		///
		/// This example reports all waivers in the current design:
		/// report_waivers
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1446
		/// </summary>
		/// <param name="file">(Optional) Name of file to report waivers</param>
		/// <param name="type">(Optional) Type of waiver - ALL, DRC, METHODOLOGY, CDC</param>
		/// <param name="write_valid_waivers">
		/// (Optional)
		/// (special) Specifies writing out the specific waivers which
		/// were used in the last report_drc/methodology/cdc run(s)
		/// </param>
		/// <param name="write_ignored_waivers">
		/// (Optional)
		/// (special) Specifies writing out the specific waivers which
		/// were NOT used in the last report_drc/methodology/cdc
		/// run(s)
		/// </param>
		/// <param name="append">(Optional) Append the current report results to the file specified with - file</param>
		/// <param name="return_string">(Optional) Return report results as a string object</param>
		/// <param name="show_msgs_with_no_waivers">
		/// (Optional)
		/// also list report_drc/methodology/cdc messages which have
		/// no defined waivers
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand report_waivers(string file = null, string type = null, bool? write_valid_waivers = null, bool? write_ignored_waivers = null, bool? append = null, bool? return_string = null, bool? show_msgs_with_no_waivers = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_waivers [-file <arg>] [-type <arg>] [-write_valid_waivers] [-write_ignored_waivers] [-append] [-return_string] [-show_msgs_with_no_waivers] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("report_waivers")
					.OptionalNamedString("file", file)
					.OptionalNamedString("type", type)
					.Flag("write_valid_waivers", write_valid_waivers)
					.Flag("write_ignored_waivers", write_ignored_waivers)
					.Flag("append", append)
					.Flag("return_string", return_string)
					.Flag("show_msgs_with_no_waivers", show_msgs_with_no_waivers)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Remove DRC report
		///
		///
		/// TCL Syntax: reset_drc [-name <arg>] [-quiet] [-verbose]
		///
		/// Clear the DRC results from the specified named result set.
		/// This command operates silently, returning nothing if successful, or returning an error if it fails.
		///
		/// The following example clears the specified results set from memory and the GUI:
		/// reset_drc -name DRC1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1449
		/// </summary>
		/// <param name="name">(Optional) DRC result name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand reset_drc(string name = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_drc [-name <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("reset_drc")
					.OptionalNamedString("name", name)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Reset one or more DRC checks to factory defaults.
		///
		///
		/// TCL Syntax: reset_drc_check [-quiet] [-verbose] [<checks>...]
		///
		/// Reset the specified DRC checks to the defaults provided by the Vivado Design Suite. This will
		/// restore the DRC check to its default configuration, including any changes to the IS_ENABLED or
		/// SEVERITY properties.
		/// The IS_ENABLED property can be modified on a specific DRC check to disable the rule from
		/// being checked, even when it is specified either directly in the report_drc command, or as part
		/// of a ruledeck.
		/// The SEVERITY property is a string property that can be modified to change the severity
		/// associated with a specific DRC rule when a violation is found during the report_drc command.
		/// The supported values are: FATAL, ERROR, "CRITICAL WARNING", WARNING, ADVISORY
		///
		/// The following example modifies the IS_ENABLED property for the ROAS-1 rule, modifies the
		/// SEVERITY property for the RFFC-1 rule, and then restores the default settings for all checks:
		/// set_property IS_ENABLED false [get_drc_checks ROAS-1]
		/// set_property SEVERITY "Critical Warning" [get_drc_checks RFFC-1]
		/// reset_drc_check [get_drc_checks]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1451
		/// </summary>
		/// <param name="checks">(Required) The list of checks to reset.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand reset_drc_check(string checks, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_drc_check [-quiet] [-verbose] [<checks>...]
			return
				new SimpleTCLCommand("reset_drc_check")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(checks)
			;
		}
		/// <summary>
		/// Reset hardware AXI core state.
		///
		///
		/// TCL Syntax: reset_hw_axi [-quiet] [-verbose] [<hw_axis>...]
		///
		/// Reset the STATUS properties of the specified hw_axi objects, or the current device.
		/// The reset_hw_axi restores the hw_axi core on the current device to a known state from which
		/// to begin running AXI transactions. The STATUS properties include:
		/// • STATUS.AXI_READ_BUSY
		/// • STATUS.AXI_READ_DONE
		/// • STATUS.AXI_WRITE_BUSY
		/// • STATUS.AXI_WRITE_DONE
		/// • STATUS.BRESP - Write Response Channel Response. Indicates results of the write transfer.
		/// • STATUS.RRESP - Read Response Channel Response. Indicates results of the read transfer.
		/// The command returns nothing if successful, and returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1453
		/// </summary>
		/// <param name="hw_axis">(Required) List of hardware AXI objects.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand reset_hw_axi(string hw_axis, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_hw_axi [-quiet] [-verbose] [<hw_axis>...]
			return
				new SimpleTCLCommand("reset_hw_axi")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_axis)
			;
		}
		/// <summary>
		/// Reset hardware ILA control properties to default values.
		///
		///
		/// TCL Syntax: reset_hw_ila [-reset_compare_values <arg>] [-quiet] [-verbose] [<hw_ilas>...]
		///
		/// Reset the trigger and capture configuration properties on the specified ILA debug core, and the
		/// TRIGGER_COMPARE_VALUE and CAPTURE_COMPARE_VALUE properties on the core's debug
		/// probes.
		/// Properties of the hw_ila object are configured with the set_property command in preparation
		/// for the run_hw_ila command to configure the ILA core on the hw_device. This command
		/// restores the user-configurable properties on the specified hw_ila to their default settings. Refer
		/// to the Vivado Design Suite User Guide: Programming and Debugging (UG908) for more information
		/// on these properties.
		/// The default properties are:
		/// • CONTROL.DATA_DEPTH is set to the MAX_DATA_DEPTH of the hw_ila object.
		/// • CONTROL.TRIGGER_POSITION 0
		/// • CONTROL.WINDOW_COUNT 1
		/// • CONTROL.TRIGGER_MODE BASIC_ONLY
		/// • CONTROL.TRIGGER_CONDITION AND
		/// • CONTROL.TRIG_OUT_MODE DISABLED
		/// • CONTROL.CAPTURE_MODE ALWAYS
		/// • CONTROL.CAPTURE_CONDITION AND
		/// • TRIGGER_COMPARE_VALUE eq1'bX (on the hw_probes)
		/// • CAPTURE_COMPARE_VALUE eq1'bX (on the hw_probes)
		/// This command operates silently, returning nothing if successful, or returning an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1455
		/// </summary>
		/// <param name="reset_compare_values">(Optional) Reset associated hardware probe compare values.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_ilas">(Optional) List of hardware ILA objects. Default: Current hardware ILA</param>
		public virtual SimpleTCLCommand reset_hw_ila(string reset_compare_values = null, bool? quiet = null, bool? verbose = null, string hw_ilas = null)
		{
			// TCL Syntax: reset_hw_ila [-reset_compare_values <arg>] [-quiet] [-verbose] [<hw_ilas>...]
			return
				new SimpleTCLCommand("reset_hw_ila")
					.OptionalNamedString("reset_compare_values", reset_compare_values)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(hw_ilas)
			;
		}
		/// <summary>
		/// Reset hardware VIO ACTIVITY_VALUE properties, for hardware probes associated with specified
		/// hardware VIO objects.
		///
		///
		/// TCL Syntax: reset_hw_vio_activity [-quiet] [-verbose] <hw_vios>...
		///
		/// Resets the ACTIVITY_VALUE properties for all hardware probes on the specified VIO debug core
		/// objects. The ACTIVITY_VALUE property is used by the Vivado IDE to represent transitions on
		/// the input probes of the VIO debug cores.
		/// In addition to reading values from the VIO input probes, you can also monitor the activity of the
		/// VIO input probes. The ACTIVITY_VALUE property is used to indicate when the values on the
		/// VIO inputs have changed in between periodic updates to the Vivado IDE. Refer to the Vivado
		/// Design Suite User Guide: Programming and Debugging (UG908) for more information.
		/// This command returns nothing if successful, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1457
		/// </summary>
		/// <param name="hw_vios">(Required) List of hardware VIO objects.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand reset_hw_vio_activity(string hw_vios, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_hw_vio_activity [-quiet] [-verbose] <hw_vios>...
			return
				new SimpleTCLCommand("reset_hw_vio_activity")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_vios)
			;
		}
		/// <summary>
		/// Reset hardware VIO core outputs to initial values.
		///
		///
		/// TCL Syntax: reset_hw_vio_outputs [-quiet] [-verbose] <hw_vios>...
		///
		/// Reset the hardware VIO debug core outputs to their initial, or "reset" state.
		/// The Virtual Input/Output (VIO) debug core can both monitor and drive internal signals on a
		/// programmed Xilinx FPGA in real time. The VIO core uses hardware probes, hw_probe objects, to
		/// monitor and drive signals on the device. Input probes monitor signals as inputs to the VIO core.
		/// Output probes drive signals to specified values from the VIO core.
		/// The reset_hw_vio_outputs command restores the signal values at the output probes of the
		/// specified hw_vio debug cores to their initial values. This affects the signal on the hw_device, but
		/// does not affect the OUTPUT_VALUE property of the hw_probe objects.
		/// TIP: This command has the effect of resetting the initial value of the signal on the hw_vio debug core, without
		/// resetting the properties on the hw_probe object.
		/// This command returns nothing if successful, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1459
		/// </summary>
		/// <param name="hw_vios">(Required) List of hardware VIO objects.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand reset_hw_vio_outputs(string hw_vios, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_hw_vio_outputs [-quiet] [-verbose] <hw_vios>...
			return
				new SimpleTCLCommand("reset_hw_vio_outputs")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_vios)
			;
		}
		/// <summary>
		/// Remove Methodology report
		///
		///
		/// TCL Syntax: reset_methodology [-name <arg>] [-quiet] [-verbose]
		///
		/// Clear the methodology results from the specified named result set.
		/// This command operates silently, returning nothing if successful, or returning an error if it fails.
		///
		/// The following example clears the specified results set from memory and the GUI:
		/// reset_methodology -name ultrafast_methodology_3
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1461
		/// </summary>
		/// <param name="name">(Optional) Methodology result name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand reset_methodology(string name = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_methodology [-name <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("reset_methodology")
					.OptionalNamedString("name", name)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Reset one or more Methodology checks to factory defaults.
		///
		///
		/// TCL Syntax: reset_methodology_check [-quiet] [-verbose] [<checks>...]
		///
		/// Reset the specified methodology checks to the defaults provided by the Vivado Design Suite.
		/// This will restore the check to its default configuration, including any changes to the IS_ENABLED
		/// or SEVERITY properties.
		/// The IS_ENABLED property can be modified on a specific methodology check to disable the rule
		/// from being checked, even when it is specified directly in the report_methodology command.
		/// The SEVERITY property is an enumerated property that can be modified to change the severity
		/// associated with a specific methodology check when a violation is found during the
		/// report_methodology command. The supported values are: FATAL, ERROR, "CRITICAL
		/// WARNING", WARNING, ADVISORY
		///
		/// The following example modifies the IS_ENABLED and SEVERITY properties for the CHECK-4
		/// methodology check, reports the properties of the check to see the changes, and then resets the
		/// methodology check to its default setting:
		/// set_property IS_ENABLED false [get_methodology_checks CHECK-4]
		/// set_property SEVERITY Warning [get_methodology_checks CHECK-4]
		/// report_property [get_methodology_checks CHECK-4]
		/// reset_methodology_check [get_methodology_checks CHECK-4]
		/// report_property [get_methodology_checks CHECK-4]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1463
		/// </summary>
		/// <param name="checks">(Required) The list of checks to reset.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand reset_methodology_check(string checks, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_methodology_check [-quiet] [-verbose] [<checks>...]
			return
				new SimpleTCLCommand("reset_methodology_check")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(checks)
			;
		}
		/// <summary>
		/// Resets or removes a message control rule previously defined by the set_msg_config command.
		///
		///
		/// TCL Syntax: reset_msg_config [-string <args>] [-id <arg>] [-severity <arg>] [-limit] [-suppress] [-count] [-default_severity] [-regexp] [-quiet] [-verbose]
		///
		/// This command restores the default settings of the message limits or severity for messages
		/// returned by the Vivado tool, or can unsuppress previously suppressed messages, as configured
		/// by the set_msg_config command.
		/// You can only perform one reset action for each reset_msg_config command. An error is
		/// returned if more than one action is attempted in a single reset_msg_config command.
		/// Message qualifiers of string, ID, and severity are used to determine which messages are reset by
		/// the reset_msg_config command. Multiple qualifiers have an AND relationship; only the
		/// messages matching the qualifiers will be reset.
		/// Note: You must supply at least one message qualifier to identify a message or group of messages to apply
		/// the command to, or an error is returned.
		/// To report the current rule configurations for messages, use the get_msg_config command.
		///
		/// The following example changes the severity of the specified message ID to a Critical Warning,
		/// and then resets the message to its default severity:
		/// set_msg_config -id "Common 17-81" -new_severity "CRITICAL WARNING"
		/// reset_msg_config -id "Common 17-81" -default_severity
		/// This example changes the severity of messages with the specified message ID, gets the current
		/// message configuration rules, and then shows two different command forms to reset the specific
		/// rule and restore the message:
		/// set_msg_config -id "Common 17-361" -severity INFO -new_severity WARNING
		/// get_msg_config -rules
		/// ---------------------
		/// Message control rules currently in effect are:
		/// Rule Name Rule Current
		/// Message Count
		/// 1 set_msg_config -ruleid {1} -id {Common 17-361} -severity {INFO} -
		/// new_severity {WARNING} 0
		/// ---------------------
		/// reset_msg_config -id "Common 17-361" -default_severity
		/// reset_msg_config -ruleid {1}
		/// TIP: In the preceding example, only one of the reset_msg_config commands is needed to reset the
		/// message.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1465
		/// </summary>
		/// <param name="@string">
		/// (Optional)
		/// A qualifier, only a rule created with a matching string
		/// qualifier will be reset/removed Default: empty
		/// </param>
		/// <param name="id">
		/// (Optional)
		/// A qualifier, only a rule created with a matching id qualifier
		/// will be reset/removed
		/// </param>
		/// <param name="severity">
		/// (Optional)
		/// A qualifier, only a rule created with a matching severity
		/// qualifier will be reset/removed
		/// </param>
		/// <param name="limit">
		/// (Optional)
		/// reset the limit values for message controls that match the
		/// given qualifiers for the current project
		/// </param>
		/// <param name="suppress">
		/// (Optional)
		/// stop suppressing messages that match the given qualifiers
		/// for the current project
		/// </param>
		/// <param name="count">
		/// (Optional)
		/// reset the count of messages for all message controls that
		/// match the given qualifiers for the current project. This will
		/// prevent messages from being suppressed by a -limit control
		/// until the message count once again exceeds the specified
		/// limit.
		/// </param>
		/// <param name="default_severity">
		/// (Optional)
		/// reset the message severity of all messages controls for the
		/// current project that match the given qualifiers to their
		/// default value
		/// </param>
		/// <param name="regexp">(Optional) The values used for -string are full regular expressions</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand reset_msg_config(string @string = null, string id = null, string severity = null, bool? limit = null, bool? suppress = null, bool? count = null, bool? default_severity = null, bool? regexp = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_msg_config [-string <args>] [-id <arg>] [-severity <arg>] [-limit] [-suppress] [-count] [-default_severity] [-regexp] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("reset_msg_config")
					.OptionalNamedString("string", @string)
					.OptionalNamedString("id", id)
					.OptionalNamedString("severity", severity)
					.Flag("limit", limit)
					.Flag("suppress", suppress)
					.Flag("count", count)
					.Flag("default_severity", default_severity)
					.Flag("regexp", regexp)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Reset message count
		///
		///
		/// TCL Syntax: reset_msg_count [-quiet] [-verbose] <id>
		///
		/// Reset the message count for the specified message ID to 0. This restarts the message counter
		/// toward the specified message limit. This can be used to reset the count of specific messages that
		/// may be reaching the limit, or reset the count of all messages returned by the tool.
		/// Every message delivered by the tool has a unique global message ID that consists of an
		/// application sub-system code and a message identifier. This results in a message ID that looks like
		/// the following:
		/// "Common 17-54"
		/// "Netlist 29-28"
		/// "Synth 8-3295"
		/// You can get the current message count for a specific message ID using the get_msg_count
		/// command.
		///
		/// The following example resets the message count for all messages:
		/// reset_msg_count *
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1469
		/// </summary>
		/// <param name="id">
		/// (Required)
		/// Unique message Id to be reset, e.g. "Common 17-99".
		/// "reset_msg_count -id *" reset all counters
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>new message count</returns>
		public virtual SimpleTCLCommand reset_msg_count(string id, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_msg_count [-quiet] [-verbose] <id>
			return
				new SimpleTCLCommand("reset_msg_count")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(id)
			;
		}
		/// <summary>
		/// Reset operating conditions to tool default for power estimation
		///
		///
		/// TCL Syntax: reset_operating_conditions [-voltage <args>] [-grade] [-process] [-junction_temp] [-ambient_temp] [-thetaja] [-thetasa] [-airflow] [-heatsink] [-thetajb] [-board] [-board_temp] [-board_layers] [-design_power_budget] [-quiet] [-verbose]
		///
		/// Resets the specified operating conditions to their default values. If no operating conditions are
		/// specified, all operating conditions are reset to their default values.
		/// Operating conditions can be set using the set_operating_conditions command. The
		/// current values can be determined using the report_operating_conditions command. The
		/// environmental operating conditions of the device are used for power analysis when running the
		/// report_power command, but are not used during timing analysis.
		/// Note: This command returns nothing if successful, or returns an error if it fails.
		///
		/// The following example resets all the operating conditions for the design to their default setting:
		/// reset_operating_conditions
		/// The following example resets the junction, ambient, and board temperature for the design to
		/// their default settings:
		/// reset_operating_conditions -junction_temp -ambient_temp -board_temp
		/// The following example resets the voltage supply Vccint to its default value:
		/// reset_operating_conditions -voltage Vccint
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1471
		/// </summary>
		/// <param name="voltage">(Optional) Resets voltage value. Supported voltage supplies vary by family.</param>
		/// <param name="grade">(Optional) Resets temperature grade</param>
		/// <param name="process">(Optional) Resets process</param>
		/// <param name="junction_temp">(Optional) Resets Junction Temperature</param>
		/// <param name="ambient_temp">(Optional) Resets Ambient Temperature</param>
		/// <param name="thetaja">(Optional) Resets ThetaJA</param>
		/// <param name="thetasa">(Optional) Resets ThetaSA</param>
		/// <param name="airflow">(Optional) Resets Airflow</param>
		/// <param name="heatsink">(Optional) Resets dimensions of heatsink</param>
		/// <param name="thetajb">(Optional) Resets ThetaJB</param>
		/// <param name="board">(Optional) Resets Board type</param>
		/// <param name="board_temp">(Optional) Resets Board Temperature</param>
		/// <param name="board_layers">(Optional) Resets Board layers</param>
		/// <param name="design_power_budget">(Optional) Design Power Budget (W)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand reset_operating_conditions(string voltage = null, bool? grade = null, bool? process = null, bool? junction_temp = null, bool? ambient_temp = null, bool? thetaja = null, bool? thetasa = null, bool? airflow = null, bool? heatsink = null, bool? thetajb = null, bool? board = null, bool? board_temp = null, bool? board_layers = null, bool? design_power_budget = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_operating_conditions [-voltage <args>] [-grade] [-process] [-junction_temp] [-ambient_temp] [-thetaja] [-thetasa] [-airflow] [-heatsink] [-thetajb] [-board] [-board_temp] [-board_layers] [-design_power_budget] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("reset_operating_conditions")
					.OptionalNamedString("voltage", voltage)
					.Flag("grade", grade)
					.Flag("process", process)
					.Flag("junction_temp", junction_temp)
					.Flag("ambient_temp", ambient_temp)
					.Flag("thetaja", thetaja)
					.Flag("thetasa", thetasa)
					.Flag("airflow", airflow)
					.Flag("heatsink", heatsink)
					.Flag("thetajb", thetajb)
					.Flag("board", board)
					.Flag("board_temp", board_temp)
					.Flag("board_layers", board_layers)
					.Flag("design_power_budget", design_power_budget)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Reset a parameter
		///
		///
		/// TCL Syntax: reset_param [-quiet] [-verbose] <name>
		///
		/// Restores a user-definable configuration parameter that has been changed with the set_param
		/// command to its default value.
		/// You can use the report_param command to see which parameters are currently defined.
		///
		/// The following example restores the tcl.statsThreshold parameter to its default value:
		/// reset_param tcl.statsThreshold
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1474
		/// </summary>
		/// <param name="name">(Required) Parameter name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>original value</returns>
		public virtual SimpleTCLCommand reset_param(string name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_param [-quiet] [-verbose] <name>
			return
				new SimpleTCLCommand("reset_param")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
			;
		}
		/// <summary>
		/// Reset current project
		///
		///
		/// TCL Syntax: reset_project [-exclude_runs] [-exclude_ips] [-exclude_sim_runs] [-quiet] [-verbose]
		///
		/// Reset the current project to its starting condition, with source and constraint files, by cleaning
		/// out the various output files created during synthesis, simulation, implementation, and
		/// write_bitstream. Also resets the state of the project to the start of the design flow.
		/// TIP: Any user-defined Tcl variables that are in the global namespace (i.e. not in a project-specific namespace)
		/// are not reset or cleared by this command. Global variables are persistent with the invocation of Vivado and are
		/// only cleared when the Vivado Design Suite is closed. You can also use the unset command to expressly clear a
		/// specific Tcl variable.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1476
		/// </summary>
		/// <param name="exclude_runs">(Optional) Do not reset runs</param>
		/// <param name="exclude_ips">(Optional) Do not reset ips</param>
		/// <param name="exclude_sim_runs">(Optional) Do not reset simulation runs</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand reset_project(bool? exclude_runs = null, bool? exclude_ips = null, bool? exclude_sim_runs = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_project [-exclude_runs] [-exclude_ips] [-exclude_sim_runs] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("reset_project")
					.Flag("exclude_runs", exclude_runs)
					.Flag("exclude_ips", exclude_ips)
					.Flag("exclude_sim_runs", exclude_sim_runs)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Reset property on object(s)
		///
		///
		/// TCL Syntax: reset_property [-quiet] [-verbose] <property_name> <objects>...
		///
		/// Restores the specified property to its default value on the specified object or objects. If no
		/// default is defined for the property, the property is unassigned on the specified object.
		///
		/// The following example sets the DOB_REG property on the specified Block RAM, and then resets
		/// the property:
		/// set_property DOB_REG 1 [get_cells usbEngine1/usbEngineSRAM/
		/// snoopyRam_reg_19]
		/// reset_property DOB_REG [get_cells usbEngine1/usbEngineSRAM/
		/// snoopyRam_reg_19]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1478
		/// </summary>
		/// <param name="property_name">(Required) Name of property to reset</param>
		/// <param name="objects">(Required) Objects to set properties</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The value that was set if success, "" if failure</returns>
		public virtual SimpleTCLCommand reset_property(string property_name, string objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_property [-quiet] [-verbose] <property_name> <objects>...
			return
				new SimpleTCLCommand("reset_property")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(property_name)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Reset an existing run
		///
		///
		/// TCL Syntax: reset_runs [-prev_step] [-from_step <arg>] [-quiet] [-verbose] <runs>
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1480
		/// </summary>
		/// <param name="runs">(Required) Runs to modify</param>
		/// <param name="prev_step">(Optional) Reset last run step</param>
		/// <param name="from_step">(Optional) First Step to reset</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand reset_runs(string runs, bool? prev_step = null, string from_step = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_runs [-prev_step] [-from_step <arg>] [-quiet] [-verbose] <runs>
			return
				new SimpleTCLCommand("reset_runs")
					.Flag("prev_step", prev_step)
					.OptionalNamedString("from_step", from_step)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(runs)
			;
		}
		/// <summary>
		/// Reset an existing simulation run
		///
		///
		/// TCL Syntax: reset_simulation [-mode <arg>] [-type <arg>] [-quiet] [-verbose] [<simset>]
		///
		/// Reset the current simulation to its starting condition, by cleaning out the various output files
		/// created during compilation and simulation for the specified simulation fileset.
		/// IMPORTANT! Local files will be removed from the project simulation folders without warning.
		/// The command returns nothing if successful, or an error if it fails.
		///
		/// The following example resets the post-synthesis timing simulation by removing files for the sim_2
		/// simset:
		/// reset_simulation -mode post-synthesis -type timing sim_2
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1481
		/// </summary>
		/// <param name="mode">
		/// (Optional)
		/// Remove generated data for the specified mode. Values:
		/// behavioral, post-synthesis, post-implementation Default:
		/// behavioral
		/// </param>
		/// <param name="type">
		/// (Optional)
		/// Remove generated data for the specified type. Applicable
		/// mode is post-synthesis or post-implementation. Values:
		/// functional, timing
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="simset">(Optional) Name of the simulation fileset to reset</param>
		public virtual SimpleTCLCommand reset_simulation(string mode = null, string type = null, bool? quiet = null, bool? verbose = null, string simset = null)
		{
			// TCL Syntax: reset_simulation [-mode <arg>] [-type <arg>] [-quiet] [-verbose] [<simset>]
			return
				new SimpleTCLCommand("reset_simulation")
					.OptionalNamedString("mode", mode)
					.OptionalNamedString("type", type)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(simset)
			;
		}
		/// <summary>
		/// Clear a SSN results set from memory
		///
		///
		/// TCL Syntax: reset_ssn [-quiet] [-verbose] <name>
		///
		/// Clear the SSN results from the specified named result set.
		///
		/// The following example clears the specified results set from memory:
		/// reset_ssn SSN1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1483
		/// </summary>
		/// <param name="name">(Required) Name of the set of results</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand reset_ssn(string name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_ssn [-quiet] [-verbose] <name>
			return
				new SimpleTCLCommand("reset_ssn")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
			;
		}
		/// <summary>
		/// Reset switching activity on specified objects
		///
		///
		/// TCL Syntax: reset_switching_activity [-default] [-type <args>] [-hier] [-all] [-no_deassert_resets] [-quiet] [-verbose] [<objects>...]
		///
		/// Resets the attributes of the switching activity on specified nets, ports, pins, and cells in the
		/// design.
		/// The switching activity is defined using the set_switching_activity command. The current
		/// switching activity defined for a specific port, pin, net, or cell can be found by using the
		/// report_switching_activity command.
		/// Note: The reset_switching_activity is used to reset switching activity for specified objects. Use
		/// set_switching_activity -default_toggle_rate or -default_static_probability to
		/// change or reset the default values for the current design.
		/// This command operates silently and does not return direct feedback of its operation.
		///
		/// The following example resets the signal_rate and static probability value on all output ports:
		/// reset_switching_activity -default [all_outputs]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1485
		/// </summary>
		/// <param name="@default">(Optional) Reset default static probability and default toggle rate</param>
		/// <param name="type">
		/// (Optional)
		/// Specify nodes in a specific category. List of valid type values:
		/// io_output, io_bidir_enable, register, lut_ram, lut, dsp,
		/// bram_enable, bram_wr_enable, gt_txdata, gt_rxdata.
		/// </param>
		/// <param name="hier">
		/// (Optional)
		/// Hierarchically resets the switching activity on a hierarchical
		/// cells provided as <objects>.
		/// </param>
		/// <param name="all">(Optional) Reset switching activity on all nets</param>
		/// <param name="no_deassert_resets">
		/// (Optional)
		/// A switch to undo the deassertion of resets via command
		/// set_switching_activity -deassert_resets
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">(Optional) Objects to reset switching activity on</param>
		public virtual SimpleTCLCommand reset_switching_activity(bool? @default = null, string type = null, bool? hier = null, bool? all = null, bool? no_deassert_resets = null, bool? quiet = null, bool? verbose = null, string objects = null)
		{
			// TCL Syntax: reset_switching_activity [-default] [-type <args>] [-hier] [-all] [-no_deassert_resets] [-quiet] [-verbose] [<objects>...]
			return
				new SimpleTCLCommand("reset_switching_activity")
					.Flag("default", @default)
					.OptionalNamedString("type", type)
					.Flag("hier", hier)
					.Flag("all", all)
					.Flag("no_deassert_resets", no_deassert_resets)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(objects)
			;
		}
		/// <summary>
		/// Reset target data for the specified source
		///
		///
		/// TCL Syntax: reset_target [-quiet] [-verbose] <name> <objects>
		///
		/// Remove the current target data for the specified IP core. This deletes any files that were
		/// delivered during generation of the specified targets. This does not remove the core from the
		/// current project, but does remove the associated target data from its referenced location.
		///
		/// The following example resets the instantiation template for the specified IP core:
		/// reset_target instantiation_template [get_ips blk_mem*]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1488
		/// </summary>
		/// <param name="name">(Required) List of targets to be reset, or 'all' to reset all generated targets</param>
		/// <param name="objects">(Required) The objects for which data needs to be reset</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand reset_target(string name, string objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_target [-quiet] [-verbose] <name> <objects>
			return
				new SimpleTCLCommand("reset_target")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Resets the timing information on the current design
		///
		///
		/// TCL Syntax: reset_timing [-invalid] [-clock_reservation] [-quiet] [-verbose]
		///
		/// Reset the timing data and constraints for the current design. Use this command to clear the
		/// current in-memory timing data and constraints, and force the timing engine to reevaluate the
		/// design comprehensively rather than iteratively.
		/// After clearing the constraints from the in-memory design, you must reload any needed
		/// constraints using the read_xdc command. The Vivado tool will not automatically reload the
		/// constraints.
		/// TIP: This command deletes the in-memory timing view, not the timing report. Use the
		/// delete_timing_results command to delete the reported timing information.
		///
		/// The following example clears the current timing data from memory, including any invalid timing
		/// constraints:
		/// reset_timing -invalid
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1490
		/// </summary>
		/// <param name="invalid">
		/// (Optional)
		/// Resets invalid timing constraints in addition to valid timing
		/// constraints.
		/// </param>
		/// <param name="clock_reservation">
		/// (Optional)
		/// Resets clock name reservations for auto-derived clocks in
		/// addition to valid timing constraints.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand reset_timing(bool? invalid = null, bool? clock_reservation = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_timing [-invalid] [-clock_reservation] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("reset_timing")
					.Flag("invalid", invalid)
					.Flag("clock_reservation", clock_reservation)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Resize net bus in the current design
		///
		///
		/// TCL Syntax: resize_net_bus [-from <arg>] [-to <arg>] [-quiet] [-verbose] <net_bus_name>...
		///
		/// Resize an existing bus net, to grow the bus, shrink the bus, or renumber the current range of
		/// indexes. You can only do a single grow, shrink, or renumber operation with each command.
		/// • You can grow the bus by indicating a new range of indexes outside the current range of
		/// indexes. Growing the bus leaves existing bits connected as they currently are.
		/// • You can shrink the bus by indicating a new range of indexes inside the current range of
		/// indexes. Shrinking the bus, eliminates connections to removed bits, but leaves the remaining
		/// bits connected as they currently are.
		/// • You can renumber the current bus indexes by providing a new range of indexes with the same
		/// width as the current range. Renumbering bits changes bus bit numeric identifiers, but doesn't
		/// otherwise change connections.
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*
		/// command.
		/// Note: Netlist editing is not allowed on the elaborated RTL design.
		/// This command returns nothing if successful, and returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1492
		/// </summary>
		/// <param name="net_bus_name">(Required) Name of the net bus to resize</param>
		/// <param name="from">(Optional) New starting bus index</param>
		/// <param name="to">(Optional) New ending bus index</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand resize_net_bus(string net_bus_name, string from = null, string to = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: resize_net_bus [-from <arg>] [-to <arg>] [-quiet] [-verbose] <net_bus_name>...
			return
				new SimpleTCLCommand("resize_net_bus")
					.OptionalNamedString("from", from)
					.OptionalNamedString("to", to)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(net_bus_name)
			;
		}
		/// <summary>
		/// Move, resize, add and remove Pblock site-range constraints
		///
		///
		/// TCL Syntax: resize_pblock [-add <args>] [-remove <args>] [-from <args>] [-to <args>] [-replace] [-locs <arg>] [-quiet] [-verbose] <pblock>
		///
		/// Place, resize, move, or remove the specified Pblock. The Pblock must have been created using
		/// the create_pblock command.
		/// A Pblock consists of a group of cells that can be assigned to one or more independent or
		/// overlapping rectangles. Using the various options defined below, you can add sites to a rectangle,
		/// or remove sites from a rectangle, or define a new rectangle to be associated with an existing
		/// Pblock.
		///
		/// The following example resizes the Pblock by adding a range of SLICEs, and removing other
		/// SLICEs, but keeps all instances placed at their current location:
		/// resize_pblock block3 -add SLICE_X6Y67:SLICE_X11Y71 \
		/// -remove SLICE_X6Y71:SLICE_X7Y71 -locs keep_all
		/// This example create a Pblock region, and defines the Pblock area by adding a range of
		/// CLOCKREGIONs:
		/// create_pblock pblock_1
		/// resize_pblock pblock_1 -add {CLOCKREGION_X0Y10:CLOCKREGION_X1Y11}
		/// The following example moves the specified Pblock by adding a range of SLICEs, removing the
		/// existing range of SLICEs, and trims any placed logic that falls outside the new Pblock. Then it
		/// adds a new range of SLICEs and block ram to the specified Pblock in a second separate rectangle:
		/// resize_pblock block3 -add SLICE_X3Y8:SLICE_X10Y3 \
		/// -remove SLICE_X6Y67:SLICE_X11Y71 -locs trim
		/// resize_pblock block3 -add {SLICE_X6Y67:SLICE_X11Y71 \
		/// RAMB18_X0Y2:RAMB18_X1Y4}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1494
		/// </summary>
		/// <param name="pblock">(Required) Pblock to resize</param>
		/// <param name="add">(Optional) Add site ranges(s)</param>
		/// <param name="remove">(Optional) Remove site ranges(s)</param>
		/// <param name="from">(Optional) Site range(s) to move</param>
		/// <param name="to">(Optional) Site range destination(s)</param>
		/// <param name="replace">(Optional) Remove all existing ranges</param>
		/// <param name="locs">(Optional) LOC treatment Default: keep_all</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand resize_pblock(string pblock, string add = null, string remove = null, string from = null, string to = null, bool? replace = null, string locs = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: resize_pblock [-add <args>] [-remove <args>] [-from <args>] [-to <args>] [-replace] [-locs <arg>] [-quiet] [-verbose] <pblock>
			return
				new SimpleTCLCommand("resize_pblock")
					.OptionalNamedString("add", add)
					.OptionalNamedString("remove", remove)
					.OptionalNamedString("from", from)
					.OptionalNamedString("to", to)
					.Flag("replace", replace)
					.OptionalNamedString("locs", locs)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(pblock)
			;
		}
		/// <summary>
		/// Resize pin bus in the current design
		///
		///
		/// TCL Syntax: resize_pin_bus [-from <arg>] [-to <arg>] [-quiet] [-verbose] <pin_bus_name>...
		///
		/// Resize an existing bus pin, to grow the bus, shrink the bus, or renumber the current range of pin
		/// indexes. You can only do a single grow, shrink, or renumber operation with each command.
		/// • You can grow the bus by indicating a new range of pin indexes outside the current range of
		/// indexes. Growing the bus leaves existing pins connected as they currently are.
		/// • You can shrink the bus by indicating a new range of pin indexes inside the current range of
		/// indexes. Shrinking the bus, eliminates connections to removed bus pins, but leaves the
		/// remaining pins connected as they currently are.
		/// • You can renumber the current bus indexes by providing a new range of pin indexes with the
		/// same width as the current range. Renumbering pins changes the pin index, but does not
		/// otherwise change connections.
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*
		/// command.
		/// Note: Netlist editing is not allowed on the elaborated RTL design.
		/// This command returns nothing if successful, and returns an error if it fails.
		///
		/// The following example creates a blackbox cell, then creates a 24-bit bidirectional bus for the
		/// specified hierarchical cell, then resizes the bus pin to expand the width to 32-bits, then
		/// renumbers the index to include negative bus indexes:
		/// create_cell -reference dmaBlock -black_box usbEngine0/myDMA
		/// create_pin -direction INOUT -from 0 -to 23 usbEngine0/myDMA/dataBus
		/// resize_pin_bus -from 0 -to 31 usbEngine0/myDMA/dataBus
		/// resize_pin_bus -from -16 -to 15 usbEngine0/myDMA/dataBus
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1497
		/// </summary>
		/// <param name="pin_bus_name">(Required) Name of the pin bus to resize</param>
		/// <param name="from">(Optional) New starting bus index</param>
		/// <param name="to">(Optional) New ending bus index</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand resize_pin_bus(string pin_bus_name, string from = null, string to = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: resize_pin_bus [-from <arg>] [-to <arg>] [-quiet] [-verbose] <pin_bus_name>...
			return
				new SimpleTCLCommand("resize_pin_bus")
					.OptionalNamedString("from", from)
					.OptionalNamedString("to", to)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(pin_bus_name)
			;
		}
		/// <summary>
		/// Resize port bus in the current design
		///
		///
		/// TCL Syntax: resize_port_bus [-from <arg>] [-to <arg>] [-quiet] [-verbose] <port_bus_name>...
		///
		/// Resize an existing bus port, to grow the bus, shrink the bus, or renumber the current range of
		/// port indexes. You can only do a single grow, shrink, or renumber operation with each command.
		/// • You can grow the bus by indicating a new range of port indexes outside the current range of
		/// indexes. Growing the bus leaves existing port indexes connected as they currently are.
		/// • You can shrink the bus by indicating a new range of port indexes inside the current range of
		/// indexes. Shrinking the bus, eliminates connections to removed bus ports, but leaves the
		/// remaining ports connected as they currently are.
		/// • You can renumber the current bus indexes by providing a new range of port indexes with the
		/// same width as the current range. Renumbering ports changes the port index, but does not
		/// otherwise change connections.
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*
		/// command.
		/// Note: Netlist editing is not allowed on the elaborated RTL design.
		/// This command returns nothing if successful, and returns an error if it fails.
		///
		/// The following example creates a 32-bit output bus port, then renumbers the ports to include
		/// negative bus indexes, then shrinks the bus width from 32-bits to 16-bits:
		/// create_port -direction out -from 0 -to 31 outPorts
		/// resize_port_bus -from -16 -to 15 outPorts
		/// resize_port_bus -from -8 -to 7 outPorts
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1500
		/// </summary>
		/// <param name="port_bus_name">(Required) Name of the port bus to resize</param>
		/// <param name="from">(Optional) New starting bus index</param>
		/// <param name="to">(Optional) New ending bus index</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand resize_port_bus(string port_bus_name, string from = null, string to = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: resize_port_bus [-from <arg>] [-to <arg>] [-quiet] [-verbose] <port_bus_name>...
			return
				new SimpleTCLCommand("resize_port_bus")
					.OptionalNamedString("from", from)
					.OptionalNamedString("to", to)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(port_bus_name)
			;
		}
		/// <summary>
		/// Rewind simulation to post loading state (as if design was reloaded), time is set to 0
		///
		///
		/// TCL Syntax: restart [-quiet] [-verbose]
		///
		/// Return the current simulation to its initial state, as if the design was reloaded, resetting the
		/// current simulation time to 0.
		/// The restart command retains breakpoints, Tcl forces, and settings in the waveform
		/// configuration window, but resets all simulation values, and clears all other Tcl commands.
		///
		/// The following example restarts the current simulation:
		/// restart
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1502
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>
		/// </returns>
		public virtual SimpleTCLCommand restart(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: restart [-quiet] [-verbose]
			return
				new SimpleTCLCommand("restart")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Resume Activity Monitor runs after paused for the specified hardware HBM(s)
		///
		///
		/// TCL Syntax: resume_hw_hbm_amon [-quiet] [-verbose] <hw_objects>
		///
		/// The resume_hw_hbm_amon command restarts a running HBM activity monitor in the Vivado
		/// hardware manager that has been previously paused using the pause_hw_hbm_amon command.
		/// This command returns nothing when successful, or returns an error when it fails.
		///
		/// The following example restarts the HBM activity monitor for the associated HBM core:
		/// resume_hw_hbm_amon [get_hw_hbms *HBM_2]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1504
		/// </summary>
		/// <param name="hw_objects">(Required) hardware objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand resume_hw_hbm_amon(string hw_objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: resume_hw_hbm_amon [-quiet] [-verbose] <hw_objects>
			return
				new SimpleTCLCommand("resume_hw_hbm_amon")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_objects)
			;
		}
		/// <summary>
		/// Route the current design
		///
		///
		/// TCL Syntax: route_design [-unroute] [-release_memory] [-nets <args>] [-physical_nets] [-pins <arg>] [-directive <arg>] [-tns_cleanup] [-no_timing_driven] [-preserve] [-delay] [-auto_delay] -max_delay <arg> -min_delay <arg> [-timing_summary] [-finalize] [-ultrathreads] [-quiet] [-verbose]
		///
		/// Route the nets in the current design to complete logic connections on the target part.
		/// Predefined routing strategies can be quickly selected using the route_design -directive
		/// command, or specific route options can be configured to define your own routing strategy.
		/// Routing can be completed automatically with route_design, or can be completed iteratively
		/// using the various options of the route_design command to achieve route completion and
		/// timing closure. Iterative routing provides you some control over the routing process to route
		/// critical nets first and then route less critical nets, and to control the level of effort and the timing
		/// algorithms for these various route passes.
		/// Routing is one step of the complete design implementation process, which can be run
		/// automatically through the use of the launch_runs command when running the Vivado tools in
		/// Project Mode.
		/// In Non-Project Mode, the implementation process must be run manually with the individual
		/// commands: opt_design, place_design, phys_opt_design, power_opt_design, and
		/// route_design. Refer to the Vivado Design Suite User Guide: Design Flows Overview (UG892) for a
		/// complete description of Project Mode and Non-Project Mode.
		/// TIP: The route_design can be multi-threaded to speed the process. Refer to the set_param command for
		/// more information on setting the general.maxThreads parameter.
		/// Both placement and routing can be completed incrementally, based on prior results stored in a
		/// Design Checkpoint file (DCP), using the incremental implementation flow. Refer to the
		/// read_checkpoint command, or to Vivado Design Suite User Guide: Implementation (UG904) for
		/// more information on incremental place and route.
		/// This command requires a placed design, and it is recommended that you have optimized the
		/// design with opt_design prior to placement.
		///
		/// Route the entire design, and direct the router to try multiple algorithms for improving critical
		/// path delay:
		/// route_design -directive Explore
		/// The following example routes the set of timing critical nets, $criticalNets, to the shortest
		/// interconnect delay, marks the nets as fixed using the IS_ROUTE_FIXED property, and then routes
		/// the rest of the design using a low effort directive for fast results:
		/// route_design -delay -nets $criticalNets
		/// set_property IS_ROUTE_FIXED 1 $criticalNets
		/// route_design -directive RuntimeOptimized
		/// Route the specified nets using the fastest runtime:
		/// route_design -nets [get_nets ctrl0/ctr*]
		/// Route the specified nets to get the shortest interconnect delays:
		/// route_design -nets [get_nets ctrl0/ctr*] -delay
		/// Route to the specified pins:
		/// route_design -pins [get_pins ctrl0/reset_reg/D ctrl0/ram0/ADDRARDADDR]
		/// Route to a particular pin, try to achieve less than 500 ps delay:
		/// route_design -pins [get_pins ctrl0/reset_reg/D] -max_delay 500
		/// Route to a particular pin, try to achieve more than 200 ps delay:
		/// route_design -pins [get_pins ctrl0/ram0/ADDRARDADDR] -min_delay 200
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1506
		/// </summary>
		/// <param name="max_delay">
		/// (Required)
		/// Use with -pins option to specify the max_delay constraint on
		/// the pins.When specified -delay is implicit.
		/// </param>
		/// <param name="min_delay">
		/// (Required)
		/// Use with -pins option to specify the max_delay constraint on
		/// the pins.When specified -delay is implicit.
		/// </param>
		/// <param name="unroute">
		/// (Optional)
		/// Unroute whole design or the given nets/pins if used with -
		/// nets or -pins.
		/// </param>
		/// <param name="release_memory">(Optional) Release Router memory. Not compatible with any other options.</param>
		/// <param name="nets">(Optional) Operate on the given nets.</param>
		/// <param name="physical_nets">(Optional) Operate on all physical nets.</param>
		/// <param name="pins">(Optional) Operate on the given pins.</param>
		/// <param name="directive">
		/// (Optional)
		/// Mode of behavior (directive) for this command. Please refer
		/// to Arguments section of this help for values for this option.
		/// Default: Default
		/// </param>
		/// <param name="tns_cleanup">(Optional) Do optional TNS clean up.</param>
		/// <param name="no_timing_driven">(Optional) Do not run in timing driven mode.</param>
		/// <param name="preserve">(Optional) Preserve existing routing.</param>
		/// <param name="delay">(Optional) Use with -nets or -pins option to route in delay driven mode.</param>
		/// <param name="auto_delay">(Optional) Use with -nets or -pins option to route in constraint driven mode.</param>
		/// <param name="timing_summary">(Optional) Enable post-router signoff timing summary.</param>
		/// <param name="finalize">(Optional) finalize route_design in interactive mode.</param>
		/// <param name="ultrathreads">(Optional) Enable Turbo mode routing.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand route_design(string max_delay, string min_delay, bool? unroute = null, bool? release_memory = null, string nets = null, bool? physical_nets = null, string pins = null, string directive = null, bool? tns_cleanup = null, bool? no_timing_driven = null, bool? preserve = null, bool? delay = null, bool? auto_delay = null, bool? timing_summary = null, bool? finalize = null, bool? ultrathreads = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: route_design [-unroute] [-release_memory] [-nets <args>] [-physical_nets] [-pins <arg>] [-directive <arg>] [-tns_cleanup] [-no_timing_driven] [-preserve] [-delay] [-auto_delay] -max_delay <arg> -min_delay <arg> [-timing_summary] [-finalize] [-ultrathreads] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("route_design")
					.Flag("unroute", unroute)
					.Flag("release_memory", release_memory)
					.OptionalNamedString("nets", nets)
					.Flag("physical_nets", physical_nets)
					.OptionalNamedString("pins", pins)
					.OptionalNamedString("directive", directive)
					.Flag("tns_cleanup", tns_cleanup)
					.Flag("no_timing_driven", no_timing_driven)
					.Flag("preserve", preserve)
					.Flag("delay", delay)
					.Flag("auto_delay", auto_delay)
					.RequiredNamedString("max_delay", max_delay)
					.RequiredNamedString("min_delay", min_delay)
					.Flag("timing_summary", timing_summary)
					.Flag("finalize", finalize)
					.Flag("ultrathreads", ultrathreads)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Run the simulation for the specified time
		///
		///
		/// TCL Syntax: run [-all] [-quiet] [-verbose] [<time>] [<unit>]
		///
		/// Run the current simulation from the current time to the specified time, or until the simulation
		/// stops.
		/// A running simulation can be stopped at a predetermined time, at a specific breakpoint in the HDL
		/// source code, by encountering a TRUE condition, by evaluating the circuit until there are no
		/// remaining events, or by encountering a runtime error such as an out-of-bounds value.
		/// The run command instructs an existing simulation to run for a specified length of time, or until
		/// there are no remaining events. The time is specified as a floating point number indicating a
		/// period of time in the current simulation units, or in the specified units.
		///
		/// The following example runs an existing simulation for the specified simulation run time, using the
		/// default units (ns):
		/// run 1000
		/// The following example runs an existing simulation for 300 microseconds (us):
		/// run 300 us
		/// The following example runs the current simulation until no event is left in the event queue, a
		/// breakpoint or valid condition is met, or a simulation runtime error occurs:
		/// run -all
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1512
		/// </summary>
		/// <param name="all">
		/// (Optional)
		/// Runs simulation till a breakpoint, an exception or no events
		/// left in the queue
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="time">(Optional) Length of simulation time</param>
		/// <param name="unit">(Optional) Unit for time from the following time units: fs, ps, ns, us, ms, sec</param>
		public virtual SimpleTCLCommand run(bool? all = null, bool? quiet = null, bool? verbose = null, string time = null, string unit = null)
		{
			// TCL Syntax: run [-all] [-quiet] [-verbose] [<time>] [<unit>]
			return
				new SimpleTCLCommand("run")
					.Flag("all", all)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(time)
					.OptionalString(unit)
			;
		}
		/// <summary>
		/// Run hardware AXI read/write transaction(s)and update transaction status in hw_axi object..
		///
		///
		/// TCL Syntax: run_hw_axi [-queue] [-quiet] [-verbose] <hw_axi_txns>...
		///
		/// Run the AXI transactions defined on the specified JTAG to AXI Master core.
		/// AXI transactions are created with the create_hw_axi_txns command.
		/// Run the specified hardware AXI read/write transactions on the AXI bus, and update the
		/// transaction status on the associated hw_axi object.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1514
		/// </summary>
		/// <param name="hw_axi_txns">(Required) hardware AXI Transaction object to execute on the AXI bus.</param>
		/// <param name="queue">(Optional) Queue Transaction. Default: 0</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand run_hw_axi(string hw_axi_txns, bool? queue = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: run_hw_axi [-queue] [-quiet] [-verbose] <hw_axi_txns>...
			return
				new SimpleTCLCommand("run_hw_axi")
					.Flag("queue", queue)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_axi_txns)
			;
		}
		/// <summary>
		/// Enable Activity Monitor runs for the specified hardware HBM(s)
		///
		///
		/// TCL Syntax: run_hw_hbm_amon [-quiet] [-verbose] <hw_objects>
		///
		/// The HBM activity monitor (amon) can be used to gain real-time access to performance
		/// monitoring and temperature sensors certain Xilinx® UltraScale+ devices that include an
		/// integrated High-Bandwidth Memory (HBM) controller. Refer to the LogiCore IP Product Guide:
		/// AXI High Bandwidth Memory Controller (PG276) for more information on this core. The HBM
		/// controller and memory stacks contain both performance counters and temperature sensors that
		/// can be accessed through the HBM activity monitor from within the Xilinx Vivado hardware
		/// manager. The HBM activity monitor displays read, write, and overall throughput of data, as well
		/// as the device temperature. The activity monitor displays, captures, and exports data to a CSV file
		/// when it is running.
		/// The run_hw_hbm_amon command runs an HBM activity monitor in the Vivado hardware
		/// manager that has been previously configured using the add_hw_hbm_pc command.
		/// This command returns the file path and name of a CSV file the collected data will be written to,
		/// or returns an error if it fails.
		///
		/// The following example runs the HBM activity monitor for the associated HBM core:
		/// run_hw_hbm_amon [get_hw_hbms *HBM_2]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1516
		/// </summary>
		/// <param name="hw_objects">(Required) hardware objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand run_hw_hbm_amon(string hw_objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: run_hw_hbm_amon [-quiet] [-verbose] <hw_objects>
			return
				new SimpleTCLCommand("run_hw_hbm_amon")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_objects)
			;
		}
		/// <summary>
		/// Arm hardware ILAs.
		///
		///
		/// TCL Syntax: run_hw_ila [-trigger_now] [-compile_only] [-file <arg>] [-force] [-quiet] [-verbose] [<hw_ilas>...]
		///
		/// Arm triggers and run the specified hardware ILA debug cores on the current hardware device.
		/// The Integrated Logic Analyzer (ILA) debug core lets you perform in-system debug of
		/// implemented designs, or design bitstreams, on a programmed Xilinx FPGA. The ILA core includes
		/// many advanced features of modern logic analyzers, including boolean trigger equations, and edge
		/// transition triggers. You can use the ILA core to probe specific signals of the design, to trigger on
		/// programmed hardware events, and capture data samples from the Xilinx FPGA in real-time. Refer
		/// to LogiCORE IP Integrated Logic Analyzer (PG172) for details of the ILA core.
		/// You can add ILA debug cores into the RTL source files of a design, or in the synthesized netlist
		/// using the create_debug_core command. Refer to the Vivado Design Suite User Guide: Vivado
		/// Programming and Debugging (UG908) for more information on adding debug cores and signal
		/// probes to the design.
		/// Debug cores and probes are written to a probes file (.ltx) using the write_debug_probes
		/// command, and associated with the hardware device along with the bitstream file (.bit) using
		/// the PROBES.FILE and PROGRAM.FILE properties of the hw_device object. The hardware device
		/// is programmed using the program_hw_devices command. The ILA debug cores in the design
		/// are accessible from the Hardware Manager using the get_hw_ilas command. The debug
		/// probes assigned to the ILA debug cores can be returned with the get_hw_probes command.
		/// The steps to debug your design in hardware using an ILA debug core are:
		/// 1. Connect to the hardware server and target using connect_hw_server and
		/// open_hw_target.
		/// 2. Program the FPGA with the bitstream (.bit) and probes (.ltx) files using
		/// program_hw_devices.
		/// 3. Set up the ILA debug core trigger events and data capture controls using set_property to
		/// configure properties of the ILA.
		/// 4. Arm the ILA debug core triggers on the Xilinx FPGA using run_hw_ila. When a trigger
		/// event occurs, or the capture condition is met, the ILA capture buffer is filled.
		/// 5. Uploaded sampled data from the hw_device into a Vivado logic analyzer hw_ila_data object
		/// using upload_hw_ila_data.
		/// 6. View the captured data in the Waveform window of the Vivado logic analyzer feature using
		/// display_hw_ila_data.
		/// You can set up an ILA debug core to trigger on specific events or conditions at the debug probes,
		/// and to capture data under specific conditions, using CONTROL properties on the hw_ila object.
		/// You set these properties with the set_property command. Refer to the Vivado Design Suite
		/// User Guide: Vivado Programming and Debugging (UG908) for more information on setting
		/// properties to configure debug cores and signal probes to monitor the design.
		/// RECOMMENDED: The Vivado IDE provides a graphical interface to configure hw_ila and hw_probes for trigger
		/// and capture. You can use the Vivado IDE to see the properties needed to configure and run the hw_ila.
		/// The specific properties on the hw_ila you can use to configure a debug core include the
		/// following:
		/// • CONTROL.DATA_DEPTH - Defaults to the MAX_DATA_DEPTH of the ILA debug core, which
		/// was set when the debug core was created or inserted into the design. The data depth defines
		/// the number of data samples the hw_ila object can capture in a data window. Set the data
		/// depth as an integer which is a power of two, from 1 to the maximum data depth
		/// (MAX_DATA_DEPTH) of the hw_ila.
		/// Note: The value of DATA_DEPTH is related to CONTROL.WINDOW_COUNT by the equation:
		/// DATA_DEPTH * WINDOW_COUNT = MAX_DATA_DEPTH
		/// • CONTROL.WINDOW_COUNT - Lets you divide the MAX_DATA_DEPTH of the ILA core into
		/// a number of data windows to store sample data from multiple trigger events. In the case of 10
		/// data windows for example, the first window will be filled at the first trigger event, and each
		/// subsequent window will be filled upon subsequent triggering events or capture conditions.
		/// • CONTROL.TRIGGER_POSITION - An integer value related to the DATA_DEPTH. Positions the
		/// trigger event in the sample data buffer. For a DATA_DEPTH of 1024, position 0 refers to the
		/// first (or left-most) data buffer and 1023 refers to the last (or right-most) data buffer. The
		/// TRIGGER_POSITION lets you capture sample data ahead of the trigger event. For instance,
		/// with a DATA_DEPTH of 256, a TRIGGER_POSITION of 100 allows you to capture 100 data
		/// samples ahead of the trigger, and 155 data samples at and after the trigger event.
		/// Note: In the case of run_hw_ila -trigger_now 1, the TRIGGER_POSITION merely positions the
		/// trigger mark in the Vivado logic analyzer waveform window. Because the trigger event is immediate,
		/// there is no time to capture data samples ahead of the trigger.
		/// • CONTROL.TRIGGER_MODE - Valid values include:
		/// ○ BASIC_ONLY - The trigger condition is the result of a Boolean equation using the
		/// TRIGGER_CONDITION to evaluate the values on each of the associated ILA probes.
		/// ○ BASIC_OR_TRIG_IN - The ILA core is triggered by a Boolean equation considering probe
		/// values, or by the TRIG_IN port on the core.
		/// ○ ADVANCED_ONLY - The ILA core is configured to have advanced trigger capabilities
		/// defined in a user-defined Trigger State Machine (TSM).
		/// ○ ADVANCED_OR_TRIG_IN - The ILA core is triggered by the TSM or by the TRIG_IN port
		/// on the core.
		/// ○ TRIG_IN_ONLY - The ILA core is triggered only by the TRIG_IN port on the core.
		/// • CONTROL.TRIGGER_CONDITION - Defines a Boolean equation which evaluates comparators
		/// on participating probes on the ILA debug core. When the condition evaluates to true, the
		/// BASIC trigger mode is satisfied. Valid values include:
		/// ○ AND - Trigger condition is "true" if all participating probe comparators evaluate "true",
		/// otherwise trigger condition is "false".
		/// ○ NAND - Trigger condition is "true" if at least one participating probe comparator evaluates
		/// "false", otherwise trigger condition is "false".
		/// ○ OR - Trigger condition is "true" if at least one participating probe comparator evaluates
		/// "true", otherwise trigger condition is "false".
		/// ○ NOR - Trigger condition is "true" if all participating probe comparators evaluate "false",
		/// otherwise trigger condition is "false".
		/// Note: The evaluation of the probes participating in the trigger condition is determined by the
		/// TRIGGER_COMPARE_VALUE property assigned to the hw_probe object, as returned by
		/// get_hw_probes. If the TRIGGER_COMPARE_VALUE is 'X' then it is not participating in the trigger
		/// condition.
		/// • CONTROL.TSM_FILE - Specify the path to a file defining a Trigger Finite State Machine (TSM)
		/// to be used for advanced trigger handling.
		/// • CONTROL.TRIG_OUT_MODE - Used to transition the TRIG_OUT port on the ILA core to be
		/// used to drive the TRIG_IN port on other ILA cores. Valid values include:
		/// ○ DISABLED - Disable the TRIG_OUT port on the ILA core.
		/// ○ TRIGGER_ONLY - Transition the TRIG_OUT port when the trigger conditions have been
		/// satisfied.
		/// ○ TRIG_IN_ONLY - Transition the TRIG_OUT when the TRIG_IN signal transitions. Use this to
		/// pass the trigger event along a chain of ILA cores.
		/// ○ TRIGGER_OR_TRIG_IN - Transition the TRIG_OUT when either the trigger conditions are
		/// satisfied, or the TRIG_IN transitions.
		/// • CONTROL.CAPTURE_MODE - Valid values include ALWAYS or BASIC. Capture and store a
		/// data sample on the debug core ALWAYS during a given clock cycle, or only if the
		/// CAPTURE_CONDITION evaluates to "true" (BASIC).
		/// • CONTROL.CAPTURE_CONDITION - Defines a Boolean equation for participating probe
		/// comparators on the ILA debug core that must evaluate to TRUE to meet the data capture
		/// condition. When the capture condition evaluates to true, the BASIC capture mode is satisfied.
		/// Valid values include:
		/// ○ AND - Capture condition is "true" if all participating probe comparators evaluate "true",
		/// otherwise capture condition is "false".
		/// ○ NAND - Capture condition is "true" if at least one participating probe comparator evaluates
		/// "false", otherwise capture condition is "false".
		/// ○ OR - Capture condition is "true" if at least one participating probe comparator evaluates
		/// "true", otherwise capture condition is "false".
		/// ○ NOR - Capture condition is "true" if all participating probe comparators evaluate "false",
		/// otherwise capture condition is "false".
		/// Note: The evaluation of the probes participating in the capture condition is determined by the
		/// CAPTURE_COMPARE_VALUE property assigned to the hw_probe object, as returned by
		/// get_hw_probes. If the CAPTURE_COMPARE_VALUE is 'X' then it is not participating in the trigger
		/// condition.
		/// TIP: There are other properties on the ILA core that also determine the operation of the core, but they are not
		/// user-configurable.
		/// With the ILA core configured, you can use the run_hw_ila command to arm the ILA cores on
		/// the target part. When this command is run, the trigger configurations defined in the hw_ila and
		/// hw_probe objects are written to the target Xilinx FPGA (hw_device) and arms the ILA core or
		/// cores on the device.
		/// With the hw_ila armed and running, the wait_on_hw_ila command stops your Tcl script to
		/// wait for the data sample buffers to be populated with captured data. When the memory of the
		/// ILA core is full on the physical hw_device, the wait_on_hw_ila command returns, and your Tcl
		/// script resumes.
		/// You can use upload_hw_ila_data to upload the captured data from the physical memory of
		/// the hw_device into a hw_ila_data object in the Vivado logic analyzer. Then view the ILA data in
		/// the waveform window of the Vivado logic analyzer using display_hw_ila_data, and write
		/// the data for use in external tools using the write_hw_ila_data command.
		/// You can also immediately trigger the probes on the hw_device using the -trigger_now option,
		/// to capture data from the device right away, rather than waiting for trigger events or capture
		/// conditions to be met over time.
		/// You can use reset_hw_ila to restore the CONTROL properties of the ILA debug core to their
		/// default setting, and reset the probe comparator values to 'X'.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1518
		/// </summary>
		/// <param name="trigger_now">(Optional) Trigger and capture immediately.</param>
		/// <param name="compile_only">(Optional) Test only compile trigger state machine file but do not upload.</param>
		/// <param name="file">(Optional) Trigger at startup file name. Command will not arm ILA core.</param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_ilas">(Optional) hardware ILAs Default: Current hardware ILA</param>
		public virtual SimpleTCLCommand run_hw_ila(bool? trigger_now = null, bool? compile_only = null, string file = null, bool? force = null, bool? quiet = null, bool? verbose = null, string hw_ilas = null)
		{
			// TCL Syntax: run_hw_ila [-trigger_now] [-compile_only] [-file <arg>] [-force] [-quiet] [-verbose] [<hw_ilas>...]
			return
				new SimpleTCLCommand("run_hw_ila")
					.Flag("trigger_now", trigger_now)
					.Flag("compile_only", compile_only)
					.OptionalNamedString("file", file)
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(hw_ilas)
			;
		}
		/// <summary>
		/// Run hardware SIO scans.
		///
		///
		/// TCL Syntax: run_hw_sio_scan [-quiet] [-verbose] <hw_sio_scans>
		///
		/// Run the specified serial I/O analyzer link scan.
		/// To analyze the margin of a given link, it is often helpful to run a scan of the link using the
		/// specialized Eye Scan hardware of Xilinx UltraScale devices or 7 series FPGAs. The Vivado serial
		/// I/O analyzer feature lets you to create, run, and save link scans.
		/// This command creates and returns a link scan object that you can use with the
		/// run_hw_sio_scan command to run analysis on the specified links, or GT receivers. You can
		/// also save the scan to disk using the write_hw_sio_scan command.
		/// This command run analysis on the specified scan objects. If running in a Tcl script, you can
		/// suspend the script while the scan completes using the wait_on_hw_sio_scan command. You
		/// can stop a running scan using the stop_hw_sio_scan command.
		/// You can save the scan to disk using the write_hw_sio_scan command.
		/// You can remove the created scan object using remove_hw_sio_scan.
		/// This command returns the hw_sio_scan object, or returns an error if the command fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1524
		/// </summary>
		/// <param name="hw_sio_scans">(Required) hardware SIO scans</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand run_hw_sio_scan(string hw_sio_scans, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: run_hw_sio_scan [-quiet] [-verbose] <hw_sio_scans>
			return
				new SimpleTCLCommand("run_hw_sio_scan")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_sio_scans)
			;
		}
		/// <summary>
		/// Run hardware SIO sweeps.
		///
		///
		/// TCL Syntax: run_hw_sio_sweep [-quiet] [-verbose] <hw_sio_sweeps>
		///
		/// Run a serial I/O analyzer link sweep scan to run multiple scans across a range of values.
		/// To analyze the margin of a given link, it is often helpful to run a scan of the link using the
		/// specialized features of Xilinx UltraScale devices or 7 series FPGAs. It can also be helpful to run
		/// multiple scans on a the link with different configuration settings for the GTs. This can help you
		/// determine which settings are best for your design. The Vivado serial I/O analyzer feature enables
		/// you to define, run, and save link sweeps, or collections of link scans run across a range of values.
		/// This command run analysis on the specified sweep scan objects. If running in a Tcl script, you can
		/// suspend the script while the sweep scan completes using the wait_on_hw_sio_sweep
		/// command. You can stop a running sweep scan using the stop_hw_sio_sweep command.
		/// You can save the sweep scan to disk using the write_hw_sio_sweep command.
		/// You can remove the created scan object using remove_hw_sio_sweep.
		/// This command returns the hw_sio_sweep object, or returns an error if the command fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1526
		/// </summary>
		/// <param name="hw_sio_sweeps">(Required) hardware SIO sweeps</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand run_hw_sio_sweep(string hw_sio_sweeps, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: run_hw_sio_sweep [-quiet] [-verbose] <hw_sio_sweeps>
			return
				new SimpleTCLCommand("run_hw_sio_sweep")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_sio_sweeps)
			;
		}
		/// <summary>
		/// change to a stable state of a specified transition
		///
		///
		/// TCL Syntax: run_state_hw_jtag [-state <args>] [-quiet] [-verbose] <stable_state>
		///
		/// Transition the hw_jtag object of the current hardware target to the specified TAP stable state.
		/// A hw_jtag object is created by the Hardware Manager feature of the Vivado Design Suite when a
		/// hardware target is opened in JTAG mode using the open_hw_target -jtag_mode command.
		/// The run_state_hw_jtag command specifies:
		/// • An ending or target TAP stable state to transition to.
		/// • An optional state path list to transition through to get from the current state to the target
		/// state.
		/// If an optional -state path list is defined, then the state list must contain all states needed to
		/// reach the stable state, or the command will return an error. If no state path list is defined, then
		/// the command will transition from the current state to the target state according to the state
		/// transition paths defined in the following table:
		/// Current Target State Transition Path
		/// State State
		/// DRPAUSE RESET DRPAUSE -> DREXIT2 -> DRUPDATE -> DRSELECT ->
		/// IRSELECT-> RESET
		/// DRPAUSE IDLE DRPAUSE -> DREXIT2 -> DRUPDATE -> IDLE
		/// DRPAUSE DRPAUSE DRPAUSE -> DREXIT2 -> DRUPDATE -> DRSELECT ->
		/// DRCAPTURE -> DREXIT1 -> DRPAUSE
		/// DRPAUSE IRPAUSE DRPAUSE -> DREXIT2 -> DRUPDATE -> DRSELECT ->
		/// IRSELECT -> IRCAPTURE -> IREXIT12 -> IRPAUSE
		/// IDLE RESET IDLE -> DRSELECT -> IRSELECT -> RESET
		/// IDLE IDLE IDLE
		/// IDLE DRPAUSE IDLE -> DRSELECT -> DRCAPTURE -> DREXIT1 ->
		/// DRPAUSE
		/// IDLE IRPAUSE IDLE -> DRPAUSE -> IRSELECT ->IRCAPTURE ->
		/// IREXIT1 -> IRPAUSE
		/// IRPAUSE RESET IRPAUSE -> IREXIT2 -> IRUPDATE -> DRSELECT ->
		/// IRSELECT -> RESET
		/// IRPAUSE IDLE IRPAUSE -> IREXIT2 -> IRUPDATE -> IDLE
		/// IRPAUSE DRPAUSE IRPAUSE -> IREXIT2 -> IRUPDATE -> DRSELECT ->
		/// DRCAPTURE -> DREXIT1 -> DRPAUSE
		/// IRPAUSE IRPAUSE IRPAUSE -> IREXIT2 -> IRUPDATE -> DRSELECT ->
		/// IRSELECT -> IRCAPTURE -> IREXIT1 -> IRPAUSE
		/// RESET RESET RESET
		/// RESET IDLE RESET -> IDLE
		/// RESET DRPAUSE RESET -> IDLE -> DRSELECT -> DRCAPTURE ->
		/// DREXIT1 -> DRPAUSE
		/// RESET IRPAUSE RESET -> IDLE -> DRSELECT -> IRSELECT ->
		/// IRCAPTURE -> IREXIT1 -> IRPAUSE
		/// This command returns the target stable state when successful, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1528
		/// </summary>
		/// <param name="stable_state">
		/// (Required)
		/// valid stable_state - valid stable states IDLE, RESET, IRPAUSE,
		/// and DRPAUSE
		/// </param>
		/// <param name="state">(Optional) valid state path sequence to stable_state</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>hardware JTAG</returns>
		public virtual SimpleTCLCommand run_state_hw_jtag(string stable_state, string state = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: run_state_hw_jtag [-state <args>] [-quiet] [-verbose] <stable_state>
			return
				new SimpleTCLCommand("run_state_hw_jtag")
					.OptionalNamedString("state", state)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(stable_state)
			;
		}
		/// <summary>
		/// Forces IEEE 1149.1 TAP state machine to a stable state for a specified wait period
		///
		///
		/// TCL Syntax: runtest_hw_jtag [-wait_state <arg>] [-end_state <arg>] [-sec <arg>] [-max_wait <arg>] [-tck <arg>] [-quiet] [-verbose]
		///
		/// Specify a wait operation for the hw_jtag object state machine which defines:
		/// • Which TAP stable state to go to perform the wait operation.
		/// • A wait time expressed as:
		/// ○ 'n' TCK cycles, where 'n' is a 32-bit unsigned decimal number.
		/// ○ A minimum and optionally maximum time in seconds to stay in the wait state, with
		/// min/max times specified as unsigned integers or real numbers.
		/// • The TAP stable state to go after the wait operation has completed.
		/// The default values for -wait_state and -end_state are IDLE. If a non-IDLE wait_state or
		/// end_state are defined, then the hw_jtag object will first transition to the specified wait_state
		/// before starting the wait operation. Once the wait time has elapsed, the hw_jtag object transitions
		/// to the specified end_state. When the wait_state and/or end_state are specified by the
		/// runtest_hw_jtag command, subsequent commands will use the same wait_state/end_state
		/// unless they are changed.
		/// This command returns the end stable state, or returns an error if it fails.
		/// Note: If the command cannot meet the wait time specification, then it will raise an exception that can be
		/// trapped by the Tcl catch command.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1531
		/// </summary>
		/// <param name="wait_state">
		/// (Optional)
		/// valid stable_state - valid stable states IDLE, RESET, IRPAUSE,
		/// and DRPAUSE
		/// </param>
		/// <param name="end_state">
		/// (Optional)
		/// valid stable_state - valid stable states IDLE, RESET, IRPAUSE,
		/// and DRPAUSE
		/// </param>
		/// <param name="sec">(Optional) Number of seconds to wait in wait_state</param>
		/// <param name="max_wait">(Optional) Maximum Number of seconds to wait in wait_state - max timeout</param>
		/// <param name="tck">
		/// (Optional)
		/// Number of TCK cycles to wait in wait_state Default: Number
		/// of TCK cycles to wait in wait_state
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand runtest_hw_jtag(string wait_state = null, string end_state = null, string sec = null, string max_wait = null, string tck = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: runtest_hw_jtag [-wait_state <arg>] [-end_state <arg>] [-sec <arg>] [-max_wait <arg>] [-tck <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("runtest_hw_jtag")
					.OptionalNamedString("wait_state", wait_state)
					.OptionalNamedString("end_state", end_state)
					.OptionalNamedString("sec", sec)
					.OptionalNamedString("max_wait", max_wait)
					.OptionalNamedString("tck", tck)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Save an existing IP subsystem design to disk file.
		///
		///
		/// TCL Syntax: save_bd_design [-quiet] [-verbose] [<name>]
		///
		/// Saves any changes to the current or specified IP subsystem design in the IP integrator of the
		/// Vivado Design Suite.
		/// This command returns TCL_OK if successful, or TCL_ERROR if it fails.
		///
		/// The following example saves the current IP subsystem design in the current project:
		/// save_bd_design
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1534
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="name">(Optional) Name of design to save.</param>
		/// <returns>TCL_OK, TCL_ERROR if failed.</returns>
		public virtual SimpleTCLCommand save_bd_design(bool? quiet = null, bool? verbose = null, string name = null)
		{
			// TCL Syntax: save_bd_design [-quiet] [-verbose] [<name>]
			return
				new SimpleTCLCommand("save_bd_design")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(name)
			;
		}
		/// <summary>
		/// Save a copy of the existing IP subsystem design to specified disk file with a different name.
		/// Generated output products will not be saved.
		///
		///
		/// TCL Syntax: save_bd_design_as [-dir <arg>] [-ignore_comments] [-force] [-quiet] [-verbose] [<name>]
		///
		/// Save a copy of an existing block design from the IP integrator to a new location, or with a
		/// different name. The generated output products of the block design will not be saved to the new
		/// block design.
		/// Note: You cannot create a copy of a block design that has locked IP. The IP must be unlocked or the
		/// command will return an error.
		///
		/// The following example saves the current block design to the specified directory, and renames it
		/// to the specified name:
		/// save_bd_design_as -dir C:/Data new_Block
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1536
		/// </summary>
		/// <param name="dir">
		/// (Optional)
		/// Directory path for remote BD to be created and managed.
		/// This is required if a name is not specified
		/// </param>
		/// <param name="ignore_comments">(Optional) Do not save user comments</param>
		/// <param name="force">(Optional) Overwrite existing file if present</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="name">
		/// (Optional)
		/// Name of the design to create. This is required if a directory
		/// is not specified
		/// </param>
		/// <returns>TCL_OK, TCL_ERROR if failed.</returns>
		public virtual SimpleTCLCommand save_bd_design_as(string dir = null, bool? ignore_comments = null, bool? force = null, bool? quiet = null, bool? verbose = null, string name = null)
		{
			// TCL Syntax: save_bd_design_as [-dir <arg>] [-ignore_comments] [-force] [-quiet] [-verbose] [<name>]
			return
				new SimpleTCLCommand("save_bd_design_as")
					.OptionalNamedString("dir", dir)
					.Flag("ignore_comments", ignore_comments)
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(name)
			;
		}
		/// <summary>
		/// Save the current design's constraints
		///
		///
		/// TCL Syntax: save_constraints [-force] [-quiet] [-verbose]
		///
		/// Saves any changes to the constraints files of the active constraints set. This command writes any
		/// changes to the constraints files to the project data on the hard drive; saving any work in progress
		/// and committing any changes.
		///
		/// The following example saves the constraints files for the active constraints set regardless of any
		/// changes to the files:
		/// save_constraints -force
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1538
		/// </summary>
		/// <param name="force">
		/// (Optional)
		/// Force constraints save, overwriting the target and source
		/// XDC if necessary
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand save_constraints(bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: save_constraints [-force] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("save_constraints")
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Save current design's constraints as a new set of constraints files
		///
		///
		/// TCL Syntax: save_constraints_as [-dir <arg>] [-target_constrs_file <arg>] [-quiet] [-verbose] <name>
		///
		/// Copies the active constraints set to create a new constraints set, with local copies of any
		/// constraints files that are part of the constraints set. You can also specify a new constraints file to
		/// use as the target for the copied constraints set.
		/// Use this command to save changes to the constraints in a design without affecting the current
		/// constraints files. This allows you to do some "what-if" type development of design constraints.
		/// Note: The new constraint set created by the save_constraints_as command will not be active in the
		/// design, although it will be referenced by the design. To make the constraints set active you must set the
		/// constrset property to point to the new constraints set for specific runs. See the example below.
		///
		/// The following example saves the active constraints set into a new constraints set called
		/// constrs_2, and copies any constraints files into the specified directory, as well as creating a new
		/// target constraints file for the constraints set:
		/// save_constraints_as -dir C:/Data/con1 \
		/// -target_constrs_file rev1.xdc constrs_2
		/// The following example saves the active constraints set as a new constraints set called newCon2,
		/// and copies any constraint files into the newCon2 constraint directory under project sources. The
		/// constrset property for the specified synthesis and implementation runs are then set to point to
		/// the new constraints set:
		/// save_constraints_as newCon2
		/// set_property CONSTRSET newCon2 [get_runs synth_1]
		/// set_property CONSTRSET newCon2 [get_runs impl_1]
		/// Note: The constraints set is not active in the design until it has been set to active for the current runs.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1540
		/// </summary>
		/// <param name="name">(Required) Name of the new constraints fileset</param>
		/// <param name="dir">(Optional) Directory to save constraints to</param>
		/// <param name="target_constrs_file">(Optional) Target constraints file for the new fileset</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand save_constraints_as(string name, string dir = null, string target_constrs_file = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: save_constraints_as [-dir <arg>] [-target_constrs_file <arg>] [-quiet] [-verbose] <name>
			return
				new SimpleTCLCommand("save_constraints_as")
					.OptionalNamedString("dir", dir)
					.OptionalNamedString("target_constrs_file", target_constrs_file)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
			;
		}
		/// <summary>
		/// Save the current project under a new name
		///
		///
		/// TCL Syntax: save_project_as [-scan_for_includes] [-exclude_run_results] [-include_local_ip_cache] [-force] [-quiet] [-verbose] <name> [<dir>]
		///
		/// Saves a currently open project file under a new name in the specified directory, or in the current
		/// working directory if no other directory is specified.
		/// This command save a Vivado Design Suite project file (.xpr), or a project file for the Vivado Lab
		/// Edition (.lpr), in the specified directory.
		/// The command returns the name of the saved project, or returns an error if it fails.
		///
		/// The following example saves the active project as a new project called myProject in a directory
		/// called myProjectDir:
		/// save_project_as myProject myProjectDir
		/// Note: Because <dir> is specified as the folder name only, the tool will create the project in the current
		/// working directory, or the directory from which the tool was launched.
		/// The following example saves the current project to a new project called myProject in a directory
		/// called C:/Designs/myProjectDir. If you use the -force argument, the tool will overwrite an
		/// existing project if one is found in the specified location.
		/// save_project_as myProject C:/Designs/myProjectDir -force
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1542
		/// </summary>
		/// <param name="name">(Required) New name for the project to save</param>
		/// <param name="scan_for_includes">(Optional) Scan for include files and add them to the new project</param>
		/// <param name="exclude_run_results">(Optional) Exclude run results in the new project</param>
		/// <param name="include_local_ip_cache">(Optional) Include IP cache results in the new project</param>
		/// <param name="force">(Optional) Overwrite existing project directory</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="dir">(Optional) Directory where the project file is saved Default: .</param>
		/// <returns>saved project object</returns>
		public virtual SimpleTCLCommand save_project_as(string name, bool? scan_for_includes = null, bool? exclude_run_results = null, bool? include_local_ip_cache = null, bool? force = null, bool? quiet = null, bool? verbose = null, string dir = null)
		{
			// TCL Syntax: save_project_as [-scan_for_includes] [-exclude_run_results] [-include_local_ip_cache] [-force] [-quiet] [-verbose] <name> [<dir>]
			return
				new SimpleTCLCommand("save_project_as")
					.Flag("scan_for_includes", scan_for_includes)
					.Flag("exclude_run_results", exclude_run_results)
					.Flag("include_local_ip_cache", include_local_ip_cache)
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
					.OptionalString(dir)
			;
		}
		/// <summary>
		/// Saves the specified or current wave configuration object to the given filename
		///
		///
		/// TCL Syntax: save_wave_config [-object <args>] [-quiet] [-verbose] [<filename>]
		///
		/// Save the current or specified wave configuration object to a specified filename.
		/// If the wave configuration object has not been saved before, and does not have a FILE_PATH
		/// property value, the <filename> is required and the NAME of the wave configuration object will
		/// be changed to match the specified <filename>.
		/// If the specified wave configuration object has been previously saved, and has a FILE_PATH
		/// property, the object will be written to its current location, and the <filename> does not need to
		/// be specified.
		/// If the wave configuration object has a FILE_PATH property, but a different <filename> is
		/// specified, the wave configuration object will be saved to the new <filename>, and the object will
		/// be renamed to match the specified <filename>.
		///
		/// The following example saves the specified wave configuration object to a new filename:
		/// save_wave_config -object [get_wave_configs test.wcfg] \
		/// C:/Data/project/newTest
		/// Note: The wave config file will be assigned the .wcfg suffix since none is specified.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1545
		/// </summary>
		/// <param name="@object">
		/// (Optional)
		/// The WCFG or wave configuration to save. Default: Current
		/// wave configuration
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="filename">(Optional) Filename to save the specified or current wave configuration object</param>
		/// <returns>The wave configuration object saved</returns>
		public virtual SimpleTCLCommand save_wave_config(string @object = null, bool? quiet = null, bool? verbose = null, string filename = null)
		{
			// TCL Syntax: save_wave_config [-object <args>] [-quiet] [-verbose] [<filename>]
			return
				new SimpleTCLCommand("save_wave_config")
					.OptionalNamedString("object", @object)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(filename)
			;
		}
		/// <summary>
		/// Perform shift DR on 'hw_jtag'.
		///
		///
		/// TCL Syntax: scan_dr_hw_jtag [-tdi <arg>] [-tdo <arg>] [-mask <arg>] [-smask <arg>] [-quiet] [-verbose] <length>
		///
		/// The scan_dr_hw_jtag command specifies a scan pattern to be scanned into the JTAG
		/// interface target data register.
		/// The command targets a hw_jtag object which is created when the hw_target is opened in JTAG
		/// mode through the use of the open_hw_target -jtag_mode command.
		/// When targeting the hw_jtag object prior to shifting the scan pattern specified in the
		/// scan_dr_hw_jtag command, the last defined header property (HDR) will be pre-pended to the
		/// beginning of the specified data pattern, and the last defined trailer property (TDR) will be
		/// appended to the end of the data pattern.
		/// The options can be specified in any order, but can only be specified once. The number of bits
		/// represented by the hex strings specified for -tdi, -tdo, -mask, or -smask cannot be greater
		/// than the maximum specified by <length>. Leading zeros are assumed for a hex string if the
		/// number of bits represented by the hex strings specified is less than the <length>.
		/// When shifting the data bits to the target data register, the scan_dr_hw_jtag command moves
		/// the JTAG TAP from the current stable state to the DRSHIFT state according to the state
		/// transition table below:
		/// Current State Transitions to get to DRSHIFT state
		/// RESET IDLE -> DRSELECT -> DRCAPTURE -> DRSHIFT
		/// IDLE DRSELECT -> DRCAPTURE ->
		/// DRSHIFT
		/// IRPAUSE IREXIT2 -> IRUPDATE -> DRSELECT -> DRCAPTURE ->
		/// DRSHIFT
		/// DRPAUSE DREXIT2 ->
		/// DRSHIFT
		/// DRPAUSE* DREXIT2 -> DRUPDATE -> DRSELECT -> DRCAPTURE -> DRSHIFT
		/// Note: * With -force_update option set.
		/// After the last data bit is shifted into the target data register, the scan_dr_hw_jtag command
		/// moves the JTAG TAP to the IDLE state, or to the stable state defined by the
		/// run_state_hw_jtag command.
		/// The scan_dr_hw_jtag command returns a hex array containing captured TDO data from the
		/// hw_jtag, or returns an error if it fails.
		/// The command raises an error that can be trapped by the Tcl catch command if TDO data from
		/// the hw_jtag does not match specified -tdo argument.
		/// TIP: If -tdo and -mask arguments are specified, then the mask is applied to the -tdo option and the hw_jtag
		/// TDO data returned before comparing the two.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1547
		/// </summary>
		/// <param name="length">(Required) Number of bits to be scanned.</param>
		/// <param name="tdi">(Optional) Hex value to be scanned into the target</param>
		/// <param name="tdo">(Optional) Hex value to be compared against the scanned value</param>
		/// <param name="mask">(Optional) Hex value mask applied when comparing TDO values</param>
		/// <param name="smask">(Optional) Hex value mask applied to TDI value</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>hardware TDO</returns>
		public virtual SimpleTCLCommand scan_dr_hw_jtag(string length, string tdi = null, string tdo = null, string mask = null, string smask = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: scan_dr_hw_jtag [-tdi <arg>] [-tdo <arg>] [-mask <arg>] [-smask <arg>] [-quiet] [-verbose] <length>
			return
				new SimpleTCLCommand("scan_dr_hw_jtag")
					.OptionalNamedString("tdi", tdi)
					.OptionalNamedString("tdo", tdo)
					.OptionalNamedString("mask", mask)
					.OptionalNamedString("smask", smask)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(length)
			;
		}
		/// <summary>
		/// Perform shift IR on 'hw_jtag'.
		///
		///
		/// TCL Syntax: scan_ir_hw_jtag [-tdi <arg>] [-tdo <arg>] [-mask <arg>] [-smask <arg>] [-quiet] [-verbose] <length>
		///
		/// The scan_ir_hw_jtag command specifies a scan pattern to be scanned into the JTAG
		/// interface target instruction register.
		/// The command targets a hw_jtag object which is created when the hw_target is opened in JTAG
		/// mode through the use of the open_hw_target -jtag_mode command.
		/// When targeting the hw_jtag object prior to shifting the scan pattern specified in the
		/// scan_ir_hw_jtag command, the last defined header property (HIR) will be pre-pended to the
		/// beginning of the specified data pattern, and the last defined trailer property (TIR) will be
		/// appended to the end of the data pattern.
		/// The options can be specified in any order, but can only be specified once. The number of bits
		/// represented by the hex strings specified for -tdi, -tdo, -mask, or -smask cannot be greater
		/// than the maximum specified by <length>. Leading zeros are assumed for a hex string if the
		/// number of bits represented by the hex strings specified is less than the <length>.
		/// When shifting the bits into the target instruction register, the scan_ir_hw_jtag command
		/// moves the JTAG TAP from the current stable state to the IRSHIFT state according to the state
		/// transition table below:
		/// Current Transitions to get to
		/// State IRSHIFT state
		/// RESET IDLE > DRSELECT > IRSELECT > IRCAPTURE > IRSHIFT
		/// IDLE IRSELECT > IRCAPTURE > IRSHIFT
		/// DRPAUSE DREXIT2 > DRUPDATE > DRSELECT > IRSELECT > IRCAPTURE > IRSHIFT
		/// IRPAUSE IREXIT2 > IRSHIFT
		/// IRPAUSE* IREXIT2 > IRUPDATE > DRSELECT > IRSELECT > IRCAPTURE > IRSHIFT
		/// Note: * With -force_update option set.
		/// After the last data bit is shifted into the target data register, the scan_ir_hw_jtag command
		/// moves the JTAG TAP to the IDLE state, or to the stable state defined by the run_state_hw_jtag
		/// command.
		/// The scan_ir_hw_jtag command returns a hex array containing captured TDO data from the
		/// hw_jtag, or returns an error if it fails.
		/// The command raises an error that can be trapped by the Tcl catch command if TDO data from
		/// the hw_jtag does not match specified -tdo argument.
		/// TIP: If -tdo and -mask arguments are specified, then the mask is applied to the -tdo option and the hw_jtag
		/// TDO data returned before comparing the two.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1551
		/// </summary>
		/// <param name="length">(Required) Number of bits to be scanned.</param>
		/// <param name="tdi">(Optional) Hex value to be scanned into the target</param>
		/// <param name="tdo">(Optional) Hex value to be compared against the scanned value</param>
		/// <param name="mask">(Optional) Hex value mask applied when comparing TDO values</param>
		/// <param name="smask">(Optional) Hex value mask applied to TDI value</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>hardware TDO</returns>
		public virtual SimpleTCLCommand scan_ir_hw_jtag(string length, string tdi = null, string tdo = null, string mask = null, string smask = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: scan_ir_hw_jtag [-tdi <arg>] [-tdo <arg>] [-mask <arg>] [-smask <arg>] [-quiet] [-verbose] <length>
			return
				new SimpleTCLCommand("scan_ir_hw_jtag")
					.OptionalNamedString("tdi", tdi)
					.OptionalNamedString("tdo", tdo)
					.OptionalNamedString("mask", mask)
					.OptionalNamedString("smask", smask)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(length)
			;
		}
		/// <summary>
		/// Select objects in GUI
		///
		///
		/// TCL Syntax: select_objects [-add] [-quiet] [-verbose] <objects>
		///
		/// Selects the specified object in the appropriate open views in the GUI mode. This command is for
		/// display purposes only. You must use the get_selected_objects command to return the
		/// selected objects for use in other commands.
		/// The select_objects command may select secondary objects in addition to the primary object
		/// specified. The selection of secondary objects is controlled through the use of Selection Rules
		/// defined in the Tools → Settings command. Refer to the Vivado Design Suite User Guide: Using the
		/// IDE (UG893) for more information on Setting Selection Rules.
		/// Selected objects can be unselected with the unselect_objects command.
		///
		/// The following example selects the specified site on the device:
		/// select_objects [get_sites SLICE_X56Y214]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1555
		/// </summary>
		/// <param name="objects">(Required) Objects to select</param>
		/// <param name="add">(Optional) Add to existing selection list</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand select_objects(string objects, bool? add = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: select_objects [-add] [-quiet] [-verbose] <objects>
			return
				new SimpleTCLCommand("select_objects")
					.Flag("add", add)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Display help for one or more topics
		///
		///
		/// TCL Syntax: select_wave_objects [-quiet] [-verbose] <items>...
		///
		/// Selects the specified object in the Waveform window of the Vivado IDE. This command is for
		/// selecting displayed items in the Waveform window only, and is similar to the select_objects
		/// command in the Vivado IDE.
		/// Note: Use the get_hdl_objects command to select simulation objects in the open simulation, or
		/// current_sim.
		/// Unselect selected objects using the select_wave_objects command with an empty string:
		/// select_wave_objects ""
		/// This command returns nothing if successful, or returns an error if it fails.
		///
		/// The following example selects the specified site on the device:
		/// select_wave_objects {sys_clk_p sysc_clk_n}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1557
		/// </summary>
		/// <param name="items">(Required) select waveform objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand select_wave_objects(string items, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: select_wave_objects [-quiet] [-verbose] <items>...
			return
				new SimpleTCLCommand("select_wave_objects")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(items)
			;
		}
		/// <summary>
		/// Define bus skew
		///
		///
		/// TCL Syntax: set_bus_skew [-from <args>] [-rise_from <args>] [-fall_from <args>] [-to <args>] [-rise_to <args>] [-fall_to <args>] [-through <args>] [-rise_through <args>] [-fall_through <args>] [-quiet] [-verbose] <value>
		///
		/// Set the bus skew requirement on bus signals that cross clock domains. The bus skew constraint
		/// defines the maximum skew spread between the fastest and slowest signals of the bus, and does
		/// not consider the overall datapath delay. The Vivado router will try to satisfy the set_bus_skew
		/// constraints. Example uses of the bus skew constraint include clock domain crossing for gray￾coded pointers, MUX-controlled and MUX-data holding CDC buses.
		/// TIP: Bus skew constraints are not overridden by clock groups, max delay, or false path, because
		/// set_bus_skew is a constraint between the signals of a bus, rather than on a particular path.
		/// The set_bus_skew constraint can be combined with the set_max_delay constraint for good
		/// results. The set_bus_skew constraint does not care about the absolute datapath delay, but
		/// only about the relative arrival times of data at the destination, taking into account source and
		/// destination clock skew. You can help set_bus_skew by also using set_max_delay -
		/// datapath_only <SRC_CLK>. This constraint helps the Vivado placer to ensure that the
		/// source and destination registers are not placed too far apart, so that the router can more easily
		/// satisfy the set_bus_skew constraint. Refer to the Vivado Design Suite User Guide: Using
		/// Constraints (UG903) for more information.
		/// In order to not over constrain the skew requirement, the bus skew value should be approximately
		/// the smallest period of the two clock domains. This will prevent multiple data captures by the
		/// destination clock domain.
		/// The set_bus_skew command requires a timing path defined by both -from and -to, or some
		/// form such as -fall_from or -rise_to. You can optionally specify -through values to
		/// further refine the path. You should specify explicit signal paths with -from/-to instead of
		/// specifying entire clock domains:
		/// • set_bus_skew -from [get_pins <hierarchy/C>] -to [get_pins
		/// <hierarchy/D>] <value>
		/// • set_bus_skew -from [get_clocks <clock name>] -to get_clocks <clock
		/// name>] <value>
		/// TIP: Do not set bus skew constraints between timed synchronous clock domains.
		/// You can use the report_bus_skew command to report the calculated skew on paths in the
		/// current design.
		/// The set_bus_skew command returns nothing if successful, or an error if it fails.
		///
		/// The following example defines the bus skew between the gray-coded Read and Write pointers:
		/// set_bus_skew -from [get_pins gray_coded_read_ptr[*]/C] \
		/// -to [get_pins gray_coded_write_ptr[*]/D] 2.5
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1559
		/// </summary>
		/// <param name="value">(Required) Constraint value</param>
		/// <param name="from">(Optional) List of path startpoints or clocks</param>
		/// <param name="rise_from">(Optional) Apply to paths rising from the list of startpoints or clocks</param>
		/// <param name="fall_from">(Optional) Apply to paths falling from the list of startpoints or clocks</param>
		/// <param name="to">(Optional) List of path endpoints or clocks</param>
		/// <param name="rise_to">(Optional) Apply to paths with rise transition at the list of endpoints or clocks</param>
		/// <param name="fall_to">(Optional) Apply to paths with fall transition at the list of endpoints or clocks</param>
		/// <param name="through">(Optional) List of through pins, cells or nets</param>
		/// <param name="rise_through">(Optional) Apply to paths rising through pins, cells or nets</param>
		/// <param name="fall_through">(Optional) Apply to paths falling through pins, cells or nets</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_bus_skew(string value, string from = null, string rise_from = null, string fall_from = null, string to = null, string rise_to = null, string fall_to = null, string through = null, string rise_through = null, string fall_through = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_bus_skew [-from <args>] [-rise_from <args>] [-fall_from <args>] [-to <args>] [-rise_to <args>] [-fall_to <args>] [-through <args>] [-rise_through <args>] [-fall_through <args>] [-quiet] [-verbose] <value>
			return
				new SimpleTCLCommand("set_bus_skew")
					.OptionalNamedString("from", from)
					.OptionalNamedString("rise_from", rise_from)
					.OptionalNamedString("fall_from", fall_from)
					.OptionalNamedString("to", to)
					.OptionalNamedString("rise_to", rise_to)
					.OptionalNamedString("fall_to", fall_to)
					.OptionalNamedString("through", through)
					.OptionalNamedString("rise_through", rise_through)
					.OptionalNamedString("fall_through", fall_through)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(value)
			;
		}
		/// <summary>
		/// Specify that an input is 1, 0, rising or falling
		///
		///
		/// TCL Syntax: set_case_analysis [-quiet] [-verbose] <value> <objects>
		///
		/// Specifies that a pin or port is in a steady state of 1, 0, rising or falling.
		/// This command is usually used to force values onto the ports to help reduce the analysis space,
		/// runtime and memory consumption. It is important to let the Vivado timing engine know about
		/// signals that have a constant value. This is also critical to ensure that non-functional and irrelevant
		/// paths are not reported.
		/// Setting a case value on a pin results in disabling timing analysis through that pin. This means that
		/// timing paths through that pin are not reported.
		/// Note: This command returns nothing if successful, or returns an error if it fails.
		///
		/// In the example below, two clocks are created on the input pins of the BUFGMUX, clock_sel, but
		/// only clk_B is propagated through the output pin after setting the constant value 1 on the
		/// selection pin S:
		/// create_clock -name clk_A -period 10.0 [get_pins clock_sel/I0]
		/// create_clock -name clk_B -period 15.0 [get_pins clock_sel/I1]
		/// set_case_analysis 1 [get_pins clock_sel/S]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1563
		/// </summary>
		/// <param name="value">
		/// (Required)
		/// Logic value on the pin: Values: 0, 1, rising, falling, zero, one,
		/// rise, fall
		/// </param>
		/// <param name="objects">(Required) List of ports or pins</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_case_analysis(string value, string objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_case_analysis [-quiet] [-verbose] <value> <objects>
			return
				new SimpleTCLCommand("set_case_analysis")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(value)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Set exclusive or asynchronous clock groups
		///
		///
		/// TCL Syntax: set_clock_groups [-name <arg>] [-logically_exclusive] [-physically_exclusive] [-asynchronous] [-group <args>] [-quiet] [-verbose]
		///
		/// TIP: The XDC > Timing Constraints language templates and the Timing Constraints Wizard in the Vivado IDE
		/// offer timing diagrams and additional details around defining specific timing constraints. You can refer to these
		/// sources for additional information.
		/// Define clocks, or groups of clocks, that are exclusive with or asynchronous to other clocks in the
		/// design. Exclusive clocks are not active at the same time, and paths between them can be ignored
		/// during timing analysis. Asynchronous clocks are clocks with no known phase relationship, which
		/// typically happens when they do not share the same primary clock or do not have a common
		/// period.
		/// Using this command is similar to defining false path constraints for data paths moving between
		/// exclusive or asynchronous clock domains. See the Vivado Design Suite User Guide: Using
		/// Constraints (UG903) for more information.
		/// If only one group is specified, the clocks in that group are asynchronous or exclusive to all other
		/// clocks in the design, but not to each other. If a new clock is created after the
		/// set_clock_groups command, it is asynchronous to that group as well.
		/// This command can also be used for multiple clocks that are derived from a single BUFGMUX as
		/// both of the clocks will not be active at the same time.
		/// Note: This command operates silently and does not return direct feedback of its operation.
		///
		/// Group all the elements driven by src_clk and sync_clk into separate clock groups. The clock
		/// groups are asynchronous to each other:
		/// set_clock_groups -group src_clk -group sync_clk -asynchronous
		/// The following example includes the generated clocks of the specified clocks, and adds those to
		/// the clock group:
		/// set_clock_groups -group [get_clocks -include_generated_clocks src_clk] \
		/// -group [get_clocks -include_generated_clocks sync_clk] -asynchronous
		/// Note: In the preceding example, src_clk and sync_clk, and all their generated clocks, are asynchronous.
		/// Otherwise the generated clocks would be timed against each other and the other master clock.
		/// In this example, the specified clocks are grouped together, and are asynchronous to all other
		/// clocks in the design:
		/// set_clock_groups -async -group [get_clocks {J_CLK U_CLK}]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1565
		/// </summary>
		/// <param name="name">(Optional) Name for clock grouping</param>
		/// <param name="logically_exclusive">(Optional) Specify logically exclusive clock groups</param>
		/// <param name="physically_exclusive">(Optional) Specify physically exclusive clock groups</param>
		/// <param name="asynchronous">(Optional) Specify asynchronous clock groups</param>
		/// <param name="group">(Optional) Clocks List</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_clock_groups(string name = null, bool? logically_exclusive = null, bool? physically_exclusive = null, bool? asynchronous = null, string group = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_clock_groups [-name <arg>] [-logically_exclusive] [-physically_exclusive] [-asynchronous] [-group <args>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("set_clock_groups")
					.OptionalNamedString("name", name)
					.Flag("logically_exclusive", logically_exclusive)
					.Flag("physically_exclusive", physically_exclusive)
					.Flag("asynchronous", asynchronous)
					.OptionalNamedString("group", group)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Capture actual or predicted clock latency
		///
		///
		/// TCL Syntax: set_clock_latency [-clock <args>] [-rise] [-fall] [-min] [-max] [-source] [-late] [-early] [-quiet] [-verbose] <latency> <objects>
		///
		/// This command defines a clock's source or network latency for specified clocks, ports, or pins.
		/// Note: This command operates silently and does not return direct feedback of its operation.
		/// Source latency is the time in nanoseconds that a clock signal takes to propagate from its
		/// waveform origin to the clock definition point in the design. For example, this would be the time
		/// delay for the clock to propagate from its source (oscillator) on the system board to the FPGA
		/// input port.
		/// Network latency is the time a clock signal takes to propagate from its definition point in the
		/// design to a register clock pin on the timing path. The total clock latency at a register clock pin is
		/// the sum of a clock's source latency and network latency.
		///
		/// This example will set an early latency on the rising edge of CLK_A.
		/// set_clock_latency -source -rise -early 0.4 [get_ports CLK_A]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1568
		/// </summary>
		/// <param name="latency">(Required) Latency value</param>
		/// <param name="objects">(Required) List of clocks, ports or pins</param>
		/// <param name="clock">(Optional) List of relative clocks</param>
		/// <param name="rise">(Optional) Specify clock rise latency</param>
		/// <param name="fall">(Optional) Specify clock fall latency</param>
		/// <param name="min">(Optional) Specify clock rise and fall min condition latency</param>
		/// <param name="max">(Optional) Specify clock rise and fall max condition latency</param>
		/// <param name="source">(Optional) Specify clock rise and fall source latency</param>
		/// <param name="late">(Optional) Specify clock rise and fall late source latency</param>
		/// <param name="early">(Optional) Specify clock rise and fall early source latency</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_clock_latency(string latency, string objects, string clock = null, bool? rise = null, bool? fall = null, bool? min = null, bool? max = null, bool? source = null, bool? late = null, bool? early = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_clock_latency [-clock <args>] [-rise] [-fall] [-min] [-max] [-source] [-late] [-early] [-quiet] [-verbose] <latency> <objects>
			return
				new SimpleTCLCommand("set_clock_latency")
					.OptionalNamedString("clock", clock)
					.Flag("rise", rise)
					.Flag("fall", fall)
					.Flag("min", min)
					.Flag("max", max)
					.Flag("source", source)
					.Flag("late", late)
					.Flag("early", early)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(latency)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Set clock sense on ports or pins
		///
		///
		/// TCL Syntax: set_clock_sense [-positive] [-negative] [-stop_propagation] [-clocks <args>] [-quiet] [-verbose] <pins>
		///
		/// Sets clock sense at specified ports or pins. This is used to define the positive or negative
		/// unateness at the pin relative to a clock object. However, the specified unateness only applies at a
		/// non-unate point in the clock network, at a point where the clock signal cannot be determined.
		/// Since the clock signal is not determined, the defined clock sense propagates forward from the
		/// given pins.
		/// Note: This command operates silently and does not return direct feedback of its operation.
		///
		/// The following example specifies that only the positive unate paths will propagate through the
		/// output pin of the XOR gate as compared with the original clock.
		/// set_clock_sense -positive [get_pins xor_a.z]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1571
		/// </summary>
		/// <param name="pins">(Required) List of port and/or pins</param>
		/// <param name="positive">(Optional) Specify positive unate (non_inverting) clock sense</param>
		/// <param name="negative">(Optional) Specify negative unate (inverting) clock sense</param>
		/// <param name="stop_propagation">(Optional) Stop clock propagation from specified pins</param>
		/// <param name="clocks">(Optional) List of clocks</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_clock_sense(string pins, bool? positive = null, bool? negative = null, bool? stop_propagation = null, string clocks = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_clock_sense [-positive] [-negative] [-stop_propagation] [-clocks <args>] [-quiet] [-verbose] <pins>
			return
				new SimpleTCLCommand("set_clock_sense")
					.Flag("positive", positive)
					.Flag("negative", negative)
					.Flag("stop_propagation", stop_propagation)
					.OptionalNamedString("clocks", clocks)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(pins)
			;
		}
		/// <summary>
		/// set clock uncertainty
		///
		///
		/// TCL Syntax: set_clock_uncertainty [-setup] [-hold] [-from <args>] [-rise_from <args>] [-fall_from <args>] [-to <args>] [-rise_to <args>] [-fall_to <args>] [-quiet] [-verbose] <uncertainty> [<objects>]
		///
		/// This command is used to add to the uncertainty of a clock in the design, and does not override
		/// the default jitter calculation. This is referred to as the user clock uncertainty. The
		/// set_clock_uncertainty command provides a convenient means to over-constrain some
		/// clocks in the design without changing the clock definitions and relationships. It can constrain
		/// setup and hold paths separately using the -setup and -hold options.
		/// Clock uncertainty is the maximum variation, specified in nanoseconds (ns), between two clock
		/// edges at registers within a single clock domain, or crossing between clock domains.
		/// The clock uncertainty is used during setup and hold analysis, where uncertainty is calculated for
		/// each timing path based on the clock edges used by the analysis and the clock tree topology. For
		/// example, for a path where the startpoint and endpoint are connected to the same clock net, the
		/// clock uncertainty is null because the same clock edge is used for both source and destination,
		/// unless the set_clock_uncertainty command is used to add uncertainty for the min delay
		/// analysis. The Vivado timing engine uses clock uncertainty in the slack calculation as determined
		/// by the following equation:
		/// • Setup Slack = Setup Path Requirement - Data Delay - Clock Uncertainty + Clock Skew
		/// Clock Uncertainty is a function of different elements of jitter, as determined by the following
		/// equation which is returned by the report_timing_summary or report_timing commands:
		/// • Clock Uncertainty = (√(Tsj2
		/// + Dj
		/// 2
		/// ))/2 + PE + UU
		/// Where:
		/// • Tsj = Total System Jitter as calculated using the system jitter. See set_system_jitter.
		/// • Dj
		/// = Discrete jitter is the amount of jitter introduced by hardware primitives such as MMCM
		/// or PLL. Discrete jitter is a feature of clocks generated by the MMCM, which includes the input
		/// jitter defined on the primary clock. See set_input_jitter.
		/// • PE = Phase Error, which comes from the MMCM/PLL device model.
		/// • UU = User Uncertainty, which defines the user clock uncertainty specified by this
		/// set_clock_uncertainty command.
		/// TIP: SYSTEM_JITTER is reported as a property of clocks, although it applies to all clocks in the design.
		/// INPUT_JITTER is also a property of primary clocks. These properties can be returned by the get_property or
		/// report_property commands. Jitter and clock uncertainty are reported by the
		/// report_timing_summary and report_timing commands.
		/// This command returns nothing if successful, or returns an error if it fails.
		///
		/// The following example defines the uncertainty between all clock domains:
		/// set_clock_uncertainty 0.225 -from [get_clocks] -to [get_clocks]
		/// The following command defines setup and hold uncertainty within the wbClk clock domain:
		/// set_clock_uncertainty -setup 0.213 [get_clocks wbClk]
		/// set_clock_uncertainty -hold 0.167 [get_clocks wbClk]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1573
		/// </summary>
		/// <param name="uncertainty">(Required) Uncertainty of clock network</param>
		/// <param name="setup">(Optional) Specify clock uncertainty for setup checks</param>
		/// <param name="hold">(Optional) Specify clock uncertainty for hold checks</param>
		/// <param name="from">(Optional) Specify inter-clock uncertainty source clock</param>
		/// <param name="rise_from">(Optional) Specify inter-clock uncertainty source clock with rising edge</param>
		/// <param name="fall_from">(Optional) Specify inter-clock uncertainty source clock with falling edge</param>
		/// <param name="to">(Optional) Specify inter-clock uncertainty destination clock</param>
		/// <param name="rise_to">(Optional) Specify inter-clock uncertainty destination clock with rising edge</param>
		/// <param name="fall_to">(Optional) Specify inter-clock uncertainty destination clock with falling edge</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">(Optional) List of clocks, ports or pins</param>
		public virtual SimpleTCLCommand set_clock_uncertainty(string uncertainty, bool? setup = null, bool? hold = null, string from = null, string rise_from = null, string fall_from = null, string to = null, string rise_to = null, string fall_to = null, bool? quiet = null, bool? verbose = null, string objects = null)
		{
			// TCL Syntax: set_clock_uncertainty [-setup] [-hold] [-from <args>] [-rise_from <args>] [-fall_from <args>] [-to <args>] [-rise_to <args>] [-fall_to <args>] [-quiet] [-verbose] <uncertainty> [<objects>]
			return
				new SimpleTCLCommand("set_clock_uncertainty")
					.Flag("setup", setup)
					.Flag("hold", hold)
					.OptionalNamedString("from", from)
					.OptionalNamedString("rise_from", rise_from)
					.OptionalNamedString("fall_from", fall_from)
					.OptionalNamedString("to", to)
					.OptionalNamedString("rise_to", rise_to)
					.OptionalNamedString("fall_to", fall_to)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(uncertainty)
					.OptionalString(objects)
			;
		}
		/// <summary>
		/// Create data to data checks
		///
		///
		/// TCL Syntax: set_data_check [-from <args>] [-to <args>] [-rise_from <args>] [-fall_from <args>] [-rise_to <args>] [-fall_to <args>] [-setup] [-hold] [-clock <args>] [-quiet] [-verbose] <value>
		///
		/// Performs a setup and hold check for a data pin with respect to another data pin. This is different
		/// from a conventional setup and hold check that is done with respect to a clock pin.
		/// This command defines min and max requirements between two endpoints, similar to setup (max)
		/// and hold (min) timing checks. Setup and hold checks are referenced from the related pin,
		/// specified by -from, to the constrained pin, specified by -to. The related pin is similar to the
		/// clock pin in a conventional setup and hold check. The timing analysis compares arrival times
		/// between the two specified endpoints. The difference must be less than the set_data_check
		/// <value> requirement in order to meet timing.
		/// Limitations of the set_data_check command include:
		/// • Variations in the destination clock delay are ignored.
		/// • This command is used for timing purposes only, and is not considered by the Vivado placer or
		/// router.
		/// Note: This command returns nothing if successful, or returns an error if it fails.
		///
		/// The following example defines a data check for a setup violation from pin A_IN to pin C_IN:
		/// set_data_check -from A_IN -to C_IN -setup 2.0
		/// In the above example, A_IN is the related pin and C_IN is the constrained pin. The above
		/// constraint would do a setup check of C_IN with respect to A_IN. The data at C_IN should arrive
		/// 2.0 ns prior to the edge of A_IN.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1576
		/// </summary>
		/// <param name="value">(Required) Setup or hold time of the defined checks</param>
		/// <param name="from">(Optional) From pin/port of data to data check</param>
		/// <param name="to">(Optional) To pin/port of the data to data check</param>
		/// <param name="rise_from">(Optional) Rise from pin/port of data to data check</param>
		/// <param name="fall_from">(Optional) Fall from pin/port of data to data check</param>
		/// <param name="rise_to">(Optional) Rise to pin/port of data to data check</param>
		/// <param name="fall_to">(Optional) Fall to pin/port of data to data check</param>
		/// <param name="setup">(Optional) Specify data check setup time</param>
		/// <param name="hold">(Optional) Specify data check hold time</param>
		/// <param name="clock">(Optional) Specify the clock domain at related pin/port of the checks</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_data_check(string value, string from = null, string to = null, string rise_from = null, string fall_from = null, string rise_to = null, string fall_to = null, bool? setup = null, bool? hold = null, string clock = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_data_check [-from <args>] [-to <args>] [-rise_from <args>] [-fall_from <args>] [-rise_to <args>] [-fall_to <args>] [-setup] [-hold] [-clock <args>] [-quiet] [-verbose] <value>
			return
				new SimpleTCLCommand("set_data_check")
					.OptionalNamedString("from", from)
					.OptionalNamedString("to", to)
					.OptionalNamedString("rise_from", rise_from)
					.OptionalNamedString("fall_from", fall_from)
					.OptionalNamedString("rise_to", rise_to)
					.OptionalNamedString("fall_to", fall_to)
					.Flag("setup", setup)
					.Flag("hold", hold)
					.OptionalNamedString("clock", clock)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(value)
			;
		}
		/// <summary>
		/// Sets the interconnect delay model for timing analysis.
		///
		///
		/// TCL Syntax: set_delay_model [-interconnect <arg>] [-quiet] [-verbose]
		///
		/// Sets the interconnect delay model for timing analysis. There are three settings for the
		/// interconnect delay model: "actual", "estimated", or "none".
		/// • If "actual" is selected, the actual delay from the routed interconnect will be used in timing
		/// analysis. If the design is only partially routed, then the actual delay from the routed portion
		/// will be used, along with estimated delay for the unrouted portion. The timing report will
		/// provide details regarding the source of the calculated delay.
		/// • If "estimated" delays are selected, the timing analysis will include an estimate of the
		/// interconnect delays based on the placement and connectivity of the design onto the device
		/// prior to implementation. Estimated delay can be specified even if the design is fully routed.
		/// • If "none" is selected, then no interconnect delay is included in the timing analysis, and only the
		/// logic delay is applied.
		/// Note: This command operates silently and does not return direct feedback of its operation.
		///
		/// The following command will use a timing delay model which is an estimated value.
		/// set_delay_model -interconnect estimated
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1579
		/// </summary>
		/// <param name="interconnect">
		/// (Optional)
		/// Interconnect delay model used for timing analysis: Values:
		/// estimated, actual(default), none
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_delay_model(string interconnect = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_delay_model [-interconnect <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("set_delay_model")
					.OptionalNamedString("interconnect", interconnect)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Disable timing arcs
		///
		///
		/// TCL Syntax: set_disable_timing [-from <arg>] [-to <arg>] [-quiet] [-verbose] <objects>
		///
		/// Disables timing arcs within a specified cell or cells that lead to the output pins of the cell. Only
		/// the I/O paths between the clock port and the outputs of the cell are disabled.
		/// The purpose of disabling a timing arc is to prevent timing analysis through the arc.
		/// If a <cell> is specified, then all timing arcs in that cell are disabled. If the optional -from and -to
		/// arguments are specified, then the timing arcs are defined by the from/to pins. If only -from is
		/// speified then all timing arcs from that pin are disabled. If only -to is specified then all timing
		/// paths to that pin are disabled.
		/// If a <port> is specified, then all timing paths from a specified input port are disabled, or timing
		/// paths to a specified output port are disabled.
		/// Note: This command operates silently and does not return direct feedback of its operation
		///
		/// The following example disable the timing arc between the pins I0 and O of the LUT
		/// div_dec_ff_i/U0/count_i_1 to break a combinational loop:
		/// set_disable_timing -from I0 -to O [get_cells div_dec_ff_i/U0/count_i_1]
		/// The following example disables the timing arcs between the specified input pin to the specified
		/// output pin of a BRAM cell:
		/// set_disable_timing -from WEBWE[3] -to CLKMEM [get_cells \
		/// ldpc_dout360_channel/U_AP_FIFO_ldpc_dout360_channel_ram/mem_reg_0]
		/// The following example disables all timing arcs of the specified cell:
		/// set arcs [get_timing_arcs -of_objects [get_cells \
		/// ldpc_dout360_channel/U_AP_FIFO_ldpc_dout360_channel_ram/mem_reg_0]]
		/// set_disable_timing $arcs
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1581
		/// </summary>
		/// <param name="objects">
		/// (Required)
		/// List of cells or pins, ports, lib-cells, lib-pins, libcell/cell
		/// timing-arcs
		/// </param>
		/// <param name="from">(Optional) From pin on cell</param>
		/// <param name="to">(Optional) To pin on cell</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_disable_timing(string objects, string from = null, string to = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_disable_timing [-from <arg>] [-to <arg>] [-quiet] [-verbose] <objects>
			return
				new SimpleTCLCommand("set_disable_timing")
					.OptionalNamedString("from", from)
					.OptionalNamedString("to", to)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Set external delay
		///
		///
		/// TCL Syntax: set_external_delay -from <args> -to <args> [-min] [-max] [-add] [-quiet] [-verbose] <delay_value>
		///
		/// TIP: The XDC > Timing Constraints language templates and the Timing Constraints Wizard in the Vivado IDE
		/// offer timing diagrams and additional details around defining specific timing constraints. You can refer to these
		/// sources for additional information.
		/// Sets the external (feedback) delay in nanoseconds (ns) between an output and input port. The
		/// external delay is used in the calculation of the PLL/MMCM compensation delay for PLLs/
		/// MMCMs with external feedback.
		/// A min or max value can be specified. By default the value specified applies to both min (hold) and
		/// max (setup) compensation delays.
		/// The command returns the defined delay.
		///
		/// The following example sets the external feedback delay to 1.0 ns between the port ClkOut and
		/// ClkFb:
		/// set_external_delay -from [get_ports ClkOut] -to [get_ports ClkFb] 1.0
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1583
		/// </summary>
		/// <param name="from">(Required) Output port</param>
		/// <param name="to">(Required) Input port</param>
		/// <param name="delay_value">(Required) External (feedback) delay value</param>
		/// <param name="min">(Optional) Specifies minimum delay</param>
		/// <param name="max">(Optional) Specifies maximum delay</param>
		/// <param name="add">(Optional) Add to existing external delay</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_external_delay(string from, string to, string delay_value, bool? min = null, bool? max = null, bool? add = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_external_delay -from <args> -to <args> [-min] [-max] [-add] [-quiet] [-verbose] <delay_value>
			return
				new SimpleTCLCommand("set_external_delay")
					.RequiredNamedString("from", from)
					.RequiredNamedString("to", to)
					.Flag("min", min)
					.Flag("max", max)
					.Flag("add", add)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(delay_value)
			;
		}
		/// <summary>
		/// Define false path
		///
		///
		/// TCL Syntax: set_false_path [-setup] [-hold] [-rise] [-fall] [-reset_path] [-from <args>] [-rise_from <args>] [-fall_from <args>] [-to <args>] [-rise_to <args>] [-fall_to <args>] [-through <args>] [-rise_through <args>] [-fall_through <args>] [-quiet] [-verbose]
		///
		/// TIP: The XDC > Timing Constraints language templates and the Timing Constraints Wizard in the Vivado IDE
		/// offer timing diagrams and additional details around defining specific timing constraints. You can refer to these
		/// sources for additional information.
		/// Sets false timing paths in the design that are ignored during timing analysis.
		/// Note: This command operates silently and does not return direct feedback of its operation
		///
		/// The following example eliminates the setup timing for paths from the bftClk:
		/// set_false_path -setup -from bftClk
		/// The following example excludes paths between the two clocks from timing analysis:
		/// set_false_path -from [get_clocks GT0_RXUSRCLK2_OUT] \
		/// -to [get_clocks DRPCLK_OUT]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1585
		/// </summary>
		/// <param name="setup">(Optional) Eliminate setup timing analysis for paths</param>
		/// <param name="hold">(Optional) Eliminate hold timing analysis for paths</param>
		/// <param name="rise">(Optional) Eliminate only rising delays for the defined paths</param>
		/// <param name="fall">(Optional) Eliminate only falling delays for the defined paths</param>
		/// <param name="reset_path">(Optional) Reset this path before setting false path</param>
		/// <param name="from">(Optional) List of path startpoints or clocks</param>
		/// <param name="rise_from">(Optional) Apply to paths rising from the list of startpoints or clocks</param>
		/// <param name="fall_from">(Optional) Apply to paths falling from the list of startpoints or clocks</param>
		/// <param name="to">(Optional) List of path endpoints or clocks</param>
		/// <param name="rise_to">(Optional) Apply to paths with rise transition at the list of endpoints or clocks</param>
		/// <param name="fall_to">(Optional) Apply to paths with fall transition at the list of endpoints or clocks</param>
		/// <param name="through">(Optional) List of through pins, cells or nets</param>
		/// <param name="rise_through">(Optional) Apply to paths rising through pins, cells or nets</param>
		/// <param name="fall_through">(Optional) Apply to paths falling through pins, cells or nets</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_false_path(bool? setup = null, bool? hold = null, bool? rise = null, bool? fall = null, bool? reset_path = null, string from = null, string rise_from = null, string fall_from = null, string to = null, string rise_to = null, string fall_to = null, string through = null, string rise_through = null, string fall_through = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_false_path [-setup] [-hold] [-rise] [-fall] [-reset_path] [-from <args>] [-rise_from <args>] [-fall_from <args>] [-to <args>] [-rise_to <args>] [-fall_to <args>] [-through <args>] [-rise_through <args>] [-fall_through <args>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("set_false_path")
					.Flag("setup", setup)
					.Flag("hold", hold)
					.Flag("rise", rise)
					.Flag("fall", fall)
					.Flag("reset_path", reset_path)
					.OptionalNamedString("from", from)
					.OptionalNamedString("rise_from", rise_from)
					.OptionalNamedString("fall_from", fall_from)
					.OptionalNamedString("to", to)
					.OptionalNamedString("rise_to", rise_to)
					.OptionalNamedString("fall_to", fall_to)
					.OptionalNamedString("through", through)
					.OptionalNamedString("rise_through", rise_through)
					.OptionalNamedString("fall_through", fall_through)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Set hierarchical separator character
		///
		///
		/// TCL Syntax: set_hierarchy_separator [-quiet] [-verbose] [<separator>]
		///
		/// Sets the character that will be used for separating levels of hierarchy in the design.
		/// Note: This command operates silently and does not return direct feedback of its operation
		///
		/// This example changes the hierarchy separator to the '|' character:
		/// set_hierarchy_separator |
		/// The following example restores the default hierarchy separator, '/':
		/// set_hierarchy_separator
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1588
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="separator">(Optional) Hierarchy separator character Default: /</param>
		public virtual SimpleTCLCommand set_hierarchy_separator(bool? quiet = null, bool? verbose = null, string separator = null)
		{
			// TCL Syntax: set_hierarchy_separator [-quiet] [-verbose] [<separator>]
			return
				new SimpleTCLCommand("set_hierarchy_separator")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(separator)
			;
		}
		/// <summary>
		/// Set the system monitor register value
		///
		///
		/// TCL Syntax: set_hw_sysmon_reg [-quiet] [-verbose] <hw_sysmon> <hexaddress> <hexdata>
		///
		/// Set the system monitor register at the specified address to the hex value specified. This
		/// command identifies a register on the hw_sysmon on the current device through its hex address
		/// value, and sets the specified hex data value into that register.
		/// IMPORTANT! Some of the registers on the system monitor are read-only and cannot be set directly. This
		/// command has no effect if you try to set the value of a read-only register on the system monitor.
		/// The System Monitor (SYSMON) Analog-to-Digital Converter (ADC) is used to measure die
		/// temperature and voltage on the hw_device. The Sysmon monitors the physical environment via
		/// on-chip temperature and supply sensors. The ADC can access up to 17 external analog input
		/// channels.
		/// Data for the system monitor is stored in dedicated registers, called status and control registers,
		/// accessible through the get_hw_sysmon_reg and set_hw_sysmon_reg commands. Refer to
		/// the Register Interface in UltraScale Architecture System Monitor User Guide (UG580), or 7 Series
		/// FPGAs and Zynq-7000 SoC XADC Dual 12-Bit 1 MSPS Analog-to-Digital Converter User Guide
		/// (UG480) for more information on the addresses of specific system monitor registers.
		/// Although the set_hw_sysmon_reg command lets you directly write the specified hex data
		/// value into the registers of a system monitor, the recommended procedure is to update the values
		/// of properties on the hw_sysmon object using the set_property command, and then write the
		/// property values to the hw_sysmon object using the commit_hw_sysmon command.
		/// The set_hw_sysmon_reg command writes the specified hex value to the hw_sysmon_reg
		/// object on the hw_sysmon object at the specified address but returns nothing, or returns an error
		/// if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1590
		/// </summary>
		/// <param name="hw_sysmon">(Required) hw_sysmon object</param>
		/// <param name="hexaddress">(Required) Hex address to write to</param>
		/// <param name="hexdata">(Required) Hex write value</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_hw_sysmon_reg(string hw_sysmon, string hexaddress, string hexdata, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_hw_sysmon_reg [-quiet] [-verbose] <hw_sysmon> <hexaddress> <hexdata>
			return
				new SimpleTCLCommand("set_hw_sysmon_reg")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_sysmon)
					.RequiredString(hexaddress)
					.RequiredString(hexdata)
			;
		}
		/// <summary>
		/// Set input delay on ports
		///
		///
		/// TCL Syntax: set_input_delay [-clock <args>] [-reference_pin <args>] [-clock_fall] [-rise] [-fall] [-max] [-min] [-add_delay] [-network_latency_included] [-source_latency_included] [-quiet] [-verbose] <delay> <objects>
		///
		/// TIP: The XDC > Timing Constraints language templates and the Timing Constraints Wizard in the Vivado IDE
		/// offer timing diagrams and additional details around defining specific timing constraints. You can refer to these
		/// sources for additional information.
		/// Specifies the external system-level path delay on a primary input port relative to a clock edge at
		/// the interface of the design. The input delay value is specified in nanoseconds (ns), and can be
		/// positive or negative, depending on the clock and data relative phase at the interface of the
		/// device.
		/// To accurately model the system-level timing of your Xilinx FPGA design, you must assign timing
		/// delays for objects external to the FPGA onto the primary input or output ports in your design.
		/// These delays are defined by the set_input_delay and set_output_delay commands.
		/// IMPORTANT! If the input port also has a set_max_delay constraint assigned, the specified input delay
		/// value is considered part of the max_delay computation. That is, the input delay consumes a portion of the max
		/// delay on the timing path that includes the input port.
		/// This command returns nothing if successful, or returns an error if it fails.
		///
		/// The following example specifies the input delay on port DIN. The input delay is 3 and is relative
		/// to the rising edge of clock clk1:
		/// set_input_delay -clock clk1 3 DIN
		/// The following example specifies the input delay on port DIN. The input delay is 2 and is relative
		/// to the falling edge of the clock clk1:
		/// set_input_delay -clock_fall -clock clk1 2 DIN
		/// The following example specifies the input delay on port reset. The input delay is 2 and is relative
		/// to the rising edge of the clock that appears on the pin wbClk_IBUF_BUFG_inst/O, originating
		/// from the clock wbClk:
		/// set_input_delay -clock wbClk 2 -reference_pin \
		/// [get_pin wbClk_IBUF_BUFG_inst/O] reset
		/// This example creates a clock named clk_ddr, and defines input delay constraints from data
		/// launched by both rising and falling edges of the clock outside the device to the data input of the
		/// internal flip-flop that is sensitive to both rising and falling clock edges:
		/// create_clock -name clk_ddr -period 6 [get_ports DDR_CLK_IN]
		/// set_input_delay -clock clk_ddr -max 2.1 [get_ports DDR_IN]
		/// set_input_delay -clock clk_ddr -max 1.9 [get_ports DDR_IN] -clock_fall -
		/// add_delay
		/// set_input_delay -clock clk_ddr -min 0.9 [get_ports DDR_IN]
		/// set_input_delay -clock clk_ddr -min 1.1 [get_ports DDR_IN] -clock_fall -
		/// add_delay
		/// Note: The use of the -add_delay option allows the new min and max delay constraints to exist alongside
		/// the first delays on the same port.
		/// The following example specifies the input delay on all non clock input ports of the design.
		/// Although all_inputs returns all ports of the design, including clock ports, set_input_delay will skip
		/// setting input delays on the clock ports. The input delay is 1 relative to the rising edge of the clock
		/// wbClk:
		/// set_input_delay -clock wbClk 1 [all_inputs]
		/// The following example sets an input delay of 4 relative to the rising edge of the clock wbClk on
		/// the ports reset and wbDataForInput:
		/// set_input_delay -clock wbClk 4 [list reset wbDataForInput]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1593
		/// </summary>
		/// <param name="delay">(Required) Delay value</param>
		/// <param name="objects">(Required) List of ports</param>
		/// <param name="clock">(Optional) Relative clock</param>
		/// <param name="reference_pin">(Optional) Relative pin or port</param>
		/// <param name="clock_fall">(Optional) Delay is relative to falling edge of clock</param>
		/// <param name="rise">(Optional) Specifies rising delay</param>
		/// <param name="fall">(Optional) Specifies falling delay</param>
		/// <param name="max">(Optional) Specifies maximum delay</param>
		/// <param name="min">(Optional) Specifies minimum delay</param>
		/// <param name="add_delay">(Optional) Don't remove existing input delay</param>
		/// <param name="network_latency_included">(Optional) Specifies network latency of clock already included</param>
		/// <param name="source_latency_included">(Optional) Specifies source latency of clock already included</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_input_delay(string delay, string objects, string clock = null, string reference_pin = null, bool? clock_fall = null, bool? rise = null, bool? fall = null, bool? max = null, bool? min = null, bool? add_delay = null, bool? network_latency_included = null, bool? source_latency_included = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_input_delay [-clock <args>] [-reference_pin <args>] [-clock_fall] [-rise] [-fall] [-max] [-min] [-add_delay] [-network_latency_included] [-source_latency_included] [-quiet] [-verbose] <delay> <objects>
			return
				new SimpleTCLCommand("set_input_delay")
					.OptionalNamedString("clock", clock)
					.OptionalNamedString("reference_pin", reference_pin)
					.Flag("clock_fall", clock_fall)
					.Flag("rise", rise)
					.Flag("fall", fall)
					.Flag("max", max)
					.Flag("min", min)
					.Flag("add_delay", add_delay)
					.Flag("network_latency_included", network_latency_included)
					.Flag("source_latency_included", source_latency_included)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(delay)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Set input jitter for a clock object
		///
		///
		/// TCL Syntax: set_input_jitter [-quiet] [-verbose] <clock> <input_jitter>
		///
		/// Use the set_input_jitter command to specify additional jitter for a specific primary clock.
		/// Input jitter is the difference between successive clock edges due to variation from the ideal
		/// arrival times. This command sets the input jitter in nanoseconds (ns) for a specified primary clock,
		/// defined with the create_clock command. Because the command accepts a single clock, the
		/// jitter for each primary clock must be set individually.
		/// You can only use the set_input_jitter command to specify input jitter on primary clocks.
		/// You cannot use the command to set input jitter on generated or auto derived clocks. Input jitter is
		/// propagated to generated clocks from the master clock, except for MMCM and PLL.
		/// The input jitter is used in the calculation of discrete jitter, which is the amount of jitter introduced
		/// by hardware primitives such as MMCM or PLL. Discrete jitter is a feature of clocks generated by
		/// the MMCM. See set_clock_uncertainty.
		/// The set_input_jitter command is ignored during synthesis.
		/// TIP: INPUT_JITTER is a property of primary clocks that can be returned by the get_property or
		/// report_property commands.
		/// This command returns nothing if successful, or returns an error if it fails.
		///
		/// The following example sets an input jitter value of 0.3 ns on two clocks, sysClk and procClk.
		/// Although the jitter values are the same, you must use two set_input_jitter commands
		/// since the command only takes one clock as an argument:
		/// set_input_jitter sysClk 0.3
		/// set_input_jitter procClk 0.3
		/// The following example defines a primary clock, sysClk, and a generated clock, sysClkDiv2, that is
		/// a divide by two version of the primary clock. An input jitter of 0.15 ns is specified on the primary
		/// clock. The input jitter is automatically propagated to the generated clock:
		/// create_clock -period 10 -name sysClk [get_ports sysClk]
		/// create_generated_clock -name sysClkDiv2 -source [get_ports sysClk] \
		/// -divide_by 2 [get_pins clkgen/sysClkDiv/Q]
		/// set_input_jitter sysClk 0.15
		/// Note: In this example sysClkDiv2 is generated by a divider implemented with flip-flops, so the input jitter is
		/// propagated from the primary clock.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1597
		/// </summary>
		/// <param name="clock">(Required) Clock</param>
		/// <param name="input_jitter">(Required) Input jitter: Value >= 0</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>clock</returns>
		public virtual SimpleTCLCommand set_input_jitter(string clock, string input_jitter, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_input_jitter [-quiet] [-verbose] <clock> <input_jitter>
			return
				new SimpleTCLCommand("set_input_jitter")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(clock)
					.RequiredString(input_jitter)
			;
		}
		/// <summary>
		/// Set capacitance on ports and nets
		///
		///
		/// TCL Syntax: set_load [-rise] [-fall] [-max] [-min] [-quiet] [-verbose] <capacitance> <objects>
		///
		/// Sets the load capacitance on output ports to the specified value. The load capacitance is used
		/// during power analysis when running the report_power command, but is not used during
		/// timing analysis.
		/// TIP: The default unit of capacitance is picofarads (pF), but can be changed using the set_units command.
		/// This command operates silently and does not return direct feedback of its operation.
		///
		/// The following example sets the specified load capacitance value for all ports:
		/// set_load 5.5 [all_outputs]
		/// The following example sets the rising and falling edge load capacitance for the specified output
		/// ports:
		/// set_load -rise -fall 8 [get_ports wbOutput*]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1600
		/// </summary>
		/// <param name="capacitance">(Required) Capacitance value</param>
		/// <param name="objects">(Required) List of ports or nets</param>
		/// <param name="rise">(Optional) Specify the rise capacitance value (for ports only)</param>
		/// <param name="fall">(Optional) Specify the fall capacitance value (for ports only)</param>
		/// <param name="max">(Optional) Specify the maximum capacitance value</param>
		/// <param name="min">(Optional) Specify the minimum capacitance value</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_load(string capacitance, string objects, bool? rise = null, bool? fall = null, bool? max = null, bool? min = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_load [-rise] [-fall] [-max] [-min] [-quiet] [-verbose] <capacitance> <objects>
			return
				new SimpleTCLCommand("set_load")
					.Flag("rise", rise)
					.Flag("fall", fall)
					.Flag("max", max)
					.Flag("min", min)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(capacitance)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Sets logic dc for port/pins
		///
		///
		/// TCL Syntax: set_logic_dc [-quiet] [-verbose] <objects>
		///
		/// Sets the specified input ports or input pins to a logic value of 'X', as unknown or don't care. This
		/// command is NOT supported in Synthesis.
		/// Note: This command operates silently and does not return direct feedback of its operation.
		///
		/// The following example sets the specified port to 'X':
		/// set_logic_dc [get_ports reset]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1602
		/// </summary>
		/// <param name="objects">(Required) List of ports or pins</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_logic_dc(string objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_logic_dc [-quiet] [-verbose] <objects>
			return
				new SimpleTCLCommand("set_logic_dc")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Sets logic one for port/pins
		///
		///
		/// TCL Syntax: set_logic_one [-quiet] [-verbose] <objects>
		///
		/// Sets the specified input ports or input pins to a logic one. This command is NOT supported in
		/// Synthesis.
		/// Note: This command operates silently and does not return direct feedback of its operation.
		///
		/// The following example sets the specified input port to a logic one:
		/// set_logic_one [get_ports reset]
		/// The following example sets the input ports reset and wbDataForInput to a logic one:
		/// set_logic_one [list [get_ports reset] [get_ports wbDataForInput]]
		/// The following example sets the input pin I on instance reset_IBUF to a logic one:
		/// set_logic_one [get_pins reset_IBUF_inst/I]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1604
		/// </summary>
		/// <param name="objects">(Required) List of ports or pins</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_logic_one(string objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_logic_one [-quiet] [-verbose] <objects>
			return
				new SimpleTCLCommand("set_logic_one")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Sets logic unconnected for port/pins
		///
		///
		/// TCL Syntax: set_logic_unconnected [-quiet] [-verbose] <objects>
		///
		/// Defines the specified output ports or pins as unconnected.
		/// Note: This command operates silently and does not return direct feedback of its operation.
		///
		/// The following example sets the specified port to unconnected:
		/// set_logic_unconnected [get_ports OUT1]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1606
		/// </summary>
		/// <param name="objects">(Required) List of ports or pins</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_logic_unconnected(string objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_logic_unconnected [-quiet] [-verbose] <objects>
			return
				new SimpleTCLCommand("set_logic_unconnected")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Sets logic zero for port/pins
		///
		///
		/// TCL Syntax: set_logic_zero [-quiet] [-verbose] <objects>
		///
		/// Sets the specified input ports and input pins to a logic zero. This command is NOT supported in
		/// Synthesis.
		/// Note: This command operates silently and does not return direct feedback of its operation.
		///
		/// The following example sets the specified port to logic state 0:
		/// set_logic_zero [get_ports reset]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1608
		/// </summary>
		/// <param name="objects">(Required) List of ports or pins</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_logic_zero(string objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_logic_zero [-quiet] [-verbose] <objects>
			return
				new SimpleTCLCommand("set_logic_zero")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Specify maximum delay for timing paths
		///
		///
		/// TCL Syntax: set_max_delay [-rise] [-fall] [-reset_path] [-from <args>] [-rise_from <args>] [-fall_from <args>] [-to <args>] [-rise_to <args>] [-fall_to <args>] [-through <args>] [-rise_through <args>] [-fall_through <args>] [-datapath_only] [-quiet] [-verbose] <delay>
		///
		/// TIP: The XDC > Timing Constraints language templates and the Timing Constraints Wizard in the Vivado IDE
		/// offer timing diagrams and additional details around defining specific timing constraints. You can refer to these
		/// sources for additional information.
		/// Sets the maximum delay allowed on a timing path, specified in nanoseconds (ns). The specified
		/// delay value is assigned to both the rising and falling edges of the defined timing paths unless the
		/// -rise or -fall arguments are specified.
		/// The maximum rising and falling delay cannot be less than the minimum rising and falling delay on
		/// the same path, as defined by the set_min_delay command. If this happens, the first assigned
		/// constraint is removed from the timing path as a conflict, and the delay value specified by the
		/// removed constraint is set to 0.
		/// The delay value must be assigned to a timing path as defined by at least one -from, -through,
		/// or -to argument. A general path delay such as -to endpoint will be over written by a more
		/// specific path definition such as -from/-to, or -from/-through/-to path definition.
		/// IMPORTANT! When assigned to a primary input or output port, any system-level delay consumes a portion of
		/// the max delay on the timing path that includes the input or output port. That is, the delay specified by
		/// set_input_delay or set_output_delay is considered part of the maximum delay.
		/// This command returns nothing if successful, or returns an error if it fails.
		///
		/// The following example defines a maximum delay of 60 ns between all the input and output ports
		/// (feedthrough paths):
		/// set_max_delay 60 -from [all_inputs] -to [all_outputs]
		/// The following example clears the existing max delay and specifies a new > maximum delay for
		/// paths to endpoints clocked by the specified clock:
		/// set_max_delay -reset_path 50 -to [get_clocks spi_clk]
		/// The set_max_delay command is often used to define timing constraints for crossing clock
		/// domains when a simple synchronizer is used. In the following example, two flops (FF1 and FF2)
		/// are clocked by different clocks, and FF1/C connects directly to FF2/D through net1. To limit the
		/// delay on this connection to 4.0 ns use one of the following constraints:
		/// set_max_delay -from FF1 -to FF2 -datapath_only 4.0
		/// set_max_delay -from FF1/C -to FF2/D -datapath_only 4.0
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1610
		/// </summary>
		/// <param name="delay">(Required) Delay value</param>
		/// <param name="rise">(Optional) Delay value applies to rising path delays</param>
		/// <param name="fall">(Optional) Delay value applies to falling path delays</param>
		/// <param name="reset_path">(Optional) Reset this path before setting max delay</param>
		/// <param name="from">(Optional) List of path startpoints or clocks</param>
		/// <param name="rise_from">(Optional) Apply to paths rising from the list of startpoints or clocks</param>
		/// <param name="fall_from">(Optional) Apply to paths falling from the list of startpoints or clocks</param>
		/// <param name="to">(Optional) List of path endpoints or clocks</param>
		/// <param name="rise_to">(Optional) Apply to paths with rise transition at the list of endpoints or clocks</param>
		/// <param name="fall_to">(Optional) Apply to paths with fall transition at the list of endpoints or clocks</param>
		/// <param name="through">(Optional) List of through pins, cells or nets</param>
		/// <param name="rise_through">(Optional) Apply to paths rising through pins, cells or nets</param>
		/// <param name="fall_through">(Optional) Apply to paths falling through pins, cells or nets</param>
		/// <param name="datapath_only">(Optional) Remove clock skew and jitter from calculation</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_max_delay(string delay, bool? rise = null, bool? fall = null, bool? reset_path = null, string from = null, string rise_from = null, string fall_from = null, string to = null, string rise_to = null, string fall_to = null, string through = null, string rise_through = null, string fall_through = null, bool? datapath_only = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_max_delay [-rise] [-fall] [-reset_path] [-from <args>] [-rise_from <args>] [-fall_from <args>] [-to <args>] [-rise_to <args>] [-fall_to <args>] [-through <args>] [-rise_through <args>] [-fall_through <args>] [-datapath_only] [-quiet] [-verbose] <delay>
			return
				new SimpleTCLCommand("set_max_delay")
					.Flag("rise", rise)
					.Flag("fall", fall)
					.Flag("reset_path", reset_path)
					.OptionalNamedString("from", from)
					.OptionalNamedString("rise_from", rise_from)
					.OptionalNamedString("fall_from", fall_from)
					.OptionalNamedString("to", to)
					.OptionalNamedString("rise_to", rise_to)
					.OptionalNamedString("fall_to", fall_to)
					.OptionalNamedString("through", through)
					.OptionalNamedString("rise_through", rise_through)
					.OptionalNamedString("fall_through", fall_through)
					.Flag("datapath_only", datapath_only)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(delay)
			;
		}
		/// <summary>
		/// Limit time borrowing for latches
		///
		///
		/// TCL Syntax: set_max_time_borrow [-quiet] [-verbose] <delay> <objects>
		///
		/// Sets the maximum amount of time in nanoseconds that can be borrowed between nets when
		/// analyzing the timing on latches.
		/// Note: This command operates silently and does not return direct feedback of its operation.
		///
		/// The following example specifies that the latches attached to "all clocks" will be allowed 0 time
		/// units of borrowing. Effectively, this disables time borrowing throughout the entire design.
		/// set_max_time_borrow 0.0 [all_clocks]
		/// The following example specifies that nets in the top level of hierarchy are allowed 20 time units
		/// of time borrowing:
		/// set_max_time_borrow 20 {top/*}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1614
		/// </summary>
		/// <param name="delay">(Required) Delay value: Value >= 0</param>
		/// <param name="objects">(Required) List of clocks, cells, data pins or clock pins</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_max_time_borrow(string delay, string objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_max_time_borrow [-quiet] [-verbose] <delay> <objects>
			return
				new SimpleTCLCommand("set_max_time_borrow")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(delay)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Specify minimum delay for timing paths
		///
		///
		/// TCL Syntax: set_min_delay [-rise] [-fall] [-reset_path] [-from <args>] [-rise_from <args>] [-fall_from <args>] [-to <args>] [-rise_to <args>] [-fall_to <args>] [-through <args>] [-rise_through <args>] [-fall_through <args>] [-quiet] [-verbose] <delay>
		///
		/// Sets the minimum delay allowed on a timing path, specified in nanoseconds (ns). The specified
		/// delay value is assigned to both the rising and falling edges of the defined timing paths unless the
		/// -rise or -fall arguments are specified.
		/// IMPORTANT! The minimum rising and falling delay cannot be greater than the maximum rising and falling
		/// delay on the same path. If this happens, the first assigned delay value is removed from the timing path and reset
		/// to 0.
		/// The delay value must be assigned to a timing path as defined by at least one -from, -through,
		/// or -to argument. A general path delay such as -to endpoint will be over written by a more
		/// specific path definition such as -from/-to, or -from/-through/-to path definition.
		/// This command operates silently and does not return direct feedback of its operation.
		///
		/// The following example specifies a minimum delay of 20ns between the primary input and output
		/// ports (combinational/feedthrough paths):
		/// set_min_delay 20 -from [all_inputs] -to [all_outputs]
		/// The following example defines a minimum delay of 20ns for timing paths with endpoints at all
		/// primary output ports:
		/// set_min_delay 20 -to [get_ports -filter {DIRECTION == out}]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1616
		/// </summary>
		/// <param name="delay">(Required) Delay value</param>
		/// <param name="rise">(Optional) Delay value applies to rising path delays</param>
		/// <param name="fall">(Optional) Delay value applies to falling path delays</param>
		/// <param name="reset_path">(Optional) Reset this path before setting min delay</param>
		/// <param name="from">(Optional) List of path startpoints or clocks</param>
		/// <param name="rise_from">(Optional) Apply to paths rising from the list of startpoints or clocks</param>
		/// <param name="fall_from">(Optional) Apply to paths falling from the list of startpoints or clocks</param>
		/// <param name="to">(Optional) List of path endpoints or clocks</param>
		/// <param name="rise_to">(Optional) Apply to paths with rise transition at the list of endpoints or clocks</param>
		/// <param name="fall_to">(Optional) Apply to paths with fall transition at the list of endpoints or clocks</param>
		/// <param name="through">(Optional) List of through pins, cells or nets</param>
		/// <param name="rise_through">(Optional) Apply to paths rising through pins, cells or nets</param>
		/// <param name="fall_through">(Optional) Apply to paths falling through pins, cells or nets</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_min_delay(string delay, bool? rise = null, bool? fall = null, bool? reset_path = null, string from = null, string rise_from = null, string fall_from = null, string to = null, string rise_to = null, string fall_to = null, string through = null, string rise_through = null, string fall_through = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_min_delay [-rise] [-fall] [-reset_path] [-from <args>] [-rise_from <args>] [-fall_from <args>] [-to <args>] [-rise_to <args>] [-fall_to <args>] [-through <args>] [-rise_through <args>] [-fall_through <args>] [-quiet] [-verbose] <delay>
			return
				new SimpleTCLCommand("set_min_delay")
					.Flag("rise", rise)
					.Flag("fall", fall)
					.Flag("reset_path", reset_path)
					.OptionalNamedString("from", from)
					.OptionalNamedString("rise_from", rise_from)
					.OptionalNamedString("fall_from", fall_from)
					.OptionalNamedString("to", to)
					.OptionalNamedString("rise_to", rise_to)
					.OptionalNamedString("fall_to", fall_to)
					.OptionalNamedString("through", through)
					.OptionalNamedString("rise_through", rise_through)
					.OptionalNamedString("fall_through", fall_through)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(delay)
			;
		}
		/// <summary>
		/// Configure how the Vivado tool will display and manage specific messages, based on message ID,
		/// string, or severity.
		///
		///
		/// TCL Syntax: set_msg_config [-id <arg>] [-string <args>] [-severity <arg>] [-limit <arg>] [-new_severity <arg>] [-suppress] [-regexp] [-quiet] [-verbose]
		///
		/// This command lets you configure the messages returned by the Vivado tool in the current
		/// project. Use this command to change the severity of messages, to limit the number of times a
		/// message is reported, or to suppress the message altogether. However, you can only perform one
		/// of these actions at one time with set_msg_config:
		/// • Customize the severity of messages returned by the tool to specific levels appropriate to your
		/// usage. For instance, set the severity of a specified message ID from one type, such as
		/// WARNING, to another type, such as ERROR.
		/// IMPORTANT! You cannot downgrade a Vivado Design System ERROR message to make it less than an error.
		/// • Define the number of messages that will be returned by the tool during a design session, or
		/// single invocation. You can specify the limit of a specific message ID, or the limit for a specific
		/// severity of messages.
		/// TIP: The default message limit for all message IDs is set to 100, and is defined by the parameter
		/// messaging.defaultLimit. This is the limit applied to each separate message returned by the tool. You
		/// can report the current value of this parameter with the get_param command, and change it as needed using
		/// the set_param command.
		/// • Suppress a specific message ID from being reported by the tool at all. You can enable
		/// messages that were previously suppressed using the reset_msg_config command.
		/// • An error is returned if more than one action is attempted in a single set_msg_config
		/// command.
		/// Message qualifiers of string, ID, and severity are used to determine which messages are
		/// configured by the set_msg_config command. You must supply at least one message qualifier
		/// to identify a message or group of messages to apply the command to. Multiple qualifiers have an
		/// AND relationship; the configuration rule will be applied only to messages matching all qualifiers.
		/// TIP: set_msg_config does not support the use of wildcards in message qualifiers.
		/// Message configuration rules are project specific, and are persistent with the project when the
		/// project is closed and reopened.
		/// IMPORTANT! Message configuration rules apply to the current project and are passed automatically to
		/// subordinate processes, such as synthesis and implementation runs. Do not use set_msg_config in pre and
		/// post Tcl scripts.
		/// Use the get_msg_config command to report the current configuration of a specific message,
		/// or the configuration rules defined in the current project. Restore messages to their default
		/// configurations using the reset_msg_config command.
		/// The set_msg_config command is not supported by report_cdc as that command does not
		/// generate messages through the message manager.
		/// This command returns nothing if successful, or returns an error if it fails.
		///
		/// The following example elevates a common INFO message to a Critical Warning:
		/// set_msg_config -id {[Common 17-81]} -new_severity "CRITICAL WARNING"
		/// IMPORTANT! In the following example the "Common 17-69" message is an ERROR message, and cannot be
		/// downgraded from an ERROR. The command in this example appears to work when run from the Tcl console,
		/// however it will not result in any change.
		/// set_msg_config -id {[Common 17-69]} -new_severity WARNING
		/// When the "Common 17-69" message is next thrown by the Vivado tool, a warning message is returned stating
		/// that an error cannot be downgraded, and the message is thrown as an ERROR:
		/// WARNING: [Common 17-239] ERROR Messages are prohibited to be downgraded.
		/// Message 'Common 17-69' is not downgraded.
		/// ERROR: [Common 17-69] Command failed: report_design_analysis
		/// -critical_paths can be run only after synthesis has successfully
		/// completed.
		/// The following example results in warning messages with message ID "17-35", and containing "clk"
		/// in the message, being redefined as Error messages:
		/// set_msg_config -severity warning -string "clk" -id "17-35" \
		/// -new_severity error
		/// This example changes the severity of messages with the specified message ID, gets the current
		/// message configuration rules, and then shows two different command forms to reset the specific
		/// rule and restore the message:
		/// set_msg_config -id "Common 17-361" -severity INFO -new_severity WARNING
		/// get_msg_config -rules
		/// ---------------------
		/// Message control rules currently in effect are:
		/// Rule Name Rule Current
		/// Message Count
		/// 1 set_msg_config -ruleid {1} -id {Common 17-361} -severity {INFO} -
		/// new_severity {WARNING} 0
		/// ---------------------
		/// reset_msg_config -id "Common 17-361" -default_severity
		/// reset_msg_config -ruleid {1}
		/// TIP: In the preceding example, only one of the reset_msg_config commands is needed to reset the
		/// message.
		/// This example shows the use of a parameter to change the default message limit, and then defines
		/// a new limit for the specified message id:
		/// get_param messaging.defaultLimit
		/// 100
		/// set_param messaging.defaultLimit 1000
		/// set_msg_config -id {[Common 17-81]} -limit 1500
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1619
		/// </summary>
		/// <param name="id">
		/// (Optional)
		/// A qualifier, apply the selected operation only to messages
		/// that match given message id. Example: '-id {Common
		/// 17-35}'. Default: match any id
		/// </param>
		/// <param name="@string">
		/// (Optional)
		/// A qualifier, apply the selected operation only to messages
		/// that contain the given list of strings. Default: none
		/// </param>
		/// <param name="severity">
		/// (Optional)
		/// A qualifier, apply the selected operation only to messages at
		/// the given severity level. Example: '-severity INFO' Default:
		/// match any severity
		/// </param>
		/// <param name="limit">
		/// (Optional)
		/// for the messages that match the qualifiers, limit the number
		/// of messages displayed to the given integer value. Can only
		/// be used in conjunction with one of -id or -severity.
		/// </param>
		/// <param name="new_severity">
		/// (Optional)
		/// for the messages that match the qualifiers, change the
		/// severity to the given value for the current project
		/// </param>
		/// <param name="suppress">
		/// (Optional)
		/// for the messages that match the qualifiers, suppress (do not
		/// display) any messages for the current project
		/// </param>
		/// <param name="regexp">(Optional) The values used for -string are full regular expressions</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_msg_config(string id = null, string @string = null, string severity = null, string limit = null, string new_severity = null, bool? suppress = null, bool? regexp = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_msg_config [-id <arg>] [-string <args>] [-severity <arg>] [-limit <arg>] [-new_severity <arg>] [-suppress] [-regexp] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("set_msg_config")
					.OptionalNamedString("id", id)
					.OptionalNamedString("string", @string)
					.OptionalNamedString("severity", severity)
					.OptionalNamedString("limit", limit)
					.OptionalNamedString("new_severity", new_severity)
					.Flag("suppress", suppress)
					.Flag("regexp", regexp)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Define multicycle path
		///
		///
		/// TCL Syntax: set_multicycle_path [-setup] [-hold] [-rise] [-fall] [-start] [-end] [-reset_path] [-from <args>] [-rise_from <args>] [-fall_from <args>] [-to <args>] [-rise_to <args>] [-fall_to <args>] [-through <args>] [-rise_through <args>] [-fall_through <args>] [-quiet] [-verbose] <path_multiplier>
		///
		/// By default, the Vivado timing engine performs a single-cycle analysis, in which the setup check is
		/// performed at the destination on the capture edge, one clock cycle after the edge of the source
		/// clock. However, this may not be appropriate for certain timing paths. The most common example
		/// is a logic path that requires more than one clock cycle for the data to stabilize at the endpoint.
		/// The set_multicycle_path command lets you choose a path multiplier, N, to establish a
		/// timing path that takes N clock cycles from the start clock edge to the capture clock edge. The
		/// path multiplier defines the total number of clock cycles required for propagation of a signal from
		/// its origin to destination when that propagation is longer than a single clock cycle. For more
		/// information on the use of this command, refer to the Vivado Design Suite User Guide: Using
		/// Constraints (UG903).
		/// The set_multicycle_path command is used to specify path multipliers for setup and hold
		/// analysis, for rising and/or falling edges, with respect to the source clock or the destination clock.
		/// This command includes three elements:
		/// • The specification of the setup and hold analysis affected by the multicycle path.
		/// • The definition of the timing paths to which the multicycle path applies.
		/// • The path multiplier defining the number of clock cycles to apply to the timing analysis.
		/// By default the path multiplier applies to both the setup and hold analysis. The hold analysis is
		/// derived from the setup analysis, so it is moved along with the setup analysis. If the path multiplier
		/// moves the setup check N clock cycles, it moves the hold check N-1 clock cycles. However, this
		/// often results in hold timing failures.
		/// You can use a second set_multicycle_path command with the -hold option to restore the
		/// hold analysis to its original location. When the -hold option is specified the <path_multiplier>
		/// acts on the hold relationship to restore the hold check to its original position. For instance, the
		/// following command sequence extends the setup check for 3 clock cycles, and consequently
		/// extends the hold check by two clock cycles (N-1). The second command restores the hold check
		/// to its original position:
		/// set_multicycle_path 3 -from {usbEngine1/u4/csr_reg[26]/C} \
		/// -to {usbEngine1/u1/u2/sizd_c_reg[12]/D}
		/// set_multicycle_path 2 -from {usbEngine1/u4/csr_reg[26]/C} \
		/// -to {usbEngine1/u1/u2/sizd_c_reg[12]/D} -hold
		/// By default, the setup path multiplier is applied with respect to the destination clock, and the hold
		/// path multiplier is applied with respect to the source clock. Use the -start or -end options to
		/// change the default setup or hold analysis with respect to the source or destination clocks.
		/// This command operates silently when successful, or returns an error if the command fails.
		///
		/// The following example establishes a path multiplier of 3 clock cycles for the setup check of the
		/// timing path defined by the -from/-to options. A path multiplier of N-1, or 2 in this example, is
		/// used to decrement the hold check on the same timing path:
		/// set_multicycle_path 3 -setup -from [get_pins data0_reg/C] \
		/// -to [get_pins data1_reg/D]
		/// set_multicycle_path 2 -hold -from [get_pins data0_reg/C] \
		/// -to [get_pins data1_reg/D]
		/// Note: For more information on the relationship between the setup and hold analysis refer to the Vivado
		/// Design Suite User Guide: Using Constraints (UG903).
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1625
		/// </summary>
		/// <param name="path_multiplier">(Required) Number of cycles</param>
		/// <param name="setup">(Optional) Only setup multiplier is set</param>
		/// <param name="hold">(Optional) Only hold multiplier is set</param>
		/// <param name="rise">(Optional) Multiplier valid for rising delays on path endpoint</param>
		/// <param name="fall">(Optional) Multiplier valid for falling delays on path endpoint</param>
		/// <param name="start">(Optional) Multiplier measured against path startpoint</param>
		/// <param name="end">(Optional) Multiplier measured against path endpoint</param>
		/// <param name="reset_path">(Optional) Reset this path before setting multicycle</param>
		/// <param name="from">(Optional) List of path startpoints or clocks</param>
		/// <param name="rise_from">(Optional) Apply to paths rising from the list of startpoints or clocks</param>
		/// <param name="fall_from">(Optional) Apply to paths falling from the list of startpoints or clocks</param>
		/// <param name="to">(Optional) List of path endpoints or clocks</param>
		/// <param name="rise_to">(Optional) Apply to paths with rise transition at the list of endpoints or clocks</param>
		/// <param name="fall_to">(Optional) Apply to paths with fall transition at the list of endpoints or clocks</param>
		/// <param name="through">(Optional) List of through pins, cells or nets</param>
		/// <param name="rise_through">(Optional) Apply to paths rising through pins, cells or nets</param>
		/// <param name="fall_through">(Optional) Apply to paths falling through pins, cells or nets</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_multicycle_path(string path_multiplier, bool? setup = null, bool? hold = null, bool? rise = null, bool? fall = null, bool? start = null, bool? end = null, bool? reset_path = null, string from = null, string rise_from = null, string fall_from = null, string to = null, string rise_to = null, string fall_to = null, string through = null, string rise_through = null, string fall_through = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_multicycle_path [-setup] [-hold] [-rise] [-fall] [-start] [-end] [-reset_path] [-from <args>] [-rise_from <args>] [-fall_from <args>] [-to <args>] [-rise_to <args>] [-fall_to <args>] [-through <args>] [-rise_through <args>] [-fall_through <args>] [-quiet] [-verbose] <path_multiplier>
			return
				new SimpleTCLCommand("set_multicycle_path")
					.Flag("setup", setup)
					.Flag("hold", hold)
					.Flag("rise", rise)
					.Flag("fall", fall)
					.Flag("start", start)
					.Flag("end", end)
					.Flag("reset_path", reset_path)
					.OptionalNamedString("from", from)
					.OptionalNamedString("rise_from", rise_from)
					.OptionalNamedString("fall_from", fall_from)
					.OptionalNamedString("to", to)
					.OptionalNamedString("rise_to", rise_to)
					.OptionalNamedString("fall_to", fall_to)
					.OptionalNamedString("through", through)
					.OptionalNamedString("rise_through", rise_through)
					.OptionalNamedString("fall_through", fall_through)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(path_multiplier)
			;
		}
		/// <summary>
		/// Set operating conditions for power estimation
		///
		///
		/// TCL Syntax: set_operating_conditions [-voltage <args>] [-grade <arg>] [-process <arg>] [-junction_temp <arg>] [-ambient_temp <arg>] [-thetaja <arg>] [-thetasa <arg>] [-airflow <arg>] [-heatsink <arg>] [-thetajb <arg>] [-board <arg>] [-board_temp <arg>] [-board_layers <arg>] [-design_power_budget <arg>] [-quiet] [-verbose]
		///
		/// Sets the real-world operating conditions that are used when performing analysis of the design.
		/// The environmental operating conditions of the device are used for power analysis when running
		/// the report_power command.
		/// Note: This command operates silently and does not return direct feedback of its operation.
		/// Operating conditions can be restored to their default values with the use of the
		/// reset_operating_conditions command.
		/// Current operating conditions can be reported with the report_operating_conditions
		/// command.
		///
		/// The following example specifies an industrial grade device with an ambient operating
		/// temperature of 75 degrees C:
		/// set_operating_conditions -grade industrial -ambient_temp 75
		/// The following example sets the supply voltage Vccaux to a value of 1.9:
		/// set_operating_conditions -voltage {Vccaux 1.89}
		/// The following example sets the manufacturing process corner to maximum:
		/// set_operating_conditions -process maximum
		/// The following example sets the manufacturing process corner to maximum and the voltage
		/// supply Vccint to 0.875:
		/// set_operating_conditions -process maximum -voltage {Vccint 0.875}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1630
		/// </summary>
		/// <param name="voltage">
		/// (Optional)
		/// List of voltage pairs, e.g., {name value}. Supported voltage
		/// supplies vary by family.
		/// </param>
		/// <param name="grade">
		/// (Optional)
		/// Temperature grade. Supported values vary by family.
		/// Default: commercial
		/// </param>
		/// <param name="process">(Optional) Process data: typical or maximum Default: typical</param>
		/// <param name="junction_temp">(Optional) Junction Temperature (C): auto|degC Default: auto</param>
		/// <param name="ambient_temp">(Optional) Ambient Temperature (C): default|degC Default: default</param>
		/// <param name="thetaja">(Optional) ThetaJA (C/W): auto|degC/W Default: auto</param>
		/// <param name="thetasa">(Optional) ThetaSA (C/W): auto|degC/W Default: auto</param>
		/// <param name="airflow">(Optional) Airflow (LFM): 0 to 750 Default: varies by family</param>
		/// <param name="heatsink">
		/// (Optional)
		/// Dimensions of heatsink: none, low, medium, high, custom
		/// Default: medium
		/// </param>
		/// <param name="thetajb">(Optional) ThetaJB (C/W): auto|degC/W Default: auto</param>
		/// <param name="board">(Optional) Board type: jedec, small, medium, large, custom Default: medium</param>
		/// <param name="board_temp">(Optional) Board Temperature degC</param>
		/// <param name="board_layers">(Optional) Board layers: 4to7, 8to11, 12to15, 16+ Default: 8to11</param>
		/// <param name="design_power_budget">(Optional) Design Power Budget (W) Default: Unspecified</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_operating_conditions(string voltage = null, string grade = null, string process = null, string junction_temp = null, string ambient_temp = null, string thetaja = null, string thetasa = null, string airflow = null, string heatsink = null, string thetajb = null, string board = null, string board_temp = null, string board_layers = null, string design_power_budget = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_operating_conditions [-voltage <args>] [-grade <arg>] [-process <arg>] [-junction_temp <arg>] [-ambient_temp <arg>] [-thetaja <arg>] [-thetasa <arg>] [-airflow <arg>] [-heatsink <arg>] [-thetajb <arg>] [-board <arg>] [-board_temp <arg>] [-board_layers <arg>] [-design_power_budget <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("set_operating_conditions")
					.OptionalNamedString("voltage", voltage)
					.OptionalNamedString("grade", grade)
					.OptionalNamedString("process", process)
					.OptionalNamedString("junction_temp", junction_temp)
					.OptionalNamedString("ambient_temp", ambient_temp)
					.OptionalNamedString("thetaja", thetaja)
					.OptionalNamedString("thetasa", thetasa)
					.OptionalNamedString("airflow", airflow)
					.OptionalNamedString("heatsink", heatsink)
					.OptionalNamedString("thetajb", thetajb)
					.OptionalNamedString("board", board)
					.OptionalNamedString("board_temp", board_temp)
					.OptionalNamedString("board_layers", board_layers)
					.OptionalNamedString("design_power_budget", design_power_budget)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Set output delay on ports
		///
		///
		/// TCL Syntax: set_output_delay [-clock <args>] [-reference_pin <args>] [-clock_fall] [-rise] [-fall] [-max] [-min] [-add_delay] [-network_latency_included] [-source_latency_included] [-quiet] [-verbose] <delay> <objects>
		///
		/// TIP: The XDC > Timing Constraints language templates and the Timing Constraints Wizard in the Vivado IDE
		/// offer timing diagrams and additional details around defining specific timing constraints. You can refer to these
		/// sources for additional information.
		/// Specifies the external system-level path delay on a primary output port relative to a clock edge at
		/// the interface of the design. The output delay value is specified in nanoseconds (ns), and can be
		/// positive or negative, depending on the clock and data relative phase outside the FPGA device.
		/// To accurately model the system-level timing of your Xilinx FPGA design, you must assign timing
		/// delays for objects external to the FPGA onto the primary input or output ports in your design.
		/// These delays are defined by the set_input_delay and set_output_delay commands.
		/// IMPORTANT! If the output port also has a set_max_delay constraint assigned, the specified output delay
		/// value is considered part of the max_delay computation. That is, the output delay consumes a portion of the max
		/// delay on the timing path that includes the output port.
		/// This command returns nothing if successful, or returns an error if it fails.
		///
		/// The following example sets an output delay on ports relative to the specified clock:
		/// set_output_delay 5.0 -clock [get_clocks cpuClk] [get_ports]
		/// The next example is the same as the prior example except that network latency is now included:
		/// set_output_delay 5.0 -clock [get_clocks cpuClk] \
		/// -network_latency_included [get_ports]
		/// This example creates a clock named clk_ddr, and defines output delay constraints from data
		/// launched by both rising and falling edges of the clock outside the device to the data output of
		/// the internal flip-flop that is sensitive to both rising and falling clock edges:
		/// create_clock -name clk_ddr -period 6 [get_ports DDR_CLK_IN]
		/// set_output_delay -clock clk_ddr -max 2.1 [get_ports DDR_OUT]
		/// set_output_delay -clock clk_ddr -max 1.9 [get_ports DDR_OUT] -clock_fall -
		/// add_delay
		/// set_output_delay -clock clk_ddr -min 0.9 [get_ports DDR_OUT]
		/// set_output_delay -clock clk_ddr -min 1.1 [get_ports DDR_OUT] -clock_fall -
		/// add_delay
		/// Note: The use of the -add_delay option allows the new min and max delay constraints to exist alongside
		/// the first delays on the same port.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1634
		/// </summary>
		/// <param name="delay">(Required) Delay value</param>
		/// <param name="objects">(Required) List of ports</param>
		/// <param name="clock">(Optional) Relative clock</param>
		/// <param name="reference_pin">(Optional) Relative pin or port</param>
		/// <param name="clock_fall">(Optional) Delay is relative to falling edge of clock</param>
		/// <param name="rise">(Optional) Specifies rising delay</param>
		/// <param name="fall">(Optional) Specifies falling delay</param>
		/// <param name="max">(Optional) Specifies maximum delay</param>
		/// <param name="min">(Optional) Specifies minimum delay</param>
		/// <param name="add_delay">(Optional) Don't remove existing input delay</param>
		/// <param name="network_latency_included">(Optional) Specifies network latency of clock already included</param>
		/// <param name="source_latency_included">(Optional) Specifies source latency of clock already included</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_output_delay(string delay, string objects, string clock = null, string reference_pin = null, bool? clock_fall = null, bool? rise = null, bool? fall = null, bool? max = null, bool? min = null, bool? add_delay = null, bool? network_latency_included = null, bool? source_latency_included = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_output_delay [-clock <args>] [-reference_pin <args>] [-clock_fall] [-rise] [-fall] [-max] [-min] [-add_delay] [-network_latency_included] [-source_latency_included] [-quiet] [-verbose] <delay> <objects>
			return
				new SimpleTCLCommand("set_output_delay")
					.OptionalNamedString("clock", clock)
					.OptionalNamedString("reference_pin", reference_pin)
					.Flag("clock_fall", clock_fall)
					.Flag("rise", rise)
					.Flag("fall", fall)
					.Flag("max", max)
					.Flag("min", min)
					.Flag("add_delay", add_delay)
					.Flag("network_latency_included", network_latency_included)
					.Flag("source_latency_included", source_latency_included)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(delay)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Set user columns on one or more package pins
		///
		///
		/// TCL Syntax: set_package_pin_val [-quiet] [-verbose] <column> <value> <package_pins>...
		///
		/// Create user-defined package pin attributes and assign values to specific pins on the package.
		/// User-defined pin attributes can be defined in a CSV file and imported into an I/O Pin Planning
		/// project using read_csv, or can be edited in the project using this command.
		/// Note: Use the set_property command to set tool-defined properties of a package pin.
		///
		/// The following example creates a new user-defined column in the Package Pins view, and assigns
		/// the value true to the specified pin:
		/// set_package_pin_val -column track1 -value true -package_pins AK27
		/// The following example creates a user-defined column called Test, then assigns the value RED to
		/// all "AK" package pins, then changes the value to GREEN for the three specified pins:
		/// set_package_pin_val -column Test -value RED \
		/// -package_pins [get_package_pins AK*]
		/// set_package_pin_val -column Test -value GREEN \
		/// -package_pins {AK1 AK2 AK3}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1637
		/// </summary>
		/// <param name="column">(Required) User column name</param>
		/// <param name="value">(Required) Value to set</param>
		/// <param name="package_pins">(Required) Package pin names</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_package_pin_val(string column, string value, string package_pins, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_package_pin_val [-quiet] [-verbose] <column> <value> <package_pins>...
			return
				new SimpleTCLCommand("set_package_pin_val")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(column)
					.RequiredString(value)
					.RequiredString(package_pins)
			;
		}
		/// <summary>
		/// Set a parameter value
		///
		///
		/// TCL Syntax: set_param [-quiet] [-verbose] <name> <value>
		///
		/// Sets the value of a user-definable configuration parameter. These parameters configure and
		/// control various behaviors of the tool. Refer to report_param for a description of currently
		/// defined parameters.
		/// As an example, a specific param that can be defined is the general.maxThreads parameter
		/// for the Vivado Design Suite. On multiprocessor systems, the Vivado Design Suite use multi￾threading to speed up certain processes, including DRC reporting, static timing analysis,
		/// placement, and routing. A default limit applies to all tasks and is based on the operating system.
		/// For Windows systems, the default is 2; for Linux systems the default is 8. The limit can be
		/// changed as follows:
		/// set_param general.maxThreads <value>
		/// Where <value> is an integer from 1 to 8, inclusive.
		/// The maximum number of simultaneous threads that can be used also varies by the task being
		/// run. You can change the maxThreads parameter prior to running these processes. The
		/// maximum number of threads for specific Tcl commands are:
		/// • phys_opt_design: 8
		/// • place_design: 8
		/// • report_drc: 8
		/// • report_timing and report_timing_summary: 8
		/// • route_design: 8
		/// • synth_design: 4
		/// You can use the reset_param command to restore any parameter that has been modified back
		/// to its default setting.
		/// Note: Setting a specified parameter value to -1 will disable the feature.
		///
		/// The following example sets the parameter defining how many threads to run for multi-threaded
		/// processes, including Placement, Routing, and Timing Analysis:
		/// set_param general.maxThreads 4
		/// Note: The Vivado tool supports between 1 to 8 threads. Use get_param to determine the current setting.
		/// The following example sets a new default value for message limit:
		/// set_param messaging.defaultLimit 1000
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1639
		/// </summary>
		/// <param name="name">(Required) Parameter name</param>
		/// <param name="value">(Required) Parameter value</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>newly set parameter value</returns>
		public virtual SimpleTCLCommand set_param(string name, string value, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_param [-quiet] [-verbose] <name> <value>
			return
				new SimpleTCLCommand("set_param")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
					.RequiredString(value)
			;
		}
		/// <summary>
		/// Sets the part on the current project. If no project is open, then a diskless project is created.
		///
		///
		/// TCL Syntax: set_part [-quiet] [-verbose] <part>
		///
		/// Change the part used by the current project for subsequent elaboration, synthesis,
		/// implementation, and analysis.
		/// TIP: The part is changed for the current project only, and not for the in-memory design. You can change the
		/// speed grade of the device in the in-memory design for timing analysis using the set_speed_grade
		/// command. You can change the part used when opening an existing design checkpoint using the -part option
		/// of the open_checkpoint or read_checkpoint commands.
		/// This command is provided to let you change the part for the in-memory project of non-project
		/// based designs, and does not support project-based designs. For a project-based design set the
		/// PART property on the project as follows:
		/// set_property PART xc7vx485tffg1158-2 [current_project]
		/// Use the get_parts command to get a list of the available parts.
		/// The set_part command creates an in-memory project for a non-project based design, or
		/// assigns the part to the existing in-memory project.
		/// Note: For a discussion of Project Mode and Non-Project Mode refer to the Vivado Design Suite User Guide:
		/// Design Flows Overview (UG892).
		/// This command returns the part that the in-memory project is set to use, or returns an error if it
		/// fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1642
		/// </summary>
		/// <param name="part">(Required) Set current project's part to this part.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_part(string part, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_part [-quiet] [-verbose] <part>
			return
				new SimpleTCLCommand("set_part")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(part)
			;
		}
		/// <summary>
		/// Set constraints for power optimization
		///
		///
		/// TCL Syntax: set_power_opt [-include_cells <args>] [-exclude_cells <args>] [-clocks <args>] [-cell_types <args>] [-quiet] [-verbose]
		///
		/// Specify cell instances to include or exclude in power optimization. The specified cells are
		/// optimized using the power_opt_design command.
		/// TIP: Block RAM optimizations are performed by default with the opt_design command. Some or all BRAM
		/// cells can be excluded from the opt_design optimization using the set_power_opt command as well.
		/// The effect of multiple set_power_opt commands is cumulative, so that you can specify a
		/// broad class of cell types to optimize, include specific hierarchical cells, and then exclude cells
		/// within the included hierarchy to refine the power optimization.
		/// The power optimizations that have been performed can be reported using the
		/// report_power_opt command.
		///
		/// The following example sets power optimization for BRAM cells only, and then runs power
		/// optimization:
		/// set_power_opt -cell_types bram
		/// power_opt_design
		/// The following example sets power optimization for BRAM and REG type cells, then adds SRLs,
		/// and runs power optimization. Then all cells are cleared, and only SRLs are included, and power
		/// optimization is run again:
		/// set_power_opt -cell_types { bram reg}
		/// set_power_opt -cell_types { srl}
		/// power_opt_design
		/// set_power_opt -cell_types { none}
		/// set_power_opt -cell_types { srl}
		/// power_opt_design
		/// The following example sets power optimization for BRAM cells only, excludes the cpuEngine
		/// block from optimization, but then includes the cpuEngine/cpu_dbg_dat_i block, then performs
		/// power optimization:
		/// set_power_opt -cell_types bram
		/// set_power_opt -exclude_cells cpuEngine
		/// set_power_opt -include_cells cpuEngine/cpu_dbg_dat_i
		/// power_opt_design
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1644
		/// </summary>
		/// <param name="include_cells">(Optional) Include only these instances for clock gating. Default: all</param>
		/// <param name="exclude_cells">(Optional) Exclude these instances from clock gating. Default: none</param>
		/// <param name="clocks">(Optional) Clock gate instances clocked by these clocks only. Default: all clocks</param>
		/// <param name="cell_types">
		/// (Optional)
		/// Clock gate these cell types only. Specify either [all|none], or
		/// one or more of [bram|reg|srl]. Default: all
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_power_opt(string include_cells = null, string exclude_cells = null, string clocks = null, string cell_types = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_power_opt [-include_cells <args>] [-exclude_cells <args>] [-clocks <args>] [-cell_types <args>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("set_power_opt")
					.OptionalNamedString("include_cells", include_cells)
					.OptionalNamedString("exclude_cells", exclude_cells)
					.OptionalNamedString("clocks", clocks)
					.OptionalNamedString("cell_types", cell_types)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Specify propagated clock latency
		///
		///
		/// TCL Syntax: set_propagated_clock [-quiet] [-verbose] <objects>
		///
		/// Propagates clock latency throughout a clock network, resulting in more accurate skew and timing
		/// results throughout the clock network.
		/// Note: This command operates silently and does not return direct feedback of its operation.
		///
		/// This example specifies that the primary system clock from the top-level should be propagated:
		/// set_propagated_clock [get_clocks top/clk]
		/// This example specifies that all clocks from "sublevel1" should be propagated:
		/// set_propagated_clock [get_clocks sublevel1/*]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1647
		/// </summary>
		/// <param name="objects">(Required) List of clocks, ports, or pins</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_propagated_clock(string objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_propagated_clock [-quiet] [-verbose] <objects>
			return
				new SimpleTCLCommand("set_propagated_clock")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Set property on object(s)
		///
		///
		/// TCL Syntax: set_property [-dict <args>] [-quiet] [-verbose] <name> <value> <objects>...
		///
		/// Assigns the defined property <name> and <value> to the specified <objects>.
		/// This command can be used to define any property on an object in the design. Each object has a
		/// set of predefined properties that have expected values, or a range of values. The set_property
		/// command can be used to define the values for these properties. To determine the defined set of
		/// properties on an object, use report_property, list_property, or
		/// list_property_values.
		/// You can also define custom properties for an object, by specifying a unique <name> and <value>
		/// pair for the object. If an object has custom properties, these will also be reported by the
		/// report_property and list_property commands.
		/// This command returns nothing if successful, and an error if it fails.
		/// TIP: You can use the get_property command to validate any properties that have been set on an object.
		///
		/// Create a user-defined boolean property, TRUTH, for cell objects, and set the property on a cell:
		/// create_property -type bool truth cell
		/// set_property truth false [lindex [get_cells] 1]
		/// Use the -dict option to specify multiple properties at one time on the current design:
		/// set_property -dict "POST_CRC enable POST_CRC_ACTION correct_and_continue"
		/// \
		/// [current_design]
		/// The following example sets the TOP property of the current fileset to define the top module of
		/// the project:
		/// set_property top fftTop [current_fileset]
		/// set_property top_file {C:/Data/sources/fftTop.v} [current_fileset]
		/// Note: Defining the top module requires the TOP property to be set to the desired hierarchical block in the
		/// source fileset of the current project. In the preceding example TOP is the property name, fftTop is the
		/// value, and current_fileset is the object. In addition, the TOP_FILE property should be defined to point to
		/// the data source for the top module.
		/// This example shows how to set a property value that includes the dash character, '-'. The dash
		/// can cause the tool to interpret the value as a new command argument, rather than part of the
		/// value being specified, and will cause an error as shown. In this case, you must use the explicit
		/// form of the positional arguments in the set_property command:
		/// set_property {XELAB.MORE_OPTIONS} {-pulse_e_style ondetect} \
		/// [get_filesets sim_1]
		/// ERROR: [Common 17-170] Unknown option '-pulse_e_style ondetect',
		/// please type 'set_property -help' for usage info.
		/// set_property -name {XELAB.MORE_OPTIONS} -value {-pulse_e_style ondetect}\
		/// -objects [get_filesets sim_1]
		/// The following example sets the internal VREF property value for the specified IO Bank:
		/// set_property internal_vref {0.75} [get_iobanks 0]
		/// The following example defines a DCI Cascade by setting the DCI_CASCADE property for the
		/// specified IO Bank:
		/// set_property DCI_CASCADE {14} [get_iobanks 0 ]
		/// The following example configures the synth_1 run, setting options for Vivado Synthesis 2013,
		/// and then launches the synthesis run:
		/// set_property flow {Vivado Synthesis 2016} \
		/// [get_runs synth_1]
		/// set_property STEPS.SYNTH_DESIGN.ARGS.FANOUT_LIMIT 500 \
		/// [get_runs synth_1]
		/// set_property STEPS.SYNTH_DESIGN.ARGS.GATED_CLOCK_CONVERSION on \
		/// [get_runs synth_1]
		/// set_property STEPS.SYNTH_DESIGN.ARGS.FSM_EXTRACTION one_hot \
		/// [get_runs synth_1]
		/// launch_runs synth_1
		/// This example is the same as the prior example, except that it uses the -dict option to set all the
		/// properties on the synthesis run in a single set_property command:
		/// set_property -dict [ list flow {Vivado Synthesis 2016} \
		/// STEPS.SYNTH_DESIGN.ARGS.FANOUT_LIMIT 500 \
		/// STEPS.SYNTH_DESIGN.ARGS.GATED_CLOCK_CONVERSION on \
		/// STEPS.SYNTH_DESIGN.ARGS.FSM_EXTRACTION \
		/// one_hot ] [get_runs synth_1]
		/// launch_runs synth_1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1649
		/// </summary>
		/// <param name="name">(Required) Name of property to set. Not valid with -dict option</param>
		/// <param name="value">(Required) Value of property to set. Not valid with -dict option</param>
		/// <param name="objects">(Required) Objects to set properties on</param>
		/// <param name="dict">(Optional) list of name/value pairs of properties to set</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_property(string name, string value, string objects, string dict = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_property [-dict <args>] [-quiet] [-verbose] <name> <value> <objects>...
			return
				new SimpleTCLCommand("set_property")
					.OptionalNamedString("dict", dict)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(name)
					.RequiredString(value)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Set Timing Speed Grade and Temperature Grade
		///
		///
		/// TCL Syntax: set_speed_grade [-temperature <arg>] [-quiet] [-verbose] [<value>]
		///
		/// Note: After set_speed_grade has been used on a design, it can be used for timing analysis, but it will no
		/// longer go through implementation. If you want to run implementation on the design, you should save the
		/// design checkpoint and use read_checkpoint -part to implement the design with the new speed
		/// grade.
		/// Sets the speed grade used for timing analysis for the target device in the current design.
		/// This command is used to change the speed grade of the target device for timing analysis only,
		/// and does not affect other aspects of the design. It must be run on an opened synthesized or
		/// implemented design.
		/// Use the set_speed_grade command prior to the report_timing_summary or
		/// report_timing command or other timing commands to change the speed grade for analysis. If
		/// the timing is valid, then you can use the set_property or set_part command to change the
		/// target part for the project to re-synthesize and implement the design.
		/// TIP: For UltraScale devices, you can specify either the temperature or the value to define the speed grade for
		/// the part. For 7 series devices, you can only specify the value.
		/// This command returns a transcript of its process, and the speed grade set, or returns an error if it
		/// fails.
		///
		/// The following example sets the speed grade for the device in the current design to -1:
		/// set_speed_grade -1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1653
		/// </summary>
		/// <param name="temperature">
		/// (Optional)
		/// Temperature grade used for timing analysis (Not available
		/// for 7 Series and earlier)
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="value">(Optional) Speed grade used for timing analysis</param>
		/// <returns>string result</returns>
		public virtual SimpleTCLCommand set_speed_grade(string temperature = null, bool? quiet = null, bool? verbose = null, string value = null)
		{
			// TCL Syntax: set_speed_grade [-temperature <arg>] [-quiet] [-verbose] [<value>]
			return
				new SimpleTCLCommand("set_speed_grade")
					.OptionalNamedString("temperature", temperature)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(value)
			;
		}
		/// <summary>
		/// Set switching activity on specified objects or default types
		///
		///
		/// TCL Syntax: set_switching_activity [-toggle_rate <arg>] [-default_toggle_rate <arg>] [-type <args>] [-all] [-static_probability <arg>] [-default_static_probability <arg>] [-signal_rate <arg>] [-hier] [-deassert_resets] [-quiet] [-verbose] [<objects>...]
		///
		/// Sets the signal rate and the switching probability to be used when performing power estimation
		/// on the current synthesized or implemented design. These include simple signal rate and simple
		/// static probability on nets, ports, and pins; and state dependent static probabilities on cells.
		/// Note: This command operates silently and does not return direct feedback of its operation.
		/// The switching activity of a design affects both the static and dynamic power consumption. The
		/// static power is often dependent on logic state transitions, and the dynamic power is directly
		/// proportional to the toggle rate.
		/// The set_switching_activity command can be used to specify default activity rates for the
		/// whole design, or to define the activity of one or more signals in the design or on a specified
		/// module.
		/// The current switching activity attributes can be found by using the
		/// report_switching_activity command. The values can be set to their default values by
		/// using the reset_switching_activity command.
		/// Note: The reset_switching_activity is used to reset switching activity for specified objects. Use the
		/// set_switching_activity -default_toggle_rate or -default_static_probability to
		/// change or reset these values.
		///
		/// The following example specifies a signal rate and switching probability for all ports, then reports
		/// the switching attributes for those ports:
		/// set_switching_activity -signal_rate 55 -static_probability .33 [get_ports]
		/// report_switching_activity [get_ports]
		/// The following example specifies the default switching probability for the current design:
		/// set_switching_activity -default_static_probability .75
		/// This example sets the specified toggle rate and static probability on all registers in the hierarchy
		/// of "CPU/MEM":
		/// set_switching_activity -type register -toggle_rate 0.4 \
		/// -static_probability 0.5 [get_cells CPU/MEM]
		/// This example sets the specified toggle rate and static probability on all registers in the hierarchy
		/// of "CPU/" and underneath hierarchy:
		/// set_switching_activity -type register -toggle_rate 0.4
		/// -static_probability 0.5 -hier [get_cells CPU]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1655
		/// </summary>
		/// <param name="toggle_rate">
		/// (Optional)
		/// Toggle rate (%) is the rate at which the output of
		/// synchronous logic element switches compared to a given
		/// clock input. It is modeled as a percentage between 0 - 200%.
		/// A toggle rate of 100% means that on average the output
		/// toggles once during every clock cycle, changing on either
		/// the rising or falling clock edges, and making the effective
		/// output signal frequency half of the clock frequency. Default:
		/// 0.0
		/// </param>
		/// <param name="default_toggle_rate">
		/// (Optional)
		/// The default toggle rate to be used in power analysis on the
		/// primary inputs of the design. The default toggle rate is set
		/// on those primary input nets whose switching activity is not
		/// specified by the user, simulation data or constraints of the
		/// design. Valid values are: 0 <= value < 200. The default value
		/// is 12.5. Default: 12.5
		/// </param>
		/// <param name="type">
		/// (Optional)
		/// Specify nodes in a specific category. List of valid type values:
		/// io_output, io_bidir_enable, register, lut_ram, lut, dsp,
		/// bram_enable, bram_wr_enable, gt_txdata, gt_rxdata.
		/// </param>
		/// <param name="all">
		/// (Optional)
		/// Used together with -type, set switching activity on -type nets
		/// within an instance
		/// </param>
		/// <param name="static_probability">(Optional) Static probability value: 0 <= Value <= 1 Default: 0.5</param>
		/// <param name="default_static_probability">
		/// (Optional)
		/// The default static probability to be used in power analysis
		/// on the design. The default static probability is set on those
		/// primary inputs whose switching activity is not specified by
		/// the user, simulation data or constraints of the design. Valid
		/// values are: 0 <= Value <= 1. The default value is 0.5. Default:
		/// 0.5
		/// </param>
		/// <param name="signal_rate">
		/// (Optional)
		/// The number of times an element changed state (high-to-low
		/// and low-to-high) per second. Xilinx tools express this as
		/// millions of transitions per second (Mtr/s). Default: 0.0
		/// </param>
		/// <param name="hier">
		/// (Optional)
		/// Hierarchically sets the switching activity on a hierarchical
		/// instance provided via <objects> option. This option should
		/// be used only with <objects> option
		/// </param>
		/// <param name="deassert_resets">
		/// (Optional)
		/// A switch to elegantly auto deassert all set,reset,preset and
		/// clear signals that do not have conflicted polarities
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">(Optional) Objects to set switching activity on</param>
		public virtual SimpleTCLCommand set_switching_activity(string toggle_rate = null, string default_toggle_rate = null, string type = null, bool? all = null, string static_probability = null, string default_static_probability = null, string signal_rate = null, bool? hier = null, bool? deassert_resets = null, bool? quiet = null, bool? verbose = null, string objects = null)
		{
			// TCL Syntax: set_switching_activity [-toggle_rate <arg>] [-default_toggle_rate <arg>] [-type <args>] [-all] [-static_probability <arg>] [-default_static_probability <arg>] [-signal_rate <arg>] [-hier] [-deassert_resets] [-quiet] [-verbose] [<objects>...]
			return
				new SimpleTCLCommand("set_switching_activity")
					.OptionalNamedString("toggle_rate", toggle_rate)
					.OptionalNamedString("default_toggle_rate", default_toggle_rate)
					.OptionalNamedString("type", type)
					.Flag("all", all)
					.OptionalNamedString("static_probability", static_probability)
					.OptionalNamedString("default_static_probability", default_static_probability)
					.OptionalNamedString("signal_rate", signal_rate)
					.Flag("hier", hier)
					.Flag("deassert_resets", deassert_resets)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(objects)
			;
		}
		/// <summary>
		/// Set system jitter
		///
		///
		/// TCL Syntax: set_system_jitter [-quiet] [-verbose] <system_jitter>
		///
		/// Sets the system jitter specified in nanoseconds (ns) for all clocks in the design, including primary
		/// and generated clocks. System jitter is used to account for excessive noise that affects all the
		/// clocks within the FPGA, like power supply noise and board noise. The default system jitter is
		/// technology-dependent and is predefined for each Xilinx FPGA family based on device
		/// characterization with several power supplies under all supported operating conditions.
		/// System Jitter is a component of the Total System Jitter (Tsj) used in the calculation of clock
		/// uncertainty for a path. It is due to the maximum noise (in time) that can be seen on the Vccint rail
		/// due to simultaneous switching of internal nodes, cross talk and other phenomenon that can
		/// impact timing on any path in the design.
		/// IMPORTANT! The jitter calculated by Xilinx takes into consideration the uncertainty introduced by the clocking
		/// resources, the input jitter and the system jitter. Using the set_system_jitter command overrides the
		/// default system jitter value calculated by Xilinx, and is not recommended.
		/// The System Jitter and the Input Jitter are random jitters which typically follow a Gaussian
		/// distribution and are added in a quadratic manner to represent the worst case combination. When
		/// the Input Jitter is null, the Total System Jitter (Tsj) for an internal register-to-register path has the
		/// following equation:
		/// • Tsj = √(SourceClockSystemJitter2
		/// + DestinationClockSystemJitter2
		/// )
		/// For example, when using the default value for system jitter of 50ps:
		/// • Tsj = √(0.0502
		/// + 0.0502
		/// ) = 0.071ns = 71ps
		/// The set_system_jitter command applies to all the clocks in the design. Use the
		/// set_input_jitter command to specify additional jitter for a specific primary clock.
		/// TIP: SYSTEM_JITTER is reported as a property of clocks, although it applies to all clocks in the design.
		/// INPUT_JITTER is also a property of primary clocks. These properties can be returned by the get_property or
		/// report_property commands.
		/// This command returns nothing if successful, or returns an error if it fails.
		///
		/// This example defines the primary clock, sysClk, and specifies a system wide jitter of 0.1 ns:
		/// create_clock -period 10 -name sysClk [get_ports sysClk]
		/// set_system_jitter 0.1
		/// The following example defines a primary clock, sysClk, and a generated clock, sysClkDiv2, that is
		/// a divide by two version of the primary clock. A system jitter of 0.2 ns is specified that applies to
		/// all the clocks in the design. An additional input jitter of 0.09 ns is specified on only the primary
		/// clock:
		/// create_clock -period 10 -name sysClk [get_ports sysClk]
		/// create_generated_clock -name sysClkDiv2 -source [get_ports sysClk] \
		/// -divide_by 2 [get_pins clkgen/sysClkDiv/Q]
		/// set_system_jitter 0.2
		/// set_input_jitter sysClk 0.09
		/// The follow example defines two primary clocks, sysClk and procClk. A system jitter of 0.2 ns is
		/// defined for all the clocks in the system. An additional input jitter of 0.05 ns is specified for the
		/// clock procClk:
		/// create_clock -period 10 -name sysClk [get_ports sysClk]
		/// create_clock -period 25 -name procClk [get_ports procClk]
		/// set_system_jitter 0.2
		/// set_input_jitter procClk 0.05
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1660
		/// </summary>
		/// <param name="system_jitter">(Required) System jitter: Value >= 0</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>system_jitter</returns>
		public virtual SimpleTCLCommand set_system_jitter(string system_jitter, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_system_jitter [-quiet] [-verbose] <system_jitter>
			return
				new SimpleTCLCommand("set_system_jitter")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(system_jitter)
			;
		}
		/// <summary>
		/// Set units for checking
		///
		///
		/// TCL Syntax: set_units [-capacitance <arg>] [-current <arg>] [-voltage <arg>] [-power <arg>] [-resistance <arg>] [-altitude <arg>] [-quiet] [-verbose]
		///
		/// This command specifies the default units to be assumed when the design is analyzed. Specifically,
		/// the -current, -voltage, -power, and -resistance options impact the values returned by
		/// the report_power command.
		/// The set_units command can be used multiple times to define and redefine units. If
		/// set_units includes a previously set unit value, the unit is redefined.
		/// Note: This command operates silently and does not return direct feedback of its operation.
		///
		/// Specify that voltage should be in millivolts and all values should use three digits
		/// set_units -voltage mV
		/// The following example changes the default unit for current to Amperes:
		/// set_units -voltage kV -current A
		/// Note: The second example of set_units redefines the Voltage units defined in the first example, as well
		/// as defining the units for current.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1663
		/// </summary>
		/// <param name="capacitance">(Optional) Capacitance unit in farad. Valid values are from kF-fF. Default: pF</param>
		/// <param name="current">(Optional) Current unit in ampere. Valid values are from kA-fA. Default: mA</param>
		/// <param name="voltage">(Optional) Voltage unit in volt. Valid values are from kV-fV. Default: V</param>
		/// <param name="power">(Optional) Wattage unit in watts. Valid values are from kW-fW. Default: mW</param>
		/// <param name="resistance">(Optional) Resistance unit in ohm. Valid values are from kOhm-fOhm. Default: ohm</param>
		/// <param name="altitude">
		/// (Optional)
		/// Altitude in metric or standard units. Valid values are meters
		/// and feet. Default: meters
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_units(string capacitance = null, string current = null, string voltage = null, string power = null, string resistance = null, string altitude = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_units [-capacitance <arg>] [-current <arg>] [-voltage <arg>] [-power <arg>] [-resistance <arg>] [-altitude <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("set_units")
					.OptionalNamedString("capacitance", capacitance)
					.OptionalNamedString("current", current)
					.OptionalNamedString("voltage", voltage)
					.OptionalNamedString("power", power)
					.OptionalNamedString("resistance", resistance)
					.OptionalNamedString("altitude", altitude)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Set the current value of an HDL object (variable, signal, wire, or reg) to a specified value
		///
		///
		/// TCL Syntax: set_value [-radix <arg>] [-quiet] [-verbose] <hdl_object> <value>
		///
		/// Specify the value of a single HDL object at the current simulation run time.
		/// HDL objects include HDL signals, variables, or constants as defined in the Verilog or VHDL test
		/// bench and source files. An HDL signal includes Verilog wire or reg entities, and VHDL signals.
		/// Examples of HDL variables include Verilog real, realtime, time, and event.
		/// HDL constants include Verilog parameters and localparams, and VHDL generic and constants.
		/// The HDL scope, or scope, is defined by a declarative region in the HDL code such as a module,
		/// function, task, process, or begin-end blocks in Verilog. VHDL scopes include entity/architecture
		/// definitions, block, function, procedure, and process blocks.
		///
		/// HDL constants include Verilog parameters and localparams, and VHDL generic and constants.
		/// The HDL scope, or scope, is defined by a declarative region in the HDL code such as a module,
		/// function, task, process, or begin-end blocks in Verilog. VHDL scopes include entity/architecture
		/// definitions, block, function, procedure, and process blocks.
		/// Arguments
		/// -radix <arg> - (Optional) Specifies the radix to use when returning the value of the specified
		/// object. Allowed values are: default, dec, bin, oct, hex, unsigned, ascii, or smag.
		/// Note: The radix dec indicates a signed decimal. Specify the radix unsigned when dealing with unsigned
		/// data.
		/// -quiet - (Optional) Execute the command quietly, returning no messages from the command.
		/// The command also returns TCL_OK regardless of any errors encountered during execution.
		/// Note: Any errors encountered on the command-line, while launching the command, will be returned. Only
		/// errors occurring inside the command will be trapped.
		/// -verbose - (Optional) Temporarily override any message limits and return all messages from this
		/// command.
		/// Note: Message limits can be defined with the set_msg_config command.
		/// <hdl_object> - (Required) Specifies a single HDL object to get the value of. The object can be
		/// specified by name, or can be returned as an object from the get_objects command.
		/// <value> - (Required) The value to set the specified object to. The specified <value> depends on
		/// the type of the <hdl_object>. HDL object types include: "logic", floating point, VHDL
		/// enumerated, and VHDL integral. For all but "logic" the -radix option is ignored.
		/// • "Logic" does not refer to an actual HDL object type, but means any object whose values are
		/// similar to those of VHDL std_logic, such as:
		/// ○ the Verilog implicit 4-state bit type,
		/// ○ the VHDL bit and std_logic predefined types,
		/// ○ any VHDL enumeration type which is a subset of std_logic, including the character literals
		/// '0' and '1'.
		/// • For logic types the value depends on the radix:
		/// ○ If the specified value has fewer bits than the logic type expects, the value is zero extended,
		/// but not sign extended, to match the expected length.
		/// ○ If the specified value has more bits than the logic type expects, the extra bits on the MSB
		/// side should all be zeros, or the Vivado simulator will return a "size mismatch" error.
		/// • Accepted values for floating point objects are floating point values.
		/// • The accepted value for non-logic VHDL enumerated types is a scalar value from the
		/// enumerated set of values, without single quotes in the case of characters.
		/// • Accepted values for VHDL integral types is a signed decimal integer in the range accepted by
		/// the type.
		/// Examples
		/// The following example sets the value of the sysClk signal:
		/// set_value sysClk Z
		/// This example uses the bin, dec, and unsigned radix to specify the same value on the given
		/// bus:
		/// set_value -radix bin /test/bench_VStatus_pad_0_i[7:0] 10100101
		/// set_value -radix unsigned /test/bench_VStatus_pad_0_i[7:0] 165
		/// set_value -radix dec /test/bench_VStatus_pad_0_i[7:0] -91
		/// The following example shows the bit extension performed when the provided value has fewer
		/// bits than the logic type expects:
		/// set_value -radix bin /test/bench_VStatus_pad_0_i[7:0] 101
		/// get_value -radix bin /test/bench_VStatus_pad_0_i[7:0]
		/// 00000101
		/// The following example shows the bit truncation performed when the provided value has more
		/// bits than the logic type expects:
		/// set_value -radix bin /test/bench_VStatus_pad_0_i[7:0] 0010100101
		/// get_value -radix bin /test/bench_VStatus_pad_0_i[7:0]
		/// 10100101
		/// set_value -radix bin /test/bench_VStatus_pad_0_i[7:0] 1110100101
		/// ERROR: [#UNDEF] Object size 8 does not match size of given value 1110100101
		/// Note: In the second set_value command, the extra bits are not zero, and so an error is returned.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1665
		/// </summary>
		/// <param name="hdl_object">(Required) Set the value on the given hdl_object.</param>
		/// <param name="value">(Required) The value to assign to the specified object.</param>
		/// <param name="radix">
		/// (Optional)
		/// radix specifies the radix to use for interpreting value.
		/// Allowed values are: default, dec, bin, oct, hex, unsigned,
		/// ascii, smag
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand set_value(string hdl_object, string value, string radix = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_value [-radix <arg>] [-quiet] [-verbose] <hdl_object> <value>
			return
				new SimpleTCLCommand("set_value")
					.OptionalNamedString("radix", radix)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hdl_object)
					.RequiredString(value)
			;
		}
		/// <summary>
		/// (User-written application) Extract IP static files from the project or repository and prepare it for
		/// compile_simlib Argument Usage: [-directory <arg>]: Extract static files in the specified directory [-
		/// ip_repo_path <arg>]: Extract static files from the specified IP repository path [-ips <arg> =
		/// Empty]: Extract static files for the specified IPs only [-library <arg> = Empty]: Extract static files
		/// for the specified IP library [-project]: Extract static files for the current project [-install]: Extract
		/// static files for the IP catalog [-no_update_catalog]: Do no update IP catalog [-force]: Overwrite
		/// static files
		///
		///
		/// TCL Syntax: setup_ip_static_library [-directory <arg>] [-ip_repo_path <arg>] [-ips <arg>] [-library <arg>] [-project] [-install] [-no_update_catalog] [-force] [-quiet] [-verbose]
		///
		/// Retrieve static simulation files for IP cores used in the current project, or from the Xilinx IP
		/// catalog, and create a source library for the compile_simlib command to use for compiling the
		/// IP files for a specified simulator.
		///
		/// The following command will build static library for all the IPs in the current project in ./
		/// static_compiled_lib:
		/// setup_ip_static_library -project
		/// The following command will build static library for the current project in /work/simlib. The
		/// command will create the specified directory if it does not exist:
		/// setup_ip_static_library -directory /work/simlib -project
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1668
		/// </summary>
		/// <param name="directory">(Optional) Extract static files in the specified directory Default: None</param>
		/// <param name="ip_repo_path">
		/// (Optional)
		/// Extract static files from the specified IP repository path
		/// Default: None
		/// </param>
		/// <param name="ips">(Optional) Extract static files for the specified IPs only Default: Empty</param>
		/// <param name="library">(Optional) Extract static files for the specified IP library Default: Empty</param>
		/// <param name="project">(Optional) Extract static files for the current project</param>
		/// <param name="install">(Optional) Extract static files for the IP catalog</param>
		/// <param name="no_update_catalog">(Optional) Do no update IP catalog Default: 1</param>
		/// <param name="force">(Optional) Overwrite static files</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>None</returns>
		public virtual SimpleTCLCommand setup_ip_static_library(string directory = null, string ip_repo_path = null, string ips = null, string library = null, bool? project = null, bool? install = null, bool? no_update_catalog = null, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: setup_ip_static_library [-directory <arg>] [-ip_repo_path <arg>] [-ips <arg>] [-library <arg>] [-project] [-install] [-no_update_catalog] [-force] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("setup_ip_static_library")
					.OptionalNamedString("directory", directory)
					.OptionalNamedString("ip_repo_path", ip_repo_path)
					.OptionalNamedString("ips", ips)
					.OptionalNamedString("library", library)
					.Flag("project", project)
					.Flag("install", install)
					.Flag("no_update_catalog", no_update_catalog)
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Creates minimum PR Configurations and Child Impl runs automatically based on the combination
		/// of Partition Instances and RMs
		///
		///
		/// TCL Syntax: setup_pr_configurations [-partitions <args>] [-use_netlist] [-force] [-run <arg>] [-quiet] [-verbose]
		///
		/// Automatically creates the minimum PR configurations and child implementation runs based on
		/// the combination of Partition Instances and Reconfigurable Modules.
		/// In the Partial Reconfiguration (PR) design flow, the PR configuration lets you specify a
		/// reconfigurable module (RM) to assign to a specific instance of a Partition Definition
		/// (partitionDef). This flow lets you create unique configurations of the design based on the
		/// combination of the core design and one or more RMs. The PR design flow requires the
		/// implementation of each PR configuration, resulting in partial bitstreams for the RMs, but
		/// complete bitstreams for each integrated configuration. Refer to the Vivado Design Suite User
		/// Guide: Dynamic Function eXchange (UG909) for more information.
		/// This command is designed to work automatically to create the needed PR configurations and
		/// implementation runs for those configurations.
		/// This command returns nothing if successful, or returns an error if the command fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1671
		/// </summary>
		/// <param name="partitions">(Optional) List of partition instances and reconfig modules pairs</param>
		/// <param name="use_netlist">
		/// (Optional)
		/// Use netlist for getting instances of partition_defs to creating
		/// PR Configurations
		/// </param>
		/// <param name="force">
		/// (Optional)
		/// Using force deletes active parent impl run's PR
		/// Configuration and it's child runs and PR Configurations, and
		/// then creates new PR Configurations and runs
		/// </param>
		/// <param name="run">
		/// (Optional)
		/// Parent impl run to which child impl runs and PR
		/// Configurations need to be created
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand setup_pr_configurations(string partitions = null, bool? use_netlist = null, bool? force = null, string run = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: setup_pr_configurations [-partitions <args>] [-use_netlist] [-force] [-run <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("setup_pr_configurations")
					.OptionalNamedString("partitions", partitions)
					.Flag("use_netlist", use_netlist)
					.Flag("force", force)
					.OptionalNamedString("run", run)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Show objects in Find Results view
		///
		///
		/// TCL Syntax: show_objects [-name <arg>] [-quiet] [-verbose] <objects>
		///
		/// Populates the specified objects into the Find Results window in the Vivado IDE.
		/// Note: This command is only useful when run in the Vivado IDE. When run in Tcl or Batch mode the
		/// command simply returns without error or comment.
		///
		/// The following example shows all DSP objects in the current design in the Find Results window.
		/// show_objects -name All_DSPs [all_dsps]
		/// The following example shows all of the cells in the design hierarchy that are Clock or DSP
		/// PRIMITIVE_TYPEs:
		/// show_objects -name find_1 [get_cells -hierarchical \
		/// -filter { PRIMITIVE_TYPE =~ CLK.*.* || PRIMITIVE_TYPE =~ MULT.dsp.* } ]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1673
		/// </summary>
		/// <param name="objects">(Required) Objects to show Find Results view</param>
		/// <param name="name">(Optional) Tab title</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand show_objects(string objects, string name = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: show_objects [-name <arg>] [-quiet] [-verbose] <objects>
			return
				new SimpleTCLCommand("show_objects")
					.OptionalNamedString("name", name)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Show netlist items in schematic view
		///
		///
		/// TCL Syntax: show_schematic [-add] [-remove] [-regenerate] [-pin_pairs] [-name <arg>] [-quiet] [-verbose] <objects>
		///
		/// Create a schematic view containing the specified design objects when the tool is invoked in GUI
		/// mode.
		/// The scope of the schematic that is displayed depends on the objects specified. A schematic
		/// created with cells, shows the specified cells and any connections between the cells. A schematic
		/// created with pins, shows the pin objects, or shows them connected as appropriate if -
		/// pin_pairs is specified. A schematic created with nets shows the nets, as well as the cells and
		/// ports connected to the nets.
		/// To display a schematic with multiple levels of hierarchy, use the current_instance command
		/// to set the top-level of the hierarchy, or the level of interest, and use the -hierarchical option
		/// when specifying design objects with a get_* command.
		/// Note: This command is only useful when run in the Vivado IDE. When run in Tcl or Batch mode the
		/// command simply returns without error or comment.
		///
		/// The following example creates a schematic for the top-level of the design, displaying the nets as
		/// well as the ports and cells they connect to:
		/// show_schematic [get_nets]
		/// The following example sets the level of hierarchy of interest, and creates a hierarchical schematic
		/// from the current level down:
		/// current_instance A
		/// show_schematic [get_nets -hier]
		/// The following example creates a schematic window showing the specified pins, and the wire
		/// connection between them:
		/// show_schematic -pin_pairs [get_pins {data0_i/O data_reg/D}]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1675
		/// </summary>
		/// <param name="objects">(Required) Netlist items to show in schematic view</param>
		/// <param name="add">(Optional) Add to existing schematic view</param>
		/// <param name="remove">(Optional) Remove from existing schematic view</param>
		/// <param name="regenerate">(Optional) Regenerate layout of schematic view</param>
		/// <param name="pin_pairs">
		/// (Optional)
		/// objects are treated as pair of connected pins. This can be
		/// useful to display paths
		/// </param>
		/// <param name="name">(Optional) Schematic window title</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand show_schematic(string objects, bool? add = null, bool? remove = null, bool? regenerate = null, bool? pin_pairs = null, string name = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: show_schematic [-add] [-remove] [-regenerate] [-pin_pairs] [-name <arg>] [-quiet] [-verbose] <objects>
			return
				new SimpleTCLCommand("show_schematic")
					.Flag("add", add)
					.Flag("remove", remove)
					.Flag("regenerate", regenerate)
					.Flag("pin_pairs", pin_pairs)
					.OptionalNamedString("name", name)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Remove differential pair relationship between 2 ports
		///
		///
		/// TCL Syntax: split_diff_pair_ports [-quiet] [-verbose] <ports>...
		///
		/// Splits an existing differential pair of ports into two single-ended ports.
		/// Note: This command operates silently and does not return direct feedback of its operation.
		///
		/// The following example splits the specified diff pair ports to form two single ended ports:
		/// split_diff_pair_ports PORT_N PORT_P
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1678
		/// </summary>
		/// <param name="ports">(Required) Ports to split</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand split_diff_pair_ports(string ports, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: split_diff_pair_ports [-quiet] [-verbose] <ports>...
			return
				new SimpleTCLCommand("split_diff_pair_ports")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(ports)
			;
		}
		/// <summary>
		/// Start GUI
		///
		///
		/// TCL Syntax: start_gui [-verbose]
		///
		/// Launches the GUI when the tool is running in the Vivado Design Suite Tcl shell. The GUI is
		/// invoked with the current project, design, and run information.
		///
		/// The following example is executed from the command prompt when the tool is running in Tcl
		/// mode:
		/// Vivado% start_gui
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1680
		/// </summary>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand start_gui(bool? verbose = null)
		{
			// TCL Syntax: start_gui [-verbose]
			return
				new SimpleTCLCommand("start_gui")
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Start capturing VCD output (equivalent of $dumpon verilog system task). This can be used after a
		/// stop_vcd TCL command has stopped VCD generation started by open_vcd
		///
		///
		/// TCL Syntax: start_vcd [-quiet] [-verbose]
		///
		/// The start_vcd command specifies that the tool start writing Value Change Dump (VCD)
		/// information into the specified VCD object. This Tcl command models the behavior of the Verilog
		/// $dumpon system task.
		/// IMPORTANT! You must execute the open_vcd command before using the start_vcd command.
		/// Nothing is returned by this command.
		///
		/// The following example starts the writing of HDL signals into the current VCD file:
		/// start_vcd
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1681
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand start_vcd(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: start_vcd [-quiet] [-verbose]
			return
				new SimpleTCLCommand("start_vcd")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Start a set of commands that can be undone/redone as a group
		///
		///
		/// TCL Syntax: startgroup [-try] [-quiet] [-verbose]
		///
		/// Starts a sequence of commands that can be undone or redone as a series. Use endgroup to end
		/// the sequence of commands.
		/// You can have multiple command groups to undo or redo, but you cannot nest command groups.
		/// You must use endgroup to end a command sequence before using startgroup to create a
		/// new command sequence.
		/// TIP: The startgroup/endgroup commands are provided to support sequences of related commands that
		/// can be undone via the undo command, or redone if needed using the redo command. However, some
		/// commands can trigger an endgroup unexpectedly, and certain commands do not support either undo or
		/// redo. The limitations are not fully defined.
		/// The startgroup command returns an integer value of 0 if a group is already started, and
		/// returns an integer value of 1 if the startgroup command has started a new group.
		///
		/// The following example defines a startgroup, executes a sequence of related commands, and
		/// then executes the endgroup. This sequence of commands can be undone or redone as a group:
		/// startgroup
		/// create_pblock pblock_wbArbEngine
		/// create_pblock pblock_usbEngnSRM
		/// add_cells_to_pblock pblock_wbArbEngine \
		/// [get_cells [list wbArbEngine]] -clear_locs
		/// add_cells_to_pblock pblock_usbEngnSRM \
		/// [get_cells [list usbEngine1/usbEngineSRAM]] -clear_locs
		/// endgroup
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1683
		/// </summary>
		/// <param name="@try">(Optional) Don't start a group if one has already been started</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>int</returns>
		public virtual SimpleTCLCommand startgroup(bool? @try = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: startgroup [-try] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("startgroup")
					.Flag("try", @try)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Step simulation to the next statement
		///
		///
		/// TCL Syntax: step [-quiet] [-verbose]
		///
		/// Step the current simulation to the next executable statement in the HDL source files.
		/// The line stepping feature lets you run the simulator stepping through the source code line-by￾line. This is helpful if you are interested in observing how each line or feature of your HDL source
		/// affects the results of simulation.
		/// The step command returns information related to the next executable line from the HDL source
		/// file, or returns an error if it fails.
		///
		/// The following example runs the current executable line of the HDL source code, and pauses at
		/// the next executable line, returning information about that line:
		/// step
		/// Stopped at time : 0 fs : File "C:/Data/ug937/sim/testbench.v" Line 17
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1685
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand step(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: step [-quiet] [-verbose]
			return
				new SimpleTCLCommand("step")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Use within a condition to tell simulation to stop when a condition is true
		///
		///
		/// TCL Syntax: stop [-quiet] [-verbose]
		///
		/// The stop command pauses the current simulation. This command can be used within a
		/// condition, defined by add_condition, to pause the simulation when the condition is true.
		///
		/// The following example defines a condition named resetLow, that becomes true when the reset
		/// signal is low, and then puts a message to the standard output, and stops the current simulation:
		/// add_condition -name resetLow {/testbench/reset == 0 } {
		/// puts "Condition Reset was encountered at [current_time]. \
		/// Stopping simulation."
		/// stop }
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1687
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>A "stop" in simulation is a pause and not a quit</returns>
		public virtual SimpleTCLCommand stop(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: stop [-quiet] [-verbose]
			return
				new SimpleTCLCommand("stop")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Close GUI
		///
		///
		/// TCL Syntax: stop_gui [-verbose]
		///
		/// Stops GUI mode and places the tool into Tcl mode, running in the Vivado Design Suite Tcl shell. In
		/// Tcl mode, all commands must be entered as Tcl commands or through Tcl scripts.
		///
		/// The following example stops and closes the GUI and places the tool into Tcl mode:
		/// stop_gui
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1689
		/// </summary>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand stop_gui(bool? verbose = null)
		{
			// TCL Syntax: stop_gui [-verbose]
			return
				new SimpleTCLCommand("stop_gui")
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Disable Activity Monitor runs for the specified hardware HBM(s)
		///
		///
		/// TCL Syntax: stop_hw_hbm_amon [-quiet] [-verbose] <hw_objects>
		///
		/// The stop_hw_hbm_amon command stops a running HBM activity monitor in the Vivado
		/// hardware manager that has been previously started using the run_hw_hbm_amon command.
		/// This command returns nothing when successful, or returns an error when it fails.
		///
		/// The following example stops the HBM activity monitor for the associated HBM core:
		/// stop_hw_hbm_amon [get_hw_hbms *HBM_2]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1690
		/// </summary>
		/// <param name="hw_objects">(Required) hardware objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand stop_hw_hbm_amon(string hw_objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: stop_hw_hbm_amon [-quiet] [-verbose] <hw_objects>
			return
				new SimpleTCLCommand("stop_hw_hbm_amon")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_objects)
			;
		}
		/// <summary>
		/// Stop hardware SIO scans.
		///
		///
		/// TCL Syntax: stop_hw_sio_scan [-quiet] [-verbose] <hw_sio_scans>
		///
		/// Stop the specified scan running in the Vivado serial I/O analyzer.
		/// To analyze the margin of a given link, it is often helpful to run a scan of the link using the
		/// specialized Eye Scan hardware of Xilinx UltraScale devices or 7 series FPGAs. The Vivado serial
		/// I/O analyzer feature lets you to create, run, and save link scans.
		/// This command lets you stop a scan that is in progress as started with the run_hw_sio_scan
		/// command.
		/// You can remove the created scan object using remove_hw_sio_scan.
		/// This command returns a message if successful, or returns an error if the command fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1692
		/// </summary>
		/// <param name="hw_sio_scans">(Required) hardware SIO scans</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand stop_hw_sio_scan(string hw_sio_scans, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: stop_hw_sio_scan [-quiet] [-verbose] <hw_sio_scans>
			return
				new SimpleTCLCommand("stop_hw_sio_scan")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_sio_scans)
			;
		}
		/// <summary>
		/// Stop hardware SIO sweeps.
		///
		///
		/// TCL Syntax: stop_hw_sio_sweep [-quiet] [-verbose] <hw_sio_sweeps>
		///
		/// Stop the specified sweep scan.
		/// To analyze the margin of a given link, it is often helpful to run a scan of the link using the
		/// specialized features of Xilinx UltraScale devices or 7 series FPGAs. It can also be helpful to run
		/// multiple scans on a the link with different configuration settings for the GTs. This can help you
		/// determine which settings are best for your design. The Vivado serial I/O analyzer feature enables
		/// you to define, run, and save link sweeps, or collections of link scans run across a range of values.
		/// This command lets you stop a sweep scan that is in progress as started with the
		/// run_hw_sio_sweep command.
		/// You can remove the created sweep scan object using remove_hw_sio_sweep.
		/// This command returns nothing if successful, or returns an error if the command fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1694
		/// </summary>
		/// <param name="hw_sio_sweeps">(Required) hardware SIO sweeps</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand stop_hw_sio_sweep(string hw_sio_sweeps, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: stop_hw_sio_sweep [-quiet] [-verbose] <hw_sio_sweeps>
			return
				new SimpleTCLCommand("stop_hw_sio_sweep")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_sio_sweeps)
			;
		}
		/// <summary>
		/// Stop capturing VCD output (equivalent of $dumpoff verilog system task). The start_vcd TCL
		/// command can be used to resume capturing VCD
		///
		///
		/// TCL Syntax: stop_vcd [-quiet] [-verbose]
		///
		/// Stop writing the simulation values to the current Value Change Dump (VCD) file. This suspends
		/// the output of simulation information to the file until the process is resumed using the
		/// start_vcd command.
		/// This Tcl command models the behavior of the Verilog $dumpoff system task.
		/// IMPORTANT! You must execute the open_vcd command before using the stop_vcd command.
		/// Nothing is returned by the command.
		///
		/// The following example stops writing simulation values to the current VCD file:
		/// stop_vcd
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1696
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand stop_vcd(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: stop_vcd [-quiet] [-verbose]
			return
				new SimpleTCLCommand("stop_vcd")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Swap two locations
		///
		///
		/// TCL Syntax: swap_locs [-quiet] [-verbose] <aloc> <bloc>
		///
		/// Swaps the LOC constraints assigned to two similar logic elements. A logic element is an element
		/// that can be placed onto a device resource on the FPGA.
		/// Some DRC checking is performed when the swap_locs command is executed to ensure that
		/// the two selected elements can in fact be assigned to their new locations. If the location of either
		/// element is invalid for any reason, the swap_locs command will fail and an error will be
		/// returned.
		///
		/// The following example swaps the instances assigned to the two specified device sites:
		/// swap_locs [get_sites {OLOGIC_X2Y1}] [get_sites {OLOGIC_X2Y0}]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1698
		/// </summary>
		/// <param name="aloc">(Required) First location (port/cell/site - should be of same type as 'bloc')</param>
		/// <param name="bloc">(Required) Second location (port/cell/site - should be of same type as 'aloc')</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand swap_locs(string aloc, string bloc, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: swap_locs [-quiet] [-verbose] <aloc> <bloc>
			return
				new SimpleTCLCommand("swap_locs")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(aloc)
					.RequiredString(bloc)
			;
		}
		/// <summary>
		/// Synthesize a design using Vivado Synthesis and open that design
		///
		///
		/// TCL Syntax: synth_design [-name <arg>] [-part <arg>] [-constrset <arg>] [-top <arg>] [-include_dirs <args>] [-generic <args>] [-verilog_define <args>] [-flatten_hierarchy <arg>] [-gated_clock_conversion <arg>] [-directive <arg>] [-rtl] [-bufg <arg>] [-no_lc] [-fanout_limit <arg>] [-shreg_min_size <arg>] [-mode <arg>] [-fsm_extraction <arg>] [-rtl_skip_ip] [-rtl_skip_constraints] [-keep_equivalent_registers] [-resource_sharing <arg>] [-cascade_dsp <arg>] [-control_set_opt_threshold <arg>] [-incremental <arg>] [-max_bram <arg>] [-max_uram <arg>] [-max_dsp <arg>] [-max_bram_cascade_height <arg>] [-max_uram_cascade_height <arg>] [-retiming] [-no_srlextract] [-assert] [-no_timing_driven] [-sfcu] [-quiet] [-verbose]
		///
		/// Directly launches the Vivado synthesis engine to compile and synthesize a design in either
		/// Project Mode or Non-Project Mode in the Vivado Design Suite. Refer to the Vivado Design Suite
		/// User Guide: Design Flows Overview (UG892) for a complete description of Project Mode and Non￾Project Mode.
		/// Vivado synthesis can be launched directly with the synth_design command in the Non￾Project Mode of the Vivado Design Suite.
		/// TIP: The synth_design can be multi-threaded to speed the process. Refer to the set_param command for
		/// more information on setting the general.maxThreads parameter.
		/// In Project Mode, synthesis should be launched from an existing synthesis run created with the
		/// create_run command. The run is launched using the launch_runs command, and this in turn
		/// calls synth_design for Vivado synthesis.
		/// You can also use the synth_design command to elaborate RTL source files, and open an
		/// elaborated design:
		/// synth_design -rtl -name rtl_1
		/// This command returns a transcript of the synthesis process, or returns an error if it fails.
		///
		/// The following example uses the set_property command to define the target part for the
		/// active project, then elaborates the source files and opens an RTL design:
		/// set_property part xc7vx485tffg1158-1 [current_project]
		/// synth_design -rtl -name rtl_1
		/// Note: The default source set, constraint set, and part will be used in this example.
		/// The following example uses the find_top command to define the top of the current design for
		/// synthesis:
		/// synth_design -top [lindex [find_top] 0]
		/// Note: Since find_top returns multiple possible candidates, choosing index 0 chooses the best top
		/// candidate for synthesis.
		/// The following example runs synthesis on the current design, defining the top module and the
		/// target part, and specifying no flattening of the hierarchy. The results of the synthesis run are then
		/// opened in a netlist design:
		/// synth_design -top top -part xc7k70tfbg676-2 -flatten_hierarchy none
		/// open_run synth_1 -name netlist_1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1700
		/// </summary>
		/// <param name="name">(Optional) Design name</param>
		/// <param name="part">(Optional) Target part</param>
		/// <param name="constrset">(Optional) Constraint fileset to use</param>
		/// <param name="top">(Optional) Specify the top module name</param>
		/// <param name="include_dirs">(Optional) Specify verilog search directories</param>
		/// <param name="generic">
		/// (Optional)
		/// Specify generic parameters. Syntax: -generic
		/// <name>=<value> -generic <name>=<value> ...
		/// </param>
		/// <param name="verilog_define">
		/// (Optional)
		/// Specify verilog defines. Syntax: -verilog_define
		/// <macro_name>[=<macro_text>] -verilog_define
		/// <macro_name>[=<macro_text>] ...
		/// </param>
		/// <param name="flatten_hierarchy">
		/// (Optional)
		/// Flatten hierarchy during LUT mapping. Values: full, none,
		/// rebuilt Default: rebuilt
		/// </param>
		/// <param name="gated_clock_conversion">
		/// (Optional)
		/// Convert clock gating logic to flop enable. Values: off, on,
		/// auto Default: off
		/// </param>
		/// <param name="directive">
		/// (Optional)
		/// Synthesis directive. Values: default, RuntimeOptimized,
		/// AreaOptimized_high,
		/// AreaOptimized_medium,AlternateRoutability,
		/// AreaMapLargeShiftRegToBRAM, AreaMultThresholdDSP,
		/// FewerCarryChains,Perfor manceOptimized Default: default
		/// </param>
		/// <param name="rtl">(Optional) Elaborate and open an rtl design</param>
		/// <param name="bufg">(Optional) Max number of global clock buffers used by synthesis Default: 12</param>
		/// <param name="no_lc">
		/// (Optional)
		/// Disable LUT combining. Do not allow combining LUT pairs
		/// into single dual output LUTs.
		/// Name Description
		/// </param>
		/// <param name="fanout_limit">
		/// (Optional)
		/// Fanout limit. This switch does not impact control signals
		/// (such as set,reset, clock enable) use MAX_FANOUT to
		/// replicate these signals if needed. Default: 10000
		/// </param>
		/// <param name="shreg_min_size">(Optional) Minimum length for chain of registers to be mapped onto SRL Default: 3</param>
		/// <param name="mode">(Optional) The design mode. Values: default, out_of_context Default: default</param>
		/// <param name="fsm_extraction">
		/// (Optional)
		/// FSM Extraction Encoding. Values: off, one_hot, sequential,
		/// johnson, gray, user_encoding, auto Default: auto
		/// </param>
		/// <param name="rtl_skip_ip">
		/// (Optional)
		/// Exclude subdesign checkpoints in the RTL elaboration of the
		/// design; requires -rtl option.
		/// </param>
		/// <param name="rtl_skip_constraints">
		/// (Optional)
		/// Do not load and validate constraints against elaborated
		/// design; requires -rtl option.
		/// </param>
		/// <param name="keep_equivalent_registers">
		/// (Optional)
		/// Prevents registers sourced by the same logic from being
		/// merged. (Note that the merging can otherwise be
		/// prevented using the synthesis KEEP attribute)
		/// </param>
		/// <param name="resource_sharing">(Optional) Sharing arithmetic operators. Value: auto, on, off Default: auto</param>
		/// <param name="cascade_dsp">
		/// (Optional)
		/// Controls how adders summing DSP block outputs will be
		/// implemented. Value: auto, tree, force Default: auto
		/// </param>
		/// <param name="control_set_opt_threshold">
		/// (Optional)
		/// Threshold for synchronous control set optimization to lower
		/// number of control sets. Valid values are 'auto' and non￾negative integers. The higher the number, the more control
		/// set optimization will be performed and fewer control sets
		/// will result. To disable control set optimization completely,
		/// set to 0. Default: auto
		/// </param>
		/// <param name="incremental">(Optional) dcp file for incremental flowvalue of this is the file name</param>
		/// <param name="max_bram">
		/// (Optional)
		/// Maximum number of block RAM allowed in design. (Note -1
		/// means that the tool will choose the max number allowed for
		/// the part in question) Default: -1
		/// </param>
		/// <param name="max_uram">
		/// (Optional)
		/// Maximum number of Ultra RAM blocks allowed in design.
		/// (Note -1 means that the tool will choose the max number
		/// allowed for the part in question) Default: -1
		/// </param>
		/// <param name="max_dsp">
		/// (Optional)
		/// Maximum number of block DSP allowed in design. (Note -1
		/// means that the tool will choose the max number allowed for
		/// the part in question) Default: -1
		/// </param>
		/// <param name="max_bram_cascade_height">
		/// (Optional)
		/// Controls the maximum number of BRAM that can be
		/// cascaded by the tool. (Note -1 means that the tool will
		/// choose the max number allowed for the part in question)
		/// Default: -1
		/// </param>
		/// <param name="max_uram_cascade_height">
		/// (Optional)
		/// Controls the maximum number of URAM that can be
		/// cascaded by the tool. (Note -1 means that the tool will
		/// choose the max number allowed for the part in question)
		/// Default: -1
		/// </param>
		/// <param name="retiming">
		/// (Optional)
		/// Seeks to improve circuit performance for intra-clock
		/// sequential paths by automatically moving registers (register
		/// balancing) across combinatorial gates or LUTs. It maintains
		/// the original behavior and latency of the circuit and does not
		/// require changes to the RTL sources.
		/// </param>
		/// <param name="no_srlextract">
		/// (Optional)
		/// Prevents the extraction of shift registers so that they get
		/// implemented as simple registers
		/// </param>
		/// <param name="assert">
		/// (Optional)
		/// Enable VHDL assert statements to be evaluated. A severity
		/// level of failure will stop the synthesis flow and produce an
		/// error.
		/// Name Description
		/// </param>
		/// <param name="no_timing_driven">(Optional) Do not run in timing driven mode</param>
		/// <param name="sfcu">(Optional) Run in single-file compilation unit mode</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>design object</returns>
		public virtual SimpleTCLCommand synth_design(string name = null, string part = null, string constrset = null, string top = null, string include_dirs = null, string generic = null, string verilog_define = null, string flatten_hierarchy = null, string gated_clock_conversion = null, string directive = null, bool? rtl = null, string bufg = null, bool? no_lc = null, string fanout_limit = null, string shreg_min_size = null, string mode = null, string fsm_extraction = null, bool? rtl_skip_ip = null, bool? rtl_skip_constraints = null, bool? keep_equivalent_registers = null, string resource_sharing = null, string cascade_dsp = null, string control_set_opt_threshold = null, string incremental = null, string max_bram = null, string max_uram = null, string max_dsp = null, string max_bram_cascade_height = null, string max_uram_cascade_height = null, bool? retiming = null, bool? no_srlextract = null, bool? assert = null, bool? no_timing_driven = null, bool? sfcu = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: synth_design [-name <arg>] [-part <arg>] [-constrset <arg>] [-top <arg>] [-include_dirs <args>] [-generic <args>] [-verilog_define <args>] [-flatten_hierarchy <arg>] [-gated_clock_conversion <arg>] [-directive <arg>] [-rtl] [-bufg <arg>] [-no_lc] [-fanout_limit <arg>] [-shreg_min_size <arg>] [-mode <arg>] [-fsm_extraction <arg>] [-rtl_skip_ip] [-rtl_skip_constraints] [-keep_equivalent_registers] [-resource_sharing <arg>] [-cascade_dsp <arg>] [-control_set_opt_threshold <arg>] [-incremental <arg>] [-max_bram <arg>] [-max_uram <arg>] [-max_dsp <arg>] [-max_bram_cascade_height <arg>] [-max_uram_cascade_height <arg>] [-retiming] [-no_srlextract] [-assert] [-no_timing_driven] [-sfcu] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("synth_design")
					.OptionalNamedString("name", name)
					.OptionalNamedString("part", part)
					.OptionalNamedString("constrset", constrset)
					.OptionalNamedString("top", top)
					.OptionalNamedString("include_dirs", include_dirs)
					.OptionalNamedString("generic", generic)
					.OptionalNamedString("verilog_define", verilog_define)
					.OptionalNamedString("flatten_hierarchy", flatten_hierarchy)
					.OptionalNamedString("gated_clock_conversion", gated_clock_conversion)
					.OptionalNamedString("directive", directive)
					.Flag("rtl", rtl)
					.OptionalNamedString("bufg", bufg)
					.Flag("no_lc", no_lc)
					.OptionalNamedString("fanout_limit", fanout_limit)
					.OptionalNamedString("shreg_min_size", shreg_min_size)
					.OptionalNamedString("mode", mode)
					.OptionalNamedString("fsm_extraction", fsm_extraction)
					.Flag("rtl_skip_ip", rtl_skip_ip)
					.Flag("rtl_skip_constraints", rtl_skip_constraints)
					.Flag("keep_equivalent_registers", keep_equivalent_registers)
					.OptionalNamedString("resource_sharing", resource_sharing)
					.OptionalNamedString("cascade_dsp", cascade_dsp)
					.OptionalNamedString("control_set_opt_threshold", control_set_opt_threshold)
					.OptionalNamedString("incremental", incremental)
					.OptionalNamedString("max_bram", max_bram)
					.OptionalNamedString("max_uram", max_uram)
					.OptionalNamedString("max_dsp", max_dsp)
					.OptionalNamedString("max_bram_cascade_height", max_bram_cascade_height)
					.OptionalNamedString("max_uram_cascade_height", max_uram_cascade_height)
					.Flag("retiming", retiming)
					.Flag("no_srlextract", no_srlextract)
					.Flag("assert", assert)
					.Flag("no_timing_driven", no_timing_driven)
					.Flag("sfcu", sfcu)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Generate a synthesis netlist for an IP
		///
		///
		/// TCL Syntax: synth_ip [-force] [-quiet] [-verbose] <objects>
		///
		/// This command is used in the non-project flow to create a synthesized design checkpoint file
		/// (DCP) to support the out-of-context (OOC) IP flow, or to synthesize and implement an IP module
		/// in the OOC hierarchical design flow. IP objects are specified by the get_ips command, or for
		/// the specified IP core file (XCI) as specified by the get_files command.
		/// IMPORTANT! To enable this functionality, the IP core must be marked for OOC generation by setting the
		/// GENERATE_SYNTH_CHECKPOINT property to true (or 1) using the set_property command on the XCI file.
		/// For project-based designs you would use the create_ip_run and launch_runs commands.
		/// Refer to the Vivado Design Suite User Guide: Design Flows Overview (UG892) for more information
		/// on Project and Non-Project Modes in Vivado.
		/// The synth_ip command will automatically generate any required target files prior to
		/// synthesizing the IP core. The source files required to synthesize the IP are copied into the IP run
		/// directory. Upon completion, any newly generated OOC target files (dcp, stub files, funcsim
		/// netlists...) are registered with the associated IP core.
		///
		/// The following example synthesizes the specified IP object, regenerating the netlist if the
		/// synthesized core is up-to-date:
		/// synth_ip [get_ips char_fifo] -force
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1709
		/// </summary>
		/// <param name="objects">(Required) All the objects for which a netlist needs to be generated for.</param>
		/// <param name="force">(Optional) Force regeneration of the netlist.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand synth_ip(string objects, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: synth_ip [-force] [-quiet] [-verbose] <objects>
			return
				new SimpleTCLCommand("synth_ip")
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Tie off unused cell pins
		///
		///
		/// TCL Syntax: tie_unused_pins [-of_objects <args>] [-quiet] [-verbose]
		///
		/// Tie up or down the unconnected pins of cells in the open synthesized or implemented design.
		/// The command uses an internal process to identify whether a pin should be tied up or down.
		/// This command is intended to tie up or down the unconnected pins of cells added to the netlist
		/// with the create_cell command.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1711
		/// </summary>
		/// <param name="of_objects">(Optional) tie unused pins of specified cell(s)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand tie_unused_pins(string of_objects = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: tie_unused_pins [-of_objects <args>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("tie_unused_pins")
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Un-do previous command
		///
		///
		/// TCL Syntax: undo [-list] [-quiet] [-verbose]
		///
		/// IMPORTANT! The undo and redo commands are intended for use in the Vivado IDE, and are not
		/// recommended for use in Tcl scripts to restore designs to a former state. To restore a design to a specific
		/// condition, you must write a design checkpoint using the write_checkpoint command, to be restored using
		/// read_checkpoint.
		/// Undo a prior command. This command can be used repeatedly to undo a series of commands.
		/// If a group of commands has been created using the startgroup and endgroup commands,
		/// this command will undo that group as a sequence. The undo command will start at the
		/// endgroup command and continue to undo until it hits the startgroup command.
		/// If you undo a command, and then change your mind, you can redo the command.
		///
		/// The following example returns a list of commands that you can undo:
		/// undo -list
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1713
		/// </summary>
		/// <param name="list">(Optional) Show a list of undoable tasks</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>with -list, the list of undoable tasks</returns>
		public virtual SimpleTCLCommand undo(bool? list = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: undo [-list] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("undo")
					.Flag("list", list)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Move the group of cells inside a hierarchy cell to its parent cell, and then remove the hierarchical
		/// cell. The connections between these cells are maintained; the connections between these cells
		/// and other cells are maintained through crossing hierarchy cell.
		///
		///
		/// TCL Syntax: ungroup_bd_cells [-prefix <arg>] [-quiet] [-verbose] [<cells>...]
		///
		/// This command is intended to undo the grouping of IP integrator cells into a hierarchical module,
		/// by either the group_bd_cells or the move_bd_cells commands. The command moves the
		/// cells inside a selected hierarchical module up one level to the parent cell, and then removes the
		/// hierarchical module.
		/// The connections between the selected cells are maintained. The connections between these cells
		/// and other cells are maintained automatically by removing unneeded subsystem ports and pins.
		/// This command returns 0 if successful, or an error message if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1715
		/// </summary>
		/// <param name="cells">(Required) Match engine names against cell names Default: *</param>
		/// <param name="prefix">(Optional) Prefix name to add to cells</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>0 if success.</returns>
		public virtual SimpleTCLCommand ungroup_bd_cells(string cells, string prefix = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: ungroup_bd_cells [-prefix <arg>] [-quiet] [-verbose] [<cells>...]
			return
				new SimpleTCLCommand("ungroup_bd_cells")
					.OptionalNamedString("prefix", prefix)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(cells)
			;
		}
		/// <summary>
		/// Unhighlight objects that are currently highlighted
		///
		///
		/// TCL Syntax: unhighlight_objects [-color_index <arg>] [-rgb <args>] [-color <arg>] [-leaf_cells] [-quiet] [-verbose] [<objects>]
		///
		/// This command is for use in GUI mode. This command unhighlights the specified object or objects
		/// that were previously highlighted by the highlight_objects command.
		/// This command supports the color options as specified below. These options can be used to
		/// unhighlight all objects currently highlighted in the specified color. See the example below.
		///
		/// The following example unhighlights the specified cell objects:
		/// unhighlight_objects -leaf_cells [get_cells cpuEngine/*]
		/// The following example unhighlights all objects currently highlighted in the color yellow:
		/// unhighlight_objects -color yellow
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1717
		/// </summary>
		/// <param name="color_index">(Optional) Color index</param>
		/// <param name="rgb">(Optional) RGB color index list</param>
		/// <param name="color">(Optional) Valid values are red green blue magenta yellow cyan and orange</param>
		/// <param name="leaf_cells">(Optional) Leaf cells</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">(Optional) Objects to unhighlight</param>
		public virtual SimpleTCLCommand unhighlight_objects(string color_index = null, string rgb = null, string color = null, bool? leaf_cells = null, bool? quiet = null, bool? verbose = null, string objects = null)
		{
			// TCL Syntax: unhighlight_objects [-color_index <arg>] [-rgb <args>] [-color <arg>] [-leaf_cells] [-quiet] [-verbose] [<objects>]
			return
				new SimpleTCLCommand("unhighlight_objects")
					.OptionalNamedString("color_index", color_index)
					.OptionalNamedString("rgb", rgb)
					.OptionalNamedString("color", color)
					.Flag("leaf_cells", leaf_cells)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(objects)
			;
		}
		/// <summary>
		/// Unmark items that are currently marked
		///
		///
		/// TCL Syntax: unmark_objects [-rgb <args>] [-color <arg>] [-quiet] [-verbose] [<objects>]
		///
		/// Unmarks the specified object or objects that were previously marked by the mark_objects
		/// command. This command is for use in GUI mode.
		/// This command supports the color options as specified below. However, these options are not
		/// necessary to unmark a specific object, but can be used to unmark all objects currently marked in
		/// the specified color. See the example below.
		///
		/// The following example unmarks the selected objects:
		/// unmark_objects [get_selected_objects]
		/// The following example unmarks all objects currently marked in the color yellow:
		/// unmark_objects -color yellow
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1719
		/// </summary>
		/// <param name="rgb">(Optional) RGB color index list</param>
		/// <param name="color">(Optional) Valid values are red green blue magenta yellow cyan and orange</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">(Optional) Objects to unmark</param>
		public virtual SimpleTCLCommand unmark_objects(string rgb = null, string color = null, bool? quiet = null, bool? verbose = null, string objects = null)
		{
			// TCL Syntax: unmark_objects [-rgb <args>] [-color <arg>] [-quiet] [-verbose] [<objects>]
			return
				new SimpleTCLCommand("unmark_objects")
					.OptionalNamedString("rgb", rgb)
					.OptionalNamedString("color", color)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(objects)
			;
		}
		/// <summary>
		/// Unplace one or more instances.
		///
		///
		/// TCL Syntax: unplace_cell [-quiet] [-verbose] <cell_list>...
		///
		/// Unplace the specified cells from their current placement site.
		///
		/// The following example unplaces the specified cell:
		/// unplace_cell {fftEngine/fftInst/ingressLoop[6].ingressFifo/buffer_fifo/
		/// i_4773_12897}
		/// The following example unplaces multiple cells:
		/// unplace_cell {div_cntr_reg_inferredi_4810_15889 div_cntr_reg[0]
		/// div_cntr_reg[1]}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1721
		/// </summary>
		/// <param name="cell_list">(Required) a list of cells to be unplaced</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand unplace_cell(string cell_list, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: unplace_cell [-quiet] [-verbose] <cell_list>...
			return
				new SimpleTCLCommand("unplace_cell")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(cell_list)
			;
		}
		/// <summary>
		/// Unregister a previously registered Tcl proc.
		///
		///
		/// TCL Syntax: unregister_proc [-quiet] [-verbose] <tasknm>
		///
		/// Unregister the Tcl command, or <tasknm>, from the Vivado Design Suite Tcl interpretor.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1723
		/// </summary>
		/// <param name="tasknm">(Required) Name of Tcl task to unregister. The task must be wrapping a proc.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Nothing</returns>
		public virtual SimpleTCLCommand unregister_proc(string tasknm, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: unregister_proc [-quiet] [-verbose] <tasknm>
			return
				new SimpleTCLCommand("unregister_proc")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(tasknm)
			;
		}
		/// <summary>
		/// Unselect items that are currently selected
		///
		///
		/// TCL Syntax: unselect_objects [-quiet] [-verbose] [<objects>]
		///
		/// Unselects the specified object or objects that were previously selected by the
		/// select_objects command.
		/// This command will unselect both primary and secondary selected objects. The selection of
		/// secondary objects is controlled through the use of Selection Rules defined in the Tools → Settings
		/// command. Refer to the Vivado Design Suite User Guide: Using the IDE (UG893) for more
		/// information on Setting Selection Rules.
		///
		/// The following example unselects the specified site on the device:
		/// unselect_objects [get_sites SLICE_X56Y214]
		/// The following example unselects all currently selected objects:
		/// unselect_objects
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1725
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">(Optional) Objects to unselect</param>
		public virtual SimpleTCLCommand unselect_objects(bool? quiet = null, bool? verbose = null, string objects = null)
		{
			// TCL Syntax: unselect_objects [-quiet] [-verbose] [<objects>]
			return
				new SimpleTCLCommand("unselect_objects")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(objects)
			;
		}
		/// <summary>
		/// Update clock routing on global clocks if they are modified after placement
		///
		///
		/// TCL Syntax: update_clock_routing [-quiet] [-verbose]
		///
		/// The update_clock_routing command is an advanced command used for manually updating
		/// the routing structures of all global clocks in designs targeting the UltraScale architecture. The
		/// command operates on all global clocks in a design, not individual clocks.
		/// Due to a more flexible clocking architecture, UltraScale and UltraScale+ designs require a two￾step process for routing global clocks. First the Vivado placer assigns the routing resources
		/// required to route the global clocks from the clock source to the destination clock regions
		/// (CLOCK_ROOT or USER_CLOCK_ROOT). Next the Vivado router fills in the routing gaps on the
		/// clock nets. In between these two steps the resulting structures are called gap trees: each global
		/// clock net has its base routing resources assigned but with large routing gaps where no routing
		/// resources have been assigned.
		/// After gap trees are constructed, the router optimally routes the remaining clock network to all
		/// leaf-level primitives to fill in the routing gaps. During an implementation run the global clock
		/// routing is handled automatically. However in cases where the clock tree has been changed after
		/// implementation, by modifying the USER_CLOCK_ROOT property on a clock net for instance, the
		/// Vivado tool may need the update_clock_routing command to properly rebuild the gap trees
		/// and fill in the routing gaps.
		/// Examples of this include:
		/// • Moving the clock root of a global clock.
		/// • Adding or moving loads of a global clock into a clock region not yet occupied by the global
		/// clock, then running timing analysis on the updated design.
		///
		/// • Moving the clock root of a global clock.
		/// • Adding or moving loads of a global clock into a clock region not yet occupied by the global
		/// clock, then running timing analysis on the updated design.
		/// Arguments
		/// -quiet - (Optional) Execute the command quietly, returning no messages from the command.
		/// The command also returns TCL_OK regardless of any errors encountered during execution.
		/// Note: Any errors encountered on the command-line, while launching the command, will be returned. Only
		/// errors occurring inside the command will be trapped.
		/// -verbose - (Optional) Temporarily override any message limits and return all messages from this
		/// command.
		/// Note: Message limits can be defined with the set_msg_config command.
		/// Examples
		/// The following example updates the USER_CLOCK_ROOT property on the specified clock nets,
		/// unroutes the nets, and then updates the clock routing:
		/// set_property USER_CLOCK_ROOT X1Y0 [get_nets {clk1 clk2}]
		/// route_design -unroute -nets [get_nets {clk1 clk2}]
		/// update_clock_routing
		/// IMPORTANT! The unroute command is needed to clean out existing clock routing on the clock nets before
		/// updating the clock routing.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1727
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand update_clock_routing(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: update_clock_routing [-quiet] [-verbose]
			return
				new SimpleTCLCommand("update_clock_routing")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Updates a fileset compile order and possibly top based on a design graph.
		///
		///
		/// TCL Syntax: update_compile_order [-force_gui] [-fileset <arg>] [-quiet] [-verbose]
		///
		/// Update the compile order of the design sources in the current project, or in the specified fileset.
		///
		/// The following example updates the compile order of the source files in the simulation fileset:
		/// update_compile_order -fileset sim_1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1729
		/// </summary>
		/// <param name="force_gui">(Optional) Execute this command, even when run interactively in the GUI.</param>
		/// <param name="fileset">(Optional) Fileset to update based on a design graph</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand update_compile_order(bool? force_gui = null, string fileset = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: update_compile_order [-force_gui] [-fileset <arg>] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("update_compile_order")
					.Flag("force_gui", force_gui)
					.OptionalNamedString("fileset", fileset)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// update the netlist of the current design
		///
		///
		/// TCL Syntax: update_design -cells <args> [-strict] [-from_file <arg>] [-from_design <arg>] [-from_cell <arg>] [-black_box] [-buffer_ports] [-quiet] [-verbose]
		///
		/// This command updates the in-memory design, replacing the current netlist in the specified cell
		/// with a netlist from a specified file, from another open design, from a specified cell of a design, or
		/// converts the cell to a black box cell.
		/// The update_design command can update a single instance, or can update all instances of a
		/// master cell.
		/// Only the in-memory view of the design is changed by the new netlist. You must save the design
		/// using the write_checkpoint command, or any updates will be lost when you close the project
		/// or exit the tool.
		///
		/// This example replaces a black box cell with the netlist from the specified file:
		/// update_design -from_file C:/Data/cell_contents.v -cell black_box_cell
		/// The following example updates the netlist in the arnd4 cell with the specified Verilog netlist:
		/// update_design -cell arnd4 -from_file C:/Data/round_4.v
		/// The following example updates the arnd4 cell in the current design with the netlist from the
		/// same cell in the specified design:
		/// update_design -cell arnd4 -from_design netlist_2 -from_cell arnd4
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1731
		/// </summary>
		/// <param name="cells">(Required) List of cells to update with a new sub-netlist.</param>
		/// <param name="strict">
		/// (Optional)
		/// Require exact ports match for replacing cell (otherwise extra
		/// ports are allowed).
		/// </param>
		/// <param name="from_file">(Optional) Name of the file containing the new sub-netlist.</param>
		/// <param name="from_design">(Optional) Name of the an open netlist design containing the new sub￾netlist.</param>
		/// <param name="from_cell">(Optional) Name of cell in the from_design which defines the new sub￾netlist.</param>
		/// <param name="black_box">(Optional) Update the cell to a black_box.</param>
		/// <param name="buffer_ports">(Optional) buffer all the ports of black box</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand update_design(string cells, bool? strict = null, string from_file = null, string from_design = null, string from_cell = null, bool? black_box = null, bool? buffer_ports = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: update_design -cells <args> [-strict] [-from_file <arg>] [-from_design <arg>] [-from_cell <arg>] [-black_box] [-buffer_ports] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("update_design")
					.RequiredNamedString("cells", cells)
					.Flag("strict", strict)
					.OptionalNamedString("from_file", from_file)
					.OptionalNamedString("from_design", from_design)
					.OptionalNamedString("from_cell", from_cell)
					.Flag("black_box", black_box)
					.Flag("buffer_ports", buffer_ports)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Update file(s) in the project based on the file(s) or directory(ies) specified
		///
		///
		/// TCL Syntax: update_files [-from_files <args>] [-norecurse] [-to_files <args>] [-filesets <args>] [-force] [-report_only] [-quiet] [-verbose]
		///
		/// Updates the specified files with the contents of specified remote files. Use this command to
		/// update a local file with the contents of its original remote file, or replace it with the contents of a
		/// different remote file.
		/// This command returns a list of updated files, or returns an error if it fails.
		///
		/// The following example updates the various project source IP core files with the specified -
		/// from_files, reporting the results without making any updates:
		/// update_files -from_files C:/Data/IP/*.xci \
		/// -to_file [get_files *.xci} -report_only
		/// Note: No warnings will be issued for newer local files that will be overwritten.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1734
		/// </summary>
		/// <param name="from_files">(Optional) New files and directories to use for updating</param>
		/// <param name="norecurse">(Optional) Recursively search in specified directories</param>
		/// <param name="to_files">(Optional) Existing project files and directories to limit updates to</param>
		/// <param name="filesets">(Optional) Fileset name</param>
		/// <param name="force">
		/// (Optional)
		/// Overwrite imported files in the project, even if read-only, if
		/// possible
		/// </param>
		/// <param name="report_only">
		/// (Optional)
		/// Do no actual file updates, but report on updates that
		/// otherwise would have been made
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of the files updated</returns>
		public virtual SimpleTCLCommand update_files(string from_files = null, bool? norecurse = null, string to_files = null, string filesets = null, bool? force = null, bool? report_only = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: update_files [-from_files <args>] [-norecurse] [-to_files <args>] [-filesets <args>] [-force] [-report_only] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("update_files")
					.OptionalNamedString("from_files", from_files)
					.Flag("norecurse", norecurse)
					.OptionalNamedString("to_files", to_files)
					.OptionalNamedString("filesets", filesets)
					.Flag("force", force)
					.Flag("report_only", report_only)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Update the SmartLynq firmware image
		///
		///
		/// TCL Syntax: update_hw_firmware [-file_path <arg>] [-config_path <arg>] [-skip_update] [-reset] [-format] [-flash] [-quiet] [-verbose] [<hw_server>]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1736
		/// </summary>
		/// <param name="file_path">(Optional) Optional path to BOOT.BIN file Default: Use default BOOT.BIN</param>
		/// <param name="config_path">(Optional) Optional path to config.ini file Default: No config.ini updated</param>
		/// <param name="skip_update">(Optional) Skip writing the BOOT.BIN to the SmartLynq</param>
		/// <param name="reset">
		/// (Optional)
		/// Reset the SmartLynq cable after any other operations to
		/// complete the update and disconnects the hw_server
		/// </param>
		/// <param name="format">
		/// (Optional)
		/// Format the SmartLynq cable EMMC prior to any other
		/// operations. Any files on SmartLynq cable will be lost.
		/// </param>
		/// <param name="flash">
		/// (Optional)
		/// Flash the SmartLynq cable QSPI. This updates the primary
		/// FSBL and Safe Mode images.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_server">(Optional) hardware server Default: current hardware server</param>
		public virtual SimpleTCLCommand update_hw_firmware(string file_path = null, string config_path = null, bool? skip_update = null, bool? reset = null, bool? format = null, bool? flash = null, bool? quiet = null, bool? verbose = null, string hw_server = null)
		{
			// TCL Syntax: update_hw_firmware [-file_path <arg>] [-config_path <arg>] [-skip_update] [-reset] [-format] [-flash] [-quiet] [-verbose] [<hw_server>]
			return
				new SimpleTCLCommand("update_hw_firmware")
					.OptionalNamedString("file_path", file_path)
					.OptionalNamedString("config_path", config_path)
					.Flag("skip_update", skip_update)
					.Flag("reset", reset)
					.Flag("format", format)
					.Flag("flash", flash)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(hw_server)
			;
		}
		/// <summary>
		/// Update the SmartLynq GPIO PMOD pin values
		///
		///
		/// TCL Syntax: update_hw_gpio [-quiet] [-verbose] [<output_enable_mask>] [<output_pin_values>] [<hw_server>]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1737
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="output_enable_mask">
		/// (Optional)
		/// 8 bit hex mask to enable output pins on GPIO Default: All
		/// output pins disabled
		/// </param>
		/// <param name="output_pin_values">(Optional) 8 bit hex value of output pins Default: All output pins driven low</param>
		/// <param name="hw_server">(Optional) hardware server Default: current hardware server</param>
		/// <returns>All GPIO PMOD pin values</returns>
		public virtual SimpleTCLCommand update_hw_gpio(bool? quiet = null, bool? verbose = null, string output_enable_mask = null, string output_pin_values = null, string hw_server = null)
		{
			// TCL Syntax: update_hw_gpio [-quiet] [-verbose] [<output_enable_mask>] [<output_pin_values>] [<hw_server>]
			return
				new SimpleTCLCommand("update_hw_gpio")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(output_enable_mask)
					.OptionalString(output_pin_values)
					.OptionalString(hw_server)
			;
		}
		/// <summary>
		/// Update the IP Catalog. Before executing this command optionally use the following to set
		/// repository paths:'set_property ip_repo_paths <repo_path_list> [current_fileset]'
		///
		///
		/// TCL Syntax: update_ip_catalog [-rebuild] [-add_ip <arg>] [-delete_ip <arg>] [-delete_mult_ip <args>] [-disable_ip <arg>] [-enable_ip <arg>] [-add_interface <arg>] [-create_index] [-repo_path <arg>] [-update_module_ref] [-quiet] [-verbose]
		///
		/// Update the IP catalog associated with the current design.
		/// The Xilinx® IP catalog, or repository, is located in the installation hierarchy of the Vivado Design
		/// Suite software release being used. You can also add custom IP to the repository by using the
		/// set_property command to set the IP_REPO_PATHS property on the source fileset to point to
		/// the locations of custom IP, as shown in the example below.
		/// The update_ip_catalog command lets you add, delete, disable, or enable individual IP cores
		/// in the catalog. When referring to individual cores, you can reference them by the path to the
		/// component.xml file, or by referencing the VLNV property of the IP.
		/// TIP: The VLNV property refers to the Vendor:Library:Name:Version string which uniquely identifies the IP in the
		/// catalog.
		/// This command returns a transcript of its process if successful, or returns an error if it fails.
		///
		/// The following example sets the IP_REPO_PATHS property of the current Source fileset, to add an
		/// IP repository, then rebuilds the IP catalog index for the whole IP catalog:
		/// set_property IP_REPO_PATHS C:/Data/IP_LIB [current_fileset]
		/// update_ip_catalog -rebuild
		/// This example disables the IP specified by its VLNV property from the specified IP repository:
		/// update_ip_catalog -disable_ip {myCo.com:ip:custom_decoder:1.0} \
		/// -repo_path C:/Data/ip
		/// This example disables the IP specified by the path to the component.xml file, from the IP
		/// repository:
		/// update_ip_catalog -disable_ip C:/Data/ip/custom_encoder_1/component.xml \
		/// -repo_path C:/Xilinx/Vivado/data/ip
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1738
		/// </summary>
		/// <param name="rebuild">
		/// (Optional)
		/// Trigger a rebuild of the specified repository's index file or
		/// rebuild all repositories if none specified
		/// </param>
		/// <param name="add_ip">
		/// (Optional)
		/// Add the specified IP into the specified repository Values:
		/// Either a path to the IP's component.xml or to a zip file
		/// containing the IP
		/// </param>
		/// <param name="delete_ip">
		/// (Optional)
		/// Remove the specified IP from the specified repository
		/// Values: Either a path to the IP's component.xml or its VLNV
		/// </param>
		/// <param name="delete_mult_ip">
		/// (Optional)
		/// Remove the specified IPs from the specified repository
		/// Values: A list of IPs; either paths to the component.xml files
		/// or their VLNVs
		/// </param>
		/// <param name="disable_ip">
		/// (Optional)
		/// Disable the specified IP from the specified repository
		/// Values: Either a path to the IP's component.xml or its VLNV
		/// </param>
		/// <param name="enable_ip">
		/// (Optional)
		/// Enable the specified disabled IP from the specified
		/// repository Values: Either a path to the IP's component.xml
		/// or its VLNV
		/// </param>
		/// <param name="add_interface">
		/// (Optional)
		/// Add the specified interface into the specified repository
		/// Values: A path to the interface's xml file
		/// </param>
		/// <param name="create_index">(Optional) Cache the specified repository's data on disk, to improve load time.</param>
		/// <param name="repo_path">
		/// (Optional)
		/// Used in conjunction with rebuild, add_ip, delete_ip,
		/// delete_mult_ip, disable_ip or create_index to specify the path
		/// of the repository on which to operate
		/// </param>
		/// <param name="update_module_ref">(Optional) Update module reference from their source (e.g. HDL file)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>True for success</returns>
		public virtual SimpleTCLCommand update_ip_catalog(bool? rebuild = null, string add_ip = null, string delete_ip = null, string delete_mult_ip = null, string disable_ip = null, string enable_ip = null, string add_interface = null, bool? create_index = null, string repo_path = null, bool? update_module_ref = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: update_ip_catalog [-rebuild] [-add_ip <arg>] [-delete_ip <arg>] [-delete_mult_ip <args>] [-disable_ip <arg>] [-enable_ip <arg>] [-add_interface <arg>] [-create_index] [-repo_path <arg>] [-update_module_ref] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("update_ip_catalog")
					.Flag("rebuild", rebuild)
					.OptionalNamedString("add_ip", add_ip)
					.OptionalNamedString("delete_ip", delete_ip)
					.OptionalNamedString("delete_mult_ip", delete_mult_ip)
					.OptionalNamedString("disable_ip", disable_ip)
					.OptionalNamedString("enable_ip", enable_ip)
					.OptionalNamedString("add_interface", add_interface)
					.Flag("create_index", create_index)
					.OptionalNamedString("repo_path", repo_path)
					.Flag("update_module_ref", update_module_ref)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Update a macro
		///
		///
		/// TCL Syntax: update_macro [-absolute_grid] [-quiet] [-verbose] <macro> <rlocs>
		///
		/// Populate a previously created macro with leaf cells and relative placements.
		/// A macro is made up of primitive, or leaf-level logic cells, and their associated connections,
		/// positioned in a placement grid. The specified relative locations, or <rlocs>, can be based on a
		/// relative grid, or on an absolute grid, called an RPM_GRID. Refer to the Vivado Design Suite User
		/// Guide: Implementation (UG904) for more information on absolute and relative placement grids
		/// A cell can only belong to a one macro. If you attempt to assign a leaf-level cell to multiple macros,
		/// the Vivado tool will return an error. If you attempt to assign a non-primitive cell to a macro, the
		/// tool will return an error.
		/// To change the contents of an existing macro, you must delete the macro with delete_macro,
		/// recreate it with create_macro, and update it with new contents. You cannot simply overwrite
		/// or modify an existing macro.
		///
		/// The following example creates a macro named usbMacro0, sets the current instance to the
		/// usbEngine0/u0 module, assigns three cells to the macro, with a relative placement for each cell
		/// to have two of them placed inside the same Slice, and the third placed in a vertically adjacent
		/// Slice:
		/// create_macro usbMacro0
		/// current_instance usbEngine0/u0
		/// update_macro usbMacro0 {rx_active_reg X0Y0 \
		/// rx_err_reg X0Y0 rx_valid_reg X0Y1}
		/// The following example creates a macro named usbMacro1, assigns three cells to the macro using
		/// the hierarchical path to the leaf-cell, with absolute coordinates specified for the cells in the
		/// macro:
		/// create_macro usbMacro1
		/// set Site1 [get_sites SLICE_X8Y77]
		/// set Site2 [get_sites SLICE_X9Y77]
		/// set Site3 [get_sites SLICE_X8Y78]
		/// set RPM1 X[get_property RPM_X $Site1]Y[get_property RPM_Y $Site1]
		/// set RPM2 X[get_property RPM_X $Site2]Y[get_property RPM_Y $Site2]
		/// set RPM3 X[get_property RPM_X $Site3]Y[get_property RPM_Y $Site3]
		/// update_macro usbMacro1 -absolute_grid "usbEngine1/u0/rx_active_reg $RPM1 \
		/// usbEngine1/u0/rx_err_reg $RPM2 usbEngine1/u0/rx_valid_reg $RPM3"
		/// Note: In the prior example, notice the use of Tcl variables to capture the Sites of interest, and extract the
		/// RPM_X and RPM_Y properties of those sites for use in the update_macro command. Also notice the use
		/// of quotes ("") instead of curly braces ({}) in the update_macro command. This is to allow the Tcl shell to
		/// perform variable substitution of the command. Refer to the Vivado Design Suite User Guide: Using Tcl
		/// Scripting (UG894) for more information on variables and variable substitution.
		/// This command reports the properties on the usbMacro1 macro to see the absolute grid
		/// coordinates assigned to the cells in the macro:
		/// report_property -all [get_macros usbMacro1]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1742
		/// </summary>
		/// <param name="macro">(Required) Macro to update</param>
		/// <param name="rlocs">(Required) a list interleaved instances and site names</param>
		/// <param name="absolute_grid">(Optional) Use absolute grid for relative locations</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand update_macro(string macro, string rlocs, bool? absolute_grid = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: update_macro [-absolute_grid] [-quiet] [-verbose] <macro> <rlocs>
			return
				new SimpleTCLCommand("update_macro")
					.Flag("absolute_grid", absolute_grid)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(macro)
					.RequiredString(rlocs)
			;
		}
		/// <summary>
		/// Refresh module reference definition and instance(s)
		///
		///
		/// TCL Syntax: update_module_reference [-quiet] [-verbose] [<ips>...]
		///
		/// Refresh the block design cell or cells that reference module definitions from RTL source files by
		/// rereading the module definition from the source file.
		/// Note: This command does not cause the Vivado tool to reread the source file. If changes have been made
		/// to the source file it must be separately updated.
		/// This command returns a transcript of the update process as well as any warnings related to
		/// design changes, or returns nothing if the command fails.
		///
		/// The following example updates the specified module references in the current design:
		/// update_module_reference {rtlRam_0 uart_0}
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1745
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="ips">
		/// (Optional)
		/// module reference to be upgraded Values: IP instance
		/// name(s) within the design
		/// </param>
		/// <returns>A return code indicating success or failure.</returns>
		public virtual SimpleTCLCommand update_module_reference(bool? quiet = null, bool? verbose = null, string ips = null)
		{
			// TCL Syntax: update_module_reference [-quiet] [-verbose] [<ips>...]
			return
				new SimpleTCLCommand("update_module_reference")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(ips)
			;
		}
		/// <summary>
		/// Update the NoC solution
		///
		///
		/// TCL Syntax: update_noc_qos [-force] [-quiet] [-verbose]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1747
		/// </summary>
		/// <param name="force">(Optional) Force update even if the existing solution is invalid</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand update_noc_qos(bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: update_noc_qos [-force] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("update_noc_qos")
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Update the dcp by adding the generated sw param info files to it
		///
		///
		/// TCL Syntax: update_sw_parameters [-quiet] [-verbose]
		///
		/// Updates the design check points (DCPs) with the latest hardware def. This hardware def will have
		/// the updated sw parameters information.
		/// Whenever a software parameter of an IP is modified, the runs need not to go stale. But already
		/// generated design checkpoints need to be updated with the modified parameter information. This
		/// information is captured in the hwdef file. With update_sw_parameters command, the
		/// hwdef file is added to already generated design checkpoints.
		///
		/// The following example modifies a software parameter for the CIPS IP, generates the hw_handoff
		/// target and then updates the DCPs with the modified values:
		/// set_property -dict [list CONFIG.PS_I2C0_PERIPHERAL_ENABLE {1}]
		/// [get_bd_cells versal_cips_0]
		/// generate_target hw_handoff [get_files top.bd]
		/// update_sw_parameters
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1748
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand update_sw_parameters(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: update_sw_parameters [-quiet] [-verbose]
			return
				new SimpleTCLCommand("update_sw_parameters")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// update timing
		///
		///
		/// TCL Syntax: update_timing [-full] [-skip_delay_calc] [-quiet] [-verbose]
		///
		/// Updates timing for the current design.
		/// Update the timing data to reflect any timing constraints that were added to the design since the
		/// timing engine was last run. This command updates the in-memory view of the timing database,
		/// without incurring the time of a full timing analysis.
		/// Timing is automatically updated by commands that change timing or need updated timing
		/// information, such as the report_timing command. The update_timing command lets you
		/// manually trigger the timing update to insure the latest constraints are applied to the timing
		/// engine.
		/// The update_timing command uses an incremental analysis approach by default, which
		/// updates only out-of-date information, to reduce process and analysis time. You can also specify a
		/// complete or full update to insure a comprehensive review of timing data in the design. However,
		/// to avoid long timing analysis run times, you should use the -full option only when you need to.
		///
		/// The following example performs a full update of the in-memory timing data:
		/// update_timing -full
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1750
		/// </summary>
		/// <param name="full">(Optional) Perform a full timing update instead of an incremental one</param>
		/// <param name="skip_delay_calc">(Optional) Skip delay calculation</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand update_timing(bool? full = null, bool? skip_delay_calc = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: update_timing [-full] [-skip_delay_calc] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("update_timing")
					.Flag("full", full)
					.Flag("skip_delay_calc", skip_delay_calc)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Upgrade configurable IPIntegrator cell(s) to later version
		///
		///
		/// TCL Syntax: upgrade_bd_cells [-latest <arg>] [-quiet] [-verbose] <objects>...
		///
		/// Upgrade IP integrator cells to the latest version available in the IP integrator catalog.
		/// This command lets you update IP integrator subsystem designs from an earlier release to use the
		/// IP cores from the latest catalog.
		/// This command returns the list of IP integrator cells that were upgraded, or returns an error if it
		/// fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1752
		/// </summary>
		/// <param name="objects">(Required) IPIntegrator cells to be upgraded</param>
		/// <param name="latest">(Optional) Upgrade the IPIntegrator block to the latest version</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>List of IPIntegrator cell names those were upgraded, "" if failed.</returns>
		public virtual SimpleTCLCommand upgrade_bd_cells(string objects, string latest = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: upgrade_bd_cells [-latest <arg>] [-quiet] [-verbose] <objects>...
			return
				new SimpleTCLCommand("upgrade_bd_cells")
					.OptionalNamedString("latest", latest)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Upgrade a configurable IP to a later version
		///
		///
		/// TCL Syntax: upgrade_ip [-srcset <arg>] [-vlnv <arg>] [-log <arg>] [-quiet] [-verbose] <objects>...
		///
		/// This command upgrades the specified IP cores from an older version to the latest version in the
		/// IP catalog.
		/// You can only upgrade IP that explicitly supports upgrading. The UPGRADE_VERSIONS property
		/// on the ipdef object indicates if there are upgrade versions for an IP core.
		/// TIP: The upgrade_ip command also accepts Block Design cell IP instances as bd_cell objects. The command
		/// upgrades the bd_cell objects within the Block Design, and does not require the diagram to be open in the Vivado
		/// IP integrator .
		///
		/// The following example upgrades all IP cores in the current project to the latest version:
		/// upgrade_ip [get_ips]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1754
		/// </summary>
		/// <param name="objects">
		/// (Required)
		/// IP to be upgraded Values: IP instance(s) within the design,
		/// as returned by 'get_ips <instance name>' or 'get_bd_cells
		/// <cell name>'
		/// </param>
		/// <param name="srcset">
		/// (Optional)
		/// (Optional) Specifies the source file set containing the IP to
		/// be upgraded Default: The current source fileset Values:
		/// Source set name
		/// </param>
		/// <param name="vlnv">
		/// (Optional)
		/// (Optional) Identifies the Catalog IP to which the IP will be
		/// upgraded. The VLNV string maps to the IPDEF property on
		/// the IP core. This is a strict comparison, and the upgrade will
		/// fail if the identified IP does not exist in the Catalog. Default:
		/// Latest version of the current IP Values: A string of the form
		/// '<vendor>:<library>:<name>:<versio n>'
		/// </param>
		/// <param name="log">
		/// (Optional)
		/// (Optional) Identifies the log file to which the IP upgrade
		/// report will be concatenated. Default: An empty string,
		/// indicating that no log will be written Values: A file path to an
		/// existing writable file, or a non-existent file location in a
		/// writable directory
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>A return code indicating success or failure.</returns>
		public virtual SimpleTCLCommand upgrade_ip(string objects, string srcset = null, string vlnv = null, string log = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: upgrade_ip [-srcset <arg>] [-vlnv <arg>] [-log <arg>] [-quiet] [-verbose] <objects>...
			return
				new SimpleTCLCommand("upgrade_ip")
					.OptionalNamedString("srcset", srcset)
					.OptionalNamedString("vlnv", vlnv)
					.OptionalNamedString("log", log)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(objects)
			;
		}
		/// <summary>
		/// Stop capturing. Upload any captured hardware ILA data.
		///
		///
		/// TCL Syntax: upload_hw_ila_data [-quiet] [-verbose] [<hw_ilas>...]
		///
		/// Upload the captured data from the memory buffers of the specified ILA debug cores on the Xilinx
		/// FPGA hardware device, and move it into a hw_ila_data object in the Vivado logic analyzer.
		/// You can upload captured data from the ILA debug core at any time during the capture process
		/// triggered by the run_hw_ila command. However, you may want to use the wait_on_hw_ila
		/// command in any Tcl scripts, to wait until the sample data buffers of the ILA core are fully
		/// populated with data. If you run the upload_hw_ila_data command prior to this, you may see
		/// a message as follows:
		/// INFO: [Labtools 27-1965] The ILA core 'hw_ila_1' trigger was stopped by
		/// user \
		/// at 2014-Mar-06 08:59:30
		/// INFO: [Labtools 27-2212] The ILA core 'hw_ila_1' captured '6' windows with
		/// \
		/// '64' samples each, and a last partial window with '0' samples.
		/// The upload process creates a hw_ila_data object in the process of moving the captured data from
		/// the ILA debug core, hw_ila, on the physical FPGA device, hw_device. The hw_ila_data object is
		/// named after the hw_ila core it is uploaded from.
		/// TIP: Each hw_ila object has only one matching hw_ila_data object associated with it. Each time
		/// upload_hw_ila_data is run for a specific hw_ila core, the hw_ila_data object is overwritten if it already exists.
		/// The data object, hw_ila_data can be viewed in the waveform viewer of the Vivado logic analyzer
		/// by using the display_hw_ila_data command, and can be written to disk using the
		/// write_hw_ila_data command.
		/// This command returns a hw_ila_data object, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1757
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_ilas">(Optional) List of hardware ILA objects. Default: Current hardware ILA</param>
		/// <returns>hardware ILA data objects</returns>
		public virtual SimpleTCLCommand upload_hw_ila_data(bool? quiet = null, bool? verbose = null, string hw_ilas = null)
		{
			// TCL Syntax: upload_hw_ila_data [-quiet] [-verbose] [<hw_ilas>...]
			return
				new SimpleTCLCommand("upload_hw_ila_data")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(hw_ilas)
			;
		}
		/// <summary>
		/// Run Parameter Propagation for specified design or for a specific cell.
		///
		///
		/// TCL Syntax: validate_bd_design [-force] [-design <arg>] [-include_pfm] [-quiet] [-verbose]
		///
		/// Validate an IP integrator subsystem design, or IP cell or hierarchical module.
		///
		/// The following example validates the current IP integrator subsystem design, forcing re-validation
		/// if needed:
		/// validate_bd_design -force
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1760
		/// </summary>
		/// <param name="force">(Optional) Force re-run validation on the design</param>
		/// <param name="design">
		/// (Optional)
		/// Design name. If not specified, run parameter propagation
		/// on current design
		/// </param>
		/// <param name="include_pfm">(Optional) including validate pfm attributes on the design</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>TCL_OK, TCL_ERROR if failed.</returns>
		public virtual SimpleTCLCommand validate_bd_design(bool? force = null, string design = null, bool? include_pfm = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: validate_bd_design [-force] [-design <arg>] [-include_pfm] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("validate_bd_design")
					.Flag("force", force)
					.OptionalNamedString("design", design)
					.Flag("include_pfm", include_pfm)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Validate the specified harware platform
		///
		///
		/// TCL Syntax: validate_hw_platform [-verbose] [-quiet] [<file>]
		///
		/// Validate a Xilinx support archive (XSA) file to ensure it has the required content for the platform.
		/// This command returns information related to the validation of the XSA, or returns an error if it
		/// fails.
		///
		/// The following example validates the specified XSA, returning verbose information related to the
		/// platform contents:
		/// validate_hw_platform C:/Data/zc706.xsa -verbose
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1762
		/// </summary>
		/// <param name="verbose">(Optional) Dump verbose information</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="file">(Optional) Xilinx Shell Archive file Values: Path to shell file.</param>
		/// <returns>The name of the shell file</returns>
		public virtual SimpleTCLCommand validate_hw_platform(bool? verbose = null, bool? quiet = null, string file = null)
		{
			// TCL Syntax: validate_hw_platform [-verbose] [-quiet] [<file>]
			return
				new SimpleTCLCommand("validate_hw_platform")
					.Flag("verbose", verbose)
					.Flag("quiet", quiet)
					.OptionalString(file)
			;
		}
		/// <summary>
		/// This command applies any pending set_property commands and returns parameter validation
		/// messages, if any exist
		///
		///
		/// TCL Syntax: validate_ip [-save_ip] [-quiet] [-verbose] [<ips>]
		///
		/// Perform DRC check on IP to ensure that it is properly constructed. This command returns 1
		/// when all IPs have been validated, or 0 when there is a problem.
		///
		/// The following example validates the IPs in the current project, and updates the persistent
		/// representation of the IP.
		/// validate_ip -save_ip [get_ips]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1764
		/// </summary>
		/// <param name="save_ip">(Optional) Write IP files on the disk</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="ips">(Optional) IPs to be validated</param>
		public virtual SimpleTCLCommand validate_ip(bool? save_ip = null, bool? quiet = null, bool? verbose = null, string ips = null)
		{
			// TCL Syntax: validate_ip [-save_ip] [-quiet] [-verbose] [<ips>]
			return
				new SimpleTCLCommand("validate_ip")
					.Flag("save_ip", save_ip)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(ips)
			;
		}
		/// <summary>
		/// Verify hardware devices
		///
		///
		/// TCL Syntax: verify_hw_devices [-key <arg>] [-user_efuse <arg>] [-control_efuse <arg>] [-security_efuse <arg>] [-verbose] [-quiet] [<hw_device>...]
		///
		/// For EFUSE encrypted devices, this command compares the bitstream assigned to the
		/// PROGRAM.FILE property on the specified hw_device with the bitstream programmed into the
		/// device with the program_hw_devices command.
		/// Filtered through a required mask file, associated with the hw_device, the verify_hw_devices
		/// command uses both the bitstream and mask file to compare only the bits that are marked as
		/// important in the mask file. A mask file can be created along with the bitstream using the
		/// write_bitstream command, and is associated with the hw_device using the
		/// create_hw_bitstream command.
		/// IMPORTANT! Verification cannot be performed on devices programmed with encrypted bitstreams, other than
		/// to verify that the -key has been programmed.
		/// The verify_hw_devices command reports that the readback data matches the programmed
		/// bitstream if successful, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1766
		/// </summary>
		/// <param name="key">(Optional) option value for key verification: efuse</param>
		/// <param name="user_efuse">(Optional) hex user fuse value for verification</param>
		/// <param name="control_efuse">(Optional) hex control fuse value for verification</param>
		/// <param name="security_efuse">(Optional) hex security fuse value for verification</param>
		/// <param name="verbose">(Optional) Shows fuse values during verification</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="hw_device">(Optional) list of hardware devices Default: current hardware device</param>
		/// <returns>hardware devices</returns>
		public virtual SimpleTCLCommand verify_hw_devices(string key = null, string user_efuse = null, string control_efuse = null, string security_efuse = null, bool? verbose = null, bool? quiet = null, string hw_device = null)
		{
			// TCL Syntax: verify_hw_devices [-key <arg>] [-user_efuse <arg>] [-control_efuse <arg>] [-security_efuse <arg>] [-verbose] [-quiet] [<hw_device>...]
			return
				new SimpleTCLCommand("verify_hw_devices")
					.OptionalNamedString("key", key)
					.OptionalNamedString("user_efuse", user_efuse)
					.OptionalNamedString("control_efuse", control_efuse)
					.OptionalNamedString("security_efuse", security_efuse)
					.Flag("verbose", verbose)
					.Flag("quiet", quiet)
					.OptionalString(hw_device)
			;
		}
		/// <summary>
		/// Returns the build for Vivado and the build date
		///
		///
		/// TCL Syntax: version [-short] [-quiet] [-verbose]
		///
		/// Returns the version number of the Xilinx® tool. This includes the software version number, build
		/// number and date, and copyright information.
		///
		/// The following example returns only the version number for the software:
		/// version -short
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1769
		/// </summary>
		/// <param name="@short">(Optional) Return only the numeric version number</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>
		/// </returns>
		public virtual SimpleTCLCommand version(bool? @short = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: version [-short] [-quiet] [-verbose]
			return
				new SimpleTCLCommand("version")
					.Flag("short", @short)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
			;
		}
		/// <summary>
		/// Wait until all hardware ILA data has been captured.
		///
		///
		/// TCL Syntax: wait_on_hw_ila [-timeout <arg>] [-quiet] [-verbose] [<hw_ilas>...]
		///
		/// Suspend Tcl script or Tcl command processing until the ILA debug core memory is filled by
		/// captured data samples.
		/// This command is used after the run_hw_ila command to pause Tcl processing to wait for the
		/// data buffers to fill up. When the wait_on_hw_ila command returns, the Tcl command or script
		/// processing can continue.
		/// With the ILA debug core memory filed with sample data, when Tcl processing resumes, you can
		/// upload the captured data samples into an ILA debug core data object, or hw_ila_data object. Use
		/// the upload_ila_data command to perform this action.
		/// This command operates silently, returning nothing if successful, or returning an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1771
		/// </summary>
		/// <param name="timeout">(Optional) Timeout in minutes. Decimal value allowed Default: No timeout</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_ilas">(Optional) hardware ILA objects. Default: Current hardware ILA</param>
		public virtual SimpleTCLCommand wait_on_hw_ila(string timeout = null, bool? quiet = null, bool? verbose = null, string hw_ilas = null)
		{
			// TCL Syntax: wait_on_hw_ila [-timeout <arg>] [-quiet] [-verbose] [<hw_ilas>...]
			return
				new SimpleTCLCommand("wait_on_hw_ila")
					.OptionalNamedString("timeout", timeout)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(hw_ilas)
			;
		}
		/// <summary>
		/// Wait until hardware SIO scan has completed.
		///
		///
		/// TCL Syntax: wait_on_hw_sio_scan [-timeout <arg>] [-quiet] [-verbose] <hw_sio_scans>...
		///
		/// Suspend a Tcl script or Tcl command processing until the specified serial I/O analyzer scan is
		/// complete.
		/// This command is used after the run_hw_sio_scan command to pause Tcl processing to wait
		/// for the scan to complete. When the wait_on_sio_scan command returns, the Tcl command
		/// or script processing can continue.
		/// This command operates silently, returning nothing if successful, or returning an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1773
		/// </summary>
		/// <param name="hw_sio_scans">(Required) List of hardware SIO scan objects.</param>
		/// <param name="timeout">(Optional) Timeout in minutes. Decimal value allowed Default: No timeout</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand wait_on_hw_sio_scan(string hw_sio_scans, string timeout = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: wait_on_hw_sio_scan [-timeout <arg>] [-quiet] [-verbose] <hw_sio_scans>...
			return
				new SimpleTCLCommand("wait_on_hw_sio_scan")
					.OptionalNamedString("timeout", timeout)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_sio_scans)
			;
		}
		/// <summary>
		/// Wait until hardware SIO sweep has completed.
		///
		///
		/// TCL Syntax: wait_on_hw_sio_sweep [-timeout <arg>] [-quiet] [-verbose] <hw_sio_sweeps>...
		///
		/// Suspend a Tcl script or Tcl command processing until the serial I/O analyzer sweep scan is
		/// complete.
		/// This command is used after the run_hw_sio_sweep command to pause Tcl processing to wait
		/// for the sweep scan to complete. When the wait_on_sio_sweep command returns, the Tcl
		/// command or script processing can continue.
		/// This command operates silently, returning nothing if successful, or returning an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1775
		/// </summary>
		/// <param name="hw_sio_sweeps">(Required) List of hardware SIO sweep objects.</param>
		/// <param name="timeout">(Optional) Timeout in minutes. Decimal value allowed Default: No timeout</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand wait_on_hw_sio_sweep(string hw_sio_sweeps, string timeout = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: wait_on_hw_sio_sweep [-timeout <arg>] [-quiet] [-verbose] <hw_sio_sweeps>...
			return
				new SimpleTCLCommand("wait_on_hw_sio_sweep")
					.OptionalNamedString("timeout", timeout)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(hw_sio_sweeps)
			;
		}
		/// <summary>
		/// Block execution of further Tcl commands until the specified run completes.
		///
		///
		/// TCL Syntax: wait_on_run [-timeout <arg>] [-quiet] [-verbose] <run>
		///
		/// Blocks the execution of Tcl commands until the specified run has completed either successfully
		/// or in error, or until the specified amount of time has elapsed.
		/// This command will tell you when the run has terminated, but not the results of the run. To
		/// determine if the run has completed successfully, you could query the value of the PROGRESS
		/// property of the run:
		/// launch_runs synth_1
		/// wait_on_run synth_1
		/// if {[get_property PROGRESS [get_runs synth_1]] != "100%"} {
		/// error "ERROR: synth_1 failed"
		/// }
		/// The wait_on_run command can be used for runs that have been launched. If the specified run
		/// has not been launched when the wait_on_run command is used, you will get an error. Runs
		/// that have already completed do not return an error.
		/// Note: This command is used for running the tool in batch mode or from Tcl scripts. It is ignored when
		/// running interactively from the GUI.
		///
		/// The following example launches the impl_1 run, and then waits for the specified run to complete,
		/// or to wait for one hour, whichever occurs first:
		/// launch_runs impl_1
		/// wait_on_run -timeout 60 impl_1
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1777
		/// </summary>
		/// <param name="run">(Required) Run to wait on</param>
		/// <param name="timeout">(Optional) Maximum time to wait for the run to complete (in minutes) Default: -1</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand wait_on_run(string run, string timeout = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: wait_on_run [-timeout <arg>] [-quiet] [-verbose] <run>
			return
				new SimpleTCLCommand("wait_on_run")
					.OptionalNamedString("timeout", timeout)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(run)
			;
		}
		/// <summary>
		/// Write an abstract shell checkpoint of the current design
		///
		///
		/// TCL Syntax: write_abstract_shell -cell <arg> [-force] [-quiet] [-verbose] <file>
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1779
		/// </summary>
		/// <param name="cell">(Required) Create an abstract shell for this reconfigurable cell</param>
		/// <param name="file">
		/// (Required)
		/// Design checkpoint file Values: A filename with alphanumeric
		/// characters and .dcp extension.
		/// </param>
		/// <param name="force">(Optional) Overwrite existing checkpoint file</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The name of the checkpoint file</returns>
		public virtual SimpleTCLCommand write_abstract_shell(string cell, string file, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_abstract_shell -cell <arg> [-force] [-quiet] [-verbose] <file>
			return
				new SimpleTCLCommand("write_abstract_shell")
					.RequiredNamedString("cell", cell)
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Export layout in native, pdf or svg
		///
		///
		/// TCL Syntax: write_bd_layout [-force] [-format <arg>] [-orientation <arg>] [-scope <arg>] [-hierarchy <arg>] [-quiet] [-verbose] <file>
		///
		/// Write the current open block design in the Vivado IP integrator to the specified file format.
		/// This command lets you print the block design, output it as a vector graphic file for use in
		/// documentation related to the design project, or recreate the block design layout in the Vivado IP
		/// integrator design canvas using the regenerate_bd_layout command.
		/// This command returns the name of the file written, or returns an error if it fails.
		///
		/// The following example prints the current block design to the specified PDF file:
		/// write_bd_layout -format pdf -orientation landscape C:/Data/microblaze.pdf
		/// The following example prints the specified hierarchical cell of the block design to the specified
		/// SVG file:
		/// write_bd_layout -format svg -orientation landscape C:/Data/microblaze.svg
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1780
		/// </summary>
		/// <param name="file">(Required) Output file</param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="format">
		/// (Optional)
		/// Values: native, pdf or svg. regenerate_bd_layout -layout_file
		/// can be used with native layout. Default: native
		/// </param>
		/// <param name="orientation">(Optional) Values: landscape or portrait</param>
		/// <param name="scope">(Optional) Values: visible or all Default: all</param>
		/// <param name="hierarchy">(Optional) Hierarchy block</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>name of the output file</returns>
		public virtual SimpleTCLCommand write_bd_layout(string file, bool? force = null, string format = null, string orientation = null, string scope = null, string hierarchy = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_bd_layout [-force] [-format <arg>] [-orientation <arg>] [-scope <arg>] [-hierarchy <arg>] [-quiet] [-verbose] <file>
			return
				new SimpleTCLCommand("write_bd_layout")
					.Flag("force", force)
					.OptionalNamedString("format", format)
					.OptionalNamedString("orientation", orientation)
					.OptionalNamedString("scope", scope)
					.OptionalNamedString("hierarchy", hierarchy)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Export the current design to a Tcl file on disk.
		///
		///
		/// TCL Syntax: write_bd_tcl [-force] [-bd_name <arg>] [-no_mig_contents] [-no_ip_version] [-ignore_minor_versions] [-bd_folder <arg>] [-check_ips <arg>] [-hier_blks <arg>] [-include_layout] [-exclude_layout] [-make_local] [-no_project_wrapper] [-exclude_pfm] [-quiet] [-verbose] <tcl_filename>
		///
		/// Export the current IP integrator subsystem design as a Tcl script file to the disk.
		/// IMPORTANT! Any directory in the path specified by the <name> option must already exist, or the script will
		/// not be created.
		/// The Tcl script file lets you recreate, reuse, and customize IP integrator subsystem designs without
		/// having to archive the original subsystem design.
		/// When working with a new software release, you must use the output script from the
		/// write_bd_tcl command to create a block design in the same software release as the Tcl script
		/// was generated. This ensures the availability of the needed versions of any IP used in the script.
		/// You can then migrate the created block design into a new software release.
		/// This command returns TCL_OK if successful, or TCL_ERROR if it fails, unless -quiet is specified.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1783
		/// </summary>
		/// <param name="tcl_filename">(Required) Name of exported Tcl file</param>
		/// <param name="force">(Optional) Flag to overwrite existing file.</param>
		/// <param name="bd_name">
		/// (Optional)
		/// Name for block diagram. By default will use current block
		/// diagram's name.
		/// </param>
		/// <param name="no_mig_contents">
		/// (Optional)
		/// Flag to not include MIG PRJ contents into generated Tcl
		/// script, but instead will load PRJ from working directory.
		/// Default is to include MIG PRJ contents in Tcl script.
		/// </param>
		/// <param name="no_ip_version">
		/// (Optional)
		/// Flag to not include the IP version as part of the IP VLNV in
		/// create_bd_cell commands. NOTE - this may have
		/// implications if there are major IP version changes.
		/// </param>
		/// <param name="ignore_minor_versions">
		/// (Optional)
		/// Use this flag to create the cells in the design using their
		/// latest minor version. For example, a project contains
		/// versions of blk_mem_gen IP like 7.3, 7.4, 8.3, 8.4. In the
		/// design there is a blk_mem_gen_v7.4. With this flag,
		/// write_bd_tcl will generate the line: create_bd_cell -type ip -
		/// vlnv xilinx.com:ip:blk_mem_gen:7.* bmg_0_v7. When the
		/// generated Tcl script is sourced, the cell bmg_0_v7 will use
		/// the latest blk_mem_gen_v7.
		/// </param>
		/// <param name="bd_folder">
		/// (Optional)
		/// Remote BD feature - Specify the folder where the design will
		/// be generated when Tcl script is sourced.
		/// </param>
		/// <param name="check_ips">
		/// (Optional)
		/// By default value = true, therefore, will check if IPs/modules
		/// exist in the IP catalog or project before continuing to
		/// reconstruct the design. Valid values are (true/false), (yes/
		/// no), or (1/0).
		/// </param>
		/// <param name="hier_blks">
		/// (Optional)
		/// Comma separated list of hierarchical blocks in the design
		/// that will be generated by the Tcl script. Will include any sub￾hierachical blocks within the specified blocks too. This
		/// option will not create the top-level design portion.
		/// </param>
		/// <param name="include_layout">
		/// (Optional)
		/// By default will NOT include the GUI layout of the design. Use
		/// this argument to include the layout information in the
		/// generated Tcl script.
		/// </param>
		/// <param name="exclude_layout">
		/// (Optional)
		/// NOTE - This flag will be obsolete in a near future release, but
		/// is currently supported for backwards compatibility. Use this
		/// argument to not include the layout information in the
		/// generated Tcl script.
		/// Name Description
		/// </param>
		/// <param name="make_local">(Optional) Use this flag when you want to write your remote BD out as a local BD.</param>
		/// <param name="no_project_wrapper">
		/// (Optional)
		/// This option is used to write the BD create TCL procs without
		/// any project wrapper.
		/// </param>
		/// <param name="exclude_pfm">(Optional) Use this flag to exclude pfm attributes for this design</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>TCL_OK, TCL_ERROR if failed.</returns>
		public virtual SimpleTCLCommand write_bd_tcl(string tcl_filename, bool? force = null, string bd_name = null, bool? no_mig_contents = null, bool? no_ip_version = null, bool? ignore_minor_versions = null, string bd_folder = null, string check_ips = null, string hier_blks = null, bool? include_layout = null, bool? exclude_layout = null, bool? make_local = null, bool? no_project_wrapper = null, bool? exclude_pfm = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_bd_tcl [-force] [-bd_name <arg>] [-no_mig_contents] [-no_ip_version] [-ignore_minor_versions] [-bd_folder <arg>] [-check_ips <arg>] [-hier_blks <arg>] [-include_layout] [-exclude_layout] [-make_local] [-no_project_wrapper] [-exclude_pfm] [-quiet] [-verbose] <tcl_filename>
			return
				new SimpleTCLCommand("write_bd_tcl")
					.Flag("force", force)
					.OptionalNamedString("bd_name", bd_name)
					.Flag("no_mig_contents", no_mig_contents)
					.Flag("no_ip_version", no_ip_version)
					.Flag("ignore_minor_versions", ignore_minor_versions)
					.OptionalNamedString("bd_folder", bd_folder)
					.OptionalNamedString("check_ips", check_ips)
					.OptionalNamedString("hier_blks", hier_blks)
					.Flag("include_layout", include_layout)
					.Flag("exclude_layout", exclude_layout)
					.Flag("make_local", make_local)
					.Flag("no_project_wrapper", no_project_wrapper)
					.Flag("exclude_pfm", exclude_pfm)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(tcl_filename)
			;
		}
		/// <summary>
		/// Write a bitstream for the current design
		///
		///
		/// TCL Syntax: write_bitstream [-force] [-verbose] [-raw_bitfile] [-no_binary_bitfile] [-mask_file] [-readback_file] [-logic_location_file] [-bin_file] [-reference_bitfile <arg>] [-cell <arg>] [-no_partial_bitfile] [-quiet] <file>
		///
		/// Writes a bitstream file for the current project. This command must be run on an Implemented
		/// Design. The bitstream written will be based on the open Implemented Design.
		/// The files that can be generated by the write_bitstream command include the following:
		/// • Bit file: The binary bitstream file (.bit).
		/// • Raw (ASCII) Bit file: A raw bit file (.rbt) that contains the same information as the binary
		/// bitstream file, but is in ASCII format.
		/// • Mask file: A mask file (.msk) that has mask data in place of the configuration data in the
		/// bitstream file.
		/// • Logic Location file: An ASCII logic location file (.ll) that shows the bitstream position of
		/// latches, flip-flops, LUTs, Block RAMs, and I/O block inputs and outputs.
		/// • Bin file: A binary file (.bin) containing only the device programming data, without the header
		/// information found in the standard binary Bit file.
		/// • Reference Bit file: An incremental bitstream file containing only the differences from the
		/// current bitstream and a specified reference bitstream.
		/// The Vivado tool can write a compressed bitstream, if you have enabled compression by setting
		/// the BITSTREAM.GENERAL.COMPRESS property on the implemented design. Refer to the Vivado
		/// Design Suite User Guide: Programming and Debugging (UG908) for more information on Device
		/// Configuration Properties. To enable compression use the following Tcl command:
		/// set_property BITSTREAM.GENERAL.COMPRESS TRUE [current_design]
		/// The Vivado Design Suite can also write an encrypted bitstream to protect the intellectual
		/// property of the design in the bitstream. To create an encrypted bitstream you must first define
		/// the type of encryption to be used, and the encryption key. You can accomplish this most easily
		/// using the Encryption page of the Edit Device Properties dialog box in the Vivado IDE. Refer to
		/// the Vivado Design Suite User Guide: Programming and Debugging (UG908) for more information on
		/// the Edit Device Properties dialog box.
		/// You can also enable encryption by manually defining the appropriate properties on the
		/// implemented design as follows:
		/// set_property BITSTREAM.ENCRYPTION.ENCRYPT YES [get_designs impl_1]
		/// set_property BITSTREAM.ENCRYPTION.ENCRYPTKEYSELECT EFUSE [get_designs
		/// impl_1]
		/// set_property BITSTREAM.ENCRYPTION.KEY0 8675309 [get_designs impl_1]
		/// The properties associated with encryption include:
		/// • BITSTREAM.ENCRYPTION.ENCRYPT - Enables encryption when generating the bitstream
		/// with write_bitstream. This property accepts a value of YES or NO.
		/// • BITSTREAM.ENCRYPTION.ENCRYPTKEYSELECT - Specifies the method for storing the
		/// encryption key on the hardware device. The accepted values are BBRAM and EFUSE, referring
		/// to battery-backed SRAM or the eFUSE registers on the device.
		/// CAUTION! eFUSEs are one-time programmable cells on the hardware device, used to store the factory￾programmed Device DNA, AES-GCM encryption key, and user specified values. Refer to the UltraScale
		/// Architecture Configuration User Guide (UG570) or 7 Series FPGAs Configuration User Guide (UG470) for more
		/// information on eFUSE registers.
		/// • BITSTREAM.ENCRYPTION.KEY0 - Specifies the encryption key to apply to the BBRAM, or
		/// the eFUSE FUSE_KEY registers on the device. The key can be specified as a 256 bit value, and
		/// will be required when accessing an encrypted bitstream to program, verify, or readback the
		/// hw_device.
		/// TIP: The write_bitstream command will write an NKY file of the same name as the bitstream file (with
		/// the .nky extension) when the BITSTREAM.ENCRYPTION.KEY0 property is specified. This encryption file can
		/// then be used in other designs by setting the BITSTREAM.ENCRYPTION.KEYFILE property.
		/// • BITSTREAM.ENCRYPTION.KEYFILE - Specifies an encryption key file (NKY or NKZ) as an
		/// alternative to setting the ENCRYPTION.KEY0 property. The specified encryption key file will
		/// be used during bitstream encryption.
		/// IMPORTANT! If both the BITSTREAM.ENCRYPTION.KEY0 and BITSTREAM.ENCRYPTION.KEYFILE properties
		/// are defined, the tool will use the encryption key specified by the BITSTREAM.ENCRYPTION.KEY0 property and
		/// return a message to that effect.
		///
		/// The following example enables compression and writes a bitstream file of the specified name:
		/// set_property BITSTREAM.GENERAL.COMPRESS TRUE [current_design]
		/// write_bitstream design1.bit
		/// The following example writes both the binary and ASCII forms of the bitstream:
		/// write_bitstream -raw_bitfile C:/Data/design1
		/// Note: The appropriate file extension will be added by the tool.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1787
		/// </summary>
		/// <param name="file">(Required) The name of the .bit file to generate</param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="verbose">(Optional) Print write_bitstream options</param>
		/// <param name="raw_bitfile">(Optional) Write raw bit file (.rbt)</param>
		/// <param name="no_binary_bitfile">(Optional) Do not write binary bit file (.bit)</param>
		/// <param name="mask_file">(Optional) Write mask file (.msk)</param>
		/// <param name="readback_file">(Optional) Write readback files (.rbd, .msd)</param>
		/// <param name="logic_location_file">(Optional) Write logic location file (.ll)</param>
		/// <param name="bin_file">(Optional) Write binary bit file without header (.bin)</param>
		/// <param name="reference_bitfile">(Optional) Reference bitfile to be used for generating partial bitstream</param>
		/// <param name="cell">(Optional) Create only partial bitstream for named cell</param>
		/// <param name="no_partial_bitfile">(Optional) Do not write partial bit files for a partial reconfiguration design</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		public virtual SimpleTCLCommand write_bitstream(string file, bool? force = null, bool? verbose = null, bool? raw_bitfile = null, bool? no_binary_bitfile = null, bool? mask_file = null, bool? readback_file = null, bool? logic_location_file = null, bool? bin_file = null, string reference_bitfile = null, string cell = null, bool? no_partial_bitfile = null, bool? quiet = null)
		{
			// TCL Syntax: write_bitstream [-force] [-verbose] [-raw_bitfile] [-no_binary_bitfile] [-mask_file] [-readback_file] [-logic_location_file] [-bin_file] [-reference_bitfile <arg>] [-cell <arg>] [-no_partial_bitfile] [-quiet] <file>
			return
				new SimpleTCLCommand("write_bitstream")
					.Flag("force", force)
					.Flag("verbose", verbose)
					.Flag("raw_bitfile", raw_bitfile)
					.Flag("no_binary_bitfile", no_binary_bitfile)
					.Flag("mask_file", mask_file)
					.Flag("readback_file", readback_file)
					.Flag("logic_location_file", logic_location_file)
					.Flag("bin_file", bin_file)
					.OptionalNamedString("reference_bitfile", reference_bitfile)
					.OptionalNamedString("cell", cell)
					.Flag("no_partial_bitfile", no_partial_bitfile)
					.Flag("quiet", quiet)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Write a bmm file
		///
		///
		/// TCL Syntax: write_bmm [-force] [-quiet] [-verbose] <file>
		///
		/// The Block RAM Memory Map (BMM) file is a text file that describes how individual block RAMs
		/// on an FPGA are grouped together into a contiguous address space called an Address Block.
		/// The write_bmm command exports BMM information from the current design to the specified
		/// file. For implemented designs the BMM file will be include placement information. The
		/// data2mem command uses the BMM file as input to direct the translation of programming data
		/// into the proper form for use in simulation, device programming, or software development in SDK.
		/// The command returns the name of the output file, or an error.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1792
		/// </summary>
		/// <param name="file">
		/// (Required)
		/// Design bmm file Values: A filename with alphanumeric
		/// characters and .bmm extension.
		/// </param>
		/// <param name="force">(Optional) Overwrite existing BMM file.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The name of the bmm file</returns>
		public virtual SimpleTCLCommand write_bmm(string file, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_bmm [-force] [-quiet] [-verbose] <file>
			return
				new SimpleTCLCommand("write_bmm")
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Generate a design specific post-configuration BSDL file (.bsd).
		///
		///
		/// TCL Syntax: write_bsdl [-force] [-bsd <arg>] [-quiet] [-verbose] <file>
		///
		/// Generate a Boundary Scan Description Language (BSDL) file (.bsd) for the current design that
		/// reflects the post-configuration boundary scan architecture of the target device.
		/// The boundary scan architecture for the device is changed when the device is configured because
		/// certain connections between the boundary scan registers and pad may change. These changes
		/// must be communicated to the boundary scan tester through a post-configuration BSDL file.
		/// Refer to the Vivado Design Suite User Guide: Programming and Debugging (UG908) for more
		/// information on the available configuration modes.
		/// The write_bsdl command reads a pre-configuration BSDL file for the target part from the
		/// Vivado Design Suite installation area, and combines that with post-configuration data from the
		/// current design.
		/// This command returns the name of the output BSDL file, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1794
		/// </summary>
		/// <param name="file">(Required) Output file name. The .bsd extension is optional.</param>
		/// <param name="force">(Optional) Overwrite existing .bsd file</param>
		/// <param name="bsd">(Optional) Specify an updated generic BSDL file.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>name of the output file</returns>
		public virtual SimpleTCLCommand write_bsdl(string file, bool? force = null, string bsd = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_bsdl [-force] [-bsd <arg>] [-quiet] [-verbose] <file>
			return
				new SimpleTCLCommand("write_bsdl")
					.Flag("force", force)
					.OptionalNamedString("bsd", bsd)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Create file(s) for programming flash memory.
		///
		///
		/// TCL Syntax: write_cfgmem [-force] -format <arg> -size <arg> [-interface <arg>] [-checksum] [-disablebitswap] [-loadbit <arg>] [-loaddata <arg>] [-quiet] [-verbose] <file>
		///
		/// This command formats a design specific configuration bitstream (.bit) file, and any specified
		/// data files, into a specified memory configuration file format to program into a flash memory
		/// device using the program_hw_cfgmem command. Supported memory configuration file formats
		/// are MCS, BIN, and HEX.
		/// TIP: When you generate a cfgmem file with write_cfgmem, by default the bits within a byte are bit-swapped,
		/// or mirrored, compared to bytes in the original input bitstream. You can disable bitswap using the -
		/// disablebitswap option as described below.
		/// The process whereby the design specific data is loaded or programmed into the Xilinx® FPGA is
		/// called configuration. The create_hw_cfgmem command defines a flash memory device used
		/// for configuring and booting the hardware device.
		/// After the hw_cfgmem object is created, and associated with the hw_device, the configuration
		/// memory can be programmed with the bitstream and other data from a memory configuration file
		/// created with the write_cfgmem command. The hw_cfgmem object is programmed using the
		/// program_hw_cfgmem command.
		/// The write_cfgmem -loadbit command loads one or more specified bitstream files into the
		/// memory configuration file, filling the available memory of the device in an upward or downward
		/// direction from a specified starting address. You can also add data files to the memory
		/// configuration file, by specifying the starting address to load the file with -loaddata.
		/// TIP: When using -loadbit and -loaddata to fill the memory of the device, you must exercise care to insure
		/// that the bitstream and data files fit into the available memory and do not overwrite each other. Any data
		/// collisions will cause the write_cfgmem command to fail with an error.
		/// The write_cfgmem command returns a transcript of its process when successful, or returns an
		/// error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1796
		/// </summary>
		/// <param name="format">(Required) Format of the file to generate</param>
		/// <param name="size">(Required) Size of memory that is being targeted in M Bytes (must be power of 2).</param>
		/// <param name="file">(Required) The name of the file to generate</param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="@interface">(Optional) Interface used to program device. Default: SMAPx8</param>
		/// <param name="checksum">
		/// (Optional)
		/// Calculate a 32-bit checksum for each file. Memory will be
		/// filed with value of 0xFF unless a different byte value is
		/// specified. Default: 0xFF
		/// </param>
		/// <param name="disablebitswap">(Optional) Disable bit swapping in a byte for bitfiles.</param>
		/// <param name="loadbit">(Optional) Load bit files into memory from given address.</param>
		/// <param name="loaddata">(Optional) Load data into memory from given address.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand write_cfgmem(string format, string size, string file, bool? force = null, string @interface = null, bool? checksum = null, bool? disablebitswap = null, string loadbit = null, string loaddata = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_cfgmem [-force] -format <arg> -size <arg> [-interface <arg>] [-checksum] [-disablebitswap] [-loadbit <arg>] [-loaddata <arg>] [-quiet] [-verbose] <file>
			return
				new SimpleTCLCommand("write_cfgmem")
					.Flag("force", force)
					.RequiredNamedString("format", format)
					.RequiredNamedString("size", size)
					.OptionalNamedString("interface", @interface)
					.Flag("checksum", checksum)
					.Flag("disablebitswap", disablebitswap)
					.OptionalNamedString("loadbit", loadbit)
					.OptionalNamedString("loaddata", loaddata)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Write a checkpoint of the current design
		///
		///
		/// TCL Syntax: write_checkpoint [-force] [-cell <arg>] [-logic_function_stripped] [-encrypt] [-key <arg>] [-incremental_synth] [-quiet] [-verbose] <file>
		///
		/// Saves the design at any point in the design process so that you can quickly import it back into the
		/// tool as needed. A design checkpoint (DCP) can contain the netlist, the constraints, and any
		/// placement and routing information from the implemented design.
		/// TIP: In the Project mode, a DCP will not have timing constraints after synthesis. The timing constraints are
		/// annotated against the design during open_run or link_design commands, or when launching an
		/// implementation run. To create a DCP with timing constraints, create the design checkpoint after opt_design,
		/// or after the implementation run completes.
		/// Use the read_checkpoint command to import a checkpoint file.
		///
		/// The following example creates the specified checkpoint file, overwriting a file of the same name
		/// if one already exists:
		/// write_checkpoint C:/Data/checkpoint1 -force
		/// Note: The tool will add the .dcp extension to the specified file name, and will overwrite an existing
		/// checkpoint1.dcp file.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1800
		/// </summary>
		/// <param name="file">
		/// (Required)
		/// Design checkpoint file Values: A filename with alphanumeric
		/// characters and .dcp extension.
		/// </param>
		/// <param name="force">(Optional) Overwrite existing checkpoint file</param>
		/// <param name="cell">(Optional) Write a checkpoint of this cell</param>
		/// <param name="logic_function_stripped">
		/// (Optional)
		/// Convert INIT strings on LUTs & RAMBs to fixed values. Note
		/// that the resulting netlist will be nonfunctional.
		/// </param>
		/// <param name="encrypt">(Optional) Encrypt unprotected modules using IEEE 1735 IP security version 2</param>
		/// <param name="key">
		/// (Optional)
		/// Key file to be used with -encrypt option; Otherwise, use
		/// Xilinx public key
		/// </param>
		/// <param name="incremental_synth">(Optional) export synthesis archive file to be used for re-using implementation.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The name of the checkpoint file</returns>
		public virtual SimpleTCLCommand write_checkpoint(string file, bool? force = null, string cell = null, bool? logic_function_stripped = null, bool? encrypt = null, string key = null, bool? incremental_synth = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_checkpoint [-force] [-cell <arg>] [-logic_function_stripped] [-encrypt] [-key <arg>] [-incremental_synth] [-quiet] [-verbose] <file>
			return
				new SimpleTCLCommand("write_checkpoint")
					.Flag("force", force)
					.OptionalNamedString("cell", cell)
					.Flag("logic_function_stripped", logic_function_stripped)
					.Flag("encrypt", encrypt)
					.OptionalNamedString("key", key)
					.Flag("incremental_synth", incremental_synth)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Export package pin and port placement information
		///
		///
		/// TCL Syntax: write_csv [-force] [-quiet] [-verbose] <file>
		///
		/// Writes package pin and port placement information into a comma separated value (CSV) file.
		/// The specific format and requirements of the CSV file are described in the Vivado Design Suite User
		/// Guide: I/O and Clock Planning (UG899).
		///
		/// The following example exports a CSV file from the current project:
		/// write_csv C:/Data/pinList.csv
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1803
		/// </summary>
		/// <param name="file">(Required) Pin Planning CSV file</param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>name of the output file</returns>
		public virtual SimpleTCLCommand write_csv(string file, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_csv [-force] [-quiet] [-verbose] <file>
			return
				new SimpleTCLCommand("write_csv")
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Write debug probes to a file
		///
		///
		/// TCL Syntax: write_debug_probes [-cell <arg>] [-no_partial_ltxfile] [-force] [-quiet] [-verbose] <file>
		///
		/// Writes a Vivado Design Suite logic analyzer probes file containing ILA debug cores and signal
		/// probes added to the current design. The debug probes data file typically has a .ltx file
		/// extension.
		/// ILA cores are added to the design using the create_debug_core command. ILA probes are
		/// added to the design using the create_debug_port command, and connected to nets in your
		/// design using the connect_debug_port command.
		/// The specific information and use of the debug probes file is described in the Vivado Design Suite
		/// User Guide: Vivado Programming and Debugging (UG908).
		///
		/// The following example write a debug probe file from the current design:
		/// write_debug_probes C:/Data/designProbes.ltx
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1805
		/// </summary>
		/// <param name="file">(Required) Debug probes file name (default extension is .ltx)</param>
		/// <param name="cell">(Optional) Hierarchical name of the Reconfigurable Partition Cell</param>
		/// <param name="no_partial_ltxfile">(Optional) Do not generate partial LTX files</param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>name of the output file</returns>
		public virtual SimpleTCLCommand write_debug_probes(string file, string cell = null, bool? no_partial_ltxfile = null, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_debug_probes [-cell <arg>] [-no_partial_ltxfile] [-force] [-quiet] [-verbose] <file>
			return
				new SimpleTCLCommand("write_debug_probes")
					.OptionalNamedString("cell", cell)
					.Flag("no_partial_ltxfile", no_partial_ltxfile)
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Export the current netlist as an EDIF file
		///
		///
		/// TCL Syntax: write_edif [-pblocks <args>] [-cell <arg>] [-force] [-security_mode <arg>] [-logic_function_stripped] [-quiet] [-verbose] <file>
		///
		/// Writes the current netlist as an EDIF file, or outputs the contents of specific Pblocks or
		/// hierarchical cells as EDIF netlist files.
		/// In the case of either the -pblocks or -cell option being used, this argument specifies a
		/// directory name where the EDIF netlist files for each Pblock or cell will be written. The EDIF
		/// netlist file will be named after the Pblock or cell. If the directory specified does not exist, the tool
		/// will return an error.
		///
		/// The following example writes an EDIF netlist file for the whole design to the specified file name:
		/// write_edif C:/Data/edifOut.edn
		/// The following example outputs an EDIF netlist for all Pblocks in the design. The files will be
		/// written to the specified directory.
		/// write_edif -pblocks [get_pblocks] C:/Data/FPGA_Design/
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1807
		/// </summary>
		/// <param name="file">(Required) Output file (directory with -pblocks or -cell)</param>
		/// <param name="pblocks">(Optional) Export netlist for these pblocks (not valid with -cell)</param>
		/// <param name="cell">(Optional) Export netlist for this cell (not valid with -pblocks)</param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="security_mode">
		/// (Optional)
		/// If set to 'all', and some of design needs encryption then
		/// whole of design will be written to a single encrypted file
		/// Default: multifile
		/// </param>
		/// <param name="logic_function_stripped">(Optional) Convert INIT strings on LUTs & RAMBs to fixed values</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>the name of the output file or directory</returns>
		public virtual SimpleTCLCommand write_edif(string file, string pblocks = null, string cell = null, bool? force = null, string security_mode = null, bool? logic_function_stripped = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_edif [-pblocks <args>] [-cell <arg>] [-force] [-security_mode <arg>] [-logic_function_stripped] [-quiet] [-verbose] <file>
			return
				new SimpleTCLCommand("write_edif")
					.OptionalNamedString("pblocks", pblocks)
					.OptionalNamedString("cell", cell)
					.Flag("force", force)
					.OptionalNamedString("security_mode", security_mode)
					.Flag("logic_function_stripped", logic_function_stripped)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Write hardware ILA data to a file
		///
		///
		/// TCL Syntax: write_hw_ila_data [-force] [-csv_file] [-vcd_file] [-legacy_csv_file] [-quiet] [-verbose] <file> [<hw_ila_data>] [<hw_ila_data>]
		///
		/// Write the ILA debug core sample data, stored in the specified hw_ila_data object, to a binary file
		/// on the disk.
		/// A hw_ila_data object is created when the hw_ila is triggered on the hw_device, or by the
		/// upload_hw_ila_data command when moving the captured data from the physical FPGA
		/// device, hw_device.
		/// The write_hw_ila_data lets you write the data of the hw_ila_data object to a binary file on
		/// the disk for later review. You can read the ILA debug core data back into the Vivado logic
		/// analyzer using the read_hw_ila_data command, which creates a new hw_ila_data object.
		/// This command returns the name of the file written, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1810
		/// </summary>
		/// <param name="file">(Required) hardware ILA data file name</param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="csv_file">(Optional) Export CSV format file only</param>
		/// <param name="vcd_file">(Optional) Export VCD format file only</param>
		/// <param name="legacy_csv_file">(Optional) Export csv file without radix information.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_ila_data">(Optional) hardware ILA data object Default: Current hardware ILA data</param>
		/// <returns>Name of the output file</returns>
		public virtual SimpleTCLCommand write_hw_ila_data(string file, bool? force = null, bool? csv_file = null, bool? vcd_file = null, bool? legacy_csv_file = null, bool? quiet = null, bool? verbose = null, string hw_ila_data = null)
		{
			// TCL Syntax: write_hw_ila_data [-force] [-csv_file] [-vcd_file] [-legacy_csv_file] [-quiet] [-verbose] <file> [<hw_ila_data>] [<hw_ila_data>]
			return
				new SimpleTCLCommand("write_hw_ila_data")
					.Flag("force", force)
					.Flag("csv_file", csv_file)
					.Flag("vcd_file", vcd_file)
					.Flag("legacy_csv_file", legacy_csv_file)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
					.OptionalString(hw_ila_data)
			;
		}
		/// <summary>
		/// Write the Xilinx Shell Archive for the current design
		///
		///
		/// TCL Syntax: write_hw_platform [-fixed] [-force] [-include_bit] [-include_emulation] [-minimal] [-quiet] [-verbose] [<file>]
		///
		/// Writes a Xilinx support archive (XSA) of the current design for use as a hardware platform.
		/// All platforms are dynamically implemented during compilation, meaning that the accelerator logic
		/// coming is implemented along with some or all of the logic contained in the hardware platform
		/// design. The XSA represents the required portion of the hardware platform. The hardware
		/// platform design used to create a XSA consists of a Vivado IP integrator subsystem design with all
		/// the required board interface IP cores configured and connected to the device I/Os. The Vivado
		/// project must also include several required XSA and PFM properties needed to define the XSA.
		/// This command reports the name of the XSA file written, or returns an error if it fails.
		///
		/// The following example writes the XSA for the current project, overwriting a XSA file of the same
		/// name if one exists:
		/// write_XSA -force C:/Data/zc702.xsa
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1813
		/// </summary>
		/// <param name="file">
		/// (Required)
		/// Device Support Archive file Values: A filename with
		/// alphanumeric characters and .xsa extension.
		/// </param>
		/// <param name="@fixed">(Optional) Write fixed Shell.</param>
		/// <param name="force">(Optional) Overwrite existing Xilinx Shell Archive file</param>
		/// <param name="include_bit">(Optional) Include bit file(s) in the Shell.</param>
		/// <param name="include_emulation">(Optional) Generate and include hardware emulation support in the Shell.</param>
		/// <param name="minimal">(Optional) Add only minimal files in the Shell.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The name of the Shell file</returns>
		public virtual SimpleTCLCommand write_hw_platform(string file, bool? @fixed = null, bool? force = null, bool? include_bit = null, bool? include_emulation = null, bool? minimal = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_hw_platform [-fixed] [-force] [-include_bit] [-include_emulation] [-minimal] [-quiet] [-verbose] [<file>]
			return
				new SimpleTCLCommand("write_hw_platform")
					.Flag("fixed", @fixed)
					.Flag("force", force)
					.Flag("include_bit", include_bit)
					.Flag("include_emulation", include_emulation)
					.Flag("minimal", minimal)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Write the unified JSON metadata file for the current design
		///
		///
		/// TCL Syntax: write_hw_platform_metadata [-quiet] [-verbose] [<file>]
		///
		/// Writes a JSON metadata file for the platform represented by the current design.
		/// This command returns the name of the JSON file written, or returns an error if it fails.
		///
		/// The following example writes the JSON file for the current project:
		/// write_hw_platform_metadata C:/Data/zc102_platform.json
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1815
		/// </summary>
		/// <param name="file">
		/// (Required)
		/// Unified JSON metadata file Values: A filename with
		/// alphanumeric characters and .json extension.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The name of the unified JSON metadata file</returns>
		public virtual SimpleTCLCommand write_hw_platform_metadata(string file, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_hw_platform_metadata [-quiet] [-verbose] [<file>]
			return
				new SimpleTCLCommand("write_hw_platform_metadata")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Write scan data to a file.
		///
		///
		/// TCL Syntax: write_hw_sio_scan [-force] [-quiet] [-verbose] <file> <hw_sio_scan>
		///
		/// Write the populated hw_sio_scan object after run_hw_sio_scan completes.
		/// To analyze the margin of a given link, it is often helpful to run a scan of the link using the
		/// specialized Eye Scan hardware of Xilinx UltraScale devices or 7 series FPGAs. The Vivado serial
		/// I/O analyzer feature lets you to create, run, and save link scans.
		/// This command saves the scan to disk after completing the scan run. The format of the file is a
		/// CSV file of values observed while running the scan.
		/// This command returns the filename of the file output, or returns an error if the command fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1817
		/// </summary>
		/// <param name="file">(Required) hardware SIO_scan file name</param>
		/// <param name="hw_sio_scan">(Required) hardware SIO scan data object</param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Name of the output file</returns>
		public virtual SimpleTCLCommand write_hw_sio_scan(string file, string hw_sio_scan, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_hw_sio_scan [-force] [-quiet] [-verbose] <file> <hw_sio_scan>
			return
				new SimpleTCLCommand("write_hw_sio_scan")
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
					.RequiredString(hw_sio_scan)
			;
		}
		/// <summary>
		/// Write sweep data to a directory.
		///
		///
		/// TCL Syntax: write_hw_sio_sweep [-force] [-quiet] [-verbose] <directory> <hw_sio_sweep>
		///
		/// Write the populated hw_sio_sweep object after run_hw_sio_sweep completes.
		/// To analyze the margin of a given link, it is often helpful to run a scan of the link using the
		/// specialized features of Xilinx UltraScale devices or 7 series FPGAs. It can also be helpful to run
		/// multiple scans on a the link with different configuration settings for the GTs. This can help you
		/// determine which settings are best for your design. The Vivado serial I/O analyzer feature enables
		/// you to define, run, and save link sweeps, or collections of link scans run across a range of values.
		/// This command saves the specified link sweep object to disk after it has been populated by the
		/// run_hw_sio_sweep command.
		/// This command returns the name of the directory created, or returns an error if the command
		/// fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1819
		/// </summary>
		/// <param name="directory">(Required) hardware SIO_sweep directory path</param>
		/// <param name="hw_sio_sweep">(Required) hardware SIO sweep data object</param>
		/// <param name="force">(Optional) Overwrite existing directory</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Name of the output directory</returns>
		public virtual SimpleTCLCommand write_hw_sio_sweep(string directory, string hw_sio_sweep, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_hw_sio_sweep [-force] [-quiet] [-verbose] <directory> <hw_sio_sweep>
			return
				new SimpleTCLCommand("write_hw_sio_sweep")
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(directory)
					.RequiredString(hw_sio_sweep)
			;
		}
		/// <summary>
		/// Generate SVF file for current_hw_target
		///
		///
		/// TCL Syntax: write_hw_svf [-force] [-quiet] [-verbose] <file_name>
		///
		/// The Vivado hardware manager supports programming of hardware devices through the use of
		/// Serial Vector Format (SVF) files. SVF files are ASCII files that contain both programming
		/// instructions and configuration data. These files are used by ATE machines and embedded
		/// controllers to perform boundary-scan operations. The SVF file captures the JTAG commands
		/// needed to program the bitstream directly into a Xilinx device, or indirectly into a flash memory
		/// device. The SVF file can be written using the write_hw_svf command, or applied to an open
		/// hw_target through the execute_hw_svf command. Refer to the Vivado Design Suite User Guide:
		/// Programming and Debugging (UG908) for more information.
		/// The specific process for creating the hw_svf file is:
		/// 1. Create an SVF target using create_hw_target.
		/// 2. Open the SVF target.
		/// 3. Create one or more devices on the SVF target using create_hw_device.
		/// 4. Program the devices using commands like program_hw_devices.
		/// 5. Write the SVF file of operation commands using write_hw_svf.
		/// In programming the hw_devices in Step 4 above, the SVF commands for the operations are
		/// cached to a temporary file. The write_hw_svf command saves the cache by giving it a file
		/// name and moving it to the specified file path.
		/// Note: Because this command is essentially flushing the cached SVF commands, after you use the
		/// write_hw_svf command, the cache is cleared, and restarted to capture any new device commands.
		/// This command returns a message indicating success, or returns an error if it fails.
		///
		/// The following example writes an SVF file to specified location:
		/// program_hw_devices [lindex [get_hw_devices] 0]
		/// write_hw_svf C:/Data/k7_design.svf
		/// This example demonstrates the correct order of creating multiple devices on an SVF target. An
		/// SVF target is created and opened, then a Xilinx device, a user part, and a second Xilinx device are
		/// created on the current target. The bitstream properties are defined for the two Xilinx devices, the
		/// devices are programmed, and an SVF file is written:
		/// open_hw
		/// connect_hw_server
		/// create_hw_target my_svf_target
		/// open_hw_target
		/// create_hw_device -part xc7k325t
		/// create_hw_device -idcode 01234567 -irlength 8 -mask ffffffff -part
		/// userPart1
		/// create_hw_device -part xcku9p
		/// set_property PROGRAM.FILE {C:/Data/k7_design.bit} [lindex [get_hw_devices]
		/// 0]
		/// set_property PROGRAM.FILE {C:/Data/ku_design.bit} [lindex [get_hw_devices]
		/// 2]
		/// program_hw_devices [lindex [get_hw_devices] 0]
		/// program_hw_devices [lindex [get_hw_devices] 2]
		/// write_hw_svf C:/Data/myDesign.svf
		/// The following example demonstrates creating a device on an SVF target, creating a configuration
		/// memory object (hw_cfgmem) associated with that device, programming the device and
		/// configuration memory, and saving that command sequence to an SVF file:
		/// create_hw_target my_svf_target
		/// open_hw_target
		/// set device [create_hw_device -part xc7k325t]
		/// set_property PROGRAM.FILE {C:/Data/k7_design.bit} $device
		/// create_hw_cfgmem -hw_device $device -mem_dev [lindex \
		/// [get_cfgmem_parts {28f00am29ew-bpi-x16}] 0]
		/// set cfgMem [current_hw_cfgmem]
		/// set_property PROGRAM.ADDRESS_RANGE {use_file} $cfgMem
		/// set_property PROGRAM.BLANK_CHECK 0 $cfgMem
		/// set_property PROGRAM.BPI_RS_PINS {none} $cfgMem
		/// set_property PROGRAM.CFG_PROGRAM 1 $cfgMem
		/// set_property PROGRAM.CHECKSUM 0 $cfgMem
		/// set_property PROGRAM.ERASE 1 $cfgMem
		/// set_property PROGRAM.UNUSED_PIN_TERMINATION {pull-none} $cfgMem
		/// set_property PROGRAM.VERIFY 1 $cfgMem
		/// set_property PROGRAM.FILES [list {C:/data/flash.mcs} ] $cfgMem
		/// create_hw_bitstream -hw_device $device [get_property \
		/// PROGRAM.HW_CFGMEM_BITFILE $device]
		/// program_hw_devices $device
		/// program_hw_cfgmem -hw_cfgmem $cfgMem
		/// write_hw_svf C:/Data/myDesign.svf
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1821
		/// </summary>
		/// <param name="file_name">(Required) SVF filename</param>
		/// <param name="force">(Optional) overwrite svf file if it exists</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand write_hw_svf(string file_name, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_hw_svf [-force] [-quiet] [-verbose] <file_name>
			return
				new SimpleTCLCommand("write_hw_svf")
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file_name)
			;
		}
		/// <summary>
		/// Writes hardware definition for use in the software development
		///
		///
		/// TCL Syntax: write_hwdef [-force] [-quiet] [-verbose] <file>
		///
		/// Writes a hardware definition (.hwdef) file for use in the software development tools (SDK).
		/// The write_hwdef command is intended to simplify the movement of designs from the Vivado
		/// Design Suite to software development in SDK. This command is run automatically by the Vivado
		/// Design Suite when generating the output products for a top-level design that includes a block
		/// design with an embedded processor like MicroBlaze, or Zynq-7000 SoC. Block designs are
		/// created in the IP integrator of the Vivado Design Suite with the create_bd_design command.
		/// The write_hwdef command is run after place_design and creates a hardware container file
		/// with .hwdef extension. The container file includes device metadata and hardware design files.
		/// The write_hwdef command returns nothing if successful, or an error if the command fails.
		///
		/// The following example creates the specified hardware definition file:
		/// write_hwdef -force C:/Data/ug940/lab1/zynq_design.hdf
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1824
		/// </summary>
		/// <param name="file">
		/// (Required)
		/// Hardware definition file (Values: A filename with
		/// alphanumeric characters and .hwdef extention.)
		/// </param>
		/// <param name="force">(Optional) Overwrites the existing hardware definition file</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>success/failure status of applied action.</returns>
		public virtual SimpleTCLCommand write_hwdef(string file, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_hwdef [-force] [-quiet] [-verbose] <file>
			return
				new SimpleTCLCommand("write_hwdef")
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Write IBIS models for current floorplan
		///
		///
		/// TCL Syntax: write_ibis [-force] [-allmodels] [-nopin] [-no_pin_mapping] [-truncate <arg>] [-component_name <arg>] [-ibs <arg>] [-pkg <arg>] [-quiet] [-verbose] <file>
		///
		/// Writes the IBIS models for the target device in the current design. The netlist and
		/// implementation details from the design are combined with the per-pin parasitic package
		/// information to create a custom IBIS model for the design.
		/// Because the write_ibis command incorporates design information into the IBIS Model, you
		/// must have an RTL, Netlist, or Implemented Design open when running this command.
		///
		/// The following example exports all buffer models for the target device, eliminates truncation of
		/// signal names, and specifies the file name and path to write:
		/// write_ibis -allmodels -truncate 0 C:/Data/FPGA_Design/ibisOut.txt
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1826
		/// </summary>
		/// <param name="file">(Required) Output file name. The .ibs extension is optional.</param>
		/// <param name="force">(Optional) Overwrite existing .ibs file</param>
		/// <param name="allmodels">
		/// (Optional)
		/// Include all available buffer models for this architecture. By
		/// default, only buffer models used by the floorplan are
		/// included.
		/// </param>
		/// <param name="nopin">
		/// (Optional)
		/// Disable inclusion of the per-pin modeling of the package
		/// (path from the die pad to the package pin). Package is
		/// reduced to a single RLC transmission line model applied to
		/// all pins and defined in the [Package] section. Default: This
		/// option is not set. IBISWriter includes per-pin modeling of
		/// the package as RLC matrices in the [Define Package Model]
		/// section if this data is available.
		/// </param>
		/// <param name="no_pin_mapping">
		/// (Optional)
		/// Do not output the [Pin Mapping] section for ultrascale,
		/// ultrascale plus, and versal.
		/// </param>
		/// <param name="truncate">
		/// (Optional)
		/// Maximum length for a signal name in the output file. Names
		/// longer than this will be truncated. This property can be set
		/// to truncate signal name length to 20, 40, or 0 (unlimited).
		/// Default: Truncate signal name length to 40 characters in
		/// accordance with the IBIS version 4.2 specification. Default:
		/// 40
		/// </param>
		/// <param name="component_name">
		/// (Optional)
		/// Specify a new component name for use in multiple FPGA
		/// designs to replace the default.
		/// </param>
		/// <param name="ibs">(Optional) Specify an updated generic IBIS models file.</param>
		/// <param name="pkg">(Optional) Specify an updated per pin parasitic package data file.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>name of the output file</returns>
		public virtual SimpleTCLCommand write_ibis(string file, bool? force = null, bool? allmodels = null, bool? nopin = null, bool? no_pin_mapping = null, string truncate = null, string component_name = null, string ibs = null, string pkg = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_ibis [-force] [-allmodels] [-nopin] [-no_pin_mapping] [-truncate <arg>] [-component_name <arg>] [-ibs <arg>] [-pkg <arg>] [-quiet] [-verbose] <file>
			return
				new SimpleTCLCommand("write_ibis")
					.Flag("force", force)
					.Flag("allmodels", allmodels)
					.Flag("nopin", nopin)
					.Flag("no_pin_mapping", no_pin_mapping)
					.OptionalNamedString("truncate", truncate)
					.OptionalNamedString("component_name", component_name)
					.OptionalNamedString("ibs", ibs)
					.OptionalNamedString("pkg", pkg)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Write file with inferred xdc timing constraints
		///
		///
		/// TCL Syntax: write_inferred_xdc [-force] [-all] [-append] [-async_clocks] [-all_async_reg] [-clock_groups] [-clocks] [-excl_clocks] [-exceptions] [-io_constraints] [-merge_existing_constraints] [-name <arg>] [-quiet] [-verbose] [<file>]
		///
		/// You can use the write_inferred_xdc to find constraints that should be defined in the open
		/// synthesized or implemented design. Write timing constraints that are automatically generated by
		/// the Vivado timing engine, rather than defined in an existing XDC file and added to the design.
		/// Run write_inferred_xdc -clocks first to define suggested clock and generated clock
		/// constraints. The suggested clock constraints will be defined with a period of 1 ns. You can edit
		/// the recommended constraints to create clocks and generated clocks with the required clock
		/// period to meet the needs of your design.
		/// You can add the edited constraints file into the design using read_xdc, or add_files, and
		/// update_timing.
		/// You may need to run the write_inferred_xdc command multiple times, using various
		/// options like -clock_groups or -async_clocks, to capture all inferred timing constraints
		/// from the fully clocked design. You can use an iterative process of writing and sourcing the
		/// inferred clocked constraints, and then writing and sourcing additional constraint files to capture
		/// all inferred constraints. See the example below for more information.
		/// This command returns a transcript of the process when successful, or returns an error if it fails.
		///
		/// The following example writes the inferred clock constraints in the current design:
		/// write_inferred_xdc -clocks C:/Data/design1_inferred_clocks.xdc
		/// The write_inferred_xdc command may need to be run multiple times to capture all the
		/// inferred constraints, as is shown in this example:
		/// write_inferred_xdc -clocks clocks.xdc
		/// source clocks.xdc
		/// write_inferred_xdc -all all.xdc
		/// source all.xdc
		/// write_inferred_xdc -async_clocks async.xdc
		/// source async.xdc
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1829
		/// </summary>
		/// <param name="file">(Required) Filename to write constraints into</param>
		/// <param name="force">(Optional) Overwrite existing file.</param>
		/// <param name="all">
		/// (Optional)
		/// Generate all constraints except missing clocks which are
		/// generated with the -clocks option
		/// </param>
		/// <param name="append">(Optional) Append the constraints to file, don't overwrite the constraints file</param>
		/// <param name="async_clocks">(Optional) Find asynchronous clock groups</param>
		/// <param name="all_async_reg">
		/// (Optional)
		/// Find the missing ASYNC_REG property for safe and unsafe
		/// Clock Domain Crossing
		/// </param>
		/// <param name="clock_groups">
		/// (Optional)
		/// Find asynchronous and exclusive clock groups, equivalent to
		/// options -async_clocks -excl_clocks
		/// </param>
		/// <param name="clocks">(Optional) Find missing clock definitions</param>
		/// <param name="excl_clocks">(Optional) Find logically and physically exclusive clock groups</param>
		/// <param name="exceptions">(Optional) Find missing exceptions</param>
		/// <param name="io_constraints">(Optional) Find missing input and output delays</param>
		/// <param name="merge_existing_constraints">(Optional) Add existing user defined constraints to the generated constraints</param>
		/// <param name="name">
		/// (Optional)
		/// Start constraints wizard in a GUI panel with this name. Do
		/// other command options can be combined with -name.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand write_inferred_xdc(string file, bool? force = null, bool? all = null, bool? append = null, bool? async_clocks = null, bool? all_async_reg = null, bool? clock_groups = null, bool? clocks = null, bool? excl_clocks = null, bool? exceptions = null, bool? io_constraints = null, bool? merge_existing_constraints = null, string name = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_inferred_xdc [-force] [-all] [-append] [-async_clocks] [-all_async_reg] [-clock_groups] [-clocks] [-excl_clocks] [-exceptions] [-io_constraints] [-merge_existing_constraints] [-name <arg>] [-quiet] [-verbose] [<file>]
			return
				new SimpleTCLCommand("write_inferred_xdc")
					.Flag("force", force)
					.Flag("all", all)
					.Flag("append", append)
					.Flag("async_clocks", async_clocks)
					.Flag("all_async_reg", all_async_reg)
					.Flag("clock_groups", clock_groups)
					.Flag("clocks", clocks)
					.Flag("excl_clocks", excl_clocks)
					.Flag("exceptions", exceptions)
					.Flag("io_constraints", io_constraints)
					.Flag("merge_existing_constraints", merge_existing_constraints)
					.OptionalNamedString("name", name)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Write a tcl script on disk that will recreate a given IP.
		///
		///
		/// TCL Syntax: write_ip_tcl [-force] [-no_ip_version] [-ip_name <arg>] [-show_defaults] [-multiple_files] [-quiet] [-verbose] [<objects>] [<tcl_filename>...]
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1833
		/// </summary>
		/// <param name="force">(Optional) Flag to overwrite existing file.</param>
		/// <param name="no_ip_version">
		/// (Optional)
		/// Flag to not include the IP version in the IP VLNV in create_ip
		/// commands. NOTE - this may have implications if there are
		/// major IP version changes.
		/// </param>
		/// <param name="ip_name">
		/// (Optional)
		/// Set the name of the IP. This argument is not supported for
		/// multiple IP.
		/// </param>
		/// <param name="show_defaults">(Optional) Add a comment containing the default parameter values of the IP.</param>
		/// <param name="multiple_files">(Optional) Flag to create a .tcl file for each IP supplied as an argument</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">
		/// (Optional)
		/// IP(s) to be written to disk Values: IP instance(s) as returned
		/// by 'get_ips <instance name>'
		/// </param>
		/// <param name="tcl_filename">
		/// (Optional)
		/// File path to the exported tcl file. If the path is a directory and
		/// multiple IP are given as an argument, a file for each IP will
		/// be created. Default: ./
		/// </param>
		/// <returns>IP TCL file</returns>
		public virtual SimpleTCLCommand write_ip_tcl(bool? force = null, bool? no_ip_version = null, string ip_name = null, bool? show_defaults = null, bool? multiple_files = null, bool? quiet = null, bool? verbose = null, string objects = null, string tcl_filename = null)
		{
			// TCL Syntax: write_ip_tcl [-force] [-no_ip_version] [-ip_name <arg>] [-show_defaults] [-multiple_files] [-quiet] [-verbose] [<objects>] [<tcl_filename>...]
			return
				new SimpleTCLCommand("write_ip_tcl")
					.Flag("force", force)
					.Flag("no_ip_version", no_ip_version)
					.OptionalNamedString("ip_name", ip_name)
					.Flag("show_defaults", show_defaults)
					.Flag("multiple_files", multiple_files)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.OptionalString(objects)
					.OptionalString(tcl_filename)
			;
		}
		/// <summary>
		/// Write iPhysOpt script.
		///
		///
		/// TCL Syntax: write_iphys_opt_tcl [-place] [-binary] [-quiet] [-verbose] [<output>]
		///
		/// Because physical optimization requires timing data that is only available after placement, the
		/// phys_opt_design command cannot be run prior to placement. However, the interactive
		/// physical optimization feature, or iphys_opt_design, lets you write out the physical
		/// optimizations performed on the post-placed design, and then apply those optimizations to the
		/// design netlist prior to placement. Refer to the Vivado Design Suite User Guide: Implementation
		/// (UG904) for more information on interactive physical optimization.
		/// Interactive physical optimization can be used in two ways:
		/// • Applying post-placement physical optimizations to the pre-placement netlist to improve the
		/// overall placement result and improve design performance.
		/// • Saving the physical optimizations in a Tcl script to be repeated as needed.
		/// The write_iphys_opt_tcl command can only be run after placement, on a design that has
		/// had actual physical optimizations performed.
		/// TIP: You can use the report_phys_opt command to report the physical optimizations that have been
		/// performed on the design.
		/// The output is a Tcl script file with a sequence of iphys_opt_design commands listing the
		/// specific optimizations performed by the phys_opt_design command. The iphys_opt Tcl
		/// script can be edited to change the specific optimizations performed. The Tcl script provides a
		/// history of the physical optimizations performed on the design after placement, marked by date
		/// and history.
		/// IMPORTANT! The iphys_opt Tcl script contains the specific optimizations performed by the
		/// phys_opt_design command, but does not include placement and routing changes or results.
		/// This command returns nothing if successful, or returns an error if it fails.
		///
		/// The following example writes the physical optimizations that have been performed in the current
		/// design to the specified Tcl script:
		/// write_iphys_opt_tcl C:/Data/myDesign_physopt.tcl
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1834
		/// </summary>
		/// <param name="output">(Required) tcl file containing iPhysOpt script</param>
		/// <param name="place">(Optional) write out placement information</param>
		/// <param name="binary">(Optional) write out in binary format</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand write_iphys_opt_tcl(string output, bool? place = null, bool? binary = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_iphys_opt_tcl [-place] [-binary] [-quiet] [-verbose] [<output>]
			return
				new SimpleTCLCommand("write_iphys_opt_tcl")
					.Flag("place", place)
					.Flag("binary", binary)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(output)
			;
		}
		/// <summary>
		/// Write the Memory Map Info of the design to a .mmi file.
		///
		///
		/// TCL Syntax: write_mem_info [-force] [-quiet] [-verbose] <file>
		///
		/// This command writes a memory information (MMI) file defining the BRAM placement and
		/// address ranges to create a memory map of the design.
		/// IMPORTANT! write_mem_info requires an open implemented design so that the memory information
		/// includes the BRAM placement data, as well as the address ranges, required for proper programming.
		/// The memory map information (MMI) file, written by the write_mem_info command, is a text
		/// file that describes how individual Block RAMs on the Xilinx device are grouped together to form
		/// a contiguous address space called an Address Block.
		/// The mem info file (MMI) contains memory mapping information similar to the Block Memory
		/// Map (BMM) file, but in a format that can be read by the updatemem command to merge with a
		/// bitstream (BIT) file. The updatemem command uses the MMI file to identify the physical BRAM
		/// resource that maps to a specific address range. Refer to the Vivado Design Suite User Guide:
		/// Embedded Processor Hardware Design (UG898) for more information on running updatemem.
		/// This command returns the name of the file created, or returns an error if it fails.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1836
		/// </summary>
		/// <param name="file">
		/// (Required)
		/// Design mem info file Values: A filename with alphanumeric
		/// characters and .mmi extension.
		/// </param>
		/// <param name="force">(Optional) Overwrite existing mem info xml file</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The name of the .mmi file</returns>
		public virtual SimpleTCLCommand write_mem_info(string file, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_mem_info [-force] [-quiet] [-verbose] <file>
			return
				new SimpleTCLCommand("write_mem_info")
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Save peripheral component to the disk.
		///
		///
		/// TCL Syntax: write_peripheral [-quiet] [-verbose] <peripheral>
		///
		/// Write the specified AXI peripheral object to disk in the form of the component.xml file. The
		/// peripheral is written to the repository location specified by the create_peripheral
		/// command, under the name specified at creation.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1838
		/// </summary>
		/// <param name="peripheral">(Required) Peripheral object</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand write_peripheral(string peripheral, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_peripheral [-quiet] [-verbose] <peripheral>
			return
				new SimpleTCLCommand("write_peripheral")
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(peripheral)
			;
		}
		/// <summary>
		/// (User-written application) Export Tcl script for re-creating the current project
		///
		///
		/// TCL Syntax: write_project_tcl [-paths_relative_to <arg>] [-origin_dir_override <arg>] [-target_proj_dir <arg>] [-force] [-all_properties] [-no_copy_sources] [-no_ip_version] [-absolute_path] [-dump_project_info] [-use_bd_files] [-internal] [-quiet] [-verbose] <file>
		///
		/// Creates a Tcl script to recreate the current project.
		/// The generated script will contain the Tcl commands for creating the project, setting the project
		/// type, creating filesets, adding/importing source files, defining runs and run properties.
		/// IMPORTANT! The new project will be created in the current working directory (CWD) where the generated Tcl
		/// script is sourced from. The script written out by write_project_tcl should be sourced in the same
		/// directory from which it was created. If you source the script from a different directory, you should first set the
		/// <origin_dir_loc> variable in Tcl shell to this alternate directory, or edit the script to define the <origin_dir>
		/// variable in the script in order to maintain the relative path between the CWD and the source files referenced in
		/// the script.
		/// This Tcl project script and the various design sources can be stored in a version control system
		/// for source file management and project archival.
		///
		/// The following example exports Tcl script named recreate.tcl for the current project:
		/// write_project_tcl recreate.tcl
		/// The following example exports a Tcl script named recreate.tcl for the current project in
		/// the ./script directory and specifies the /tmp/test directory for the create_project
		/// command. When the recreate.tcl script is run in the Vivado Tcl shell, the project will be re￾created in /tmp/test directory:
		/// write_project_tcl -target_proj_dir "/tmp/test" ./script/recreate.tcl
		/// The following command exports Tcl script for the current project and writes all the properties,
		/// both default or non-default values:
		/// write_project_tcl -all_properties recreate.tcl
		/// The following command exports Tcl script for the current project and adds files that are local in
		/// this project. The recreated project will reference these files:
		/// write_project_tcl -no_copy_sources -use_bd_files recreate.tcl
		/// IMPORTANT! The -use_bd_files switch is required for use with -no_copy_sources in designs with
		/// block diagrams.
		/// The following command exports recreate.tcl script for the current project in the current
		/// working directory, creates a new project in ./my_test directory, prints the list of files in the
		/// new project, prints the current project settings and then closes the newly created project:
		/// open_project ./test/test.xpr
		/// write_project_tcl -force recreate.tcl
		/// close_project
		/// file mkdir my_test
		/// cd my_test
		/// source ../recreate.tcl
		/// get_files -of_objects [get_filesets sources_1]
		/// report_property [current_project]
		/// close_project
		/// The following command creates a new project named bft_test, adds files to the project, sets the
		/// fileset property, exports a tcl script named bft.tcl in the current working directory, creates a
		/// new project in ./my_bft directory, prints the list of files in the new project (test_1.v and
		/// test_2.v), prints the "verilog_define" property value and then closes the newly created project:
		/// create_project bft_test ./bft_test
		/// add_files test_1.v
		/// add_files test_2.v
		/// set_property verilog_define {a=10} [get_filesets sources_1]
		/// write_project_tcl -force bft.tcl
		/// close_project
		/// file mkdir my_bft
		/// cd my_bft
		/// source ../bft.tcl
		/// get_files -of_objects [get_filesets sources_1]
		/// get_property verilog_define [get_filesets sources_1]
		/// close_project
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1840
		/// </summary>
		/// <param name="file">(Required) Name of the tcl script file to generate</param>
		/// <param name="paths_relative_to">
		/// (Optional)
		/// Override the reference directory variable for source file
		/// relative paths Default: Script output directory path
		/// </param>
		/// <param name="origin_dir_override">
		/// (Optional)
		/// Set 'origin_dir' directory variable to the specified value
		/// (Default is value specified with the -paths_relative_to switch)
		/// Default: None
		/// </param>
		/// <param name="target_proj_dir">
		/// (Optional)
		/// Directory where the project needs to be restored Default:
		/// Current project directory path
		/// </param>
		/// <param name="force">(Optional) Overwrite existing tcl script file</param>
		/// <param name="all_properties">(Optional) Write all properties (default & non-default) for the project object(s)</param>
		/// <param name="no_copy_sources">
		/// (Optional)
		/// Do not import sources even if they were local in the original
		/// project Default: 1
		/// </param>
		/// <param name="no_ip_version">
		/// (Optional)
		/// Flag to not include the IP version as part of the IP VLNV in
		/// create_bd_cell commands. Default: 1
		/// </param>
		/// <param name="absolute_path">(Optional) Make all file paths absolute wrt the original project directory</param>
		/// <param name="dump_project_info">(Optional) Write object values</param>
		/// <param name="use_bd_files">(Optional) Use BD sources directly instead of writing out procs to create them</param>
		/// <param name="@internal">(Optional) Print basic header information in the generated tcl script</param>
		/// <param name="quiet">(Optional) Execute the command quietly, returning no messages from the command.</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>true (0) if success, false (1) otherwise</returns>
		public virtual SimpleTCLCommand write_project_tcl(string file, string paths_relative_to = null, string origin_dir_override = null, string target_proj_dir = null, bool? force = null, bool? all_properties = null, bool? no_copy_sources = null, bool? no_ip_version = null, bool? absolute_path = null, bool? dump_project_info = null, bool? use_bd_files = null, bool? @internal = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_project_tcl [-paths_relative_to <arg>] [-origin_dir_override <arg>] [-target_proj_dir <arg>] [-force] [-all_properties] [-no_copy_sources] [-no_ip_version] [-absolute_path] [-dump_project_info] [-use_bd_files] [-internal] [-quiet] [-verbose] <file>
			return
				new SimpleTCLCommand("write_project_tcl")
					.OptionalNamedString("paths_relative_to", paths_relative_to)
					.OptionalNamedString("origin_dir_override", origin_dir_override)
					.OptionalNamedString("target_proj_dir", target_proj_dir)
					.Flag("force", force)
					.Flag("all_properties", all_properties)
					.Flag("no_copy_sources", no_copy_sources)
					.Flag("no_ip_version", no_ip_version)
					.Flag("absolute_path", absolute_path)
					.Flag("dump_project_info", dump_project_info)
					.Flag("use_bd_files", use_bd_files)
					.Flag("internal", @internal)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Write QoR Suggestions to the given file
		///
		///
		/// TCL Syntax: write_qor_suggestions [-strategy_dir <arg>] [-tcl_output_dir <arg>] [-force] [-of_objects <args>] [-quiet] [-verbose] <file>
		///
		/// Write the QoR suggestions generated by the report_qor_suggestions command. You can
		/// combine the suggestions from the latest report with suggestions read into the design with
		/// read_qor_suggestions so that you can manage all suggestions in a single RQS file.
		/// To write out specific QoR suggestions, use the -of_objects option. When this is not specified, all
		/// suggestions will be written.
		/// The recommended way to manage suggestions is using RQS objects. However, it is possible to
		/// view and execute the commands using TCL. Specifying the -tcl_output_dir option writes Tcl
		/// scripts for the automated suggestions that are property based.
		/// Implementation strategies that use machine learning to analyze the design can be generated
		/// running report_qor_suggestions. When specifying the -strategy_dir option. Multiple
		/// TCL files and one RQS file will be written for each strategy. The TCL files aid integration into
		/// project or non project flows. The main RQS file should not be used as the suggestions are
		/// contained in the run specific files along with strategy information.
		/// This command returns the name of the output file created when successful, or returns an error if
		/// it fails.
		///
		/// This example reports QoR suggestions, then writes them to the specified file.
		/// report_qor_suggestions
		/// write_qor_suggestions C:/Data/qor_results.rqs
		/// This example reports QoR suggestions, then writes them to the specified file.
		/// report_qor_suggestions
		/// write_qor_suggestions -strategy_dir C:/Data/strategy_dir C:/Data/
		/// qor_suggestions.rqs
		/// In project mode you must then source the TCL script generated for project mode. There is one
		/// script per run to source. Examples of non project scripts are also given.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1845
		/// </summary>
		/// <param name="file">
		/// (Required)
		/// QoR suggestions file Values: A filename with alphanumeric
		/// characters and .rqs extension.
		/// </param>
		/// <param name="strategy_dir">
		/// (Optional)
		/// Directory to create Strategy RQS & TCL files Values: If
		/// passed a directory path, for each strategy suggested one set
		/// of RQS and TCL files will be generated.
		/// </param>
		/// <param name="tcl_output_dir">
		/// (Optional)
		/// Directory to create TCL files Values: TCL files for the QoR
		/// suggestions will be generated in the provided directory.
		/// </param>
		/// <param name="force">(Optional) Overwrite existing suggestions file</param>
		/// <param name="of_objects">(Optional) List of QoR suggestion objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand write_qor_suggestions(string file, string strategy_dir = null, string tcl_output_dir = null, bool? force = null, string of_objects = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_qor_suggestions [-strategy_dir <arg>] [-tcl_output_dir <arg>] [-force] [-of_objects <args>] [-quiet] [-verbose] <file>
			return
				new SimpleTCLCommand("write_qor_suggestions")
					.OptionalNamedString("strategy_dir", strategy_dir)
					.OptionalNamedString("tcl_output_dir", tcl_output_dir)
					.Flag("force", force)
					.OptionalNamedString("of_objects", of_objects)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Export schematic
		///
		///
		/// TCL Syntax: write_schematic [-force] [-format <arg>] [-orientation <arg>] [-scope <arg>] [-name <arg>] [-quiet] [-verbose] <file>
		///
		/// Output the currently opened, or specified Schematic window in the Vivado IDE to a file.
		/// The file can be written as a native ASCII file that can be read back into the Vivado IDE using the
		/// read_schematic command, or can be written as a PDF or SVG file for use outside of the Vivado
		/// Design Suite. This can be useful when documenting IP cores from the IP packager flow, or from
		/// the Vivado IP integrator.
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1848
		/// </summary>
		/// <param name="file">(Required) Output file</param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="format">
		/// (Optional)
		/// Values: native or pdf. read_schematic can be used to view
		/// native format. Default: native
		/// </param>
		/// <param name="orientation">(Optional) Values: landscape or portrait</param>
		/// <param name="scope">(Optional) Values: current_page, visible or all Default: current_page</param>
		/// <param name="name">(Optional) Schematic window title</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>name of the output file</returns>
		public virtual SimpleTCLCommand write_schematic(string file, bool? force = null, string format = null, string orientation = null, string scope = null, string name = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_schematic [-force] [-format <arg>] [-orientation <arg>] [-scope <arg>] [-name <arg>] [-quiet] [-verbose] <file>
			return
				new SimpleTCLCommand("write_schematic")
					.Flag("force", force)
					.OptionalNamedString("format", format)
					.OptionalNamedString("orientation", orientation)
					.OptionalNamedString("scope", scope)
					.OptionalNamedString("name", name)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// write_sdf command generates flat sdf delay files for event simulation
		///
		///
		/// TCL Syntax: write_sdf [-process_corner <arg>] [-cell <arg>] [-rename_top <arg>] [-force] [-mode <arg>] [-gzip] [-quiet] [-verbose] <file>
		///
		/// Writes the timing delays for cells in the design to a Standard Delay Format (SDF) file.
		/// The output SDF file can be used by the write_verilog command to create Verilog netlists for
		/// static timing analysis and timing simulation.
		///
		/// The following example writes an SDF file to the specified directory:
		/// write_sdf C:/Data/FPGA_Design/designOut.sdf
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1851
		/// </summary>
		/// <param name="file">(Required) File name</param>
		/// <param name="process_corner">
		/// (Optional)
		/// Specify process corner for which SDF delays are required;
		/// Values: slow, fast Default: slow
		/// </param>
		/// <param name="cell">(Optional) Root of the design to write, e.g. des.subblk.cpu Default: whole design</param>
		/// <param name="rename_top">
		/// (Optional)
		/// Replace name of top module with custom name e.g. netlist
		/// Default: new top module name
		/// </param>
		/// <param name="force">(Optional) Overwrite existing SDF file</param>
		/// <param name="mode">
		/// (Optional)
		/// Specify sta (Static Timing Analysis) or timesim (Timing
		/// Simulation) mode for SDF Default: timesim
		/// </param>
		/// <param name="gzip">(Optional) write gzipped SDF</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand write_sdf(string file, string process_corner = null, string cell = null, string rename_top = null, bool? force = null, string mode = null, bool? gzip = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_sdf [-process_corner <arg>] [-cell <arg>] [-rename_top <arg>] [-force] [-mode <arg>] [-gzip] [-quiet] [-verbose] <file>
			return
				new SimpleTCLCommand("write_sdf")
					.OptionalNamedString("process_corner", process_corner)
					.OptionalNamedString("cell", cell)
					.OptionalNamedString("rename_top", rename_top)
					.Flag("force", force)
					.OptionalNamedString("mode", mode)
					.Flag("gzip", gzip)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Export the current netlist in Verilog format
		///
		///
		/// TCL Syntax: write_verilog [-cell <arg>] [-mode <arg>] [-lib] [-port_diff_buffers] [-write_all_overrides] [-keep_vcc_gnd] [-rename_top <arg>] [-sdf_anno <arg>] [-sdf_file <arg>] [-force] [-include_xilinx_libs] [-logic_function_stripped] [-quiet] [-verbose] <file>
		///
		/// Write a Verilog netlist of the current design or from a specific cell of the design to the specified
		/// file or directory. The output is a IEEE 1364-2001 compliant Verilog HDL file that contains netlist
		/// information obtained from the input design files.
		/// You can output a complete netlist of the design or specific cell, or output a port list for the
		/// design, or a Verilog netlist for simulation or static timing analysis.
		///
		/// The following example writes a Verilog simulation netlist file for the whole design to the specified
		/// file and path:
		/// write_verilog C:/Data/my_verilog.v
		/// In the following example, because the -mode timesim and -sdf_anno options are specified,
		/// the $sdf_annotate statement will be added to the Verilog netlist. However, since the -
		/// sdf_file option is not specified, the SDF file is assumed to have the same name as the Verilog
		/// output file, with an .sdf file extension:
		/// write_verilog C:/Data/my_verilog.net -mode timesim -sdf_anno true
		/// Note: The SDF filename written to the $sdf_annotate statement will be my_verilog.sdf.
		/// In the following example, the functional simulation mode is specified, the option to keep VCC
		/// and GND primitives in the output simulation netlist is enabled, and the output file is specified:
		/// write_verilog -mode funcsim -keep_vcc_gnd out.v
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1853
		/// </summary>
		/// <param name="file">(Required) Which file to write</param>
		/// <param name="cell">(Optional) Root of the design to write, e.g. des.subblk.cpu Default: whole design</param>
		/// <param name="mode">
		/// (Optional)
		/// Values: design, pin_planning, synth_stub, sta, funcsim,
		/// timesim Default: design
		/// </param>
		/// <param name="lib">(Optional) Write each library into a separate file</param>
		/// <param name="port_diff_buffers">(Optional) Output differential buffers when writing in -port mode</param>
		/// <param name="write_all_overrides">
		/// (Optional)
		/// Write parameter overrides on Xilinx primitives even if the
		/// override value is the same as the default value
		/// </param>
		/// <param name="keep_vcc_gnd">
		/// (Optional)
		/// Don't replace VCC/GND instances by literal constants on
		/// load terminals. For simulation modes only.
		/// </param>
		/// <param name="rename_top">
		/// (Optional)
		/// Replace top module name with custom name e.g. netlist
		/// Default: new top module name
		/// </param>
		/// <param name="sdf_anno">(Optional) Specify if sdf_annotate system task statement is generated</param>
		/// <param name="sdf_file">(Optional) Full path to sdf file location Default: <file>.sdf</param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="include_xilinx_libs">
		/// (Optional)
		/// Include simulation models directly in netlist instead of
		/// linking to library
		/// </param>
		/// <param name="logic_function_stripped">
		/// (Optional)
		/// Convert INIT strings on LUTs & RAMBs to fixed values.
		/// Resulting netlist will not behave correctly.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>the name of the output file or directory</returns>
		public virtual SimpleTCLCommand write_verilog(string file, string cell = null, string mode = null, bool? lib = null, bool? port_diff_buffers = null, bool? write_all_overrides = null, bool? keep_vcc_gnd = null, string rename_top = null, string sdf_anno = null, string sdf_file = null, bool? force = null, bool? include_xilinx_libs = null, bool? logic_function_stripped = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_verilog [-cell <arg>] [-mode <arg>] [-lib] [-port_diff_buffers] [-write_all_overrides] [-keep_vcc_gnd] [-rename_top <arg>] [-sdf_anno <arg>] [-sdf_file <arg>] [-force] [-include_xilinx_libs] [-logic_function_stripped] [-quiet] [-verbose] <file>
			return
				new SimpleTCLCommand("write_verilog")
					.OptionalNamedString("cell", cell)
					.OptionalNamedString("mode", mode)
					.Flag("lib", lib)
					.Flag("port_diff_buffers", port_diff_buffers)
					.Flag("write_all_overrides", write_all_overrides)
					.Flag("keep_vcc_gnd", keep_vcc_gnd)
					.OptionalNamedString("rename_top", rename_top)
					.OptionalNamedString("sdf_anno", sdf_anno)
					.OptionalNamedString("sdf_file", sdf_file)
					.Flag("force", force)
					.Flag("include_xilinx_libs", include_xilinx_libs)
					.Flag("logic_function_stripped", logic_function_stripped)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Export the current netlist in VHDL format
		///
		///
		/// TCL Syntax: write_vhdl [-cell <arg>] [-mode <arg>] [-lib] [-port_diff_buffers] [-write_all_overrides] [-keep_vcc_gnd] [-rename_top <arg>] [-arch_only] [-force] [-include_xilinx_libs] [-quiet] [-verbose] <file>
		///
		/// Write a VHDL netlist of the current design or from a specific cell of the design to the specified
		/// file or directory.
		/// The output of this command is a VHDL IEEE 1076.4 VITAL-2000 compliant VHDL file that
		/// contains netlist information obtained from the input design files. You can output a complete
		/// netlist of the design or specific cell, or output a port list for the design.
		///
		/// The following example writes a VHDL simulation netlist file for the whole design to the specified
		/// file and path:
		/// write_vhdl C:/Data/bft_top.vhd
		/// In the following example the entity definition of the top-level module is not output to the VHDL
		/// netlist:
		/// write_vhdl C:/Data/vhdl_arch_only.vhd -arch_only
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1857
		/// </summary>
		/// <param name="file">(Required) Which file to write</param>
		/// <param name="cell">(Optional) Root of the design to write, e.g. des.subblk.cpu Default: whole design</param>
		/// <param name="mode">
		/// (Optional)
		/// Output mode. Valid values: funcsim, pin_planning,
		/// synth_stub Default: funcsim
		/// </param>
		/// <param name="lib">(Optional) Write each library into a separate file</param>
		/// <param name="port_diff_buffers">(Optional) Output differential buffers when writing in -port mode</param>
		/// <param name="write_all_overrides">
		/// (Optional)
		/// Write parameter overrides on Xilinx primitives even if the
		/// same as the default value
		/// </param>
		/// <param name="keep_vcc_gnd">
		/// (Optional)
		/// Don't replace VCC/GND instances by literal constants on
		/// load terminals. For simulation modes only.
		/// </param>
		/// <param name="rename_top">
		/// (Optional)
		/// Replace top module name with custom name e.g. netlist
		/// Default: new top module name
		/// </param>
		/// <param name="arch_only">
		/// (Optional)
		/// Write only the architecture, not the entity declaration for the
		/// top cell
		/// </param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="include_xilinx_libs">
		/// (Optional)
		/// Include simulation models directly in netlist instead of
		/// linking to library
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>the name of the output file or directory</returns>
		public virtual SimpleTCLCommand write_vhdl(string file, string cell = null, string mode = null, bool? lib = null, bool? port_diff_buffers = null, bool? write_all_overrides = null, bool? keep_vcc_gnd = null, string rename_top = null, bool? arch_only = null, bool? force = null, bool? include_xilinx_libs = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_vhdl [-cell <arg>] [-mode <arg>] [-lib] [-port_diff_buffers] [-write_all_overrides] [-keep_vcc_gnd] [-rename_top <arg>] [-arch_only] [-force] [-include_xilinx_libs] [-quiet] [-verbose] <file>
			return
				new SimpleTCLCommand("write_vhdl")
					.OptionalNamedString("cell", cell)
					.OptionalNamedString("mode", mode)
					.Flag("lib", lib)
					.Flag("port_diff_buffers", port_diff_buffers)
					.Flag("write_all_overrides", write_all_overrides)
					.Flag("keep_vcc_gnd", keep_vcc_gnd)
					.OptionalNamedString("rename_top", rename_top)
					.Flag("arch_only", arch_only)
					.Flag("force", force)
					.Flag("include_xilinx_libs", include_xilinx_libs)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Write out one or more DRC/METHODOLOGY/CDC message waivers in command form
		///
		///
		/// TCL Syntax: write_waivers [-type <arg>] [-objects <args>] [-return_string] [-force] [-quiet] [-verbose] [<file>]
		///
		/// To save waivers from one design session to the next, you must use write_waivers to create
		/// an XDC file of the waiver commands, and read_xdc to read those waivers back into the design
		/// when it is reopened.
		///
		/// This example writes all waivers in the current design:
		/// write_waivers C:/Data/design_waivers.xdc
		/// The following example writes only DRC type waivers:
		/// write_waivers -type DRC C:/Data/drc_waivers.xdc
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1860
		/// </summary>
		/// <param name="file">(Required) Name of file to write waivers</param>
		/// <param name="type">(Optional) Type of waiver(s) - ALL, DRC, METHODOLOGY, CDC to write</param>
		/// <param name="objects">(Optional) List of DRC/METHODOLOGY/CDC waiver objects to be written</param>
		/// <param name="return_string">(Optional) Return report results as a string object</param>
		/// <param name="force">(Optional) Overwrite existing file.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand write_waivers(string file, string type = null, string objects = null, bool? return_string = null, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_waivers [-type <arg>] [-objects <args>] [-return_string] [-force] [-quiet] [-verbose] [<file>]
			return
				new SimpleTCLCommand("write_waivers")
					.OptionalNamedString("type", type)
					.OptionalNamedString("objects", objects)
					.Flag("return_string", return_string)
					.Flag("force", force)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Writes constraints to a Xilinx Design Constraints (XDC) file. The default file extension for a XDC
		/// file is .xdc.
		///
		///
		/// TCL Syntax: write_xdc [-no_fixed_only] [-constraints <arg>] [-cell <arg>] [-sdc] [-no_tool_comments] [-force] [-exclude_timing] [-exclude_physical] [-add_netlist_placement] [-logic_function_stripped] [-type <args>] [-quiet] [-verbose] [<file>]
		///
		/// Writes constraints to a Xilinx® Design Constraints file (XDC). The XDC can be exported from the
		/// top-level, which is the default, or from a specific hierarchical cell.
		/// IMPORTANT! The write_xdc command writes the constraints to the specified file in the same order they
		/// are added to or executed in the design.
		/// The write_xdc command lets you write invalid XDC constraints so that you can quickly report
		/// constraints that have been ignored by the Vivado Design Suite due to a problem with the way
		/// the constraint is written or applied. This is useful for debugging constraint files applied in specific
		/// designs.
		/// This command can be used to create an XDC file from a design with UCF files. All constraints
		/// from the active constraint fileset will be exported to the XDC, even if they come from multiple
		/// files.
		/// TIP: The write_xdc command will not convert all UCF constraints into XDC format, and is not intended to
		/// automatically convert UCF based designs to XDC. Refer to the Vivado Design Suite Migration Methodology
		/// Guide (UG911) for more information on migrating UCF constraints to XDC.
		///
		/// The following example writes the valid and invalid constraints, including both fixed and unfixed
		/// cells, to the specified file:
		/// write_xdc -no_fixed_only -constraints all C:/Data/design.xdc
		/// This example writes only the invalid constraints, including both fixed and unfixed cells, to the
		/// specified file:
		/// write_xdc -constraints invalid C:/Data/bad_constraints.xdc
		/// The following example writes the physical constraints only, including any placement constraints
		/// defined in any netlist source files:
		/// write_xdc -exclude_timing -add_netlist_placement C:/Data/physical.xdc
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1862
		/// </summary>
		/// <param name="file">(Required) Output constraints to the specified XDC file.</param>
		/// <param name="no_fixed_only">
		/// (Optional)
		/// Export fixed and non-fixed placement (by default only fixed
		/// placement is exported)
		/// </param>
		/// <param name="constraints">
		/// (Optional)
		/// Include constraints that are flagged invalid Values: valid,
		/// invalid, all Default: valid
		/// </param>
		/// <param name="cell">(Optional) Hierarchical cell for which constraints are exported.</param>
		/// <param name="sdc">(Optional) Export all timing constriants in SDC compatible format.</param>
		/// <param name="no_tool_comments">
		/// (Optional)
		/// Don't write verbose tool generated comments to the xdc
		/// when translating from ucf.
		/// </param>
		/// <param name="force">(Optional) Overwrite existing file.</param>
		/// <param name="exclude_timing">(Optional) Don't export timing constraints.</param>
		/// <param name="exclude_physical">(Optional) Don't export physical constraints.</param>
		/// <param name="add_netlist_placement">(Optional) Export netlist placement constraints.</param>
		/// <param name="logic_function_stripped">
		/// (Optional)
		/// Write disable_timing constraints which are associated with
		/// having previously run write_edif with its -
		/// logic_function_stripped option.
		/// </param>
		/// <param name="type">
		/// (Optional)
		/// Types of constraint to export. Values: timing, io, misc, waiver
		/// and physical. If not specified, all constraints will be
		/// exported.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public virtual SimpleTCLCommand write_xdc(string file, bool? no_fixed_only = null, string constraints = null, string cell = null, bool? sdc = null, bool? no_tool_comments = null, bool? force = null, bool? exclude_timing = null, bool? exclude_physical = null, bool? add_netlist_placement = null, bool? logic_function_stripped = null, string type = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_xdc [-no_fixed_only] [-constraints <arg>] [-cell <arg>] [-sdc] [-no_tool_comments] [-force] [-exclude_timing] [-exclude_physical] [-add_netlist_placement] [-logic_function_stripped] [-type <args>] [-quiet] [-verbose] [<file>]
			return
				new SimpleTCLCommand("write_xdc")
					.Flag("no_fixed_only", no_fixed_only)
					.OptionalNamedString("constraints", constraints)
					.OptionalNamedString("cell", cell)
					.Flag("sdc", sdc)
					.Flag("no_tool_comments", no_tool_comments)
					.Flag("force", force)
					.Flag("exclude_timing", exclude_timing)
					.Flag("exclude_physical", exclude_physical)
					.Flag("add_netlist_placement", add_netlist_placement)
					.Flag("logic_function_stripped", logic_function_stripped)
					.OptionalNamedString("type", type)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(file)
			;
		}
		/// <summary>
		/// Load a simulation snapshot for simulation and return a simulation object
		///
		///
		/// TCL Syntax: xsim [-view <args>] [-autoloadwcfg] [-runall] [-R] [-maxdeltaid <arg>] [-nolog] [-maxlogsize <arg>] [-onfinish <arg>] [-onerror <arg>] [-tclbatch <args>] [-t <args>] [-testplusarg <args>] [-vcdfile <arg>] [-vcdunit <arg>] [-wdb <arg>] [-tp] [-tl] [-nosignalhandlers] [-ieeewarnings] [-stats] [-scNoLogFile] [-sv_seed <arg>] [-protoinst <args>] [-cov_db_dir <arg>] [-cov_db_name <arg>] [-ignore_assertions] [-ignore_coverage] [-downgrade_error2info] [-downgrade_error2warning] [-downgrade_fatal2info] [-downgrade_fatal2warning] [-ignore_feature <args>] [-downgrade_severity <args>] [-quiet] [-verbose] <snapshot>
		///
		/// The xsim command loads a simulation snapshot to run a batch mode simulation, or to provide a
		/// GUI and/or Tcl-based interactive simulation environment. The snapshot must be generated using
		/// the xelab command.
		///
		/// The following example launches xsim on the specified simulation snapshot:
		/// xsim C:/Data/project_xsim/project_xsim.sim/sim_1/behav/testbench_behav
		///
		/// See ug835-vivado-tcl-commands.pdf, page 1865
		/// </summary>
		/// <param name="snapshot">(Required) The name of design snapshot or WDB file</param>
		/// <param name="view">
		/// (Optional)
		/// Open a wave configuration file. This switch may be repeated
		/// to open multiple files.
		/// </param>
		/// <param name="autoloadwcfg">
		/// (Optional)
		/// For a WDB file named <name>.wdb, automatically open all
		/// WCFG files named <name>#.wcfg. Ignored if -view is
		/// present.
		/// </param>
		/// <param name="runall">(Optional) Run simulation until completion, then quit (does 'run -all; exit')</param>
		/// <param name="R">(Optional) Run simulation until completion, then quit (does 'run -all; exit')</param>
		/// <param name="maxdeltaid">
		/// (Optional)
		/// Specify the maximum delta number. Will report error if it
		/// exceeds maximum simulation loops at the same time
		/// Default: 10000
		/// </param>
		/// <param name="nolog">(Optional) Ignored (for compatibility with xsim command-line tool)</param>
		/// <param name="maxlogsize">
		/// (Optional)
		/// Set the maximum size a log file can reach in MB. The default
		/// setting is unlimited Default: -1
		/// </param>
		/// <param name="onfinish">(Optional) Specify behavior at end of simulation: quit|stop Default: stop</param>
		/// <param name="onerror">
		/// (Optional)
		/// Specify behavior upon simulation run-time error: quit|stop
		/// Default: stop
		/// </param>
		/// <param name="tclbatch">(Optional) Specify the TCL file for batch mode execution</param>
		/// <param name="t">(Optional) Specify the TCL file for batch mode execution</param>
		/// <param name="testplusarg">
		/// (Optional)
		/// Specify plusargs to be used by $test$plusargs and $value
		/// $plusargs system functions
		/// </param>
		/// <param name="vcdfile">(Optional) Specify the vcd output file Name Description</param>
		/// <param name="vcdunit">
		/// (Optional)
		/// Specify the vcd output unit. Default is the same as the
		/// engine precision unit
		/// </param>
		/// <param name="wdb">(Optional) Specify the waveform database output file</param>
		/// <param name="tp">(Optional) Enable printing of hierarchical names of process being executed</param>
		/// <param name="tl">
		/// (Optional)
		/// Enable printing of file name and line number of statements
		/// being executed.
		/// </param>
		/// <param name="nosignalhandlers">(Optional) Run with no signal handlers to avoid conflict with security software</param>
		/// <param name="ieeewarnings">(Optional) Enable warnings from VHDL IEEE functions</param>
		/// <param name="stats">(Optional) Display memory and cpu stats upon exiting</param>
		/// <param name="scNoLogFile">(Optional) Keep the SystemC output separate from XSim output</param>
		/// <param name="sv_seed">(Optional) Seed for constraint random stimulus Default: 1</param>
		/// <param name="protoinst">(Optional) Specify a .protoinst file for protocol analysis</param>
		/// <param name="cov_db_dir">
		/// (Optional)
		/// System Verilog Coverage Run Directory. The coverage data
		/// will be present under <cov_db_dir>/xsim.covdb/
		/// <cov_db_name> directory.Default is ./ or inherits value set in
		/// similar xelab option.
		/// </param>
		/// <param name="cov_db_name">
		/// (Optional)
		/// System Verilog Coverage Run Name. The coverage data will
		/// be present under <cov_db_dir>/xsim.covdb/<cov_db_name>
		/// directory.Default is snapshot name or inherits value set in
		/// similar xelab option.
		/// </param>
		/// <param name="ignore_assertions">(Optional) Ignore System Verilog concurrent assertion constructs at runtime.</param>
		/// <param name="ignore_coverage">(Optional) Ignore System Verilog Functional Coverage at runtime.</param>
		/// <param name="downgrade_error2info">(Optional) Downgrade System verilog message severity from error to info level.</param>
		/// <param name="downgrade_error2warning">(Optional) Downgrade System verilog message severity from error to warning level.</param>
		/// <param name="downgrade_fatal2info">(Optional) Downgrade System verilog message severity from fatal to info level.</param>
		/// <param name="downgrade_fatal2warning">(Optional) Downgrade System verilog message severity from fatal to warning level.</param>
		/// <param name="ignore_feature">
		/// (Optional)
		/// Specify System Verilog feature to be ignored at runtime.
		/// Choices are: assertion : Ignore concurrent assertions.
		/// </param>
		/// <param name="downgrade_severity">
		/// (Optional)
		/// Downgrade severity level of System Verilog HDL
		/// messages.Choices are: error2warning|error2info|
		/// fatal2warning|fatal2info.
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Current simulation object</returns>
		public virtual SimpleTCLCommand xsim(string snapshot, string view = null, bool? autoloadwcfg = null, bool? runall = null, bool? R = null, string maxdeltaid = null, bool? nolog = null, string maxlogsize = null, string onfinish = null, string onerror = null, string tclbatch = null, string t = null, string testplusarg = null, string vcdfile = null, string vcdunit = null, string wdb = null, bool? tp = null, bool? tl = null, bool? nosignalhandlers = null, bool? ieeewarnings = null, bool? stats = null, bool? scNoLogFile = null, string sv_seed = null, string protoinst = null, string cov_db_dir = null, string cov_db_name = null, bool? ignore_assertions = null, bool? ignore_coverage = null, bool? downgrade_error2info = null, bool? downgrade_error2warning = null, bool? downgrade_fatal2info = null, bool? downgrade_fatal2warning = null, string ignore_feature = null, string downgrade_severity = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: xsim [-view <args>] [-autoloadwcfg] [-runall] [-R] [-maxdeltaid <arg>] [-nolog] [-maxlogsize <arg>] [-onfinish <arg>] [-onerror <arg>] [-tclbatch <args>] [-t <args>] [-testplusarg <args>] [-vcdfile <arg>] [-vcdunit <arg>] [-wdb <arg>] [-tp] [-tl] [-nosignalhandlers] [-ieeewarnings] [-stats] [-scNoLogFile] [-sv_seed <arg>] [-protoinst <args>] [-cov_db_dir <arg>] [-cov_db_name <arg>] [-ignore_assertions] [-ignore_coverage] [-downgrade_error2info] [-downgrade_error2warning] [-downgrade_fatal2info] [-downgrade_fatal2warning] [-ignore_feature <args>] [-downgrade_severity <args>] [-quiet] [-verbose] <snapshot>
			return
				new SimpleTCLCommand("xsim")
					.OptionalNamedString("view", view)
					.Flag("autoloadwcfg", autoloadwcfg)
					.Flag("runall", runall)
					.Flag("R", R)
					.OptionalNamedString("maxdeltaid", maxdeltaid)
					.Flag("nolog", nolog)
					.OptionalNamedString("maxlogsize", maxlogsize)
					.OptionalNamedString("onfinish", onfinish)
					.OptionalNamedString("onerror", onerror)
					.OptionalNamedString("tclbatch", tclbatch)
					.OptionalNamedString("t", t)
					.OptionalNamedString("testplusarg", testplusarg)
					.OptionalNamedString("vcdfile", vcdfile)
					.OptionalNamedString("vcdunit", vcdunit)
					.OptionalNamedString("wdb", wdb)
					.Flag("tp", tp)
					.Flag("tl", tl)
					.Flag("nosignalhandlers", nosignalhandlers)
					.Flag("ieeewarnings", ieeewarnings)
					.Flag("stats", stats)
					.Flag("scNoLogFile", scNoLogFile)
					.OptionalNamedString("sv_seed", sv_seed)
					.OptionalNamedString("protoinst", protoinst)
					.OptionalNamedString("cov_db_dir", cov_db_dir)
					.OptionalNamedString("cov_db_name", cov_db_name)
					.Flag("ignore_assertions", ignore_assertions)
					.Flag("ignore_coverage", ignore_coverage)
					.Flag("downgrade_error2info", downgrade_error2info)
					.Flag("downgrade_error2warning", downgrade_error2warning)
					.Flag("downgrade_fatal2info", downgrade_fatal2info)
					.Flag("downgrade_fatal2warning", downgrade_fatal2warning)
					.OptionalNamedString("ignore_feature", ignore_feature)
					.OptionalNamedString("downgrade_severity", downgrade_severity)
					.Flag("quiet", quiet)
					.Flag("verbose", verbose)
					.RequiredString(snapshot)
			;
		}
	}
}
