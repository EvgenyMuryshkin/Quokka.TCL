#pragma warning disable IDE1006 // Naming Styles
// Generated file, do not modify
// See VivadoGenerator for implementation
using System;
using Quokka.TCL.Tools;
using System.Collections.Generic;
namespace Quokka.TCL.Vivado
{
	public partial class ToolLaunchCommands<TTCL> where TTCL : TCLFile
	{
		private readonly TTCL _tcl;
		private readonly VivadoTCLBuilder _builder;
		public ToolLaunchCommands(TTCL tcl, VivadoTCLBuilder builder)
		{
			_tcl = tcl;
			_builder = builder;
		}
		/// <summary>
		/// <para>
		/// Get registered simulators<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_simulators [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Get the list of simulators registered for use with the Vivado Design Suite unified simulation<br/>
		/// environment.<br/>
		/// The Vivado Design Suite comes with some simulators pre-registered for use with the unified<br/>
		/// simulation environment. You can also register your own third-party simulators using the<br/>
		/// register_simulator command.<br/>
		/// This command returns the names of registered simulators, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 920<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match simulator names against patterns Default: *</param>
		public TTCL get_simulators(bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_simulators [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			_tcl.Entry(_builder.get_simulators(regexp, nocase, filter, quiet, verbose, patterns));
			return _tcl;
		}
		/// <summary>
		/// <para>
		/// Issues an error that you can not run this command<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: launch_chipscope_analyzer [-run &lt;arg&gt;] [-csproject &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Launches the ChipScope™ Pro Analyzer tool for the active run, or a specified Implemented<br/>
		/// Design run. You can setup a Netlist Design for use with ChipScope prior to implementation, using<br/>
		/// the create_debug_core, create_debug_port, and connect_debug_port commands.<br/>
		/// The Implemented Design must also have a bitstream file generated by BitGen for<br/>
		/// launch_chipscope_analyzer to run. If BitGen has not been run, an error will be returned.<br/>
		/// Note: It is not enough to use the write_bitstream command to create a bitstream file. You must follow<br/>
		/// the steps outlined below in the second example.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example launches ChipScope Pro Analyzer, specifying the implementation run to<br/>
		/// use and the name of the ChipScope project to create:<br/>
		/// launch_chipscope_analyzer -run impl_3 -csproject impl_3_cs_project<br/>
		/// The following example sets the add_step Bitgen property for the impl_4 run, launches the<br/>
		/// impl_4 run, and then launches the ChipScope Pro Analyzer on the specified run:<br/>
		/// set_property add_step Bitgen [get_runs impl_4]<br/>
		/// launch_runs impl_4 -jobs 2<br/>
		/// launch_chipscope_analyzer -run impl_4<br/>
		/// Note: In this example the ChipScope project will be called csdefaultproj.cpj.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1008<br/>
		/// </para>
		/// </summary>
		/// <param name="run">(Optional) Implemented run to launch ChipScope Analyzer with</param>
		/// <param name="csproject">(Optional) ChipScope project</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public TTCL launch_chipscope_analyzer(String run = null, String csproject = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: launch_chipscope_analyzer [-run <arg>] [-csproject <arg>] [-quiet] [-verbose]
			_tcl.Entry(_builder.launch_chipscope_analyzer(run, csproject, quiet, verbose));
			return _tcl;
		}
		/// <summary>
		/// <para>
		/// Issues an error that you can not run this command<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: launch_impact [-run &lt;arg&gt;] [-ipf &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Launch iMPACT to configure your device and generate programming files. You can also read back<br/>
		/// and verify design configuration data, debug configuration problems, or execute XSVF files.<br/>
		/// You must generate the bitstream file using write_bitstream prior to using iMPACT.<br/>
		/// The command returns the list of files read.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example launches iMPACT using the specified implementation run:<br/>
		/// launch_impact -run impl_3<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1010<br/>
		/// </para>
		/// </summary>
		/// <param name="run">(Optional) Implemented run to launch iMPACT with</param>
		/// <param name="ipf">(Optional) Project for iMPACT</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public TTCL launch_impact(String run = null, String ipf = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: launch_impact [-run <arg>] [-ipf <arg>] [-quiet] [-verbose]
			_tcl.Entry(_builder.launch_impact(run, ipf, quiet, verbose));
			return _tcl;
		}
		/// <summary>
		/// <para>
		/// Generate simulation scripts of the design and launch steps for the target simulator.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: launch_simulation [-step &lt;arg&gt;] [-simset &lt;arg&gt;] [-mode &lt;arg&gt;] [-type &lt;arg&gt;] [-scripts_only] [-of_objects &lt;args&gt;] [-absolute_path] [-install_path &lt;arg&gt;] [-gcc_install_path &lt;arg&gt;] [-noclean_dir] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Launch a simulator to perform analysis and verification of a design.<br/>
		/// The launch_simulation command creates a script file for the target simulator and then<br/>
		/// executes this file in the simulation run directory. The simulation results are saved in the log files<br/>
		/// created in the run directory.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// To run simulation for a specific simulator, you must first define the target simulator by setting the<br/>
		/// TARGET_SIMULATOR property on the design project:<br/>
		/// set_property TARGET_SIMULATOR &lt;name&gt; [current_project]<br/>
		/// The TARGET_SIMULATOR property can have a value of XSim, ModelSim, IES, Xcelium, VCS,<br/>
		/// Riviera, or ActiveHDL. The default value is XSim, the Vivado simulator.<br/>
		/// The target simulator can also be defined from the Vivado IDE. Create or open a project, select<br/>
		/// Tools → Settings → Simulation menu item, and select the Target simulator from the drop-down<br/>
		/// menu. The available choices are: Vivado simulator, ModelSim Simulator, Questa Advanced<br/>
		/// Simulator, Incisive Enterprise Simulator (IES), Xcelium Parallel Simulator, Verilog Compiler<br/>
		/// Simulator (VCS), Riviera-PRO Simulator, and Active-HDL Simulator.<br/>
		/// TIP: Some of these simulators are only available on Linux and some are only available on Windows.<br/>
		/// The launch_simulation command uses a three-step process comprised of compile,<br/>
		/// elaborate, and simulate steps. A script file for the target simulator is created for each step in the<br/>
		/// process, (compile.bat, elaborate.bat, simulate.bat), and written to the simulation run<br/>
		/// directory.<br/>
		/// TIP: On Linux the script files are named with the .sh suffix instead of .bat.<br/>
		/// By default, launch_simulation will run these script files in sequence to run the simulation.<br/>
		/// You can create the scripts without running them by using the -scripts_only option.<br/>
		/// This command returns a transcript of its process, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following commands run behavioral simulation of the design using the Vivado simulator:<br/>
		/// set_property target_simulator "XSim" [current_project]<br/>
		/// launch_simulation<br/>
		/// The following commands run post-synthesis functional simulation of the design using the<br/>
		/// ModelSim Simulator:<br/>
		/// set_property target_simulator "ModelSim" [current_project]<br/>
		/// launch_simulation -mode "post-synthesis" -type "functional"<br/>
		/// The following commands run post-implementation functional simulation of the design using the<br/>
		/// Cadence IES Simulator:<br/>
		/// set_property target_simulator "IES" [current_project]<br/>
		/// launch_simulation -mode "post-implementation" -type "functional"<br/>
		/// The following commands run post-implementation timing simulation of the design using the<br/>
		/// Synopsys VCS Simulator:<br/>
		/// set_property target_simulator "VCS" [current_project]<br/>
		/// launch_simulation -mode "post-implementation" -type "timing"<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following command generates behavioral simulation scripts for the target simulator in the<br/>
		/// simulation run directory:<br/>
		/// launch_simulation -scripts_only<br/>
		/// The following commands run behavioral simulation flow of the design for the "my_simset"<br/>
		/// simulation fileset for the target simulator in the simulation run directory:<br/>
		/// launch_simulation -simset [get_filesets my_simset]<br/>
		/// The following command runs behavioral simulation flow for the char_fifo.xci IP for the<br/>
		/// target simulator in the simulation run directory, and does not clean up prior simulation files:<br/>
		/// launch_simulation -noclean_dir -of_objects [get_files char_fifo.xci]<br/>
		/// The following command generates absolute paths for the source files in the generated script files:<br/>
		/// launch_simulation -absolute_path<br/>
		/// The following command will pick the simulator tools from the specified installation path instead<br/>
		/// of from the PATH variable:<br/>
		/// launch_simulation -install_path /tools/ius/13.20.005/tools/bin<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1017<br/>
		/// </para>
		/// </summary>
		/// <param name="step">
		/// <para>
		/// (Optional)<br/>
		/// Launch a simulation step. Values: all, compile, elaborate,<br/>
		/// simulate. Default:all (launch all steps). Default: all<br/>
		/// </para>
		/// </param>
		/// <param name="simset">(Optional) Name of the simulation fileset</param>
		/// <param name="mode">
		/// <para>
		/// (Optional)<br/>
		/// Simulation mode. Values: behavioral, post-synthesis, post-implementation Default: behavioral<br/>
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// (Optional)<br/>
		/// Netlist type. Values: functional, timing. This is only<br/>
		/// applicable when mode is set to post-synthesis or post-implementation<br/>
		/// </para>
		/// </param>
		/// <param name="scripts_only">(Optional) Only generate scripts</param>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Generate compile order file for this object (applicable with -<br/>
		/// scripts_only option only)<br/>
		/// </para>
		/// </param>
		/// <param name="absolute_path">(Optional) Make design source file paths in 'absolute' format</param>
		/// <param name="install_path">(Optional) Custom installation directory path</param>
		/// <param name="gcc_install_path">
		/// <para>
		/// (Optional)<br/>
		/// Specify GNU compiler installation directory path for the g+<br/>
		/// +/gcc executables<br/>
		/// </para>
		/// </param>
		/// <param name="noclean_dir">(Optional) Do not remove simulation run directory files</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public TTCL launch_simulation(launch_simulation_step? step = null, String simset = null, launch_simulation_mode? mode = null, launch_simulation_type? type = null, bool? scripts_only = null, TCLParameterList of_objects = null, bool? absolute_path = null, String install_path = null, String gcc_install_path = null, bool? noclean_dir = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: launch_simulation [-step <arg>] [-simset <arg>] [-mode <arg>] [-type <arg>] [-scripts_only] [-of_objects <args>] [-absolute_path] [-install_path <arg>] [-gcc_install_path <arg>] [-noclean_dir] [-quiet] [-verbose]
			_tcl.Entry(_builder.launch_simulation(step, simset, mode, type, scripts_only, of_objects, absolute_path, install_path, gcc_install_path, noclean_dir, quiet, verbose));
			return _tcl;
		}
	}
}
#pragma warning restore IDE1006 // Naming Styles
