#pragma warning disable IDE1006 // Naming Styles
// Generated file, do not modify
// See VivadoGenerator for implementation
using System;
using Quokka.TCL.Tools;
using System.Collections.Generic;
namespace Quokka.TCL.Vivado
{
	public partial class VivadoTCL : FluentVivadoTCLFile<VivadoTCL>
	{
		public VivadoTCL(VivadoTCLBuilder builder = null) : base(builder)
		{
		}
		/// <summary>
		/// <para>
		/// Add breakpoint at a line of a HDL source<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: add_bp [-quiet] [-verbose] &lt;file_name&gt; &lt;line_number&gt;
		/// <br/>
		/// <para>
		/// The add_bp command lets you add breakpoints to an HDL source file to pause the current<br/>
		/// simulation.<br/>
		/// A breakpoint is a user-determined stopping point in the source code used for debugging the<br/>
		/// design. When simulating a design with breakpoints, simulation of the design stops at each<br/>
		/// breakpoint to let you examine values and verify the design behavior.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// You can report breakpoints in the current simulation using the report_bps command, and<br/>
		/// remove existing breakpoints using the remove_bps command.<br/>
		/// This command returns a new breakpoint object if there is not already a breakpoint set at the<br/>
		/// specified file line, or returns an existing breakpoint object if there is already a breakpoint defined<br/>
		/// for the specified file and line number.<br/>
		/// TIP: You can capture the returned breakpoint object in a Tcl variable if needed.<br/>
		/// The add_bp command returns an error if the command fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example adds a the breakpoint to the HDL source file at the specified line number:<br/>
		/// add_bp C:/Data/ug937/sources/sinegen.vhd 137<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 33<br/>
		/// </para>
		/// </summary>
		/// <param name="file_name">(Required) Filename to add the breakpoint</param>
		/// <param name="line_number">(Required) Line number of the given file to set the breakpoint</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>
		/// </returns>
		public VivadoTCL add_bp(String file_name, Int32 line_number, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: add_bp [-quiet] [-verbose] <file_name> <line_number>
			this.Entry(_builder.add_bp(file_name, line_number, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Add cells to a Pblock<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: add_cells_to_pblock [-top] [-add_primitives] [-clear_locs] [-quiet] [-verbose] &lt;pblock&gt; [&lt;cells&gt;...]
		/// <br/>
		/// <para>
		/// Adds specified logic instances to a Pblock in an open implemented design. Once cells have been<br/>
		/// added to a Pblock, you can place the Pblocks onto the fabric of the FPGA using the<br/>
		/// resize_pblock command. The resize_pblock command can also be used to manually<br/>
		/// move and resize Pblocks.<br/>
		/// You can remove instances from the Pblock using the remove_cells_from_pblock command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates a Pblock called pb_cpuEngine, and then adds only the leaf-cells<br/>
		/// found in the cpuEngine module, clearing placement constraints for placed instances:<br/>
		/// create_pblock pb_cpuEngine<br/>
		/// add_cells_to_pblock pb_cpuEngine [get_cells cpuEngine/*] \<br/>
		/// -add_primitives -clear_locs<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 35<br/>
		/// </para>
		/// </summary>
		/// <param name="pblock">(Required) Pblock to add cells to</param>
		/// <param name="top">
		/// <para>
		/// (Optional)<br/>
		/// Add the top level instance; This option can't be used with -<br/>
		/// cells, or -add_primitives options. You must specify either -<br/>
		/// cells or -top option.<br/>
		/// </para>
		/// </param>
		/// <param name="add_primitives">
		/// <para>
		/// (Optional)<br/>
		/// Assign to the pblock only primitive cells from the specified<br/>
		/// list of cells.<br/>
		/// </para>
		/// </param>
		/// <param name="clear_locs">(Optional) Clear instance location constraints</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="cells">
		/// <para>
		/// (Optional)<br/>
		/// Cells to add. You can't use this option with -top option. You<br/>
		/// must specify either -cells or -top option.<br/>
		/// </para>
		/// </param>
		public VivadoTCL add_cells_to_pblock(String pblock, bool? top = null, bool? add_primitives = null, bool? clear_locs = null, bool? quiet = null, bool? verbose = null, TCLParameterList cells = null)
		{
			// TCL Syntax: add_cells_to_pblock [-top] [-add_primitives] [-clear_locs] [-quiet] [-verbose] <pblock> [<cells>...]
			this.Entry(_builder.add_cells_to_pblock(pblock, top, add_primitives, clear_locs, quiet, verbose, cells));
			return this;
		}
		/// <summary>
		/// <para>
		/// Conditionally execute Tcl commands<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: add_condition [-name &lt;arg&gt;] [-radix &lt;arg&gt;] [-notrace] [-quiet] [-verbose] &lt;condition_expression&gt; &lt;commands&gt;
		/// <br/>
		/// <para>
		/// Add a condition that is evaluated by a specified condition, &lt;condition_expression&gt;, and runs a<br/>
		/// series of simulation Tcl commands when the condition is TRUE.<br/>
		/// Conditions can be defined prior to starting the simulation. When a condition is added, the<br/>
		/// simulator evaluates the condition expression anytime a signal change is detected. When a<br/>
		/// specified condition expression becomes TRUE, the condition commands are run.<br/>
		/// The add_condition command returns a condition identifier for the added condition, or returns<br/>
		/// an error if the command fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example defines a condition named resetLow, that becomes true when the reset<br/>
		/// signal is low, and then puts a message to the standard output, and stops the current simulation:<br/>
		/// add_condition -name resetLow {/testbench/reset == 0 } {<br/>
		/// puts "Condition Reset was encountered at [current_time]. Stopping<br/>
		/// simulation."<br/>
		/// stop }<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This next example defines a Tcl procedure, called myProc, that uses the add_force command to<br/>
		/// define clk and reset signal values, and print a standard message when it completes. A<br/>
		/// condition is then added that calls myProc when reset is low:<br/>
		/// proc myProc {} {<br/>
		/// add_force clk {0 1} { 1 2} -repeat_every 4 -cancel_after 500<br/>
		/// add_force reset 1<br/>
		/// run 10 ns<br/>
		/// remove_force force2<br/>
		/// puts "Reached end of myProc"<br/>
		/// }<br/>
		/// add_condition -radix unsigned /top/reset==0 myproc<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 37<br/>
		/// </para>
		/// </summary>
		/// <param name="condition_expression">(Required) The condition expression when true executes the given commands</param>
		/// <param name="commands">(Required) Commands to execute upon condition</param>
		/// <param name="name">
		/// <para>
		/// (Optional)<br/>
		/// Assign a unique name (label) to a condition. Multiple<br/>
		/// conditions cannot be assigned the same name. If no name<br/>
		/// is specified, then a default label named as condition&lt;id&gt; is<br/>
		/// automatically created<br/>
		/// </para>
		/// </param>
		/// <param name="radix">
		/// <para>
		/// (Optional)<br/>
		/// Specifies which radix to use. Allowed values are: default,<br/>
		/// dec, bin, oct, hex, unsigned, ascii, smag.<br/>
		/// </para>
		/// </param>
		/// <param name="notrace">(Optional) Turn off the logging of condition commands</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The condition object created</returns>
		public VivadoTCL add_condition(String condition_expression, String commands, String name = null, String radix = null, bool? notrace = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: add_condition [-name <arg>] [-radix <arg>] [-notrace] [-quiet] [-verbose] <condition_expression> <commands>
			this.Entry(_builder.add_condition(condition_expression, commands, name, radix, notrace, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Add DRC rule check objects to a rule deck<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: add_drc_checks [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] -ruledeck &lt;arg&gt; [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Add design rule checks to the specified drc_ruledeck object.<br/>
		/// A rule deck is a collection of design rule checks grouped for convenience, to be run with the<br/>
		/// report_drc command at different stages of the Xilinx design flow, such as during I/O planning<br/>
		/// or placement. The tool comes with a set of factory defined rule decks, but you can also create<br/>
		/// new user-defined rule decks with the create_drc_ruledeck command.<br/>
		/// Use the get_drc_ruledecks command to return a list of the currently defined rule decks<br/>
		/// available for use in the report_drc command.<br/>
		/// You can add standard factory defined rule checks to the rule deck, or add user-defined rule<br/>
		/// checks that were created using the create_drc_check command. Use the get_drc_checks<br/>
		/// command to get a list of checks that can be added to a rule deck.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Checks can also be removed from a rule deck using the remove_drc_checks command.<br/>
		/// Note: To temporarily disable a specific DRC rule, use the set_property command to set the<br/>
		/// IS_ENABLED property for the rule to false. This will disable the rule from being run in report_drc,<br/>
		/// without having to remove the rule from the rule deck. Use reset_drc_check to restore the rule to its<br/>
		/// default setting.<br/>
		/// This command returns the list of design rule checks that were added to the rule deck.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example adds the rule checks matching the specified search pattern to the<br/>
		/// project_rules rule deck:<br/>
		/// add_drc_checks -ruledeck project_rules {*DCI* *BUF*}<br/>
		/// The following example creates a new rule deck called placer+, copies all of the rule checks from<br/>
		/// the placer_checks rule deck into the placer+ rule deck, then adds some additional checks:<br/>
		/// create_drc_ruledeck placer+<br/>
		/// add_drc_checks -of_objects [get_drc_ruledecks placer_checks] \<br/>
		/// -ruledeck placer+<br/>
		/// add_drc_checks -ruledeck placer+ *IO*<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example adds only the rule checks with a severity of Warning to the rule deck:<br/>
		/// add_drc_checks -filter {SEVERITY == Warning} -ruledeck warn_only<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 40<br/>
		/// </para>
		/// </summary>
		/// <param name="ruledeck">(Required) DRC rule deck to modify</param>
		/// <param name="of_objects">(Optional) Get 'rule_check' objects of these types: 'drc_ruledeck'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'rule_check' objects against patterns. Default: *</param>
		/// <returns>drc_check</returns>
		public VivadoTCL add_drc_checks(String ruledeck, TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: add_drc_checks [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] -ruledeck <arg> [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.add_drc_checks(ruledeck, of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Add sources to the active fileset<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: add_files [-fileset &lt;arg&gt;] [-of_objects &lt;args&gt;] [-norecurse] [-copy_to &lt;arg&gt;] [-force] [-scan_for_includes] [-quiet] [-verbose] [&lt;files&gt;...]
		/// <br/>
		/// <para>
		/// Adds one or more source files, or the source file contents of one or more directories, to the<br/>
		/// specified fileset in the current project. Valid source files include HDL sources (VHDL, Verilog,<br/>
		/// SystemVerilog, and related header files), netlist sources (DCP, EDIF, and NGC), and memory<br/>
		/// interface files (BMM, MIF, MEM, ELF).<br/>
		/// IP and Block Design sources are not added through the add_files command. These are<br/>
		/// compound files that are supported by separate commands such as import_ip, read_bd, and<br/>
		/// read_ip.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// For every file added to a project the Vivado Design Suite attempts to store and maintain both a<br/>
		/// relative path and an absolute path to the file or directory. When a project is opened, these paths<br/>
		/// are used to locate the files and directories. By default the Vivado Design Suite applies a Relative<br/>
		/// First approach to resolving paths, searching the relative path first, then the absolute path. You<br/>
		/// can use the PATH_MODE property to change how the Vivado tool resolves file paths or<br/>
		/// properties for specific objects. For more information, see the Vivado Design Suite Properties<br/>
		/// Reference Guide (UG912).<br/>
		/// IMPORTANT! Adding multiple files one at a time can cause noticeable performance degradation. It is<br/>
		/// more efficient to use a single add_files command to import a list of files:<br/>
		/// add_files {file1 file2 file3 ... fileN}<br/>
		/// The Vivado tool does not read the contents of a file automatically when the file is added to the<br/>
		/// project with add_files, but rather reads the file contents when they are needed. For instance,<br/>
		/// a constraints file is not read when added to the design until needed by synthesis, timing, or<br/>
		/// implementation. To read the file at the time of adding it to the design, use the read_xxx<br/>
		/// command instead.<br/>
		/// TIP: When running the Vivado tool in Non-Project mode, in which there is no project file to maintain and<br/>
		/// manage the various project source files, you should use the read_xxx commands to read the contents of<br/>
		/// source files into the in-memory design. Refer to the Vivado Design Suite User Guide: Design Flows<br/>
		/// Overview (UG892) for more information on Non-Project mode.<br/>
		/// The add_files command adds them by reference to the specified fileset. This is different from<br/>
		/// the import_files command, which copies the file into the local project folders as well as<br/>
		/// adding them to the specified fileset.<br/>
		/// This command returns the files that were added, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example adds a file called rtl.v to the current project:<br/>
		/// add_files rtl.v<br/>
		/// In the preceding example the tool looks for the rtl.v file in the current working directory since no<br/>
		/// file path is specified, and the file is added to the source fileset as a default since no fileset is<br/>
		/// specified.<br/>
		/// The following example adds a file called top.xdc to the constrs_1 constraint fileset, as well<br/>
		/// as any appropriate source files found in the project_1 directory, and its subdirectories:<br/>
		/// add_files -fileset constrs_1 -quiet c:/Design/top.xdc c:/Design/project_1<br/>
		/// In addition, the tool ignores any command line errors because the -quiet argument was<br/>
		/// specified.<br/>
		/// If the -norecurse option had been specified then only constraint files found in the<br/>
		/// project_1 directory would have been added, but subdirectories would not be searched.<br/>
		/// The following example adds an existing IP core file to the current project:<br/>
		/// add_files -norecurse C:/Data/ip/c_addsub_v11_0_0.xci<br/>
		/// Note: Use the import_ip command to import the IP file into the local project folders.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example reads a top-level design netlist, and the char_fifo IP in a Non-Project<br/>
		/// Mode design:<br/>
		/// # Read top-level EDIF and IP DCP<br/>
		/// read_edif ./sources/wave_gen.edif<br/>
		/// add_files ./my_IP/char_fifo/char_fifo.xci<br/>
		/// Note: Either add_files or read_ip can be used reading in an IP core. All output products of the IP,<br/>
		/// including a design checkpoint ( DCP), will be read as needed.<br/>
		/// The following example adds an existing DSP module, created in System Generator, into the<br/>
		/// current project:<br/>
		/// add_files C:/Data/model1.mdl<br/>
		/// Note: Use the create_sysgen command to use System Generator to create a new DSP module.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 44<br/>
		/// </para>
		/// </summary>
		/// <param name="fileset">(Optional) Fileset name</param>
		/// <param name="of_objects">(Optional) Filesets or sub-designs or RMs to add the files to</param>
		/// <param name="norecurse">(Optional) Do not recursively search in specified directories</param>
		/// <param name="copy_to">(Optional) Copy the file to the specified directory before adding it to project</param>
		/// <param name="force">(Optional) Overwrite the existing file when -copy_to is used</param>
		/// <param name="scan_for_includes">(Optional) Scan and add any included files found in the fileset's RTL sources</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="files">
		/// <para>
		/// (Optional)<br/>
		/// Name of the files and/or directories to add. Must be<br/>
		/// specified if -scan_for_includes is not used.<br/>
		/// </para>
		/// </param>
		/// <returns>list of file objects that were added</returns>
		public VivadoTCL add_files(String fileset = null, TCLParameterList of_objects = null, bool? norecurse = null, String copy_to = null, bool? force = null, bool? scan_for_includes = null, bool? quiet = null, bool? verbose = null, TCLParameterList files = null)
		{
			// TCL Syntax: add_files [-fileset <arg>] [-of_objects <args>] [-norecurse] [-copy_to <arg>] [-force] [-scan_for_includes] [-quiet] [-verbose] [<files>...]
			this.Entry(_builder.add_files(fileset, of_objects, norecurse, copy_to, force, scan_for_includes, quiet, verbose, files));
			return this;
		}
		/// <summary>
		/// <para>
		/// Force value of signal, wire, or reg to a specified value<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: add_force [-radix &lt;arg&gt;] [-repeat_every &lt;arg&gt;] [-cancel_after &lt;arg&gt;] [-quiet] [-verbose] &lt;hdl_object&gt; &lt;values&gt;...
		/// <br/>
		/// <para>
		/// Force the value of a signal, wire, or reg to a certain value during simulation.<br/>
		/// The add_force command has the same effect as the Verilog force/release commands in<br/>
		/// the test bench or the module definition. It forces an HDL object to hold the specified value for<br/>
		/// the specified time, or until released by the -cancel_after option, or the remove_forces<br/>
		/// command.<br/>
		/// IMPORTANT! If there are Verilog force/release statements on an HDL object in the test bench or<br/>
		/// module, these commands are overridden by the Tcl add_force command. When the Tcl force expires or<br/>
		/// is released, the HDL object resumes normal operation in the simulation, including the application of any<br/>
		/// Verilog forces.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This command returns the name of the force object created, or returns an error if the command<br/>
		/// failed. The name of the returned force object is important when using the remove_forces<br/>
		/// command, and should be captured in a Tcl variable for later recall, as shown in the examples.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example forces the reset signal high at 300 nanoseconds, using the default radix,<br/>
		/// and captures the name of the returned force object in a Tcl variable which can be used to later<br/>
		/// remove the force:<br/>
		/// set for10 [ add_force reset 1 300 ]<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example shows the use of {&lt;value&gt; &lt;time&gt;} pairs, repeated periodically, and<br/>
		/// canceled after a specified time.<br/>
		/// add_force mySig {0} {1 50} {0 100} {1 150} -repeat_every 200<br/>
		/// -cancel_after 10000<br/>
		/// Note: In the preceding example, the first {&lt;value&gt; &lt;time&gt;} pair does not include a time. This indicates that<br/>
		/// the specified value, 0, is applied at time 0 (the current_time).<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 48<br/>
		/// </para>
		/// </summary>
		/// <param name="hdl_object">(Required) Specifies the object upon which to add a force</param>
		/// <param name="values">(Required) Adds a value and time offset to the force: {value [ time_offset ] }</param>
		/// <param name="radix">
		/// <para>
		/// (Optional)<br/>
		/// Specifies which radix to use. Allowed values are: default,<br/>
		/// dec, bin, oct, hex, unsigned, ascii, smag<br/>
		/// </para>
		/// </param>
		/// <param name="repeat_every">(Optional) Repeat every time duration</param>
		/// <param name="cancel_after">(Optional) Cancel after time offset</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The force objects added</returns>
		public VivadoTCL add_force(String hdl_object, TCLParameterList values, String radix = null, String repeat_every = null, String cancel_after = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: add_force [-radix <arg>] [-repeat_every <arg>] [-cancel_after <arg>] [-quiet] [-verbose] <hdl_object> <values>...
			this.Entry(_builder.add_force(hdl_object, values, radix, repeat_every, cancel_after, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Select Pseudo Channel to add to Activity Monitor on the specified hardware HBM(s). Must<br/>
		/// specify the Memory Controller number first, follow by Pseudo Channel number.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: add_hw_hbm_pc [-quiet] [-verbose] &lt;mc_num&gt; &lt;pc_num&gt; &lt;hw_objects&gt;
		/// <br/>
		/// <para>
		/// The HBM activity monitor (amon) can be used to gain real-time access to performance<br/>
		/// monitoring and temperature sensors certain Xilinx® UltraScale+ devices that include an<br/>
		/// integrated High-Bandwidth Memory (HBM) controller. Refer to the LogiCore IP Product Guide:<br/>
		/// AXI High Bandwidth Memory Controller (PG276) for more information on this core. The HBM<br/>
		/// controller and memory stacks contain both performance counters and temperature sensors that<br/>
		/// can be accessed through the HBM activity monitor from within the Xilinx Vivado hardware<br/>
		/// manager. Each HBM stack is split into eight independent memory channels, each of which is<br/>
		/// further divided into two 64-bit pseudo channels (pc).<br/>
		/// After configuring an HBM enabled device with a design that contains instances of the AXI High<br/>
		/// Bandwidth Memory Controller, the HBM cores will be visible in the Vivado hardware manager.<br/>
		/// The add_hw_hbm_pc command lets you specify a memory channel (mc)/psuedo channel (pc) to<br/>
		/// monitor in the HBM activity monitor prior to using the run_hw_hbm_amon command.<br/>
		/// TIP: The HBM activity monitor must not be running when adding or removing psuedo channels.<br/>
		/// This command returns nothing if successful, or returns an error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example adds the specified memory channels/psuedo channels on the defined<br/>
		/// HBM controller (hw_hbm) object, and then runs the HBM activity monitor in the Vivado<br/>
		/// hardware manager:<br/>
		/// set hbm_mon [get_hw_hbms *HBM_2]<br/>
		/// add_hw_hbm_pc 0 0 $hbm_mon<br/>
		/// add_hw_hbm_pc 0 1 $hbm_mon<br/>
		/// add_hw_hbm_pc 1 0 $hbm_mon<br/>
		/// add_hw_hbm_pc 1 1 $hbm_mon<br/>
		/// add_hw_hbm_pc 2 0 $hbm_mon<br/>
		/// add_hw_hbm_pc 2 1 $hbm_mon<br/>
		/// add_hw_hbm_pc 3 0 $hbm_mon<br/>
		/// add_hw_hbm_pc 3 1 $hbm_mon<br/>
		/// run_hw_hbm_amon $hbm_mon<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 52<br/>
		/// </para>
		/// </summary>
		/// <param name="mc_num">(Required) Memory Controller number to select: 0 to 7</param>
		/// <param name="pc_num">(Required) Pseudo Channel number to select: 0 or 1</param>
		/// <param name="hw_objects">(Required) hardware objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL add_hw_hbm_pc(String mc_num, String pc_num, String hw_objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: add_hw_hbm_pc [-quiet] [-verbose] <mc_num> <pc_num> <hw_objects>
			this.Entry(_builder.add_hw_hbm_pc(mc_num, pc_num, hw_objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Add an enumerated name-value pair to a hw_probe enumeration.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: add_hw_probe_enum [-no_gui_update] [-dict &lt;args&gt;] [-quiet] [-verbose] &lt;name&gt; &lt;value&gt; &lt;hw_probe&gt;
		/// <br/>
		/// <para>
		/// Assign enumerated name/value pairs to specified hardware probe objects.<br/>
		/// This command is intended to make it easier to monitor the states of signals in the Vivado logic<br/>
		/// analyzer. The command lets you define a set of states, or enumerated names to be associated<br/>
		/// with specific values that may be found on a hw_probe object. This lets you monitor state<br/>
		/// machine probes and some other types of probes, by comparing symbolic names with trigger<br/>
		/// values and waveform data values.<br/>
		/// The enumerated name is added as an ENUM.NAME property on the specified hw_probe object,<br/>
		/// and associated with the specified bit value on the probe. Enumerated names can be used to<br/>
		/// specify trigger/capture compare values for hw_probes.<br/>
		/// TIP: Enumerated names are displayed in the waveform viewer of the Vivado logic analyzer. Display of the<br/>
		/// enumerated names can be disabled on a per probe basis. Refer to the Vivado Design Suite User Guide:<br/>
		/// Programming and Debugging (UG908) for more information on the waveform viewer.<br/>
		/// This command returns the enumerated name property, or returns an error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example uses the -dict option to define the enumerated name/value pairs for<br/>
		/// the specified hw_probe object:<br/>
		/// add_hw_probe_enum -dict {ZERO eq5'h00 RED eq5'h12 GREEN eq5'h13 \<br/>
		/// BLUE eq5'h14 WHITE eq5'h15 YELLOW eq5'h16 GREY eq5'h17} \<br/>
		/// [get_hw_probes op1 -of_objects [current_hw_ila]]<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example defines the enumerated name/value pairs for the specified hw_probe<br/>
		/// object:<br/>
		/// add_hw_probe_enum ZERO eq5'h00 [get_hw_probes op1 \<br/>
		/// -of_objects [current_hw_ila]]<br/>
		/// add_hw_probe_enum RED eq5'h12 [get_hw_probes op1 \<br/>
		/// -of_objects [current_hw_ila]]<br/>
		/// add_hw_probe_enum GREEN eq5'h13 [get_hw_probes op1 \<br/>
		/// -of_objects [current_hw_ila]]<br/>
		/// add_hw_probe_enum BLUE eq5'h14 [get_hw_probes op1 \<br/>
		/// -of_objects [current_hw_ila]]<br/>
		/// add_hw_probe_enum WHITE eq5'h15 [get_hw_probes op1 \<br/>
		/// -of_objects [current_hw_ila]]<br/>
		/// add_hw_probe_enum YELLOW eq5'h16 [get_hw_probes op1 \<br/>
		/// -of_objects [current_hw_ila]]<br/>
		/// add_hw_probe_enum GREY eq5'h17 [get_hw_probes op1 \<br/>
		/// -of_objects [current_hw_ila]]<br/>
		/// The following example returns the ENUM property assigned to the specified hw_probe object:<br/>
		/// report_property [get_hw_probes op1 -of_objects [current_hw_ila]] ENUM*<br/>
		/// Property Type Read-only Visible Value<br/>
		/// ENUM.ZERO string true true eq5'h00<br/>
		/// ENUM.RED string true true eq5'h12<br/>
		/// ENUM.GREEN string true true eq5'h13<br/>
		/// ENUM.BLUE string true true eq5'h14<br/>
		/// ENUM.WHITE string true true eq5'h15<br/>
		/// ENUM.YELLOW string true true eq5'h16<br/>
		/// ENUM.GREY string true true eq5'h17<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 54<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Enumerated name.</param>
		/// <param name="value">(Required) Explicit value.</param>
		/// <param name="hw_probe">(Required) hw_probe object.</param>
		/// <param name="no_gui_update">(Optional) Defer GUI update.</param>
		/// <param name="dict">(Optional) List of parameter name-value pairs.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL add_hw_probe_enum(String name, String value, String hw_probe, bool? no_gui_update = null, TCLParameterList dict = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: add_hw_probe_enum [-no_gui_update] [-dict <args>] [-quiet] [-verbose] <name> <value> <hw_probe>
			this.Entry(_builder.add_hw_probe_enum(name, value, hw_probe, no_gui_update, dict, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Add a new bus interface to a peripheral.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: add_peripheral_interface -interface_mode &lt;arg&gt; -axi_type &lt;arg&gt; [-quiet] [-verbose] &lt;name&gt; &lt;peripheral&gt;
		/// <br/>
		/// <para>
		/// Add an AXI bus interface to a peripheral created with the create_peripheral command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 57<br/>
		/// </para>
		/// </summary>
		/// <param name="interface_mode">(Required) Mode of an interface, supported option - master,slave.</param>
		/// <param name="axi_type">(Required) Type of a axi interface, supported option - lite,full,stream.</param>
		/// <param name="name">(Required) Name to initialize the newly added element e.g S1_AXI, M1_AXI</param>
		/// <param name="peripheral">(Required) Peripheral object</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL add_peripheral_interface(String interface_mode, String axi_type, String name, String peripheral, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: add_peripheral_interface -interface_mode <arg> -axi_type <arg> [-quiet] [-verbose] <name> <peripheral>
			this.Entry(_builder.add_peripheral_interface(interface_mode, axi_type, name, peripheral, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Add power sources to power Rail<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: add_to_power_rail [-power_sources &lt;args&gt;] [-quiet] [-verbose] &lt;power_rail&gt;
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 59<br/>
		/// </para>
		/// </summary>
		/// <param name="power_rail">(Required) Power rail to add sources to</param>
		/// <param name="power_sources">(Optional) List of power_sources to add. Can be power rails and/or power supplies</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL add_to_power_rail(String power_rail, TCLParameterList power_sources = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: add_to_power_rail [-power_sources <args>] [-quiet] [-verbose] <power_rail>
			this.Entry(_builder.add_to_power_rail(power_rail, power_sources, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Add new waves<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: add_wave [-into &lt;args&gt;] [-at_wave &lt;args&gt;] [-after_wave &lt;args&gt;] [-before_wave &lt;args&gt;] [-reverse] [-radix &lt;arg&gt;] [-color &lt;arg&gt;] [-name &lt;arg&gt;] [-recursive] [-r] [-regexp] [-nocase] [-quiet] [-verbose] &lt;items&gt;...
		/// <br/>
		/// <para>
		/// The add_wave command creates one or more new design-based wave objects.<br/>
		/// This command returns the name of the newly-created wave object(s).<br/>
		/// Note: This command can only be used when running a simulation. At a minimum, you must specify an<br/>
		/// item, which is an HDL object (signal) within the simulation project. In the Vivado interface, the object<br/>
		/// would display in the Objects Window.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example defines a wave group, defines a color for that group, and adds all signals<br/>
		/// that begin with the letter 's', and has at least one character following it followed by 0 or more<br/>
		/// characters, to the wave window in the wave group:<br/>
		/// set groupColor YELLOW<br/>
		/// set AXIS_ID [add_wave_group "Streaming Data"]<br/>
		/// add_wave -into $AXIS_ID -color $groupColor -regexp s.*<br/>
		/// Add the dout_tvalid signal from the rsb_design_testbench to the existing simulation waveform<br/>
		/// configuration:<br/>
		/// add_wave dout_tvalid /rsb_design_testbench/dout_tvalid<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 60<br/>
		/// </para>
		/// </summary>
		/// <param name="items">
		/// <para>
		/// (Required)<br/>
		/// the design objects from which to create wave objects<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// </param>
		/// <param name="into">
		/// <para>
		/// (Optional)<br/>
		/// the wave configuration, group, or virtual bus into which the<br/>
		/// new wave object(s) will be inserted.<br/>
		/// </para>
		/// </param>
		/// <param name="at_wave">
		/// <para>
		/// (Optional)<br/>
		/// inserts the new wave object(s) into the specified wave<br/>
		/// object, or after the specified wave object if not a group or<br/>
		/// virtual bus<br/>
		/// </para>
		/// </param>
		/// <param name="after_wave">(Optional) inserts the new wave objects(s) after the specified wave object</param>
		/// <param name="before_wave">(Optional) inserts the new wave objects(s) before the specified wave object</param>
		/// <param name="reverse">(Optional) reverses the displayed bit order of the new wave objects(s)</param>
		/// <param name="radix">
		/// <para>
		/// (Optional)<br/>
		/// sets the displayed radix of the new wave object(s) to the<br/>
		/// specified radix. Allowed values are: default, dec, bin, oct,<br/>
		/// hex, unsigned, ascii, smag<br/>
		/// </para>
		/// </param>
		/// <param name="color">
		/// <para>
		/// (Optional)<br/>
		/// sets the displayed color of the new wave object(s) to the<br/>
		/// specified color, which can be a standard color name or a<br/>
		/// string of the form #RRGGBB<br/>
		/// </para>
		/// </param>
		/// <param name="name">
		/// <para>
		/// (Optional)<br/>
		/// sets the displayed name of the single new wave object to<br/>
		/// the specified string<br/>
		/// </para>
		/// </param>
		/// <param name="recursive">
		/// <para>
		/// (Optional)<br/>
		/// if the design object is a scope, this option specifies that<br/>
		/// wave objects for all design objects under that scope should<br/>
		/// be created<br/>
		/// </para>
		/// </param>
		/// <param name="r">
		/// <para>
		/// (Optional)<br/>
		/// if the design object is a scope, this option specifies that<br/>
		/// wave objects for all design objects under that scope should<br/>
		/// be created<br/>
		/// </para>
		/// </param>
		/// <param name="regexp">(Optional) interprets &lt;items&gt; using regular expressions</param>
		/// <param name="nocase">(Optional) only when regexp is used, performs a case insensitive match</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The new waves</returns>
		public VivadoTCL add_wave(TCLParameterList items, TCLParameterList into = null, TCLParameterList at_wave = null, TCLParameterList after_wave = null, TCLParameterList before_wave = null, bool? reverse = null, String radix = null, String color = null, String name = null, bool? recursive = null, bool? r = null, bool? regexp = null, bool? nocase = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: add_wave [-into <args>] [-at_wave <args>] [-after_wave <args>] [-before_wave <args>] [-reverse] [-radix <arg>] [-color <arg>] [-name <arg>] [-recursive] [-r] [-regexp] [-nocase] [-quiet] [-verbose] <items>...
			this.Entry(_builder.add_wave(items, into, at_wave, after_wave, before_wave, reverse, radix, color, name, recursive, r, regexp, nocase, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Add a new divider<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: add_wave_divider [-into &lt;args&gt;] [-at_wave &lt;args&gt;] [-after_wave &lt;args&gt;] [-before_wave &lt;args&gt;] [-color &lt;arg&gt;] [-quiet] [-verbose] [&lt;name&gt;]
		/// <br/>
		/// <para>
		/// Creates a wave divider in the wave form viewer. The wave divider can be used to separate<br/>
		/// groups of related objects, for easier viewing.<br/>
		/// The wave divider can be added into a specified or current waveform configuration (WCFG) at the<br/>
		/// specified location. If no location is specified the wave divider is inserted at the end of the<br/>
		/// waveform configuration.<br/>
		/// This command returns the name of the newly-created wave divider.<br/>
		/// Note: This command can only be used when running a simulation.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example inserts a wave divider named Div1, after the CLK wave object:<br/>
		/// add_wave_divider -after_wave CLK Div1<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 63<br/>
		/// </para>
		/// </summary>
		/// <param name="into">
		/// <para>
		/// (Optional)<br/>
		/// the wave configuration or group into which the new divider<br/>
		/// will be inserted.<br/>
		/// </para>
		/// </param>
		/// <param name="at_wave">
		/// <para>
		/// (Optional)<br/>
		/// inserts the new divider into the specified wave object, or<br/>
		/// after the specified wave object if not a group<br/>
		/// </para>
		/// </param>
		/// <param name="after_wave">(Optional) inserts the new divider after the specified wave object</param>
		/// <param name="before_wave">(Optional) inserts the new divider before the specified wave object</param>
		/// <param name="color">
		/// <para>
		/// (Optional)<br/>
		/// sets the displayed color of the new divider to the specified<br/>
		/// color, which can be a standard color name or a string of the<br/>
		/// form #RRGGBB Default: default<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="name">
		/// <para>
		/// (Optional)<br/>
		/// the displayed name of the new divider to the specified<br/>
		/// string Default: new_divider<br/>
		/// </para>
		/// </param>
		/// <returns>The new divider</returns>
		public VivadoTCL add_wave_divider(TCLParameterList into = null, TCLParameterList at_wave = null, TCLParameterList after_wave = null, TCLParameterList before_wave = null, String color = null, bool? quiet = null, bool? verbose = null, String name = null)
		{
			// TCL Syntax: add_wave_divider [-into <args>] [-at_wave <args>] [-after_wave <args>] [-before_wave <args>] [-color <arg>] [-quiet] [-verbose] [<name>]
			this.Entry(_builder.add_wave_divider(into, at_wave, after_wave, before_wave, color, quiet, verbose, name));
			return this;
		}
		/// <summary>
		/// <para>
		/// Add a new group<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: add_wave_group [-into &lt;args&gt;] [-at_wave &lt;args&gt;] [-after_wave &lt;args&gt;] [-before_wave &lt;args&gt;] [-quiet] [-verbose] [&lt;name&gt;]
		/// <br/>
		/// <para>
		/// Creates a wave group into a specified or current waveform configuration. New wave objects and<br/>
		/// wave_dividers can be added into the wave group to build up the waveform display.<br/>
		/// The wave group can be inserted at a specified location. If no location is specified the group is<br/>
		/// inserted at the end of the specified waveform configuration.<br/>
		/// The command returns the name of the newly created wave group object.<br/>
		/// Note: This command can only be used when running a simulation.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// Add a clk to the existing waveform configuration:<br/>
		/// add_wave_group clk<br/>
		/// group10<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 65<br/>
		/// </para>
		/// </summary>
		/// <param name="into">
		/// <para>
		/// (Optional)<br/>
		/// the wave configuration or group into which the new group<br/>
		/// will be inserted.<br/>
		/// </para>
		/// </param>
		/// <param name="at_wave">
		/// <para>
		/// (Optional)<br/>
		/// inserts the new group into the specified wave object, or<br/>
		/// after the specified wave object if not a group<br/>
		/// </para>
		/// </param>
		/// <param name="after_wave">(Optional) inserts the new group after the specified wave object</param>
		/// <param name="before_wave">(Optional) inserts the new group before the specified wave object</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="name">
		/// <para>
		/// (Optional)<br/>
		/// the displayed name of the new group to the specified string<br/>
		/// Default: new_group<br/>
		/// </para>
		/// </param>
		/// <returns>The new group</returns>
		public VivadoTCL add_wave_group(TCLParameterList into = null, TCLParameterList at_wave = null, TCLParameterList after_wave = null, TCLParameterList before_wave = null, bool? quiet = null, bool? verbose = null, String name = null)
		{
			// TCL Syntax: add_wave_group [-into <args>] [-at_wave <args>] [-after_wave <args>] [-before_wave <args>] [-quiet] [-verbose] [<name>]
			this.Entry(_builder.add_wave_group(into, at_wave, after_wave, before_wave, quiet, verbose, name));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a new wave marker<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: add_wave_marker [-into &lt;arg&gt;] [-name &lt;arg&gt;] [-quiet] [-verbose] [&lt;time&gt;] [&lt;unit&gt;]
		/// <br/>
		/// <para>
		/// Creates a wave marker at the specified time and of the specified name in the current waveform<br/>
		/// configuration.<br/>
		/// This command returns nothing.<br/>
		/// Note: This command can only be used when running a simulation.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// Add a marker to the existing waveform configuration at 500ns:<br/>
		/// add_wave_marker 500 ns<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 67<br/>
		/// </para>
		/// </summary>
		/// <param name="into">(Optional) the wave configuration in which to create the marker</param>
		/// <param name="name">(Optional) sets the name of the new marker to the specified string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="time">(Optional) the numerical portion of the new marker's time Default: 0</param>
		/// <param name="unit">
		/// <para>
		/// (Optional)<br/>
		/// the time unit portion of the new marker's time. Allowed<br/>
		/// values are fs, ps, ns, us, ms, and s.<br/>
		/// </para>
		/// </param>
		/// <returns>The new created marker</returns>
		public VivadoTCL add_wave_marker(String into = null, String name = null, bool? quiet = null, bool? verbose = null, String time = null, String unit = null)
		{
			// TCL Syntax: add_wave_marker [-into <arg>] [-name <arg>] [-quiet] [-verbose] [<time>] [<unit>]
			this.Entry(_builder.add_wave_marker(into, name, quiet, verbose, time, unit));
			return this;
		}
		/// <summary>
		/// <para>
		/// Add a new virtual bus<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: add_wave_virtual_bus [-into &lt;args&gt;] [-at_wave &lt;args&gt;] [-after_wave &lt;args&gt;] [-before_wave &lt;args&gt;] [-reverse] [-radix &lt;arg&gt;] [-color &lt;arg&gt;] [-quiet] [-verbose] [&lt;name&gt;]
		/// <br/>
		/// <para>
		/// The add_wave_virtual_bus command creates a new virtual bus of the specified &lt;name&gt;.<br/>
		/// The command inserts the virtual bus into the wave configuration (WCFG) where specified, or by<br/>
		/// default at the bottom of the existing WCFG. It returns a vb### for the newly-created virtual bus.<br/>
		/// Note: This command can only be used when running a simulation. At a minimum, you must specify a name,<br/>
		/// which is the name of the new virtual bus<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// Add a virtual bus of the name dout_tvalid to the end of the current waveform configuration:<br/>
		/// add_wave_virtual_bus dout_tvalid<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 69<br/>
		/// </para>
		/// </summary>
		/// <param name="into">
		/// <para>
		/// (Optional)<br/>
		/// the wave configuration, group, or virtual bus into which the<br/>
		/// new virtual bus will be inserted.<br/>
		/// </para>
		/// </param>
		/// <param name="at_wave">
		/// <para>
		/// (Optional)<br/>
		/// inserts the new virtual bus into the specified wave object, or<br/>
		/// after the specified wave object if not a group or virtual bus<br/>
		/// </para>
		/// </param>
		/// <param name="after_wave">(Optional) inserts the new virtual bus after the specified wave object</param>
		/// <param name="before_wave">(Optional) inserts the new virtual bus before the specified wave object</param>
		/// <param name="reverse">(Optional) reverses the displayed bit order of the new virtual bus</param>
		/// <param name="radix">
		/// <para>
		/// (Optional)<br/>
		/// sets the displayed radix of the new virtual bus to the<br/>
		/// specified radix. Allowed values are: default, dec, bin, oct,<br/>
		/// hex, unsigned, ascii, smag<br/>
		/// </para>
		/// </param>
		/// <param name="color">
		/// <para>
		/// (Optional)<br/>
		/// sets the displayed color of the new virtual bus to the<br/>
		/// specified color, which can be a standard color name or a<br/>
		/// string of the form #RRGGBB Default: default<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="name">
		/// <para>
		/// (Optional)<br/>
		/// the displayed name of the new virtual bus to the specified<br/>
		/// string Default: new_virtual_bus<br/>
		/// </para>
		/// </param>
		/// <returns>The new virtual bus</returns>
		public VivadoTCL add_wave_virtual_bus(TCLParameterList into = null, TCLParameterList at_wave = null, TCLParameterList after_wave = null, TCLParameterList before_wave = null, bool? reverse = null, String radix = null, String color = null, bool? quiet = null, bool? verbose = null, String name = null)
		{
			// TCL Syntax: add_wave_virtual_bus [-into <args>] [-at_wave <args>] [-after_wave <args>] [-before_wave <args>] [-reverse] [-radix <arg>] [-color <arg>] [-quiet] [-verbose] [<name>]
			this.Entry(_builder.add_wave_virtual_bus(into, at_wave, after_wave, before_wave, reverse, radix, color, quiet, verbose, name));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of all clocks in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: all_clocks [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Returns a list of all clocks that have been declared in the current design.<br/>
		/// To get a list of specific clocks in the design, use the get_clocks command, or use the filter<br/>
		/// command to filter the results returned by all_clocks.<br/>
		/// Clocks can be defined by using the create_clock or create_generated_clock<br/>
		/// commands.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example shows all clocks in the sample CPU netlist project:<br/>
		/// % all_clocks<br/>
		/// cpuClk wbClk usbClk phy_clk_pad_0_i phy_clk_pad_1_i fftClk<br/>
		/// The following example applies the set_propagated_clock command to all clocks, and also<br/>
		/// demonstrates how the returned list (all_clocks) can be passed to another command:<br/>
		/// % set_propagated_clock [all_clocks]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 72<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of clock objects</returns>
		public VivadoTCL all_clocks(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: all_clocks [-quiet] [-verbose]
			this.Entry(_builder.all_clocks(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of cpu cells in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: all_cpus [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Returns a list of all CPU cell objects in the current design. Creates a list of all the CPU cell objects<br/>
		/// that have been declared in the current design.<br/>
		/// The list of CPUs returned by all_cpus can also be limited or reduced by the filter command<br/>
		/// to filter according to properties assigned to the CPU cell objects. Properties of an object can be<br/>
		/// returned by the list_property or report_property commands.<br/>
		/// The all_cpus command is scoped to return the objects hierarchically, from the top-level of the<br/>
		/// design or from the level of the current instance. By default the current instance is defined as the<br/>
		/// top level of the design, but can be changed by using the current_instance command.<br/>
		/// Note: This command returns a list of CPU cell objects<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns all CPU objects in the current design:<br/>
		/// all_cpus<br/>
		/// The following example shows how the list returned can be passed to another command:<br/>
		/// set_false_path -from [all_cpus] -to [all_registers]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 74<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of cpu cell objects</returns>
		public VivadoTCL all_cpus(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: all_cpus [-quiet] [-verbose]
			this.Entry(_builder.all_cpus(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of dsp cells in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: all_dsps [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Returns a list of all DSP cell objects that have been declared in the current design.<br/>
		/// The list of DSPs returned by all_dsps can also be limited or reduced by the filter command<br/>
		/// to filter according to properties assigned to the DSP objects. Properties of an object can be<br/>
		/// returned by the list_property or report_property commands.<br/>
		/// The all_dsps command is scoped to return the objects hierarchically, from the top-level of the<br/>
		/// design or from the level of the current instance. By default the current instance is defined as the<br/>
		/// top level of the design, but can be changed by using the current_instance command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns a list of all DSPs defined in the current design, and filters that list<br/>
		/// to return a single DSP assigned to the specified SITE:<br/>
		/// filter [all_dsps] {SITE == DSP48_X1Y6}<br/>
		/// The following example shows how the list returned can be passed to another command:<br/>
		/// set_false_path -from [all_dsps] -to [all_registers]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 76<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of dsp cell objects</returns>
		public VivadoTCL all_dsps(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: all_dsps [-quiet] [-verbose]
			this.Entry(_builder.all_dsps(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of pins or cells in fanin of specified sinks<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: all_fanin [-startpoints_only] [-flat] [-only_cells] [-levels &lt;arg&gt;] [-pin_levels &lt;arg&gt;] [-trace_arcs &lt;arg&gt;] [-quiet] [-verbose] &lt;to&gt;
		/// <br/>
		/// <para>
		/// Returns a list of port, pin or cell objects in the fan-in of the specified sinks.<br/>
		/// The all_fanin command is scoped to return objects from current level of the hierarchy of the<br/>
		/// design, either from the top-level or from the level of the current instance. By default the current<br/>
		/// instance is defined as the top level of the design, but can be changed by using the<br/>
		/// current_instance command. To return the fan-in across all levels of the hierarchy, use the -<br/>
		/// flat option.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example lists the timing fan-in of the led_pins output port:<br/>
		/// all_fanin [get_ports led_pins[*] ]<br/>
		/// The following example traces back from the clock pin of the specified flip- flop to the clock<br/>
		/// source (an MMCM output pin in this example):<br/>
		/// all_fanin -flat -startpoints_only [get_pins cmd_parse_i0/prescale_reg[7]/C]<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following examples returns the ports connected to the input pins of IDELAYs, ignoring the<br/>
		/// hierarchy of the design:<br/>
		/// all_fanin -flat -startpoints_only [get_pins IDELAY*/IDATAIN]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 78<br/>
		/// </para>
		/// </summary>
		/// <param name="to">(Required) List of sink pins, ports, or nets</param>
		/// <param name="startpoints_only">(Optional) Find only the timing startpoints</param>
		/// <param name="flat">(Optional) Hierarchy is ignored</param>
		/// <param name="only_cells">(Optional) Only cells</param>
		/// <param name="levels">(Optional) Maximum number of cell levels to traverse:Value &gt;= 0 Default: 0</param>
		/// <param name="pin_levels">(Optional) Maximum number of pin levels to traverse:Value &gt;= 0 Default: 0</param>
		/// <param name="trace_arcs">(Optional) Type of network arcs to trace: Values: timing, enabled, all</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of cell or pin objects</returns>
		public VivadoTCL all_fanin(String to, bool? startpoints_only = null, bool? flat = null, bool? only_cells = null, Int32? levels = null, Int32? pin_levels = null, all_fanin_trace_arcs? trace_arcs = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: all_fanin [-startpoints_only] [-flat] [-only_cells] [-levels <arg>] [-pin_levels <arg>] [-trace_arcs <arg>] [-quiet] [-verbose] <to>
			this.Entry(_builder.all_fanin(to, startpoints_only, flat, only_cells, levels, pin_levels, trace_arcs, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of pins or cells in fanout of specified sources<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: all_fanout [-endpoints_only] [-flat] [-only_cells] [-levels &lt;arg&gt;] [-pin_levels &lt;arg&gt;] [-trace_arcs &lt;arg&gt;] [-quiet] [-verbose] &lt;from&gt;
		/// <br/>
		/// <para>
		/// Returns a list of port, pin, or cell objects in the fanout of the specified sources.<br/>
		/// The all_fanout command is scoped to return objects from current level of the hierarchy of the<br/>
		/// design, either from the top-level or from the level of the current instance. By default the current<br/>
		/// instance is defined as the top level of the design, but can be changed by using the<br/>
		/// current_instance command. To return the fanout across all levels of the hierarchy, use the -<br/>
		/// flat option.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets the fanout for all input ports in the design:<br/>
		/// all_fanout [all_inputs]<br/>
		/// This example gets the fanout for all inputs assigned to I/O Bank 15 in the current design:<br/>
		/// all_fanout [filter [all_inputs] {IOBANK == 15}]<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 81<br/>
		/// </para>
		/// </summary>
		/// <param name="from">(Required) List of source pins, ports, or nets</param>
		/// <param name="endpoints_only">(Optional) Find only the timing endpoints</param>
		/// <param name="flat">(Optional) Hierarchy is ignored</param>
		/// <param name="only_cells">(Optional) Only cells</param>
		/// <param name="levels">(Optional) Maximum number of cell levels to traverse:Value &gt;= 0 Default: 0</param>
		/// <param name="pin_levels">(Optional) Maximum number of pin levels to traverse:Value &gt;= 0 Default: 0</param>
		/// <param name="trace_arcs">(Optional) Type of network arcs to trace: Values: timing, enabled, all</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of cell or pin objects</returns>
		public VivadoTCL all_fanout(String from, bool? endpoints_only = null, bool? flat = null, bool? only_cells = null, Int32? levels = null, Int32? pin_levels = null, all_fanout_trace_arcs? trace_arcs = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: all_fanout [-endpoints_only] [-flat] [-only_cells] [-levels <arg>] [-pin_levels <arg>] [-trace_arcs <arg>] [-quiet] [-verbose] <from>
			this.Entry(_builder.all_fanout(from, endpoints_only, flat, only_cells, levels, pin_levels, trace_arcs, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of flip flop cells in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: all_ffs [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Returns a list of all flip flop instances in the current design.<br/>
		/// You can use the get_cells command, or use the filter command to limit the results from<br/>
		/// the all_ffs command to return a list of flip-flop cells matching the specified properties.<br/>
		/// The all_ffs command is scoped to return the objects hierarchically, from the top-level of the<br/>
		/// design or from the level of the current instance. By default the current instance is defined as the<br/>
		/// top level of the design, but can be changed by using the current_instance command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the count of all flops in the design, then returns the count of all<br/>
		/// flops in the fftEngine module:<br/>
		/// current_instance<br/>
		/// INFO: [Vivado 12-618] Current instance is the top level of design<br/>
		/// 'netlist_1'.<br/>
		/// top<br/>
		/// llength [all_ffs]<br/>
		/// 15741<br/>
		/// current_instance fftEngine<br/>
		/// fftEngine<br/>
		/// llength [all_ffs]<br/>
		/// 1519<br/>
		/// This example filters the results of all_ffs to return only the FDRE flops:<br/>
		/// filter [all_ffs] {REF_NAME == FDRE}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 84<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of flip flop cell objects</returns>
		public VivadoTCL all_ffs(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: all_ffs [-quiet] [-verbose]
			this.Entry(_builder.all_ffs(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of hsio cells in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: all_hsios [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Returns a list of all High Speed IO (HSIO) cell objects that have been declared in the current<br/>
		/// design. These HSIO cell objects can be assigned to a variable or passed into another command.<br/>
		/// The list of high-speed IOs returned by all_hsios can also be limited or reduced by the<br/>
		/// filter command to filter according to properties assigned to the HSIO objects. Properties of<br/>
		/// an object can be returned by the list_property or report_property commands.<br/>
		/// The all_hsios command is scoped to return the objects hierarchically, from the top-level of<br/>
		/// the design or from the level of the current instance. By default the current instance is defined as<br/>
		/// the top level of the design, but can be changed by using the current_instance command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns all HSIO objects in the current design:<br/>
		/// all_hsios<br/>
		/// The following example shows how the list returned can be directly passed to another command:<br/>
		/// set_false_path -from [all_hsios] -to [all_registers]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 86<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of hsio cell objects</returns>
		public VivadoTCL all_hsios(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: all_hsios [-quiet] [-verbose]
			this.Entry(_builder.all_hsios(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of all input ports in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: all_inputs [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Returns a list of all input port objects in the current design.<br/>
		/// To get a list of specific inputs in the design, use the get_ports command, or use the filter<br/>
		/// command to filter the results returned by all_inputs.<br/>
		/// The all_inputs command is scoped to return the objects hierarchically, from the top-level of<br/>
		/// the design or from the level of the current instance. By default the current instance is defined as<br/>
		/// the top level of the design, but can be changed by using the current_instance command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns all input port objects in the current design:<br/>
		/// all_inputs<br/>
		/// This example gets all input port objects, filters out the GT ports, and sets the IOSTANDARD<br/>
		/// property for the non-GT ports:<br/>
		/// set non_gt_ports [filter [all_inputs] {!is_gt_term}]<br/>
		/// set_property IOSTANDARD LVCMOS18 $non_gt_ports<br/>
		/// The following example shows how the list returned can be passed to another command:<br/>
		/// set_input_delay 5 -clock REFCLK [all_inputs]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 88<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of port objects</returns>
		public VivadoTCL all_inputs(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: all_inputs [-quiet] [-verbose]
			this.Entry(_builder.all_inputs(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of all latch cells in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: all_latches [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Returns a list of all latches that have been declared in the current design.<br/>
		/// The list of latches returned by all_latches can also be limited or reduced by the filter<br/>
		/// command to filter according to properties assigned to the latches. Properties of an object can be<br/>
		/// returned by the list_property or report_property commands.<br/>
		/// The all_latches command is scoped to return the objects hierarchically, from the top-level of<br/>
		/// the design or from the level of the current instance. By default the current instance is defined as<br/>
		/// the top level of the design, but can be changed by using the current_instance command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns a list of all latches in the current design:<br/>
		/// all_latches<br/>
		/// The following example shows how the list returned can be passed to another command:<br/>
		/// set_false_path -from [all_mults] -to [all_latches]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 90<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of latch cell objects</returns>
		public VivadoTCL all_latches(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: all_latches [-quiet] [-verbose]
			this.Entry(_builder.all_latches(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of all output ports in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: all_outputs [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Returns a list of all output port objects that have been declared in the current design.<br/>
		/// To get a list of specific outputs in the design, use the get_ports command, or use the filter<br/>
		/// command to filter the results returned by all_outputs.<br/>
		/// The all_outputs command is scoped to return the objects hierarchically, from the top-level of<br/>
		/// the design or from the level of the current instance. By default the current instance is defined as<br/>
		/// the top level of the design, but can be changed by using the current_instance command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns all the output ports in the current design:<br/>
		/// all_outputs<br/>
		/// The following example sets the output delay for all outputs in the design:<br/>
		/// set_output_delay 5 -clock REFCLK [all_outputs]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 92<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of port objects</returns>
		public VivadoTCL all_outputs(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: all_outputs [-quiet] [-verbose]
			this.Entry(_builder.all_outputs(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of ram cells in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: all_rams [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Returns a list of all the RAM cell objects present in the current instance, including Block RAMS,<br/>
		/// Block RAM FIFOs, and Distributed RAMS. These RAM cell objects can be assigned to a variable<br/>
		/// or passed into another command.<br/>
		/// To get a list of specific RAM cells in the design, use the filter command to filter the results<br/>
		/// returned by all_rams based on properties assigned to the RAM cells. Properties of an object<br/>
		/// can be returned by the list_property or report_property commands.<br/>
		/// The all_rams command is scoped to return the objects hierarchically, from the top-level of the<br/>
		/// design or from the level of the current instance. By default the current instance is defined as the<br/>
		/// top level of the design, but can be changed by using the current_instance command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns all RAM cells in the design:<br/>
		/// all_rams<br/>
		/// This example returns all RAM cells in the design, and filters the results to return only the FIFO<br/>
		/// block memories:<br/>
		/// filter [all_rams] {PRIMITIVE_SUBGROUP == fifo}<br/>
		/// The following example sets the current instance, and returns all RAM objects hierarchically from<br/>
		/// the level of the current instance:<br/>
		/// current_instance usbEngine0<br/>
		/// all_rams<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 94<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of ram cell objects</returns>
		public VivadoTCL all_rams(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: all_rams [-quiet] [-verbose]
			this.Entry(_builder.all_rams(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of register cells or pins in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: all_registers [-clock &lt;args&gt;] [-rise_clock &lt;args&gt;] [-fall_clock &lt;args&gt;] [-cells] [-data_pins] [-clock_pins] [-async_pins] [-output_pins] [-level_sensitive] [-edge_triggered] [-no_hierarchy] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Returns a list of sequential register cells or register pins in the current design.<br/>
		/// TIP: Returned objects includes DSPs and BRAMs as they contain internal registers.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The list of returned objects can be limited by the use of the arguments described below. You can<br/>
		/// limit the list of registers returned to a specific clock or clocks, or to registers triggered by the<br/>
		/// rising or falling edge of a specified clock.<br/>
		/// The list of registers returned by all_registers can also be limited or reduced by the filter<br/>
		/// command to filter according to properties assigned to the registers. Properties of an object can<br/>
		/// be returned by the list_property or report_property commands.<br/>
		/// You can also get a list of the pins of collected registers instead of the register objects by<br/>
		/// specifying one or more of the pin arguments.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns a list of registers that are triggered by the falling edge of any clock<br/>
		/// in the design:<br/>
		/// all_registers -fall_clock [all_clocks]<br/>
		/// The following example sets the minimum delay:<br/>
		/// set_min_delay 2.0 -to [all_registers -clock CCLK -data_pins]<br/>
		/// The following example extracts all registers on clk_A with *meta* in the name:<br/>
		/// filter [all_registers -clock clk_A] {name =~ *meta*}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 96<br/>
		/// </para>
		/// </summary>
		/// <param name="clock">(Optional) Consider registers of this clock</param>
		/// <param name="rise_clock">(Optional) Consider registers triggered by clock rising edge</param>
		/// <param name="fall_clock">(Optional) Consider registers triggered by clock falling edge</param>
		/// <param name="cells">(Optional) Return list of cells (default)</param>
		/// <param name="data_pins">(Optional) Return list of register data pins</param>
		/// <param name="clock_pins">(Optional) Return list of register clock pins</param>
		/// <param name="async_pins">(Optional) Return list of async preset/clear pins</param>
		/// <param name="output_pins">(Optional) Return list of register output pins</param>
		/// <param name="level_sensitive">(Optional) Only consider level-sensitive latches</param>
		/// <param name="edge_triggered">(Optional) Only consider edge-triggered flip-flops</param>
		/// <param name="no_hierarchy">(Optional) Only search the current instance</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of cell or pin objects</returns>
		public VivadoTCL all_registers(TCLParameterList clock = null, TCLParameterList rise_clock = null, TCLParameterList fall_clock = null, bool? cells = null, bool? data_pins = null, bool? clock_pins = null, bool? async_pins = null, bool? output_pins = null, bool? level_sensitive = null, bool? edge_triggered = null, bool? no_hierarchy = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: all_registers [-clock <args>] [-rise_clock <args>] [-fall_clock <args>] [-cells] [-data_pins] [-clock_pins] [-async_pins] [-output_pins] [-level_sensitive] [-edge_triggered] [-no_hierarchy] [-quiet] [-verbose]
			this.Entry(_builder.all_registers(clock, rise_clock, fall_clock, cells, data_pins, clock_pins, async_pins, output_pins, level_sensitive, edge_triggered, no_hierarchy, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Runs an automation rule on an IPI object.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: apply_bd_automation -rule &lt;arg&gt; [-config &lt;args&gt;] -dict &lt;arg&gt; -opts &lt;arg&gt; [-quiet] [-verbose] &lt;objects&gt;...
		/// <br/>
		/// <para>
		/// IP integrator provides the Designer Assistance feature, using the apply_bd_automation<br/>
		/// command, to automatically configure and/or add other relevant IP integrator cells around a<br/>
		/// selected IP integrator object. For more information on the Designer Assistance features refer to<br/>
		/// the Vivado Design Suite User Guide: Designing with IP (UG896) or the Vivado Design Suite User<br/>
		/// Guide: Designing IP Subsystems Using IP Integrator (UG994).<br/>
		/// Currently block and connection automation exists for cells, interfaces, pins and ports. The Block<br/>
		/// Automation feature is provided for certain complex blocks such as the Zynq device, MicroBlaze<br/>
		/// processor, AXI Ethernet and memory IP.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The Connection Automation feature helps automate different types of connections. For instance<br/>
		/// when connecting Slave AXI-MM interfaces, the automation will also connect up the relevant<br/>
		/// clock and reset pins and also create an interconnect if one is required. Connection Automation<br/>
		/// may also help with board-level connections; connecting pins and interfaces from relevant cells, to<br/>
		/// external ports and interfaces, and applying appropriate board constraints on these external I/Os.<br/>
		/// Note: This IP integrator command is issued from within the Vivado IDE via the Designer Assistance GUI<br/>
		/// feature. It is recommended that you make use of this command in IP integrator through the Vivado IDE,<br/>
		/// rather than directly from Tcl scripts. Use the write_bd_tcl command to output Tcl for use within a user<br/>
		/// script.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 99<br/>
		/// </para>
		/// </summary>
		/// <param name="rule">(Required) Rule ID string</param>
		/// <param name="dict">(Required) List of objects and corresponding parameter name-value pairs.</param>
		/// <param name="opts">(Required) List of settings that apply to all objects in this rule.</param>
		/// <param name="objects">(Required) The objects to run the automation rule on</param>
		/// <param name="config">(Optional) List of parameter value pairs</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Returns success or failure</returns>
		public VivadoTCL apply_bd_automation(String rule, String dict, String opts, TCLParameterList objects, TCLParameterList config = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: apply_bd_automation -rule <arg> [-config <args>] -dict <arg> -opts <arg> [-quiet] [-verbose] <objects>...
			this.Entry(_builder.apply_bd_automation(rule, dict, opts, objects, config, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Applies board connections to given designs<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: apply_board_connection [-board_interface &lt;arg&gt;] -ip_intf &lt;arg&gt; -diagram &lt;arg&gt; [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Connects the interface pin of an IP core in the specified block design to the interface of the<br/>
		/// current board part in the current project or design.<br/>
		/// The board part provides a representation of the Xilinx device in the context of the board-level<br/>
		/// system, and can help define key aspects of the design, such as clock constraints, I/O port<br/>
		/// assignments, and supported interfaces. The board part file stores information regarding board<br/>
		/// attributes. The file, called board_part.xml, is located in the data/boards/board_parts<br/>
		/// folder of the Vivado Design Suite installation area.<br/>
		/// The command lets you quickly connect compatible interface pins of an IP integrator block design<br/>
		/// to the appropriate interface definition on the current board part. To make the connection<br/>
		/// between the IP core to the board part, the IP integrator of the Vivado Design Suite adds an<br/>
		/// external interface port and interface connection to the block design. The added external<br/>
		/// interface port is named for the specified board part interface.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The apply_board_connection commands uses the available interfaces of the current board<br/>
		/// part defined in the project. An error is returned if the project uses a target part rather than a<br/>
		/// target board. You can use the current_board_part command to identify the target board<br/>
		/// used by the project, or get_board_parts to list the boards available for use by the project.<br/>
		/// Use the get_board_part_interfaces command to determine the list of available interfaces<br/>
		/// on the current board.<br/>
		/// To remove an existing IP interface connection, specify the -ip_intf option, but do not specify<br/>
		/// the -board_interface. If no board part interface is specified, the IP interface pin is<br/>
		/// disconnected.<br/>
		/// This command returns a transcript of it actions, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 103<br/>
		/// </para>
		/// </summary>
		/// <param name="ip_intf">
		/// <para>
		/// (Required)<br/>
		/// Full path of IP interface name to which board automation<br/>
		/// need to be applied.<br/>
		/// </para>
		/// </param>
		/// <param name="diagram">(Required) The IP Integrator design name.</param>
		/// <param name="board_interface">(Optional) Board interface name to which connection need to be applied.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>sucess/failure status of applied action.</returns>
		public VivadoTCL apply_board_connection(String ip_intf, String diagram, String board_interface = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: apply_board_connection [-board_interface <arg>] -ip_intf <arg> -diagram <arg> [-quiet] [-verbose]
			this.Entry(_builder.apply_board_connection(ip_intf, diagram, board_interface, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Apply trigger at startup init values to an ILA core in the design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: apply_hw_ila_trigger [-ila_cell &lt;arg&gt;] [-quiet] [-verbose] [&lt;file&gt;]
		/// <br/>
		/// <para>
		/// Apply a trigger configuration file to the bitstream of a design, to support ILA trigger at startup.<br/>
		/// This command is used to configure the trigger settings of an ILA core in a design bitstream (.bit)<br/>
		/// file, so that the ILA debug core is armed to trigger on events immediately after device<br/>
		/// configuration and startup. This allows data to be captured from the earliest stages of device<br/>
		/// activity, which would not be possible through the use of the Hardware Manager feature of the<br/>
		/// Vivado Design Suite, and the run_hw_ila command.<br/>
		/// The apply_hw_ila_trigger command reads a trigger configuration file written by<br/>
		/// run_hw_ila -file and applies the various trigger settings to the ILA core in the implemented<br/>
		/// design. The trigger configuration for the ILA core then become part of the bitstream written by<br/>
		/// write_bitstream, that is used to program the Xilinx FPGA device.<br/>
		/// The process for using the trigger at startup feature includes the following steps:<br/>
		/// 1. From the Hardware Manager, use run_hw_ila -file to export the trigger register map<br/>
		/// file for the ILA core.<br/>
		/// 2. Open the implemented design, or the implemented design checkpoint.<br/>
		/// 3. Use the apply_hw_ila_trigger command to apply the trigger settings to the in-memory<br/>
		/// design.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// 4. Use the write_bitstream command to write the bitstream with the applied trigger<br/>
		/// configuration file.<br/>
		/// Note: Be sure to use the write_bitstream command, and not the Flow Navigator commands in the<br/>
		/// Vivado IDE.<br/>
		/// 5. Return to the Hardware Manager, and use program_hw_device to program the hw_device<br/>
		/// using the new bitstream file.<br/>
		/// Once programmed, the new ILA core should immediately arm at startup. In the Vivado logic<br/>
		/// analyzer feature, you should see the "Trigger Capture Status" for the ILA core is now populated<br/>
		/// with captured data samples if trigger events or capture conditions have occurred. Refer to the<br/>
		/// Vivado Design Suite User Guide: Vivado Programming and Debugging (UG908) for more information.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 106<br/>
		/// </para>
		/// </summary>
		/// <param name="ila_cell">(Optional) Apply trigger settings to this ila cell</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="file">(Optional) ILA startup trigger settings file</param>
		public VivadoTCL apply_hw_ila_trigger(String ila_cell = null, bool? quiet = null, bool? verbose = null, String file = null)
		{
			// TCL Syntax: apply_hw_ila_trigger [-ila_cell <arg>] [-quiet] [-verbose] [<file>]
			this.Entry(_builder.apply_hw_ila_trigger(ila_cell, quiet, verbose, file));
			return this;
		}
		/// <summary>
		/// <para>
		/// Archive the current project<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: archive_project [-temp_dir &lt;arg&gt;] [-force] [-exclude_run_results] [-include_config_settings] [-include_runs_in_progress] [-include_local_ip_cache] [-quiet] [-verbose] [&lt;file&gt;]
		/// <br/>
		/// <para>
		/// Archives a project to store as backup, or to encapsulate the design and send it to a remote site.<br/>
		/// The tool parses the hierarchy of the design, copies the required source files, include files, and<br/>
		/// remote files from the library directories, copies the constraint files, copies the results of the<br/>
		/// various synthesis, simulation, and implementation runs, and then creates a ZIP file of the project.<br/>
		/// TIP: In order to archive the tcl.pre and tcl.post scripts, associated with the synthesis and implementation<br/>
		/// steps in the Design Run Settings dialog box, you must add these script files to the project as design sources.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// An alternative method of archiving the project is using write_project_tcl to create a Tcl<br/>
		/// script that will recreate the project in its current form.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following command archives the current project:<br/>
		/// archive_project<br/>
		/// Note: The project archive is named &lt;project_name&gt;.zip because no file name is specified.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example specifies project_3 as the current project, and then archives that<br/>
		/// project into a file called proj3.zip:<br/>
		/// current_project project_3<br/>
		/// archive_project -force -exclude_run_results proj3.zip<br/>
		/// Note: The use of the -force argument causes the tool to overwrite the proj3.zip file if one exists. The<br/>
		/// use of the -exclude_run_results argument causes the tool to leave any results from synthesis or<br/>
		/// implementation runs out of the archive. The various runs defined in the project are included in the archive,<br/>
		/// but not any of the results.<br/>
		/// The following command archives the current project in the specified file, overwrites an existing<br/>
		/// file if needed, excludes the run results, and includes any configuration settings used when<br/>
		/// launching the Vivado tool:<br/>
		/// archive_project -force mb1_archive.zip -temp_dir C:/Data/Temp \<br/>
		/// -exclude_run_results -include_config_settings<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 109<br/>
		/// </para>
		/// </summary>
		/// <param name="temp_dir">(Optional) specify temporary location to save project copy to archive Default: .</param>
		/// <param name="force">(Optional) Overwrite existing archived file</param>
		/// <param name="exclude_run_results">(Optional) Exclude run results from the archive</param>
		/// <param name="include_config_settings">
		/// <para>
		/// (Optional)<br/>
		/// Include current project environment configuration settings/<br/>
		/// files in archive<br/>
		/// </para>
		/// </param>
		/// <param name="include_runs_in_progress">
		/// <para>
		/// (Optional)<br/>
		/// Include run result even if the run is in progress, this switch<br/>
		/// will be ignored if -exclude_run_results is specified<br/>
		/// </para>
		/// </param>
		/// <param name="include_local_ip_cache">(Optional) Include IP cache results in the archive</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="file">(Optional) Name of the archive file</param>
		/// <returns>true</returns>
		public VivadoTCL archive_project(String temp_dir = null, bool? force = null, bool? exclude_run_results = null, bool? include_config_settings = null, bool? include_runs_in_progress = null, bool? include_local_ip_cache = null, bool? quiet = null, bool? verbose = null, String file = null)
		{
			// TCL Syntax: archive_project [-temp_dir <arg>] [-force] [-exclude_run_results] [-include_config_settings] [-include_runs_in_progress] [-include_local_ip_cache] [-quiet] [-verbose] [<file>]
			this.Entry(_builder.archive_project(temp_dir, force, exclude_run_results, include_config_settings, include_runs_in_progress, include_local_ip_cache, quiet, verbose, file));
			return this;
		}
		/// <summary>
		/// <para>
		/// Automatically assign addresses to unmapped IP<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: assign_bd_address [-target_address_space &lt;arg&gt;] [-boundary] [-master_boundary] [-external] -dict &lt;arg&gt; [-import_from_file &lt;arg&gt;] [-export_to_file &lt;arg&gt;] [-export_gui_to_file &lt;arg&gt;] [-offset &lt;arg&gt;] [-range &lt;arg&gt;] [-base_high &lt;arg&gt;] [-force] [-quiet] [-verbose] [&lt;objects&gt;...]
		/// <br/>
		/// <para>
		/// Assign unmapped IP address segments to address spaces in the IP integrator subsystem design.<br/>
		/// If the target address space is not specified, the IP integrator will automatically assign the address<br/>
		/// segment to an available address space on a connected AXI master.<br/>
		/// If no bd_addr_seg objects are specified the assign_bd_address command will assign all<br/>
		/// unmapped address segments to any connected AXI master address spaces.<br/>
		/// This command returns the newly mapped address segments, or returns an error if it failed.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 112<br/>
		/// </para>
		/// </summary>
		/// <param name="dict">
		/// <para>
		/// (Required)<br/>
		/// dictionary of offset range address pairs, e.g. {offset<br/>
		/// 0x00000000 range 32K offset 0x20000000 range 32K} used to<br/>
		/// map an external interface to more than one address<br/>
		/// </para>
		/// </param>
		/// <param name="target_address_space">(Optional) Target address space to place segment into</param>
		/// <param name="boundary">
		/// <para>
		/// (Optional)<br/>
		/// assign peripherals to the exported slave hierarchical<br/>
		/// boundary of the design<br/>
		/// </para>
		/// </param>
		/// <param name="master_boundary">
		/// <para>
		/// (Optional)<br/>
		/// set hierarchical master boundary by assigning exported<br/>
		/// master interface segments to internal masters<br/>
		/// </para>
		/// </param>
		/// <param name="external">
		/// <para>
		/// (Optional)<br/>
		/// allow an external master interface to be mapped to more<br/>
		/// than one address<br/>
		/// </para>
		/// </param>
		/// <param name="import_from_file">
		/// <para>
		/// (Optional)<br/>
		/// import the addressing from file. When extension is csv,<br/>
		/// format = &lt;address space name&gt;,&lt;slave<br/>
		/// segment&gt;,&lt;offset&gt;,&lt;range&gt;<br/>
		/// </para>
		/// </param>
		/// <param name="export_to_file">
		/// <para>
		/// (Optional)<br/>
		/// export the address map to a file in csv format. format =<br/>
		/// &lt;address space name&gt;,&lt;slave segment&gt;,&lt;offset&gt;,&lt;range&gt;<br/>
		/// </para>
		/// </param>
		/// <param name="export_gui_to_file">
		/// <para>
		/// (Optional)<br/>
		/// export the address map to a file in csv format. Structure is<br/>
		/// same as Address Editor GUI<br/>
		/// </para>
		/// </param>
		/// <param name="offset">(Optional) Offset of assignment. e.g. 0x00000000</param>
		/// <param name="range">(Optional) Range of assignment. e.g. 4096, 4K, 16M, 1G</param>
		/// <param name="base_high">
		/// <para>
		/// (Optional)<br/>
		/// colon separated base:high offsets of a range assignment.<br/>
		/// e.g. 0x0000:0xFFFF<br/>
		/// </para>
		/// </param>
		/// <param name="force">(Optional) force the assignment, do not run any validity checks</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">(Optional) The objects to assign UG835 (v2020.2) November 18, 2020 www.xilinx.com</param>
		/// <returns>The newly mapped segments, "" if failed.</returns>
		public VivadoTCL assign_bd_address(String dict, String target_address_space = null, bool? boundary = null, bool? master_boundary = null, bool? external = null, String import_from_file = null, String export_to_file = null, String export_gui_to_file = null, String offset = null, String range = null, String base_high = null, bool? force = null, bool? quiet = null, bool? verbose = null, TCLParameterList objects = null)
		{
			// TCL Syntax: assign_bd_address [-target_address_space <arg>] [-boundary] [-master_boundary] [-external] -dict <arg> [-import_from_file <arg>] [-export_to_file <arg>] [-export_gui_to_file <arg>] [-offset <arg>] [-range <arg>] [-base_high <arg>] [-force] [-quiet] [-verbose] [<objects>...]
			this.Entry(_builder.assign_bd_address(dict, target_address_space, boundary, master_boundary, external, import_from_file, export_to_file, export_gui_to_file, offset, range, base_high, force, quiet, verbose, objects));
			return this;
		}
		/// <summary>
		/// <para>
		/// Auto detect the XPM Libraries that are used in the design and set the XPM_LIBRARIES project<br/>
		/// property.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: auto_detect_xpm [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// This command collects the list of Xilinx Parameterized Macros (XPM) used in RTL design files and<br/>
		/// sets the XPM_LIBRARIES property. Because it identifies XPM used in the RTL source files, it<br/>
		/// must be used after the RTL files are read or added to the design as shown in the example.<br/>
		/// TIP: This command is intended for use in non-project mode, and is not needed for project-based flows.<br/>
		/// This command will find all the XPMs used in the user RTL and update the XPM_LIBRARIES<br/>
		/// property on the current project. Synthesis and simulation will use the XPM_LIBRARIES property<br/>
		/// to properly support these macros.<br/>
		/// This command returns nothing, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reads the specified RTL file, and then uses auto_detect_xpm to define<br/>
		/// the XPM_LIBRARIES used in the files:<br/>
		/// read_verilog ../top_bgRAM_173_0.v<br/>
		/// read_xdc ../top_bgRAM_173_0.xdc<br/>
		/// auto_detect_xpm<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 116<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL auto_detect_xpm(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: auto_detect_xpm [-quiet] [-verbose]
			this.Entry(_builder.auto_detect_xpm(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Issue JTAG Program command to hw_device<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: boot_hw_device [-disable_done_check] [-timeout &lt;arg&gt;] [-quiet] [-verbose] &lt;hw_device&gt;
		/// <br/>
		/// <para>
		/// Issue JTAG PROGRAM command to the hw_device (FPGA).<br/>
		/// The boot_hw_device command triggers the FPGA boot and board startup sequence. The boot<br/>
		/// sequence starts the FPGA configuration process to clear the device of any prior programming,<br/>
		/// and then to load a new program, depending on the mode pin settings.<br/>
		/// The hw_device will boot based on its mode pin settings. If the FPGA's mode pins on the device<br/>
		/// are set to JTAG mode, or the interface is not active (e.g. the PROM is not configured) the net<br/>
		/// effect of the boot_hw_device command is to clear the prior programming.<br/>
		/// This command returns a 1 if it detects that the DONE pin has gone HIGH, or when the device<br/>
		/// has been cleared, otherwise it returns 0.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 118<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_device">(Required) Target hw_device connection</param>
		/// <param name="disable_done_check">(Optional) Disable done check for boot device</param>
		/// <param name="timeout">(Optional) Time out for boot (seconds) Default: default</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL boot_hw_device(String hw_device, bool? disable_done_check = null, String timeout = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: boot_hw_device [-disable_done_check] [-timeout <arg>] [-quiet] [-verbose] <hw_device>
			this.Entry(_builder.boot_hw_device(hw_device, disable_done_check, timeout, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Calculate device configuration time (ms)<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: calc_config_time [-verbose] [-max] [-min] [-typical] [-por_used] [-por_ramp &lt;arg&gt;] [-clk_freq &lt;arg&gt;] [-bitstream_size &lt;arg&gt;] [-quiet]
		/// <br/>
		/// <para>
		/// Estimates the time in milliseconds (ms) to configure a Xilinx device for the current design.<br/>
		/// TIP: The Device Configuration Mode must be defined for this command to work.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Some applications require that the Xilinx device be configured and operational within a short<br/>
		/// time. This command lets you estimate the configuration time for the device and design in<br/>
		/// question. The configuration time includes the device initialization time plus the configuration<br/>
		/// time. Configuration time depends on the size of the device and speed of the configuration logic.<br/>
		/// For more information on the configuration time refer to UltraFast Design Methodology Guide for<br/>
		/// the Vivado Design Suite (UG949), the UltraScale Architecture Configuration User Guide (UG570), or<br/>
		/// the 7 Series FPGAs Configuration User Guide (UG470).<br/>
		/// Some of the settings needed to calculate the configuration time are stored as properties on the<br/>
		/// current design, such as the BITSTREAM.CONFIG.CONFIGRATE or<br/>
		/// BITSTREAM.CONFIG.EXTMASTERCCLK_EN properties. In some master modes, the FPGA<br/>
		/// provides the configuration clock to control configuration, with the nominal configuration clock<br/>
		/// frequency specified by BITSTREAM.CONFIG.CONFIGRATE. The property can be defined in the<br/>
		/// Edit Device Properties dialog box of the Vivado Design Suite IDE, or by using set_property to<br/>
		/// directly set the value of the specified property.<br/>
		/// For a slave configuration mode, or for configuration modes using an external master clock, the<br/>
		/// needed clock frequency is specified by the -clk_freq option.<br/>
		/// This command returns a value in milliseconds if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 121<br/>
		/// </para>
		/// </summary>
		/// <param name="verbose">(Optional) Print out calculation parameters</param>
		/// <param name="max">(Optional) Calculate Maximum Configuration Time</param>
		/// <param name="min">(Optional) Calculate Minimum Configuration Time</param>
		/// <param name="typical">(Optional) Calculate Typical Configuration Time</param>
		/// <param name="por_used">
		/// <para>
		/// (Optional)<br/>
		/// (Deprecated) Specify if Power On Reset (POR) is used by<br/>
		/// using a non-zero por_ramp<br/>
		/// </para>
		/// </param>
		/// <param name="por_ramp">
		/// <para>
		/// (Optional)<br/>
		/// Specify a Power On Reset (POR) ramp rate as 1 ms to 50 ms<br/>
		/// Default: 0 ms<br/>
		/// </para>
		/// </param>
		/// <param name="clk_freq">
		/// <para>
		/// (Optional)<br/>
		/// Specify a clock frequency for Slave mode, or for Master<br/>
		/// mode if using external master clock (MHz) Default: 0 MHz<br/>
		/// </para>
		/// </param>
		/// <param name="bitstream_size">(Optional) Specify a bitstream size to override the default Default: 0</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <returns>Report</returns>
		public VivadoTCL calc_config_time(bool? verbose = null, bool? max = null, bool? min = null, bool? typical = null, bool? por_used = null, String por_ramp = null, String clk_freq = null, String bitstream_size = null, bool? quiet = null)
		{
			// TCL Syntax: calc_config_time [-verbose] [-max] [-min] [-typical] [-por_used] [-por_ramp <arg>] [-clk_freq <arg>] [-bitstream_size <arg>] [-quiet]
			this.Entry(_builder.calc_config_time(verbose, max, min, typical, por_used, por_ramp, clk_freq, bitstream_size, quiet));
			return this;
		}
		/// <summary>
		/// <para>
		/// Check if a module can be referenced<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: can_resolve_reference [-quiet] [-verbose] &lt;module&gt;...
		/// <br/>
		/// <para>
		/// This command is used to validate reference to modules prior to trying to import them into the<br/>
		/// design. Its primary use is in scripts like the script produced by the write_bd_tcl command,<br/>
		/// though you can use it in your own scripts as well.<br/>
		/// This command returns 0 if the reference cannot be resolved, or returns 1 if it can be resolved.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// This example determines if the reference to the specified module can be resolved:<br/>
		/// can_resolve_reference clk_div<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 124<br/>
		/// </para>
		/// </summary>
		/// <param name="module">(Required) module name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL can_resolve_reference(TCLParameterList module, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: can_resolve_reference [-quiet] [-verbose] <module>...
			this.Entry(_builder.can_resolve_reference(module, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Check HDL syntax in the supplied fileset or active fileset.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: check_syntax [-fileset &lt;arg&gt;] [-return_string] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Parses Verilog, SystemVerilog, and VHDL source files and generates syntax warnings and error<br/>
		/// messages for the design.<br/>
		/// TIP: The syntax is also checked automatically as the file is edited in the Vivado text editor, or when the file<br/>
		/// is saved.<br/>
		/// This command returns warnings or errors related to the files it examines, or returns nothing if no<br/>
		/// problems are found.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example checks the syntax of files in the simulation fileset:<br/>
		/// check_syntax -fileset sim_1<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 126<br/>
		/// </para>
		/// </summary>
		/// <param name="fileset">(Optional) Fileset to check for syntax</param>
		/// <param name="return_string">(Optional) Return the syntax check messages as a string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL check_syntax(String fileset = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: check_syntax [-fileset <arg>] [-return_string] [-quiet] [-verbose]
			this.Entry(_builder.check_syntax(fileset, return_string, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Check the design for possible timing problems<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: check_timing [-file &lt;arg&gt;] [-no_header] [-loop_limit &lt;arg&gt;] [-append] [-name &lt;arg&gt;] [-override_defaults &lt;args&gt;] [-include &lt;args&gt;] [-exclude &lt;args&gt;] [-return_string] [-rpx &lt;arg&gt;] [-cells &lt;args&gt;] [-verbose] [-quiet]
		/// <br/>
		/// <para>
		/// Checks the design elements of ports, pins, and paths, against the current timing constraints. Use<br/>
		/// this command to identify possible problems with design data and timing constraints before<br/>
		/// running the report_timing command. The check_timing command runs a series of default<br/>
		/// timing checks, and reports a summary of any violations found. To get detailed information about<br/>
		/// violations, use the -verbose option.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Note: By default the report is written to the Tcl console or STD output. However, the results can also be<br/>
		/// written to the GUI with the -name option, or to a file with -file.<br/>
		/// Default Timing Checks:<br/>
		/// • constant_clock - Checks for clock signals connected to a constant signal (gnd/vss/data).<br/>
		/// • generated_clocks - Checks for loops, or circular definitions within the generated clock<br/>
		/// network. This check will return an error if a generated clock uses a second generated clock as<br/>
		/// its source, when the second generated clock uses the first clock as its source.<br/>
		/// • latch_loops - Checks for and warns of combinational latch loops in the design.<br/>
		/// • loops - Checks for and warns of combinational feedback loops in the design.<br/>
		/// • multiple_clock - Warns if multiple clocks reach a register clock pin. If more than one clock<br/>
		/// signal reaches a register clock pin it is unclear which clock will be used for analysis. In this<br/>
		/// case, use the set_case_analysis command so that only one clock will propagate to the<br/>
		/// register clock pin.<br/>
		/// • no_clock - Reports unclocked registers. In this case, no setup or hold checks are performed<br/>
		/// on data pins related to the register clock pin.<br/>
		/// • no_input_delay - Reports the input ports without an input delay constraint. Input delays<br/>
		/// can be assigned using the set_input_delay command. Input ports that are unclocked will<br/>
		/// not be checked for input delays.<br/>
		/// • no_output_delay - Reports the output ports without an output delay constraint. Output<br/>
		/// delays can be assigned using the set_output_delay command. Output ports that are<br/>
		/// unclocked will not be checked for output delays.<br/>
		/// • partial_input_delay - Reports the input ports having partially defined input delay<br/>
		/// constraints. Assigning set_input_delay -max or set_input_delay -min to an input<br/>
		/// port, without assigning the other, creates a partially defined input delay. In such cases, paths<br/>
		/// starting from the input port may become unconstrained and no timing checks will be done<br/>
		/// against the port. Assigning set_input_delay without specifying either -min or -max<br/>
		/// allows the tool to assume both min and max delays, and so does not result in a partial input<br/>
		/// delay.<br/>
		/// Note: Unclocked input ports are not checked for partial input delays.<br/>
		/// • partial_output_delay - Reports the output ports having partially defined output delay<br/>
		/// constraints. Assigning set_output_delay -max or set_output_delay -min to an<br/>
		/// output port, without assigning the other, creates a partially defined output delay. In such<br/>
		/// cases, paths reaching the port may become unconstrained and no timing checks will be done<br/>
		/// against the port. Assigning set_output_delay without specifying either -min or -max<br/>
		/// allows the tool to assume both min and max delays, and so does not result in a partial output<br/>
		/// delay.<br/>
		/// Note: Unclocked output ports are not checked for partial output delays.<br/>
		/// • pulse_width_clock - Reports clock pins that have only a pulse width check associated<br/>
		/// with the pin, and no setup or hold check, no recovery, removal, or clk-&gt;Q check.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// • unconstrained_internal_endpoints - This warning identifies timing path endpoints at<br/>
		/// register data pins that are not constrained. Endpoints at register data pins are constrained by<br/>
		/// clock assignment using the create_clock command. Endpoints at output ports are checked<br/>
		/// and reported by the no_output_delay check.<br/>
		/// • unexpandable_clocks - Reports clock sets in which the period is not expandable with<br/>
		/// respect to each other, when there is at least 1 path between the clock sets. A clock is<br/>
		/// unexpandable if no common multiples are found within 1000 cycles between the source and<br/>
		/// destination clocks.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example runs check_timing, but excludes the specified checks from the default<br/>
		/// timing checks:<br/>
		/// check_timing -exclude {loops generated_clocks}<br/>
		/// The following example uses the -verbose argument to obtain detailed results running just the<br/>
		/// multiple_clocks check, and then uses get_clocks to look further into the issue:<br/>
		/// check_timing -verbose -override_defaults {multiple_clock}<br/>
		/// Checking multiple_clock.<br/>
		/// There are 2 register/latch pins with multiple clocks.<br/>
		/// procEngine/mode_du/set_reg[0]/C<br/>
		/// provEngine/mode_du/set_reg[1]/C<br/>
		/// get_clocks -of_objects [get_pin procEngine/mode_du/set_reg[0]/C]<br/>
		/// sysClk coreClk<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 128<br/>
		/// </para>
		/// </summary>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="no_header">(Optional) do not generate a report header</param>
		/// <param name="loop_limit">(Optional) Limit the number of loops reported for loops check Default: 100</param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="override_defaults">(Optional) Overrides the checks in the default timing checks listed below</param>
		/// <param name="include">
		/// <para>
		/// (Optional)<br/>
		/// Add this list of checks to be performed along with default<br/>
		/// timing checks listed below<br/>
		/// </para>
		/// </param>
		/// <param name="exclude">
		/// <para>
		/// (Optional)<br/>
		/// Exclude this list of checks to be performed from the default<br/>
		/// timing checks listed below<br/>
		/// </para>
		/// </param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="rpx">(Optional) Filename to output interactive results to.</param>
		/// <param name="cells">(Optional) run check_timing on the specified cell(s)</param>
		/// <param name="verbose">(Optional) Return a detailed list of all timing problems found</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		public VivadoTCL check_timing(String file = null, bool? no_header = null, Int32? loop_limit = null, bool? append = null, String name = null, TCLParameterList override_defaults = null, TCLParameterList include = null, TCLParameterList exclude = null, bool? return_string = null, String rpx = null, TCLParameterList cells = null, bool? verbose = null, bool? quiet = null)
		{
			// TCL Syntax: check_timing [-file <arg>] [-no_header] [-loop_limit <arg>] [-append] [-name <arg>] [-override_defaults <args>] [-include <args>] [-exclude <args>] [-return_string] [-rpx <arg>] [-cells <args>] [-verbose] [-quiet]
			this.Entry(_builder.check_timing(file, no_header, loop_limit, append, name, override_defaults, include, exclude, return_string, rpx, cells, verbose, quiet));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a VCD checkpoint (equivalent of Verilog $dumpall system task)<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: checkpoint_vcd [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// The checkpoint_vcd command inserts current HDL object signal values into the Value Change<br/>
		/// Dump (VCD) file. Nothing is returned. This Tcl command is the equivalent of the Verilog<br/>
		/// $dumpall system task, providing the initial values of the specified signals.<br/>
		/// VCD is an ASCII file containing header information, variable definitions, and value change details<br/>
		/// of a set of HDL signals. The VCD file can be used to view simulation result in a VCD viewer or to<br/>
		/// estimate the power consumption of the design. See the IEEE Standard for Verilog Hardware<br/>
		/// Description Language (IEEE Std 1364-2005) for a description of the VCD file format.<br/>
		/// You must execute the open_vcd and log_vcd commands before using the checkpoint_vcd<br/>
		/// command. After you execute the checkpoint_vcd command, run or rerun the simulation to<br/>
		/// capture the signal values.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following is an example of the checkpoint_vcd command where the command dumps<br/>
		/// signal values of specified HDL objects into the open VCD file:<br/>
		/// checkpoint_vcd<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 133<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL checkpoint_vcd(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: checkpoint_vcd [-quiet] [-verbose]
			this.Entry(_builder.checkpoint_vcd(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Close a design.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: close_bd_design [-quiet] [-verbose] &lt;name&gt;
		/// <br/>
		/// <para>
		/// Closes the specified IP subsystem design in the IP integrator of the Vivado Design Suite.<br/>
		/// If the design has been modified, you will not be prompted to save the design prior to closing. You<br/>
		/// will need to run save_bd_design to save any changes made to the design before using the<br/>
		/// close_bd_design command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 135<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name of design to close</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The design object, "" if failed.</returns>
		public VivadoTCL close_bd_design(String name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: close_bd_design [-quiet] [-verbose] <name>
			this.Entry(_builder.close_bd_design(name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Close the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: close_design [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Closes the currently active design. If the design has been modified, you will not be prompted to<br/>
		/// save the design prior to closing. You will need to run save_design or save_design_as to<br/>
		/// save any changes made to the design before using the close_design command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example closes the current design:<br/>
		/// close_design<br/>
		/// Note: If multiple designs are open, you can specify the current design with the current_design<br/>
		/// command prior to using close_design.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example sets the current design, then closes it:<br/>
		/// current_design rtl_1<br/>
		/// close_design<br/>
		/// current_design sets rtl_1 as the active design, then the close_design command closes<br/>
		/// it.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 137<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL close_design(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: close_design [-quiet] [-verbose]
			this.Entry(_builder.close_design(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Close the hardware tool<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: close_hw_manager [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Close the Hardware Manager tool in the Vivado Design Suite.<br/>
		/// Opening the Hardware Manager using the open_hw_manager command, is the first step in<br/>
		/// programming and/or debugging your design in Xilinx FPGA hardware. For more information refer<br/>
		/// to the Vivado Design Suite User Guide: Programming and Debugging (UG908).<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 139<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL close_hw_manager(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: close_hw_manager [-quiet] [-verbose]
			this.Entry(_builder.close_hw_manager(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Close a hardware target<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: close_hw_target [-quiet] [-verbose] [&lt;hw_target&gt;]
		/// <br/>
		/// <para>
		/// Close the connection to the current or specified hardware target that was previously opened<br/>
		/// using the open_hw_target command.<br/>
		/// The hardware target is a system board containing a JTAG chain of one or more Xilinx devices that<br/>
		/// you can program with a bitstream file, or use to debug your design. Connections between<br/>
		/// hardware targets on the system board and the Vivado Design Suite are managed by the<br/>
		/// hw_server application. Refer to Vivado Design Suite User Guide: Programming and Debugging<br/>
		/// (UG908) for a list of supported JTAG download cables and devices.<br/>
		/// This command returns connection messages from the hardware server, or returns an error if it<br/>
		/// fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 141<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_target">(Optional) hardware target Default: current hardware target</param>
		public VivadoTCL close_hw_target(bool? quiet = null, bool? verbose = null, String hw_target = null)
		{
			// TCL Syntax: close_hw_target [-quiet] [-verbose] [<hw_target>]
			this.Entry(_builder.close_hw_target(quiet, verbose, hw_target));
			return this;
		}
		/// <summary>
		/// <para>
		/// Close current opened project<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: close_project [-delete] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Closes the current open project.<br/>
		/// TIP: Any user-defined Tcl variables that are in the global namespace (i.e. not in a project-specific<br/>
		/// namespace) are not reset or cleared by this command. Global variables are persistent with the invocation<br/>
		/// of Vivado and are only cleared when the Vivado Design Suite is closed. You can also use the unset<br/>
		/// command to expressly clear a specific Tcl variable.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following command closes the active project:<br/>
		/// close_project<br/>
		/// This example closes the current project. If you have multiple projects open, the<br/>
		/// close_project command applies to the current project which can be defined with the<br/>
		/// current_project command.<br/>
		/// The following example sets project_1 as the current project, and then closes the project and<br/>
		/// deletes it from the computer hard disk:<br/>
		/// current_project project_1<br/>
		/// close_project -delete<br/>
		/// Note: Use the -delete argument with caution. You will not be prompted to confirm the deletion of<br/>
		/// project data.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 143<br/>
		/// </para>
		/// </summary>
		/// <param name="delete">(Optional) Delete the project from disk also</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL close_project(bool? delete = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: close_project [-delete] [-quiet] [-verbose]
			this.Entry(_builder.close_project(delete, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Flush SAIF toggle information to the SAIF output file and close the file<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: close_saif [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Closes the open SAIF file.<br/>
		/// Only one SAIF file can be open in the Vivado simulator at one time, using open_saif. You must<br/>
		/// close the currently opened SAIF file before opening another file.<br/>
		/// This command returns nothing if it is successful, or an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following is an example:<br/>
		/// close_saif<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 145<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL close_saif(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: close_saif [-quiet] [-verbose]
			this.Entry(_builder.close_saif(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Unload the current simulation without exiting Vivado<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: close_sim [-force] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Close the current Vivado simulation.<br/>
		/// Note: This command does not support third party simulators.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example closes the current simulation, forcing the close even if changes would be<br/>
		/// lost:<br/>
		/// close_sim -force<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 147<br/>
		/// </para>
		/// </summary>
		/// <param name="force">
		/// <para>
		/// (Optional)<br/>
		/// Forces the closing of the simulation, even if changes would<br/>
		/// be lost. Default behavior is to reject the closing with an error<br/>
		/// if changes would be lost.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL close_sim(bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: close_sim [-force] [-quiet] [-verbose]
			this.Entry(_builder.close_sim(force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Flush VCD information to the VCD output file and close the file<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: close_vcd [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Closes the open Value Change Dump (VCD) file.<br/>
		/// Only one VCD file can be open in the Vivado simulator at one time. You must close the currently<br/>
		/// opened VCD file before opening another file.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example closes the current VCD object:<br/>
		/// close_vcd<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 149<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL close_vcd(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: close_vcd [-quiet] [-verbose]
			this.Entry(_builder.close_vcd(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Closes the wave config<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: close_wave_config [-force] [-quiet] [-verbose] [&lt;wcfgobj&gt;]
		/// <br/>
		/// <para>
		/// Close the current, or specified wave configuration.<br/>
		/// In the Vivado® simulator GUI, you can work with a waveform to analyze your design and debug<br/>
		/// your code. A wave configuration object displays with top-level HDL objects, and can be further<br/>
		/// populated using commands like add_wave and add_wave_divider. A new wave<br/>
		/// configuration object can be created in the current simulation with the create_wave_config<br/>
		/// command.<br/>
		/// Any changes made to a wave configuration object can be saved to a Wave Config file with the<br/>
		/// save_wave_config command. You can open a saved Wave Config file with the<br/>
		/// open_wave_config command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example closes all Wave Config files associated with the current simulation:<br/>
		/// close_wave_config [get_wave_configs]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 151<br/>
		/// </para>
		/// </summary>
		/// <param name="force">
		/// <para>
		/// (Optional)<br/>
		/// Forces the closing of the wave configuration, even if<br/>
		/// changes would be lost. Default behavior is to reject the<br/>
		/// closing with an error if changes would be lost.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="wcfgobj">
		/// <para>
		/// (Optional)<br/>
		/// Closes and destroys the specified wave configuration object,<br/>
		/// or the current wave configuration if none specified Default:<br/>
		/// NULL<br/>
		/// </para>
		/// </param>
		public VivadoTCL close_wave_config(bool? force = null, bool? quiet = null, bool? verbose = null, String wcfgobj = null)
		{
			// TCL Syntax: close_wave_config [-force] [-quiet] [-verbose] [<wcfgobj>]
			this.Entry(_builder.close_wave_config(force, quiet, verbose, wcfgobj));
			return this;
		}
		/// <summary>
		/// <para>
		/// Add a hw_emu Xilinx Shell Archive to an existing hw Xilinx Shell Archive<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: combine_hw_platforms [-hw &lt;arg&gt;] [-hw_emu &lt;arg&gt;] [-o &lt;arg&gt;] [-add_digest] [-force] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 153<br/>
		/// </para>
		/// </summary>
		/// <param name="hw">
		/// <para>
		/// (Optional)<br/>
		/// A hw Xilinx Shell Archive Values: A filename with<br/>
		/// alphanumeric characters and .xsa extension.<br/>
		/// </para>
		/// </param>
		/// <param name="hw_emu">
		/// <para>
		/// (Optional)<br/>
		/// A hw_emu Xilinx Shell Archive Values: A filename with<br/>
		/// alphanumeric characters and .xsa extension.<br/>
		/// </para>
		/// </param>
		/// <param name="o">
		/// <para>
		/// (Optional)<br/>
		/// The (optional) output Xilinx Shell Archive. If not specified,<br/>
		/// the hw_emu will be added to the hw file, overwriting the<br/>
		/// original file. Values: A filename with alphanumeric<br/>
		/// characters and .xsa extension.<br/>
		/// </para>
		/// </param>
		/// <param name="add_digest">(Optional) Remove this!!!</param>
		/// <param name="force">(Optional) Overwrite existing Xilinx Shell Archive file</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL combine_hw_platforms(String hw = null, String hw_emu = null, String o = null, bool? add_digest = null, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: combine_hw_platforms [-hw <arg>] [-hw_emu <arg>] [-o <arg>] [-add_digest] [-force] [-quiet] [-verbose]
			this.Entry(_builder.combine_hw_platforms(hw, hw_emu, o, add_digest, force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Commit the property changes of the current hardware object. Inputs can be HBM or device<br/>
		/// hardware object. At least one object is required.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: commit_hw_hbm [-quiet] [-verbose] &lt;hw_objects&gt;
		/// <br/>
		/// <para>
		/// Commit the current values of properties defined on the specified HBM controller in the Vivado<br/>
		/// hardware manager to the current hardware device.<br/>
		/// The commit_hw_hbm command takes the current property values defined on a hw_hbm object<br/>
		/// and commits them to the current hardware device connected to the hardware server.<br/>
		/// When you change the property values on the hw_hbm object, they are not written to the<br/>
		/// hardware device until you use the commit_hw_hbm command.<br/>
		/// This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example changes a property of the specified HBM controller object, and then<br/>
		/// commits the change to the device:<br/>
		/// set_property MC2.INIT.AM_REPEAT_EN 1 [get_hw_hbms *HBM_2]<br/>
		/// commit_hw_hbm [get_hw_hbm *HBM_2]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 154<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_objects">(Required) hardware objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL commit_hw_hbm(String hw_objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: commit_hw_hbm [-quiet] [-verbose] <hw_objects>
			this.Entry(_builder.commit_hw_hbm(hw_objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Commit the property changes of the current hardware object. Inputs can be any mig, device,<br/>
		/// target, or server hardware object. At least one object is required.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: commit_hw_mig [-quiet] [-verbose] &lt;hw_objects&gt;
		/// <br/>
		/// <para>
		/// Commit the current values of properties defined on the specified memory IP debug core<br/>
		/// hardware objects in the Hardware Manager feature of the Vivado Design Suite to the current<br/>
		/// hardware device.<br/>
		/// The commit_hw_mig command takes the current property values defined on a hw_mig object in<br/>
		/// the Vivado logic analyzer, and commits them to the current hardware device connected to the<br/>
		/// hardware server.<br/>
		/// When you change the property values on the hw_mig object, like the CONFIG.* properties, they<br/>
		/// are not written to the hardware device until you use the commit_hw_mig command.<br/>
		/// This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 156<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_objects">(Required) hardware objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL commit_hw_mig(String hw_objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: commit_hw_mig [-quiet] [-verbose] <hw_objects>
			this.Entry(_builder.commit_hw_mig(hw_objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Commit the property changes of the current hardware object. Inputs can be any serial I/O<br/>
		/// (except scan and sweep), device, target, or server hardware object. At least one object is required.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: commit_hw_sio [-quiet] [-verbose] &lt;hw_objects&gt;
		/// <br/>
		/// <para>
		/// Commit the current values of properties defined on the specified serial I/O hardware objects in<br/>
		/// the Hardware Manager feature of the Vivado Design Suite to the current hardware device.<br/>
		/// Specified objects can include any serial I/O object such as GTs, RXs, TXs, PLLs, or Commons,<br/>
		/// excluding hw_sio_scan and hw_sio_sweep objects. SIO objects also include device, target, or<br/>
		/// server hardware objects.<br/>
		/// The SIO IBERT core operates on an object property-based set/commit use model. You can set<br/>
		/// the property values on the hardware objects using the set_property command. You can then<br/>
		/// drive those values onto the current hardware device using the commit_hw_sio command.<br/>
		/// TIP: To update the properties on the hardware object with the actual value on the device use the<br/>
		/// refresh_hw_sio command.<br/>
		/// This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 158<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_objects">(Required) hardware objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL commit_hw_sio(String hw_objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: commit_hw_sio [-quiet] [-verbose] <hw_objects>
			this.Entry(_builder.commit_hw_sio(hw_objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Commit the property changes of the current hardware object. Inputs can be hw_server,<br/>
		/// hw_target, hw_device or hw_sysmon objects. At least one object is required.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: commit_hw_sysmon [-quiet] [-verbose] &lt;hw_objects&gt;
		/// <br/>
		/// <para>
		/// The commit_hw_sysmon command takes the current property values defined on a hw_sysmon<br/>
		/// object, and commits them to the system monitor registers on the hardware device.<br/>
		/// When you change the property values on the hw_sysmon object, like the CONFIG.* properties,<br/>
		/// they are not written to the hardware device until you use the commit_hw_sysmon command.<br/>
		/// This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 160<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_objects">(Required) hardware objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL commit_hw_sysmon(String hw_objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: commit_hw_sysmon [-quiet] [-verbose] <hw_objects>
			this.Entry(_builder.commit_hw_sysmon(hw_objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Write hardware VIO probe OUTPUT_VALUE properties values to VIO core(s).<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: commit_hw_vio [-quiet] [-verbose] &lt;hw_objects&gt;...
		/// <br/>
		/// <para>
		/// Commit the current values defined on the probes of the VIO Debug core to the current hardware<br/>
		/// device.<br/>
		/// The Virtual Input/Output (VIO) debug core can both monitor and drive internal signals on a<br/>
		/// programmed Xilinx FPGA in real time. The VIO core uses hardware probes, hw_probe objects, to<br/>
		/// monitor and drive signals on the device. Input probes monitor signals as inputs to the VIO core.<br/>
		/// Output probes drive signals to specified values from the VIO core.<br/>
		/// The VIO core operates on an object property-based set/commit use model. You can set the<br/>
		/// OUTPUT_VALUE property on the output probes of the VIO core using the set_property<br/>
		/// command. You can then drive those values onto probed signals on the hardware device using the<br/>
		/// commit_hw_vio command.<br/>
		/// This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 162<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_objects">(Required) List of hardware VIO and hardware probe objects.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL commit_hw_vio(TCLParameterList hw_objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: commit_hw_vio [-quiet] [-verbose] <hw_objects>...
			this.Entry(_builder.commit_hw_vio(hw_objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Compile C code into RTL<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: compile_c [-force] [-quiet] [-verbose] &lt;objects&gt;
		/// <br/>
		/// <para>
		/// In IP cores that are imported from Vivado HLS, the compile_c command detects C, C++, and<br/>
		/// SystemC files and converts those files to RTL for synthesis by the Vivado Design Suite.<br/>
		/// This lets you use Vivado HLS to describe IP cores in a high-level language, like C or C++ rather<br/>
		/// than RTL.<br/>
		/// When HLS-based IP cores are generated, they only deliver the C source. When the HLS-based IP<br/>
		/// is synthesized, either in the out-of-context flow, or with the top-level design, the compile_c<br/>
		/// command launches Vivado HLS to convert the C source files into RTL, and import the resulting<br/>
		/// RTL sources back into the design prior to synthesis.<br/>
		/// RECOMMENDED: The compile_c command is automatically called by the Vivado Design Suite when<br/>
		/// it encounters IP with C code from the Vivado HLS system. You should not need to manually call this<br/>
		/// command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 164<br/>
		/// </para>
		/// </summary>
		/// <param name="objects">(Required) The objects which need C to RTL conversion</param>
		/// <param name="force">(Optional) Force generate product state regeneration</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL compile_c(String objects, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: compile_c [-force] [-quiet] [-verbose] <objects>
			this.Entry(_builder.compile_c(objects, force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Compile simulation libraries<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: compile_simlib [-directory &lt;arg&gt;] [-family &lt;arg&gt;] [-force] [-language &lt;arg&gt;] [-library &lt;arg&gt;] [-print_library_info &lt;arg&gt;] -simulator &lt;arg&gt; [-simulator_exec_path &lt;arg&gt;] [-gcc_exec_path &lt;arg&gt;] [-source_library_path &lt;arg&gt;] [-no_ip_compile] [-32bit] [-no_systemc_compile] [-no_dpi_compile] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Compile Xilinx® simulation libraries for the cells and IP used in the current project, or from a<br/>
		/// specified directory for use in multiple design projects.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The Vivado Design Suite provides simulation models as a set of files and libraries that contain the<br/>
		/// behavioral and timing models for use by the Vivado simulator. The compile_simlib command<br/>
		/// compiles these libraries for use by third-party simulators prior to design simulation. Libraries<br/>
		/// must generally be compiled or recompiled with a new software release to update simulation<br/>
		/// models and to support a new version of a simulator.<br/>
		/// IMPORTANT! You should rerun the compile_simlib command any time a new third party simulator<br/>
		/// will be used, or a new Vivado Design Suite version or update is installed.<br/>
		/// When this command is run from a current project, the tool will use the device family, target<br/>
		/// language, and library settings specified by the project as the default values, rather than the<br/>
		/// default settings of the command defined below. The default settings can be overridden by<br/>
		/// specifying the necessary options when the command is run.<br/>
		/// The compile_simlib command uses simulator compilation directives when compiling the<br/>
		/// simulation libraries. You can edit the default configuration settings using the<br/>
		/// config_compile_simlib command.<br/>
		/// The command returns information related to the compiled libraries, or an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example shows how to compile UNISIM and SIMPRIM libraries for ModelSim<br/>
		/// (VHDL) for a design using a Virtex-7 device:<br/>
		/// compile_simlib -simulator modelsim -family virtex7 -library unisim \<br/>
		/// -library simprim -language vhdl<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 166<br/>
		/// </para>
		/// </summary>
		/// <param name="simulator">(Required) Compile libraries for this simulator</param>
		/// <param name="directory">(Optional) Directory path for saving the compiled results Default: .</param>
		/// <param name="family">(Optional) Select device architecture Default: all</param>
		/// <param name="force">(Optional) Overwrite the pre-compiled libraries</param>
		/// <param name="language">(Optional) Compile libraries for this language Default: all</param>
		/// <param name="library">(Optional) Select library to compile Default: all</param>
		/// <param name="print_library_info">(Optional) Print Pre-Compiled library information</param>
		/// <param name="simulator_exec_path">(Optional) Use simulator executables from this directory</param>
		/// <param name="gcc_exec_path">(Optional) Use GNU executables from this directory</param>
		/// <param name="source_library_path">
		/// <para>
		/// (Optional)<br/>
		/// If specified, this directory will be searched for the library<br/>
		/// source files before searching the default path(s) found in<br/>
		/// environment variable XILINX_VIVADO for Vivado<br/>
		/// </para>
		/// </param>
		/// <param name="no_ip_compile">(Optional) Do not compile IP static files from repository</param>
		/// <param name="_32bit">(Optional) Perform the 32-bit compilation</param>
		/// <param name="no_systemc_compile">(Optional) Do not compile models for system simulation</param>
		/// <param name="no_dpi_compile">(Optional) Do not compile DPI models</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL compile_simlib(String simulator, String directory = null, String family = null, bool? force = null, String language = null, String library = null, String print_library_info = null, String simulator_exec_path = null, String gcc_exec_path = null, String source_library_path = null, bool? no_ip_compile = null, bool? _32bit = null, bool? no_systemc_compile = null, bool? no_dpi_compile = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: compile_simlib [-directory <arg>] [-family <arg>] [-force] [-language <arg>] [-library <arg>] [-print_library_info <arg>] -simulator <arg> [-simulator_exec_path <arg>] [-gcc_exec_path <arg>] [-source_library_path <arg>] [-no_ip_compile] [-32bit] [-no_systemc_compile] [-no_dpi_compile] [-quiet] [-verbose]
			this.Entry(_builder.compile_simlib(simulator, directory, family, force, language, library, print_library_info, simulator_exec_path, gcc_exec_path, source_library_path, no_ip_compile, _32bit, no_systemc_compile, no_dpi_compile, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Configure settings for compile_simlib<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: config_compile_simlib [-cfgopt &lt;arg&gt;] [-simulator &lt;arg&gt;] [-reset] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Configure third party simulator options for use by the compile_simlib command.<br/>
		/// The Vivado Design Suite has a pre-defined configuration file for the compile_simlib<br/>
		/// command, with compilation options defined for supported third-party simulators, languages, and<br/>
		/// libraries. The config_compile_simlib command is provided to let you change the<br/>
		/// configuration options for specific combinations of simulator, language, and library.<br/>
		/// Use the config_compile_simlib command without any arguments to return all current<br/>
		/// configuration options.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example configures the compilation options for the Modelsim simulator, Verilog<br/>
		/// language, and Unisim library:<br/>
		/// config_compile_simlib -cfgopt {modelsim.verilog.unisim: -quiet}<br/>
		/// The following example configures the compilation options for multiple simulation libraries:<br/>
		/// config_compile_simlib -cfgopt {modelsim.verilog.synopsys: -quiet} \<br/>
		/// -cfgopt {modelsim.verilog.simprim:-source +define+XIL_TIMING}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 171<br/>
		/// </para>
		/// </summary>
		/// <param name="cfgopt">(Optional) Configuration option in form of simulator.language.library.options</param>
		/// <param name="simulator">(Optional) Display the configurations for specified simulator</param>
		/// <param name="reset">(Optional) Reset all configurations</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL config_compile_simlib(String cfgopt = null, String simulator = null, bool? reset = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: config_compile_simlib [-cfgopt <arg>] [-simulator <arg>] [-reset] [-quiet] [-verbose]
			this.Entry(_builder.config_compile_simlib(cfgopt, simulator, reset, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// This command configures general features of design analysis.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: config_design_analysis [-max_common_paths &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// This command configures features of the report_design_analysis command.<br/>
		/// The design analysis report analyzes timing paths at various stages in the Vivado tool flow,<br/>
		/// including synthesis, optimization, placement, routing. The -max_common_paths option<br/>
		/// specifies how many setup timing paths to capture at each stage in the flow.<br/>
		/// Note: This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example ignores the package delays during timing analysis:<br/>
		/// config_design_analysis 500<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 174<br/>
		/// </para>
		/// </summary>
		/// <param name="max_common_paths">
		/// <para>
		/// (Optional)<br/>
		/// Number of paths to consider for finding common paths<br/>
		/// across phases (&lt; 20000) Default: 1000<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL config_design_analysis(Int32? max_common_paths = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: config_design_analysis [-max_common_paths <arg>] [-quiet] [-verbose]
			this.Entry(_builder.config_design_analysis(max_common_paths, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Configure the device GTs for the specified device.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: config_hw_sio_gts [-dict &lt;args&gt;] [-quiet] [-verbose] &lt;hw_device&gt;
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 176<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_device">(Required) hardware device object</param>
		/// <param name="dict">
		/// <para>
		/// (Optional)<br/>
		/// list of name/value pairs of GT settings and values to use to<br/>
		/// configure GTs<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL config_hw_sio_gts(String hw_device, TCLParameterList dict = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: config_hw_sio_gts [-dict <args>] [-quiet] [-verbose] <hw_device>
			this.Entry(_builder.config_hw_sio_gts(hw_device, dict, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Configure Implementation<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: config_implementation [-quiet] [-verbose] [&lt;list&gt;]
		/// <br/>
		/// <para>
		/// This command lets you configure implementation parameters to control the behavior of the<br/>
		/// implementation process.<br/>
		/// The list of properties that can be configured, or have been configured by this command can be<br/>
		/// reported by the report_config_implementation command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example configures implementation parameters:<br/>
		/// config_implementation { {incr.ignore_user_clock_uncertainty True}<br/>
		/// {&lt;other_param&gt; &lt;other_value&gt;} }<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 177<br/>
		/// </para>
		/// </summary>
		/// <param name="list">(Required) list of config params which need to be configured</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL config_implementation(String list, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: config_implementation [-quiet] [-verbose] [<list>]
			this.Entry(_builder.config_implementation(list, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Manage the IP instance Synthesis cache. Lists out the IP Cache entries if no options are specified.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: config_ip_cache [-use_cache_location &lt;arg&gt;] [-use_project_cache] [-disable_cache] [-clear_output_repo] [-clear_local_cache] [-cache_has_match] [-cache_was_used] [-get_id] [-get_entry_location &lt;arg&gt;] [-remove] [-vlnv &lt;arg&gt;] [-old_swvers] [-unused] [-swver &lt;arg&gt;] [-num_days_old &lt;arg&gt;] [-num_days_unused &lt;arg&gt;] [-obs_synth_crc] [-disk_usage_output_repo] [-report] [-rptfile &lt;arg&gt;] [-csvfile &lt;arg&gt;] [-zip_cache &lt;arg&gt;] [-import_from_project] [-filter &lt;arg&gt;] [-regexp] [-nocase] [-purge] [-quiet] [-verbose] [&lt;ip&gt;]
		/// <br/>
		/// <para>
		/// This command lets you manage the Vivado Design Suite out-of-context (OOC) IP cache. The<br/>
		/// Vivado Design Suite caches the synthesis results for customized OOC IP in an IP repository, so<br/>
		/// multiple IP that use the same customization profile can share OOC synthesis results to decrease<br/>
		/// run time. The cached synthesis results can be reused in a single project from the project cache, or<br/>
		/// across multiple projects using a remote cache location.<br/>
		/// When generating the synthesis output products for an OOC IP, if a matching IP customization is<br/>
		/// found in the IP repository, the cached synthesis results will be used. If no suitable match is found<br/>
		/// in the IP repository, the synthesis output products will be generated as usual and the results,<br/>
		/// including the design checkpoint (DCP), will be copied into the IP synthesis cache for future use.<br/>
		/// TIP: When cached results are used, an information message is displayed in the Tcl console indicating the IP<br/>
		/// cache location used.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// You can specify a repository of cached IP synthesis results either within the current project, or at<br/>
		/// an external location. The location of the IP cache is defined by the IP_OUTPUT_REPO property<br/>
		/// on a project, with the value of a string defining a valid file system directory. You can set this<br/>
		/// property using the check_ip_cache command with either the -use_cache_location or<br/>
		/// the -use_project_cache options. The default IP synthesis cache location is in the current<br/>
		/// project folders.<br/>
		/// The use of the IP synthesis cache is controlled by the IP_CACHE_PERMISSIONS property that<br/>
		/// can be set with the set_property command. The current values are:<br/>
		/// • disabled - Do not use the IP synthesis cache. This is the default setting.<br/>
		/// • read - Use the IP synthesis cache to read OOC synthesis results from and apply as appropriate<br/>
		/// in the current project.<br/>
		/// • write - Use the IP synthesis cache to write OOC synthesis results into, but do not use them to<br/>
		/// read IP into the current project.<br/>
		/// • read write - Use the IP synthesis cache for both writing results to, and using those results in<br/>
		/// the current project.<br/>
		/// The config_ip_cache command should be followed by the update_ip_catalog command<br/>
		/// to read the specified IP cache repository into the Vivado tool.<br/>
		/// TIP: The IP synthesis cache can be enabled, and the cache repository specified, in the Vivado Design Suite<br/>
		/// IDE using the Settings dialog box. Refer to the Vivado Design Suite User Guide: Designing with IP (UG896)<br/>
		/// for more information on using the cache.<br/>
		/// By default, without any of the arguments specified below, the config_ip_cache command<br/>
		/// returns a list of entries in the IP synthesis cache, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 179<br/>
		/// </para>
		/// </summary>
		/// <param name="use_cache_location">(Optional) Set current project properties to use the specified cache location</param>
		/// <param name="use_project_cache">
		/// <para>
		/// (Optional)<br/>
		/// Set current project properties to use the default project IP<br/>
		/// cache location<br/>
		/// </para>
		/// </param>
		/// <param name="disable_cache">(Optional) Disable cache use.</param>
		/// <param name="clear_output_repo">
		/// <para>
		/// (Optional)<br/>
		/// Delete from disk and in memory all cache entries that exist<br/>
		/// in the current project's designated cache (local or remote).<br/>
		/// </para>
		/// </param>
		/// <param name="clear_local_cache">
		/// <para>
		/// (Optional)<br/>
		/// Delete from disk and in memory all local cache entries for<br/>
		/// this project.<br/>
		/// </para>
		/// </param>
		/// <param name="cache_has_match">
		/// <para>
		/// (Optional)<br/>
		/// Returns the cache-ID of the cache entry that would work for<br/>
		/// this IP instance; else ''.<br/>
		/// </para>
		/// </param>
		/// <param name="cache_was_used">
		/// <para>
		/// (Optional)<br/>
		/// Returns '1' if the cache was used to obtain the IP's current<br/>
		/// synthesis results; else '0'.<br/>
		/// </para>
		/// </param>
		/// <param name="get_id">(Optional) Calculate and return IP cache ID string for specified &lt;ip&gt;</param>
		/// <param name="get_entry_location">(Optional) Return directory where this cache-ID entry is located.</param>
		/// <param name="remove">
		/// <para>
		/// (Optional)<br/>
		/// Remove the corresponding cache entry for the specified IP<br/>
		/// instance or specified cachedInst; return cache ID string if<br/>
		/// successful, otherwise blank.<br/>
		/// </para>
		/// </param>
		/// <param name="vlnv">
		/// <para>
		/// (Optional)<br/>
		/// Used with -purge or -get_resource_data, specifies the VLNV<br/>
		/// of the cache entries to delete or find. May use a wildcard<br/>
		/// ('*') in one or more fields in the VLNV.<br/>
		/// </para>
		/// </param>
		/// <param name="old_swvers">
		/// <para>
		/// (Optional)<br/>
		/// Used with -purge to delete cache entries created with old<br/>
		/// Vivado SW Versions.<br/>
		/// </para>
		/// </param>
		/// <param name="unused">(Optional) Used with -purge to delete cache entries that have never been used.</param>
		/// <param name="swver">
		/// <para>
		/// (Optional)<br/>
		/// Used with -purge to delete any cache entries created from<br/>
		/// this specific Vivado SW Version (i.e., '2017.1').<br/>
		/// </para>
		/// </param>
		/// <param name="num_days_old">
		/// <para>
		/// (Optional)<br/>
		/// Used with -purge to delete any cache entries that are this<br/>
		/// number of days old or older.<br/>
		/// </para>
		/// </param>
		/// <param name="num_days_unused">
		/// <para>
		/// (Optional)<br/>
		/// Used with -purge to delete any cache entries that have not<br/>
		/// been used for this number of days or longer.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Name Description<br/>
		/// </para>
		/// </param>
		/// <param name="obs_synth_crc">
		/// <para>
		/// (Optional)<br/>
		/// Used with -purge to delete cache entries whose component<br/>
		/// synth checksum is not the same as the IP Catalog's current<br/>
		/// component synthesis checksum.<br/>
		/// </para>
		/// </param>
		/// <param name="disk_usage_output_repo">
		/// <para>
		/// (Optional)<br/>
		/// Return total disk usage in MB for all cache entries in the<br/>
		/// current project's ip_output_repo.<br/>
		/// </para>
		/// </param>
		/// <param name="report">
		/// <para>
		/// (Optional)<br/>
		/// Report cache statistics for the specified IP or cache object,<br/>
		/// or for the current cache location if none specified. If -rptfile<br/>
		/// is specified, write statistics to that file. If -dir is specified,<br/>
		/// write statistics for cache entries found under that directory.<br/>
		/// </para>
		/// </param>
		/// <param name="rptfile">
		/// <para>
		/// (Optional)<br/>
		/// Used with -report, specifies the text file to write the cache<br/>
		/// statistics to.<br/>
		/// </para>
		/// </param>
		/// <param name="csvfile">
		/// <para>
		/// (Optional)<br/>
		/// Used with -report, specifies the csv file to write the cache<br/>
		/// statistics to, in csv format.<br/>
		/// </para>
		/// </param>
		/// <param name="zip_cache">
		/// <para>
		/// (Optional)<br/>
		/// Zip up all cache entries used by the current project and<br/>
		/// write to the given filename.<br/>
		/// </para>
		/// </param>
		/// <param name="import_from_project">(Optional) Import existing synthesized IP from the project into the cache.</param>
		/// <param name="filter">(Optional) Filter result of '-list'</param>
		/// <param name="regexp">(Optional) Use regular expressions instead of globs in '-filter' argument(s)</param>
		/// <param name="nocase">(Optional) Use case insensitive matching in '-filter' argument(s)</param>
		/// <param name="purge">
		/// <para>
		/// (Optional)<br/>
		/// Delete all cache entries that match the specified type(s): -<br/>
		/// vlnv, -obs_swvers, -obs_synth_crc, and/or -swver. Returns<br/>
		/// the number of entries deleted.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="ip">(Optional) IP instance object, IP file, or IP name pattern</param>
		public VivadoTCL config_ip_cache(String use_cache_location = null, bool? use_project_cache = null, bool? disable_cache = null, bool? clear_output_repo = null, bool? clear_local_cache = null, bool? cache_has_match = null, bool? cache_was_used = null, bool? get_id = null, String get_entry_location = null, bool? remove = null, String vlnv = null, bool? old_swvers = null, bool? unused = null, String swver = null, Int32? num_days_old = null, Int32? num_days_unused = null, bool? obs_synth_crc = null, bool? disk_usage_output_repo = null, bool? report = null, String rptfile = null, String csvfile = null, String zip_cache = null, bool? import_from_project = null, String filter = null, bool? regexp = null, bool? nocase = null, bool? purge = null, bool? quiet = null, bool? verbose = null, String ip = null)
		{
			// TCL Syntax: config_ip_cache [-use_cache_location <arg>] [-use_project_cache] [-disable_cache] [-clear_output_repo] [-clear_local_cache] [-cache_has_match] [-cache_was_used] [-get_id] [-get_entry_location <arg>] [-remove] [-vlnv <arg>] [-old_swvers] [-unused] [-swver <arg>] [-num_days_old <arg>] [-num_days_unused <arg>] [-obs_synth_crc] [-disk_usage_output_repo] [-report] [-rptfile <arg>] [-csvfile <arg>] [-zip_cache <arg>] [-import_from_project] [-filter <arg>] [-regexp] [-nocase] [-purge] [-quiet] [-verbose] [<ip>]
			this.Entry(_builder.config_ip_cache(use_cache_location, use_project_cache, disable_cache, clear_output_repo, clear_local_cache, cache_has_match, cache_was_used, get_id, get_entry_location, remove, vlnv, old_swvers, unused, swver, num_days_old, num_days_unused, obs_synth_crc, disk_usage_output_repo, report, rptfile, csvfile, zip_cache, import_from_project, filter, regexp, nocase, purge, quiet, verbose, ip));
			return this;
		}
		/// <summary>
		/// <para>
		/// Configure timing analysis general settings<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: config_timing_analysis [-enable_input_delay_default_clock &lt;arg&gt;] [-enable_preset_clear_arcs &lt;arg&gt;] [-ignore_io_paths &lt;arg&gt;] [-disable_flight_delays &lt;arg&gt;] [-merge_exceptions &lt;arg&gt;] [-timing_early_launch_at_borrowing_latches &lt;arg&gt;] [-enable_time_borrowing_for_max_delay_exceptions &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// This command configures general features of timing analysis.<br/>
		/// Note: This command returns nothing if successful, or returns an error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example ignores the package delays during timing analysis:<br/>
		/// config_timing_analysis -disable_flight_delays true<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 186<br/>
		/// </para>
		/// </summary>
		/// <param name="enable_input_delay_default_clock">
		/// <para>
		/// (Optional)<br/>
		/// Launch SDC unclocked input delays from an internally<br/>
		/// defined clock: Values: true, false; This option is not<br/>
		/// supported for UCF constraints<br/>
		/// </para>
		/// </param>
		/// <param name="enable_preset_clear_arcs">
		/// <para>
		/// (Optional)<br/>
		/// Time paths through asynchronous preset or clear timing<br/>
		/// arcs: true, false;<br/>
		/// </para>
		/// </param>
		/// <param name="ignore_io_paths">
		/// <para>
		/// (Optional)<br/>
		/// Ignore paths from primary inputs and paths to primary<br/>
		/// outputs: Values: true, false<br/>
		/// </para>
		/// </param>
		/// <param name="disable_flight_delays">(Optional) Disable adding package times to IO Calculations : Values: true, false;</param>
		/// <param name="merge_exceptions">
		/// <para>
		/// (Optional)<br/>
		/// Allow/Prevent the timing engine from merging timing<br/>
		/// exceptions : Values: true, false;<br/>
		/// </para>
		/// </param>
		/// <param name="timing_early_launch_at_borrowing_latches">
		/// <para>
		/// (Optional)<br/>
		/// Remove clock latency pessimism from the launching enable<br/>
		/// of paths through transparent latches. Values: auto, true,<br/>
		/// false Default: auto<br/>
		/// [-<br/>
		/// enable_time_borrowing_for_max_delay_exceptions<br/>
		/// ]<br/>
		/// Allow timing paths covered by set_max_delay timing<br/>
		/// exceptions to borrow time. Values: true, false<br/>
		/// </para>
		/// </param>
		/// <param name="enable_time_borrowing_for_max_delay_exceptions">(Optional)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL config_timing_analysis(bool? enable_input_delay_default_clock = null, String enable_preset_clear_arcs = null, bool? ignore_io_paths = null, bool? disable_flight_delays = null, bool? merge_exceptions = null, bool? timing_early_launch_at_borrowing_latches = null, String enable_time_borrowing_for_max_delay_exceptions = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: config_timing_analysis [-enable_input_delay_default_clock <arg>] [-enable_preset_clear_arcs <arg>] [-ignore_io_paths <arg>] [-disable_flight_delays <arg>] [-merge_exceptions <arg>] [-timing_early_launch_at_borrowing_latches <arg>] [-enable_time_borrowing_for_max_delay_exceptions <arg>] [-quiet] [-verbose]
			this.Entry(_builder.config_timing_analysis(enable_input_delay_default_clock, enable_preset_clear_arcs, ignore_io_paths, disable_flight_delays, merge_exceptions, timing_early_launch_at_borrowing_latches, enable_time_borrowing_for_max_delay_exceptions, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Configure single / multi corner timing analysis settings<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: config_timing_corners [-corner &lt;arg&gt;] [-delay_type &lt;arg&gt;] [-setup] [-hold] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// This command configures the Slow and Fast timing corners in the current design for single or<br/>
		/// multi-corner timing analysis. A synthesized or implemented design must be opened when<br/>
		/// running this command.<br/>
		/// The variation in the manufacturing process of the physical device, and the voltage and<br/>
		/// temperature at which the device is operating, combine to create a timing corner. These three<br/>
		/// variables (PVT) determine the delay across the device. The fast corner represents a device<br/>
		/// operating with the smallest manufacturing process tolerances, the highest voltage, and the<br/>
		/// lowest temperature. The slow corner represents a device operating with the greatest<br/>
		/// manufacturing tolerances, the lowest voltage, and the highest temperature. By default the<br/>
		/// Vivado Design Suite performs both a setup and hold analysis for both slow and fast process<br/>
		/// corners, also known as quad analysis:<br/>
		/// config_timing_corners -corner Slow -setup -hold<br/>
		/// config_timing_corners -corner Fast -setup -hold<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The config_timing_corners command can be used to limit the default four corner analysis<br/>
		/// performed by the Vivado timing engine as appropriate to the design, to improve timing<br/>
		/// performance. To change or disable the default analysis for both corners, you must configure both<br/>
		/// the Fast and Slow corners:<br/>
		/// config_timing_corners -corner Slow -delay_type max<br/>
		/// config_timing_corners -corner Fast -delay_type none<br/>
		/// Note: This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example configures the Slow timing corner for both setup and hold analysis:<br/>
		/// config_timing_corners -corner slow -setup -hold<br/>
		/// config_timing_corners -corner slow -delay_type min_max<br/>
		/// Note: The two preceding examples have the same effect.<br/>
		/// The following example configures the Fast corner for min delay analysis, and disables the Slow<br/>
		/// corner analysis:<br/>
		/// config_timing_corners -corner fast -delay_type min<br/>
		/// config_timing_corners -corner slow -delay_type none<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 189<br/>
		/// </para>
		/// </summary>
		/// <param name="corner">(Optional) Name of the timing corner to be modified : Values: Slow, Fast</param>
		/// <param name="delay_type">
		/// <para>
		/// (Optional)<br/>
		/// Type of path delays to be analyzed for specified timing<br/>
		/// corner: Values: none, max, min, min_max<br/>
		/// </para>
		/// </param>
		/// <param name="setup">
		/// <para>
		/// (Optional)<br/>
		/// Enable timing corner for setup analysis (equivalent to -<br/>
		/// delay_type max)<br/>
		/// </para>
		/// </param>
		/// <param name="hold">
		/// <para>
		/// (Optional)<br/>
		/// Enable timing corner for hold analysis (equivalent to -<br/>
		/// delay_type min)<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL config_timing_corners(config_timing_corners_corner? corner = null, config_timing_corners_delay_type? delay_type = null, bool? setup = null, bool? hold = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: config_timing_corners [-corner <arg>] [-delay_type <arg>] [-setup] [-hold] [-quiet] [-verbose]
			this.Entry(_builder.config_timing_corners(corner, delay_type, setup, hold, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Enable/disable WebTalk to send software, IP and device usage statistics to Xilinx. Note: WebTalk<br/>
		/// is always enabled for WebPACK users. WebTalk ignores user and install preference when a<br/>
		/// bitstream is generated using the WebPACK license. If a design is using a device contained in<br/>
		/// WebPACK and a WebPACK license is available, the WebPACK license will be used. To change<br/>
		/// this, please see answer record 34746.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: config_webtalk [-info] [-user &lt;arg&gt;] [-install &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// WebTalk is a secure design data collection feature of Xilinx software that helps Xilinx understand<br/>
		/// how you are using Xilinx devices, software, and Intellectual Property (IP).<br/>
		/// This command returns the current state of the WebTalk feature for the current user and software<br/>
		/// installation. You can also enable or disable WebTalk to send software, IP and device usage<br/>
		/// statistics to Xilinx. No data is sent if you disable WebTalk, except for the use of the WebPACK<br/>
		/// license to generate a bitstream.<br/>
		/// Participation in WebTalk is voluntary, except for the use of the WebPACK license. WebTalk data<br/>
		/// transmission is mandatory, and is always enabled for WebPACK users. WebTalk ignores user and<br/>
		/// install preference when a bitstream is generated using the WebPACK license.<br/>
		/// Note: If a design is using a device contained in WebPACK and a WebPACK license is available, the<br/>
		/// WebPACK license will be used. To change this, please see answer record 34746.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the current state of the WebTalk configuration:<br/>
		/// config_webtalk -info<br/>
		/// INFO: [Coretcl-120] Webtalk has been disabled by the current user.<br/>
		/// INFO: [Coretcl-123] Webtalk has been enabled for the current installation.<br/>
		/// INFO: [Coretcl-110] This combination of user/install settings means that<br/>
		/// WebTalk is currently disabled.<br/>
		/// The following example enables WebTalk for the current user:<br/>
		/// config_webtalk -user on<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 192<br/>
		/// </para>
		/// </summary>
		/// <param name="info">(Optional) Show whether WebTalk is currently enabled or disabled</param>
		/// <param name="user">
		/// <para>
		/// (Optional)<br/>
		/// Enable/disable WebTalk for the current user. Specify either<br/>
		/// 'on' to enable or 'off' to disable. Default: empty<br/>
		/// </para>
		/// </param>
		/// <param name="install">
		/// <para>
		/// (Optional)<br/>
		/// Enable/disable WebTalk for all users of the current<br/>
		/// installation. Specify either 'on' to enable or 'off' to disable.<br/>
		/// If you specify 'off', individual users will not be able to enable<br/>
		/// WebTalk using the -user option. You may need<br/>
		/// administrator rights to use this option. Default: empty<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL config_webtalk(bool? info = null, String user = null, String install = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: config_webtalk [-info] [-user <arg>] [-install <arg>] [-quiet] [-verbose]
			this.Entry(_builder.config_webtalk(info, user, install, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Connect intf_port and intf_pin list.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: connect_bd_intf_net [-intf_net &lt;arg&gt;] [-boundary_type &lt;arg&gt;] [-quiet] [-verbose] &lt;object1&gt; &lt;object2&gt; [&lt;auto&gt;]
		/// <br/>
		/// <para>
		/// Connect the interface pins on an IP integrator cell to other interface pins, or to external interface<br/>
		/// ports. An interface is a grouping of signals that share a common function in the IP integrator<br/>
		/// subsystem design.<br/>
		/// This command will create an interface net of the name specified by the -intf_net option, will<br/>
		/// connect to an existing interface net of the specified name, or will assign a name if none is<br/>
		/// specified.<br/>
		/// Returns the connected interface net object, or returns an error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 194<br/>
		/// </para>
		/// </summary>
		/// <param name="object1">(Required) Name of intf_port or intf_pin to connect</param>
		/// <param name="object2">(Required) Name of intf_port or intf_pin to connect</param>
		/// <param name="intf_net">(Optional) The single intf_net that all objects connect to</param>
		/// <param name="boundary_type">
		/// <para>
		/// (Optional)<br/>
		/// Used when source object is on a hierarchical block's<br/>
		/// interface pin. Valid values are 'upper', 'lower', or 'both'. If<br/>
		/// 'lower' boundary, searches from the lower level of hierarchy<br/>
		/// onwards. Default: both<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="auto">(Optional) Automatically connect associated pins</param>
		/// <returns>TCL_OK, TCL_ERROR if failed.</returns>
		public VivadoTCL connect_bd_intf_net(String object1, String object2, String intf_net = null, String boundary_type = null, bool? quiet = null, bool? verbose = null, String auto = null)
		{
			// TCL Syntax: connect_bd_intf_net [-intf_net <arg>] [-boundary_type <arg>] [-quiet] [-verbose] <object1> <object2> [<auto>]
			this.Entry(_builder.connect_bd_intf_net(object1, object2, intf_net, boundary_type, quiet, verbose, auto));
			return this;
		}
		/// <summary>
		/// <para>
		/// Connect port and pin object list.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: connect_bd_net [-net &lt;arg&gt;] [-boundary_type &lt;arg&gt;] [-quiet] [-verbose] &lt;objects&gt;...
		/// <br/>
		/// <para>
		/// Create a new net in the current IP integrator subsystem design connecting the specified list of<br/>
		/// block diagram port and pin objects, or connect an existing net to the specified pins and ports.<br/>
		/// If the -net option is not specified, a new net is created connecting the listed objects. If -net is<br/>
		/// used, the specified net is either connected or created as needed.<br/>
		/// Use the get_bd_ports and get_bd_pins commands to specify the port and pin objects to<br/>
		/// connect.<br/>
		/// You can use this command to connect pins or ports at different levels of the subsystem design<br/>
		/// hierarchy. However, in this case, you cannot specify the -net option because the connection,<br/>
		/// when complete, will result in multiple nets rather than a single net.<br/>
		/// The command returns the connected IP integrator subsystem design net object, or returns an<br/>
		/// error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example connects two pins on different levels of the IP subsystem design<br/>
		/// hierarchy:<br/>
		/// connect_bd_net [get_bd_pins /vidOut_1/locked] \<br/>
		/// [get_bd_pins /newMod1/bridge_1/fid]<br/>
		/// Note: Because /vidOut_1/locked and /newMod1/bridge_1/fid are in different levels of the<br/>
		/// subsystem design hierarchy, the -net option is not specified. In this case, multiple nets are created for<br/>
		/// connection across the hierarchy.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 196<br/>
		/// </para>
		/// </summary>
		/// <param name="objects">(Required) The objects connect to the net</param>
		/// <param name="net">(Optional) The single net that all objects connect to</param>
		/// <param name="boundary_type">
		/// <para>
		/// (Optional)<br/>
		/// Used when source object is on a hierarchical block's pin.<br/>
		/// Valid values are 'upper', 'lower', or 'both'. If 'lower'<br/>
		/// boundary, searches from the lower level of hierarchy<br/>
		/// onwards. Default: both<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>TCL_OK, TCL_ERROR if failed.</returns>
		public VivadoTCL connect_bd_net(TCLParameterList objects, String net = null, String boundary_type = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: connect_bd_net [-net <arg>] [-boundary_type <arg>] [-quiet] [-verbose] <objects>...
			this.Entry(_builder.connect_bd_net(objects, net, boundary_type, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Connect debug slave instances to the master instance. A valid master is a debug bridge or debug<br/>
		/// hub instance configured in "From BSCAN To DebugHUB" mode. A valid slave could be any of the<br/>
		/// following debug cores (Ex: ILA, VIO, JTAG_to_AXI). connect_debug_cores can only connect<br/>
		/// master and slave instances that exist in the same region (either in Reconfigurable Partition or<br/>
		/// static)<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: connect_debug_cores -master &lt;args&gt; -slaves &lt;args&gt; [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Connect debug slave instances to the specified master instance. The command can add the<br/>
		/// specified slaves into an existing debug chain, where the specified slaves will be connected to the<br/>
		/// debug hub or bridge, without affecting debug slaves that are already in the connection chain.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Debug masters include both the Debug Hub and Debug Bridge. The Vivado Debug Hub core<br/>
		/// provides an interface between the JTAG Boundary Scan (BSCAN) interface of the Xilinx device<br/>
		/// and the Vivado Debug cores, including the Integrated Logic Analyzer (ILA), Virtual Input/Output<br/>
		/// (VIO), and the JTAG-to-AXI. The Vivado Debug Bridge is a debug controller that provides<br/>
		/// multiple options to communicate with the debug cores in both flat designs, or Partial<br/>
		/// Reconfiguration (PR) designs. The Debug Bridge can be configured to debug designs using a<br/>
		/// JTAG cable, or remotely through Ethernet, PCIe, or other interfaces using a Xilinx Virtual Cable<br/>
		/// (XVC), without the need for a JTAG cable. Refer to the Vivado Design Suite User Guide: Vivado<br/>
		/// Programming and Debugging (UG908) for more information.<br/>
		/// IMPORTANT! For Partial Reconfiguration (PR) designs, the connect_debug_cores command can<br/>
		/// only connect master and slave instances that occur in the Static Region, or in the same Reconfigurable<br/>
		/// Partition.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example connects the specified ILA cores to the debug bridge:<br/>
		/// connect_debug_cores -master [get_cells inst_count/debug_bridge_0] \<br/>
		/// -slaves [list [get_cells inst_count/ila_0] [get_cells inst_count/ila_1] ]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 198<br/>
		/// </para>
		/// </summary>
		/// <param name="master">
		/// <para>
		/// (Required)<br/>
		/// A valid debug bridge or debug hub instance configured in<br/>
		/// "From BSCAN To DebugHUB" mode. Only one master<br/>
		/// instance is allowed.<br/>
		/// </para>
		/// </param>
		/// <param name="slaves">
		/// <para>
		/// (Required)<br/>
		/// List of valid slave instances. A valid slave instance is any of<br/>
		/// the following debug cores (Ex: ILA, VIO, JTAG_to_AXI)<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>debug master and slave instances</returns>
		public VivadoTCL connect_debug_cores(TCLParameterList master, TCLParameterList slaves, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: connect_debug_cores -master <args> -slaves <args> [-quiet] [-verbose]
			this.Entry(_builder.connect_debug_cores(master, slaves, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Connect nets and pins to debug port channels<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: connect_debug_port [-channel_start_index &lt;arg&gt;] [-quiet] [-verbose] &lt;port&gt; &lt;nets&gt;...
		/// <br/>
		/// <para>
		/// Connects a signal from the netlist design to a port on an ILA debug core that was added to the<br/>
		/// design using the create_debug_core command. The signal can either be connected to a<br/>
		/// specific channel index on the port, or simply connected to an available channel on the port.<br/>
		/// If you try to connect too many signals to a port, or there are not enough channels to support the<br/>
		/// connection, the tool will return an error.<br/>
		/// Additional ports can be added to a debug core through the use of the create_debug_port<br/>
		/// command, and you can increase the available channels on an existing port with the<br/>
		/// set_property port_width command. See the examples below.<br/>
		/// You can disconnect signals from ports using the disconnect_debug_port command.<br/>
		/// When the debug core has been defined and connected, you can implement the debug core as a<br/>
		/// block for inclusion in the netlist design. Use the implement_debug_core command to<br/>
		/// implement the core.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates a new PROBE port on the myCore debug core, increases the<br/>
		/// PORT_WIDTH property of the port in order to prepare it to receive the number of signals to be<br/>
		/// connected, and connects signals to the port starting at the third channel position (index 2).<br/>
		/// create_debug_port myCore PROBE<br/>
		/// set_property PORT_WIDTH 8 [get_debug_ports myCore/PROBE1]<br/>
		/// connect_debug_port myCore/PROBE1 [get_nets [list m0_ack_o m0_cyc_i \<br/>
		/// m0_err_o m0_rty_o m0_stb_i m0_we_i ]] -channel_start_index 2<br/>
		/// Note: If you specify too many nets to connect to the available channels on the port, the tool will return an<br/>
		/// error and will not connect the ports.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 201<br/>
		/// </para>
		/// </summary>
		/// <param name="port">(Required) Debug port name</param>
		/// <param name="nets">(Required) List of nets or pins</param>
		/// <param name="channel_start_index">(Optional) Connect nets starting at channel index</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL connect_debug_port(String port, TCLParameterList nets, String channel_start_index = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: connect_debug_port [-channel_start_index <arg>] [-quiet] [-verbose] <port> <nets>...
			this.Entry(_builder.connect_debug_port(port, nets, channel_start_index, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Open a connection to a hardware server<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: connect_hw_server [-url &lt;arg&gt;] [-cs_url &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// IMPORTANT! You must use the open_hw command to open the Hardware Manager in the Vivado<br/>
		/// Design Suite before using this command.<br/>
		/// To open a hardware target containing a JTAG chain of one or more Xilinx devices, for<br/>
		/// programming and/or debugging your design, you must first connect to a Vivado tools hardware<br/>
		/// server (hw_server) to manage the connection to the hardware target (hw_target).<br/>
		/// The hw_server manages the connection to the physical programming target. It should be running<br/>
		/// on the machine connected to the hardware programmer, or test board, connected either locally<br/>
		/// or remotely. The hw_server command must be launched as a separate application, and can be<br/>
		/// found in the /bin folder of your Vivado Design Suite installation directory.<br/>
		/// To connect to a hardware server, the hw_server application must be running, and the host<br/>
		/// name and port number noted for the -url argument of the connect_hw_server command.<br/>
		/// The default URL for the hw_server process is localhost:3121. For more information on<br/>
		/// setting up and running the Vivado hardware server, refer to the Vivado Design Suite User Guide:<br/>
		/// Programming and Debugging (UG908).<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// You can connect a single instance of the Vivado Design Suite to multiple hardware servers, to<br/>
		/// support programming and debugging different device configurations. However, you can only<br/>
		/// have one connection to a specific hardware server as identified by the host name/port number<br/>
		/// combination. An error is returned if you attempt to open a connection to a server that is already<br/>
		/// connected.<br/>
		/// The last connected hardware server is the current hardware server, unless changed by the<br/>
		/// current_hw_server command. Any connected server can be disconnected with the<br/>
		/// disconnect_hw_server command.<br/>
		/// This command returns the host name of the hardware server that has been connected.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 203<br/>
		/// </para>
		/// </summary>
		/// <param name="url">(Optional) hw_server url Default: localhost:3121</param>
		/// <param name="cs_url">
		/// <para>
		/// (Optional)<br/>
		/// Url to use for cs_server. If default url is used and no server is<br/>
		/// running there, cs_server will be automatically launched on<br/>
		/// the default url. Default: TCP:localhost:3042<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>hardware server</returns>
		public VivadoTCL connect_hw_server(String url = null, String cs_url = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: connect_hw_server [-url <arg>] [-cs_url <arg>] [-quiet] [-verbose]
			this.Entry(_builder.connect_hw_server(url, cs_url, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Connect a net to pins or ports<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: connect_net [-hierarchical] [-basename &lt;arg&gt;] [-net &lt;args&gt;] [-objects &lt;args&gt;] [-net_object_list &lt;args&gt;] [-dict &lt;args&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// This command allows the user to connect a specified net to one or more pins or ports in the<br/>
		/// netlist of an open Synthesized or Implemented Design.<br/>
		/// The connect_net command will also connect nets across levels of hierarchy in the design, by<br/>
		/// adding pins and hierarchical nets as needed to complete the connection. Added nets and pins can<br/>
		/// be assigned a custom basename to make them easy to identify, or will be assigned a basename<br/>
		/// by the Vivado tool.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// TIP: You can specify multiple nets, and a list of pins and ports to connect those nets to, using a single<br/>
		/// connect_net command with the -net_object_list or -dict options, to significantly speed the<br/>
		/// addition of multiple nets to the current design.<br/>
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not<br/>
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made<br/>
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or<br/>
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*<br/>
		/// command.<br/>
		/// Note: Netlist editing is not allowed on the elaborated RTL design.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 206<br/>
		/// </para>
		/// </summary>
		/// <param name="objects">(Required) List of pin and port objects to connect</param>
		/// <param name="hierarchical">
		/// <para>
		/// (Optional)<br/>
		/// Allow hierarchical connection, creating nets and pins as<br/>
		/// needed (see -basename).<br/>
		/// </para>
		/// </param>
		/// <param name="basename">
		/// <para>
		/// (Optional)<br/>
		/// base name to use for net / pin names needed when doing<br/>
		/// hierarchical connection (see -hier). Default value is inferred<br/>
		/// from the name of the net being connected (see -net).<br/>
		/// </para>
		/// </param>
		/// <param name="net">(Optional) Net to connect to given objects.</param>
		/// <param name="net_object_list">
		/// <para>
		/// (Optional)<br/>
		/// optional, a list of net and pin/port list pairs, each pin or port<br/>
		/// list element is connected to the corresponding net, e.g.<br/>
		/// { net_a { pin_b port_c } net_d pin_e }. Cannot be used with -<br/>
		/// net, -objects list is ignored when -net_object_list is used.<br/>
		/// </para>
		/// </param>
		/// <param name="dict">
		/// <para>
		/// (Optional)<br/>
		/// alternative to -net_object_list, faster, but requires a list of<br/>
		/// net and pin/port object pairs (must be a list of objects, not<br/>
		/// names or other TCL objects), each pin or port list element is<br/>
		/// connected to the corresponding net, e.g. { $net_1 $pin_1<br/>
		/// $net_2 $pin_2 }. Cannot be used with -net, -objects list is<br/>
		/// ignored when -dict is used.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL connect_net(TCLParameterList objects, bool? hierarchical = null, String basename = null, TCLParameterList net = null, TCLParameterList net_object_list = null, TCLParameterList dict = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: connect_net [-hierarchical] [-basename <arg>] [-net <args>] [-objects <args>] [-net_object_list <args>] [-dict <args>] [-quiet] [-verbose]
			this.Entry(_builder.connect_net(objects, hierarchical, basename, net, net_object_list, dict, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Convert specified IP to or from core container format.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: convert_ips [-force] [-to_core_container] [-from_core_container] [-quiet] [-verbose] &lt;objects&gt;
		/// <br/>
		/// <para>
		/// This command converts existing IP into core container format, or reverts core container IP into<br/>
		/// the expanded non-core container format.<br/>
		/// The core container format for IP is a compressed zip file that reduces the file structure in the<br/>
		/// design, and increases tool performance.<br/>
		/// By default, the Vivado tool adds IP from the Xilinx IP catalog into a design using the core<br/>
		/// container format. However, the convert_ips command lets you convert IP in existing designs<br/>
		/// to take advantage of the core container format. In addition, the convert_ips command also<br/>
		/// lets you revert the compressed core container format into the expanded non-core container<br/>
		/// format.<br/>
		/// TIP: If neither -to_core_container or -from_core_container options are specified then the<br/>
		/// convert_ips command will convert the IP from its current format into the opposite form. Any core<br/>
		/// container IP will be converted to non-core container format, and any non-core container IP will be<br/>
		/// converted to core container format.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// IP that is user-managed, cannot be converted from its current format. IP that is locked requires<br/>
		/// the use of the -force option to convert. Refer to the Vivado Design Suite User Guide: Designing<br/>
		/// with IP (UG896) for more information on editing IP and the IS_LOCKED and IS_MANAGED<br/>
		/// properties.<br/>
		/// This command returns a transcript of its actions, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example converts all IP in the current project into core container format:<br/>
		/// convert_ips -to_core_container [get_ips]<br/>
		/// Note: Any IP already in the core container format will be skipped.<br/>
		/// The following example converts the specified IP file to core container format:<br/>
		/// convert_ips -to_core_container \<br/>
		/// [get_files C:/Data/wave1/wave1.srcs/sources_1/ip/char_fifo/char_fifo.xci]<br/>
		/// The following example toggles the current format of all IP in the design, switching from core<br/>
		/// container to non-core container, and from non-core container to core container:<br/>
		/// convert_ips [get_ips]<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 210<br/>
		/// </para>
		/// </summary>
		/// <param name="objects">(Required) Input objects for the IP. May IP or source file objects</param>
		/// <param name="force">(Optional) Force conversion even if the IP is locked.</param>
		/// <param name="to_core_container">(Optional) Convert IP to core container format.</param>
		/// <param name="from_core_container">(Optional) Convert IP to non core container format.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL convert_ips(String objects, bool? force = null, bool? to_core_container = null, bool? from_core_container = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: convert_ips [-force] [-to_core_container] [-from_core_container] [-quiet] [-verbose] <objects>
			this.Entry(_builder.convert_ips(objects, force, to_core_container, from_core_container, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// (User-written application) Convert all provided NGC files to a supported format<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: convert_ngc [-output_dir &lt;arg&gt;] [-format &lt;arg&gt;] [-add_to_project] [-force] [-quiet] [-verbose] &lt;files&gt;
		/// <br/>
		/// <para>
		/// Converts provided NGC files to a supported format.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example will convert test.ngc to test.edn, with verbose messaging. The<br/>
		/// test.edn file will be added to the current open project:<br/>
		/// convert_ngc ./test.ngc -add_to_project -verbose<br/>
		/// The following example will convert test.ngc to test.edn. The test.edn file will be placed<br/>
		/// in the ./output directory. If ./output/test.edn exists it will be replaced:<br/>
		/// convert_ngc ./test.ngc -output_dir output -force<br/>
		/// The following example converts all NGC files in the current directory and in all sub-directories:<br/>
		/// convert_ngc [ glob ./**/*.ngc ] [ glob ./*.ngc ]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 213<br/>
		/// </para>
		/// </summary>
		/// <param name="files">(Required) A list of NGC files to convert</param>
		/// <param name="output_dir">
		/// <para>
		/// (Optional)<br/>
		/// Directory to place all output, else the output is placed at<br/>
		/// location of NGC file Default: Script output directory path<br/>
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// (Optional)<br/>
		/// Accepts 'Verilog' or 'EDIF' (Default: EDIF), specifies the<br/>
		/// desired output format Default: EDIF<br/>
		/// </para>
		/// </param>
		/// <param name="add_to_project">
		/// <para>
		/// (Optional)<br/>
		/// Adds the output files to the current project, if no project is<br/>
		/// open, then this option does nothing<br/>
		/// </para>
		/// </param>
		/// <param name="force">
		/// <para>
		/// (Optional)<br/>
		/// Force overwriting of files that already exist on disk, replaces<br/>
		/// files in project if add_to_project switch was specified<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>None</returns>
		public VivadoTCL convert_ngc(String files, String output_dir = null, String format = null, bool? add_to_project = null, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: convert_ngc [-output_dir <arg>] [-format <arg>] [-add_to_project] [-force] [-quiet] [-verbose] <files>
			this.Entry(_builder.convert_ngc(files, output_dir, format, add_to_project, force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Make copies of the objects and add the copies to the given hierarchical cell.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: copy_bd_objs [-prefix &lt;arg&gt;] [-from_design &lt;arg&gt;] [-quiet] [-verbose] &lt;parent_cell&gt; &lt;objects&gt;...
		/// <br/>
		/// <para>
		/// Use this command to copy IP integrator objects from one open subsystem design to a second<br/>
		/// subsystem design. The selected objects can be copied into the top-level of the current subsystem<br/>
		/// design, or into an existing hierarchical module.<br/>
		/// Because get_bd_cells, and other commands like it, operate on the current subsystem design,<br/>
		/// you must store the objects to be copied in a Tcl variable, as shown in the example below. Set the<br/>
		/// current subsystem design to the source design, select the group of objects to be copied, and<br/>
		/// store them in a Tcl variable. Then change the current_bd_design to the target design, and<br/>
		/// copy the selected objects. In this case, the -from_design option must be used.<br/>
		/// You can also use this command to copy objects from one level of hierarchy in the current<br/>
		/// subsystem design to another. In this case, the -from_design argument does not need to be<br/>
		/// specified.<br/>
		/// This command returns 0 if successful, and returns an error if it failed.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 215<br/>
		/// </para>
		/// </summary>
		/// <param name="parent_cell">(Required) Parent cell</param>
		/// <param name="objects">(Required) The objects to copy</param>
		/// <param name="prefix">(Optional) Prefix name to add to cells</param>
		/// <param name="from_design">(Optional) The design to own the original objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>0, "" if failed.</returns>
		public VivadoTCL copy_bd_objs(String parent_cell, TCLParameterList objects, String prefix = null, String from_design = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: copy_bd_objs [-prefix <arg>] [-from_design <arg>] [-quiet] [-verbose] <parent_cell> <objects>...
			this.Entry(_builder.copy_bd_objs(parent_cell, objects, prefix, from_design, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Copy an existing IP<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: copy_ip -name &lt;arg&gt; [-dir &lt;arg&gt;] [-quiet] [-verbose] &lt;objects&gt;...
		/// <br/>
		/// <para>
		/// Create a copy of an IP core that has been previously instanced into the current project.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 218<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name of copied IP</param>
		/// <param name="objects">(Required) IP to be copied</param>
		/// <param name="dir">
		/// <para>
		/// (Optional)<br/>
		/// Directory path for remote IP to be created and managed<br/>
		/// outside the project<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>IP file object that was added to the project</returns>
		public VivadoTCL copy_ip(String name, TCLParameterList objects, String dir = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: copy_ip -name <arg> [-dir <arg>] [-quiet] [-verbose] <objects>...
			this.Entry(_builder.copy_ip(name, objects, dir, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// (User-written application) Copy a run from an already existing run, source-run, to a new copy of<br/>
		/// that run, destination-run.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: copy_run [-parent_run &lt;arg&gt;] [-verbose] -name &lt;arg&gt; [-quiet] &lt;run&gt;
		/// <br/>
		/// <para>
		/// Copies an existing synthesis or implementation run.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example will copy synth_1 run into a new synth_2 run:<br/>
		/// copy_run -name synth_2 [get_runs synth_1]<br/>
		/// The following example will copy the impl_1 run into a new run called impl_2, and assign synth_2<br/>
		/// as the parent of the new run:<br/>
		/// copy_run -name impl_2 [get_runs impl_1] -parent_run synth_2<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 220<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Specify the name of the new run</param>
		/// <param name="run">(Required) The run to be copied, accepts name or run object</param>
		/// <param name="parent_run">
		/// <para>
		/// (Optional)<br/>
		/// Specify the synthesis run for the new implementation run,<br/>
		/// accepts name or run object (Default: same as source run)<br/>
		/// Default: None<br/>
		/// </para>
		/// </param>
		/// <param name="verbose">(Optional) Print detailed information as the copy progresses</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <returns>The new run object</returns>
		public VivadoTCL copy_run(String name, String run, String parent_run = null, bool? verbose = null, bool? quiet = null)
		{
			// TCL Syntax: copy_run [-parent_run <arg>] [-verbose] -name <arg> [-quiet] <run>
			this.Entry(_builder.copy_run(name, run, parent_run, verbose, quiet));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a new segment.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_bd_addr_seg -range &lt;arg&gt; -offset &lt;arg&gt; [-quiet] [-verbose] [&lt;parent_addr_space&gt;] [&lt;slave_segment&gt;] &lt;name&gt;
		/// <br/>
		/// <para>
		/// Create a new address segment object, bd_addr_seg, in the current IP integrator subsystem<br/>
		/// design.<br/>
		/// This command returns the newly created master address segment object, or returns nothing if it<br/>
		/// failed.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 222<br/>
		/// </para>
		/// </summary>
		/// <param name="range">(Required) Range of segment. e.g. 4096, 4K, 16M, 1G</param>
		/// <param name="offset">(Required) Offset of segment. e.g. 0x00000000</param>
		/// <param name="parent_addr_space">(Required) Parent address space of segment</param>
		/// <param name="slave_segment">(Required) Slave segment of the created segment</param>
		/// <param name="name">(Required) Name of segment to create</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The newly created segment object, "" if failed.</returns>
		public VivadoTCL create_bd_addr_seg(String range, String offset, String parent_addr_space, String slave_segment, String name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_bd_addr_seg -range <arg> -offset <arg> [-quiet] [-verbose] [<parent_addr_space>] [<slave_segment>] <name>
			this.Entry(_builder.create_bd_addr_seg(range, offset, parent_addr_space, slave_segment, name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Add an IP cell from the IP catalog, or add a new hierarchical block.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_bd_cell [-vlnv &lt;arg&gt;] [-type &lt;arg&gt;] [-reference &lt;arg&gt;] [-revision &lt;arg&gt;] [-quiet] [-verbose] &lt;name&gt;
		/// <br/>
		/// <para>
		/// Add a cell from the Vivado catalog to the current subsystem design, create a new hierarchical<br/>
		/// module to add to the subsystem design, or create a new module by referencing the module<br/>
		/// definition from an HDL source file.<br/>
		/// When adding an IP core from the catalog, the -vlnv argument is required.<br/>
		/// When creating a new hierarchical block design module, the -type hier argument is required.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// When creating a block design module that references an RTL module or entity declaration the -<br/>
		/// type module argument is required, as well as -reference. The module reference feature lets<br/>
		/// you add a module definition from an RTL file (Verilog or VHDL) into the block design. The source<br/>
		/// file containing the module definition must be added to the project, or read into the design before<br/>
		/// creating a module reference. Refer to the Vivado Design Suite User Guide: Designing IP Subsystems<br/>
		/// Using IP Integrator (UG994) for more information on referencing modules.<br/>
		/// This command returns the name of the newly created cell object, or returns nothing if the<br/>
		/// command fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// This example adds an AXI FIFO core from the IP integrator catalog to the current subsystem<br/>
		/// design, with the specified name:<br/>
		/// create_bd_cell -vlnv xilinx.com:ip:axi_fifo_mm_s:4.0 axi_fifo_1<br/>
		/// Note: The -vlnv argument identifies the core to add from the Vivado catalog.<br/>
		/// This example creates a new block design container in the block design, referencing the specified<br/>
		/// module definition from a previously loaded BD source file:<br/>
		/// set bdc [ create_bd_cell -type container -reference hier_0 bdc ]<br/>
		/// This example creates a new module in the block design, referencing the specified module<br/>
		/// definition from a previously loaded RTL source file:<br/>
		/// create_bd_cell -type module -reference rtlRam rtlRam_0<br/>
		/// This example creates a new hierarchical module, myModule1, and moves the AXI FIFO from the<br/>
		/// prior example into the new module. myModule1 is set as the current instance in the subsystem<br/>
		/// design, and a new module is created, myModule2, which is added to the current instance. Finally<br/>
		/// the current instance is reset to point to the top-level of the subsystem design:<br/>
		/// create_bd_cell -type hier myModule1<br/>
		/// /myModule1<br/>
		/// move_bd_cells /myModule1 [get_bd_cells /axi_fifo_1]<br/>
		/// /myModule1<br/>
		/// current_bd_instance /myModule1<br/>
		/// /myModule1<br/>
		/// create_bd_cell -type hier myModule2<br/>
		/// /myModule1/myModule2<br/>
		/// current_bd_instance<br/>
		/// /<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 224<br/>
		/// </para>
		/// </summary>
		/// <param name="vlnv">(Required) Vendor:Library:Name:Version of the IP cell to add from the IP catalog.</param>
		/// <param name="name">(Required) Name of cell to create</param>
		/// <param name="type">
		/// <para>
		/// (Optional)<br/>
		/// Type of cell to create. Valid values are IP, hier, container and<br/>
		/// module. Default: IP<br/>
		/// </para>
		/// </param>
		/// <param name="reference">
		/// <para>
		/// (Optional)<br/>
		/// Top module-name or file-path of the module which is<br/>
		/// referred to create the cell.<br/>
		/// </para>
		/// </param>
		/// <param name="revision">(Optional) (Optional) Core revision Default: -1</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The newly created cell object. Returns nothing if the command fails.</returns>
		public VivadoTCL create_bd_cell(String vlnv, String name, String type = null, String reference = null, String revision = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_bd_cell [-vlnv <arg>] [-type <arg>] [-reference <arg>] [-revision <arg>] [-quiet] [-verbose] <name>
			this.Entry(_builder.create_bd_cell(vlnv, name, type, reference, revision, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a new design and its top level hierarchy cell with the same name.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_bd_design [-dir &lt;arg&gt;] [-cell &lt;arg&gt;] [-quiet] [-verbose] &lt;name&gt;
		/// <br/>
		/// <para>
		/// Create a new IP subsystem design module to add to the current project, and for use with the IP<br/>
		/// integrator of the Vivado Design Suite.<br/>
		/// An empty IP subsystem module is created and added to the source files of the current project.<br/>
		/// The subsystem module and file are created with the specified &lt;name&gt; in the current project at:<br/>
		/// &lt;project_name&gt;/&lt;project_name&gt;.srcs/sources_1/bd/&lt;name&gt;/&lt;name&gt;.bd<br/>
		/// This command returns the file path and name of the IP subsystem design created if the command<br/>
		/// is successful. An error is returned if the command fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 227<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name of design to create</param>
		/// <param name="dir">
		/// <para>
		/// (Optional)<br/>
		/// Directory path for remote BD to be created and managed<br/>
		/// outside the project<br/>
		/// </para>
		/// </param>
		/// <param name="cell">(Optional) hierarchical cell name which sub design to be copied into new design</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The newly created design object, "" if failed.</returns>
		public VivadoTCL create_bd_design(String name, String dir = null, String cell = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_bd_design [-dir <arg>] [-cell <arg>] [-quiet] [-verbose] <name>
			this.Entry(_builder.create_bd_design(name, dir, cell, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a new intf_net.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_bd_intf_net [-quiet] [-verbose] &lt;name&gt;
		/// <br/>
		/// <para>
		/// Create a new IP integrator interface net for the subsystem design.<br/>
		/// This command returns the newly created interface net object if successful, and returns noting if it<br/>
		/// failed.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 229<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name of intf_net to create</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The newly created intf_net object, "" if failed.</returns>
		public VivadoTCL create_bd_intf_net(String name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_bd_intf_net [-quiet] [-verbose] <name>
			this.Entry(_builder.create_bd_intf_net(name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a new intf_pin.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_bd_intf_pin [-vlnv &lt;arg&gt;] [-mode &lt;arg&gt;] [-quiet] [-verbose] [&lt;name&gt;]
		/// <br/>
		/// <para>
		/// Create a new interface pin on an IP integrator hierarchical module. An IP integrator interface is a<br/>
		/// grouping of signals that share a common function, and can include both individual signals and<br/>
		/// buses that share a related function. An AXI4-Lite master, for example, is an interface that<br/>
		/// includes a large number of individual signals plus multiple buses.<br/>
		/// To create a single connection pin, or standard bus pin, use the create_bd_pin command.<br/>
		/// Interface pins connect with other compatible interface pins, or interface ports. The interface pin<br/>
		/// is added as a port inside the hierarchical module, to connect outside of the module, and as a pin<br/>
		/// on the hierarchical module.<br/>
		/// You must define the hierarchical module as the current instance in the IP integrator subsystem<br/>
		/// design, using the current_bd_instance command. The current instance is the target of the<br/>
		/// create_bd_intf_pin command.<br/>
		/// This command returns the name of the newly created interface pin object if successful, and<br/>
		/// returns an error if it failed.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 231<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name of intf_pin to create</param>
		/// <param name="vlnv">(Optional) Bus vlnv</param>
		/// <param name="mode">(Optional) Bus interface mode</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The newly created intf_pin object, "" if failed.</returns>
		public VivadoTCL create_bd_intf_pin(String name, String vlnv = null, String mode = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_bd_intf_pin [-vlnv <arg>] [-mode <arg>] [-quiet] [-verbose] [<name>]
			this.Entry(_builder.create_bd_intf_pin(name, vlnv, mode, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a new interface port.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_bd_intf_port [-vlnv &lt;arg&gt;] [-mode &lt;arg&gt;] [-quiet] [-verbose] [&lt;name&gt;]
		/// <br/>
		/// <para>
		/// Create a new IP integrator subsystem design interface port. An IP integrator interface is a<br/>
		/// grouping of signals that share a common function, and can include both individual signals and<br/>
		/// buses that share a related function. An AXI4-Lite master, for example, is an interface that<br/>
		/// includes a large number of individual signals plus multiple buses.<br/>
		/// To create a single connection port, or common bus port, use the create_bd_port command.<br/>
		/// This command returns the name of the newly created interface port object if successful, and<br/>
		/// returns nothing if it failed.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 233<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name of port to create</param>
		/// <param name="vlnv">(Optional) Bus vlnv</param>
		/// <param name="mode">(Optional) Bus interface mode</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The newly created interface port object, "" if failed.</returns>
		public VivadoTCL create_bd_intf_port(String name, String vlnv = null, String mode = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_bd_intf_port [-vlnv <arg>] [-mode <arg>] [-quiet] [-verbose] [<name>]
			this.Entry(_builder.create_bd_intf_port(name, vlnv, mode, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a new TLM interface port.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_bd_intf_tlm_port -vlnv &lt;arg&gt; -mode &lt;arg&gt; [-quiet] [-verbose] &lt;name&gt;
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 235<br/>
		/// </para>
		/// </summary>
		/// <param name="vlnv">(Required) TLM interface vlnv</param>
		/// <param name="mode">(Required) TLM interface mode</param>
		/// <param name="name">(Required) TLM interface name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The newly created TLM interface port object, "" if failed.</returns>
		public VivadoTCL create_bd_intf_tlm_port(String vlnv, String mode, String name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_bd_intf_tlm_port -vlnv <arg> -mode <arg> [-quiet] [-verbose] <name>
			this.Entry(_builder.create_bd_intf_tlm_port(vlnv, mode, name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a new net.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_bd_net [-quiet] [-verbose] &lt;name&gt;
		/// <br/>
		/// <para>
		/// Create a new net in the current IP integrator subsystem design.<br/>
		/// This command returns the newly created net object, or returns an error if failed.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 236<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name of net to create</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The newly created net object, "" if failed.</returns>
		public VivadoTCL create_bd_net(String name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_bd_net [-quiet] [-verbose] <name>
			this.Entry(_builder.create_bd_net(name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a new pin.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_bd_pin [-from &lt;arg&gt;] [-to &lt;arg&gt;] -dir &lt;arg&gt; [-type &lt;arg&gt;] [-quiet] [-verbose] &lt;name&gt;
		/// <br/>
		/// <para>
		/// Create a new pin to add to an IP integrator hierarchical module.<br/>
		/// This command returns the name of the newly created pin object, or returns an error message if it<br/>
		/// failed.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates a new input pin on the specified module in the current IP<br/>
		/// integrator subsystem design:<br/>
		/// create_bd_pin -dir I -type rst /newMod1/rst<br/>
		/// /newMod1/rst<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 238<br/>
		/// </para>
		/// </summary>
		/// <param name="dir">(Required) Pin direction</param>
		/// <param name="name">(Required) Name of pin to create</param>
		/// <param name="from">(Optional) Begin index Default: Unspecified</param>
		/// <param name="to">(Optional) End index Default: Unspecified</param>
		/// <param name="type">(Optional) Pin type</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The newly created pin object, "" if failed.</returns>
		public VivadoTCL create_bd_pin(String dir, String name, String from = null, String to = null, String type = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_bd_pin [-from <arg>] [-to <arg>] -dir <arg> [-type <arg>] [-quiet] [-verbose] <name>
			this.Entry(_builder.create_bd_pin(dir, name, from, to, type, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a new port for an IP subsystem design.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_bd_port [-from &lt;arg&gt;] [-to &lt;arg&gt;] -dir &lt;arg&gt; [-type &lt;arg&gt;] [-freq_hz &lt;arg&gt;] [-quiet] [-verbose] &lt;name&gt;
		/// <br/>
		/// <para>
		/// Create a new port to add to an IP integrator subsystem design. The port is a connection to<br/>
		/// signals external to the subsystem design.<br/>
		/// This command returns the name of the newly created port object, or returns an error message if<br/>
		/// it failed.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates a new bidirectional bus port in the current IP integrator<br/>
		/// subsystem design:<br/>
		/// create_bd_port -from 0 -to 32 -dir IO -type data addr<br/>
		/// /addr<br/>
		/// The following example creates a new 125 MHz clock port:<br/>
		/// create_bd_port -dir I -type clk -freq_hz 125000000 my_clock<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 240<br/>
		/// </para>
		/// </summary>
		/// <param name="dir">(Required) Port direction. Valid values are I, O, or IO.</param>
		/// <param name="name">(Required) Name of port to create</param>
		/// <param name="from">(Optional) Beginning index Default: Unspecified</param>
		/// <param name="to">(Optional) Ending index Default: Unspecified</param>
		/// <param name="type">(Optional) Port type. Valid values are clk, ce, rst, intr, data.</param>
		/// <param name="freq_hz">(Optional) Frequency in Hertz for clock ports Default: Unspecified</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The newly created port object. Returns nothing if the command fails.</returns>
		public VivadoTCL create_bd_port(String dir, String name, String from = null, String to = null, String type = null, String freq_hz = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_bd_port [-from <arg>] [-to <arg>] -dir <arg> [-type <arg>] [-freq_hz <arg>] [-quiet] [-verbose] <name>
			this.Entry(_builder.create_bd_port(dir, name, from, to, type, freq_hz, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a new TLM port for an IP subsystem design.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_bd_tlm_port [-quiet] [-verbose] &lt;name&gt;
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 242<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name of port to create</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The newly created TLM port object. Returns nothing if the command fails.</returns>
		public VivadoTCL create_bd_tlm_port(String name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_bd_tlm_port [-quiet] [-verbose] <name>
			this.Entry(_builder.create_bd_tlm_port(name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create cells in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_cell -reference &lt;arg&gt; [-black_box] [-quiet] [-verbose] &lt;cells&gt;...
		/// <br/>
		/// <para>
		/// Add cells to the netlist of the current Synthesized or Implemented design.<br/>
		/// Note: You cannot add cells to library macros, or macro-primitives.<br/>
		/// New cell instances can be added to the top-level of the design, or hierarchically within any<br/>
		/// module of the design. Instances can reference an existing cell from the library or design source<br/>
		/// files, or a black box instance can be added that reference cells that have not yet been created.<br/>
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not<br/>
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made<br/>
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or<br/>
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*<br/>
		/// command.<br/>
		/// Note: Netlist editing is not allowed on the elaborated RTL design.<br/>
		/// This command returns the name of the created cell instance or instances.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates three new cell instances of the or1200_cpu module with the<br/>
		/// specified instance names:<br/>
		/// create_cell -reference or1200_cpu myCell1 myCell2 myCell3<br/>
		/// The following example sets the hierarchy separator character, then creates a black box instance<br/>
		/// for the referenced cell, specifying a hierarchical instance name:<br/>
		/// set_hierarchy_separator |<br/>
		/// create_cell -reference dmaBlock -black_box usbEngine0|myDMA<br/>
		/// Note: The tool will return an error when -black_box is used, but the -reference cell already exists.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 243<br/>
		/// </para>
		/// </summary>
		/// <param name="reference">(Required) Library cell or design which cells reference</param>
		/// <param name="cells">(Required) Names of cells to create</param>
		/// <param name="black_box">(Optional) Create black box instance</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL create_cell(String reference, TCLParameterList cells, bool? black_box = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_cell -reference <arg> [-black_box] [-quiet] [-verbose] <cells>...
			this.Entry(_builder.create_cell(reference, cells, black_box, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a clock object<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_clock -period &lt;arg&gt; [-name &lt;arg&gt;] [-waveform &lt;args&gt;] [-add] [-quiet] [-verbose] [&lt;objects&gt;]
		/// <br/>
		/// <para>
		/// TIP: The XDC &gt; Timing Constraints language templates and the Timing Constraints Wizard in the Vivado<br/>
		/// IDE offer timing diagrams and additional details around defining specific timing constraints. You can refer<br/>
		/// to these sources for additional information.<br/>
		/// Create a clock object with the specified period or waveform defined in nanoseconds (ns). This<br/>
		/// command defines primary clocks which are used by the timing engine as the delay propagation<br/>
		/// starting point of any clock edge. The defined clock can be added to the definition of an existing<br/>
		/// clock, or overwrite the existing clock.<br/>
		/// A virtual clock can be created that has no source in the design. A virtual clock can be used as a<br/>
		/// time reference for setting input and output delays but does not physically exist in the design.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// A clock can also be generated from an existing physical clock, and derive many of its properties<br/>
		/// from the master clock. Use the create_generated_clock command to derive a clock from<br/>
		/// an existing physical clock.<br/>
		/// IMPORTANT! If you use create_clock to create a generated clock, instead of<br/>
		/// create_generated_clock, the created clock does not inherit any of the properties of its source<br/>
		/// clock. The insertion delay and jitter of the parent clock will not be propagated to the generated clock,<br/>
		/// causing incorrect timing calculations.<br/>
		/// The create_clock command returns the name of the clock object that is created.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates a physical clock called bftClk and defines the clock period:<br/>
		/// create_clock -name bftClk -period 5.000 [get_ports bftClk]<br/>
		/// Note: If the get_ports command defining the objects is left off of this example, a virtual clock is created<br/>
		/// in the design rather than a physical clock.<br/>
		/// The following example creates a clock named clk on the input port, bftClk, with a period of 10ns,<br/>
		/// the rising edge at 2.4ns and the falling edge at 7.4ns:<br/>
		/// create_clock -name clk -period 10.000 -waveform {2.4 7.4} [get_ports bftClk]<br/>
		/// The following example creates a virtual clock since no clock source is specified:<br/>
		/// create_clock -name virtual_clock -period 5.000<br/>
		/// The following example creates a clock with the falling edge at 2ns and the rising edge at 7ns:<br/>
		/// create_clock -name clk -period 10.000 -waveform {7 2} [get_ports bftClk]<br/>
		/// Note: Because the falling edge is earlier than the rising edge in the -waveform definition, although it is<br/>
		/// specified as arg2, it occurs first in the waveform.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 246<br/>
		/// </para>
		/// </summary>
		/// <param name="period">(Required) Clock period: Value &gt; 0</param>
		/// <param name="name">(Optional) Clock name</param>
		/// <param name="waveform">(Optional) Clock edge specification</param>
		/// <param name="add">(Optional) Add to the existing clock in source_objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">(Optional) List of clock source ports, pins or nets</param>
		/// <returns>new clock object</returns>
		public VivadoTCL create_clock(String period, String name = null, TCLParameterList waveform = null, bool? add = null, bool? quiet = null, bool? verbose = null, String objects = null)
		{
			// TCL Syntax: create_clock -period <arg> [-name <arg>] [-waveform <args>] [-add] [-quiet] [-verbose] [<objects>]
			this.Entry(_builder.create_clock(period, name, waveform, add, quiet, verbose, objects));
			return this;
		}
		/// <summary>
		/// <para>
		/// Creates a cluster configuration<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_cluster_configuration -submit_cmd &lt;arg&gt; -kill_cmd &lt;arg&gt; -type &lt;arg&gt; [-quiet] [-verbose] &lt;name&gt;
		/// <br/>
		/// <para>
		/// Creates cluster configuration to be used for launching runs (synthesis and implementation).<br/>
		/// Cluster configuration is defined using name, submit command, kill command and type.<br/>
		/// Cluster configuration allows user to create configurations for different clusters and are persisted<br/>
		/// in Vivado tool settings. So user has to create cluster configuration just once and use whenever<br/>
		/// required.<br/>
		/// Currently, Vivado supports following clusters management tools.<br/>
		/// • Load Sharing Facility (LSF)<br/>
		/// • Sun Grid Engine (SGE)<br/>
		/// • Simple Linux Utility For Resource Management (SLURM)<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates a cluster configuration named lsf_cluster_1 of type LSF. The<br/>
		/// submit command is bsub and the kill command is bkill.<br/>
		/// create_cluster_configuration lsf_cluster_1 bsub bkill LSF<br/>
		/// The following example creates a cluster configuration named lsf_medium of type LSF. The submit<br/>
		/// command is bsub with resource requirement string which looks for 64bit linux os with either<br/>
		/// rhel or centos distro and version of the os is 7 and the jobs will be submitted to medium queue.<br/>
		/// The kill command is bkill.<br/>
		/// create_cluster_configuration lsf_medium {bsub -R "select[os == lin &amp;&amp; type<br/>
		/// == X86_64 &amp;&amp; (osdistro == rhel || osdistro == centos) &amp;&amp; (osver == ws7)]" -<br/>
		/// N -q medium} bkill LSF<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example creates a cluster configuration named sge_conf of type SGE. The submit<br/>
		/// command is qsub and the kill command is qdel.<br/>
		/// create_cluster_configuration sge_conf qsub qdel SGE<br/>
		/// The following example creates a cluster configuration named slurm_conf of type SLURM. The<br/>
		/// submit command is sbatch and the kill command is scancel.<br/>
		/// create_cluster_configuration slurm_conf sbatch scancel SLURM<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 250<br/>
		/// </para>
		/// </summary>
		/// <param name="submit_cmd">(Required) Submit command of cluster configuration</param>
		/// <param name="kill_cmd">(Required) Kill command of cluster configuration</param>
		/// <param name="type">(Required) Type of cluster configuration</param>
		/// <param name="name">(Required) Name of cluster configuration</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL create_cluster_configuration(String submit_cmd, String kill_cmd, String type, String name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_cluster_configuration -submit_cmd <arg> -kill_cmd <arg> -type <arg> [-quiet] [-verbose] <name>
			this.Entry(_builder.create_cluster_configuration(submit_cmd, kill_cmd, type, name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create the Gadget for Project summary dashboard<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_dashboard_gadget -name &lt;arg&gt; -type &lt;arg&gt; [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// IMPORTANT! This command is primarily intended to be used in the Vivado IDE, with the Project<br/>
		/// Summary, and the Add Gadget command.<br/>
		/// Create a new "gadget" for a dashboard, such as the Project Summary dashboard that lets you<br/>
		/// view different aspects of the synthesized or implemented design run. Aspects of the design<br/>
		/// include timing information, resource utilization, DRC and methodology violations, and power<br/>
		/// analysis.<br/>
		/// A dashboard gadget has a series of properties that define the information displayed, and the way<br/>
		/// it is displayed. These properties can be set using the set_property command. To determine<br/>
		/// the properties on a gadget, you can use the following command:<br/>
		/// report_property -all [get_dashboard_gadget &lt;gadget_name&gt;]<br/>
		/// Properties of a dashboard gadget can be set using the set_property command. Some of the<br/>
		/// properties of a gadget that can be set include:<br/>
		/// • TYPE: Indicates the type of information presented by the gadget as defined by the -type<br/>
		/// option.<br/>
		/// • ROW: Indicates the row placement in the dashboard.<br/>
		/// • COL: Indicates the column placement of the gadget in the dashboard.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// • REPORTS: specifies the reports associated with the gadget.<br/>
		/// • RUN.STEP and TYPE: specifies the synthesis or implementation run step that the gadget<br/>
		/// applies to.<br/>
		/// • VIEW.TYPE and ORIENTATION: Specifies the presentation of information as a graph or table,<br/>
		/// and indicates the orientation of the data.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 253<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name of the gadget</param>
		/// <param name="type">(Required) Type of the gadget</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL create_dashboard_gadget(String name, String type, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_dashboard_gadget -name <arg> -type <arg> [-quiet] [-verbose]
			this.Entry(_builder.create_dashboard_gadget(name, type, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a new Integrated Logic Analyzer debug core<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_debug_core [-quiet] [-verbose] &lt;name&gt; &lt;type&gt;
		/// <br/>
		/// <para>
		/// Adds a new Integrated Logic Analyzer (ILA) debug core to an open netlist design in the current<br/>
		/// project. The ILA debug core defines ports for connecting nets to for debugging the design in the<br/>
		/// logic analyzer feature of the Vivado Design Suite available through the open_hw command.<br/>
		/// ILA debug cores can be added to the RTL source files of the design using debug cores from the<br/>
		/// Xilinx IP catalog, or added to the netlist design after synthesis using this command. Refer to the<br/>
		/// Vivado Design Suite User Guide: Vivado Programming and Debugging (UG908) for more information<br/>
		/// on using ILA debug cores.<br/>
		/// Note: A debug core can only be added to an open netlist design using this command.<br/>
		/// The ILA core is created with a CLK port and a PROBE port by default. The CLK port defines the<br/>
		/// clock domain for the ILA core, and allows you to probe signals that are common to that domain.<br/>
		/// The CLK port only supports one clock signal, and so you must create a separate debug core for<br/>
		/// each clock domain. The PROBE port provides a probe point for nets marked for debug with the<br/>
		/// MARK_DEBUG property. The PROBE port offers multiple channels to probe multiple nets from a<br/>
		/// single ILA core.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// You can add new ports to an existing ILA core with the create_debug_port command, and<br/>
		/// connect signals to the ports using the connect_debug_port command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example opens the synthesis run, creating the specified netlist design name, and<br/>
		/// then creates a new ILA debug core in that design:<br/>
		/// open_run -name netlist_1 synth_1<br/>
		/// create_debug_core myCore ila<br/>
		/// The properties of the debug core can be customized by using the set_property command as<br/>
		/// in the following example:<br/>
		/// set_property C_DATA_DEPTH 2048 [get_debug_cores myCore]<br/>
		/// This example marks a sequence of nets for debugging using the MARK_DEBUG property, creates<br/>
		/// a new debug core, connects the CLK port to the appropriate clock domain, and assigns the debug<br/>
		/// nets to the PROBE ports on the core:<br/>
		/// set_property MARK_DEBUG true [get_nets [list {control_reg[0]}<br/>
		/// {control_reg[1]} \<br/>
		/// {control_reg[2]} {control_reg[3]} {control_reg[4]} {control_reg[5]} \<br/>
		/// {control_reg[6]} {control_reg[7]} {control_reg[8]} {control_reg[9]} \<br/>
		/// {control_reg[10]} {control_reg[11]} {control_reg[12]} {control_reg[13]}<br/>
		/// \<br/>
		/// {control_reg[14]} {control_reg[15]} {control_reg[16]} {control_reg[17]}<br/>
		/// \<br/>
		/// {control_reg[18]} {control_reg[19]} {control_reg[20]} {control_reg[21]}<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// \<br/>
		/// {control_reg[22]} {control_reg[23]} {control_reg[24]} {control_reg[25]}<br/>
		/// \<br/>
		/// {control_reg[26]} {control_reg[27]} {control_reg[28]} {control_reg[29]}<br/>
		/// \<br/>
		/// {control_reg[30]} {control_reg[31]}]]<br/>
		/// create_debug_core u_ila_0 ila<br/>
		/// set_property port_width 1 [get_debug_ports u_ila_0/CLK]<br/>
		/// connect_debug_port u_ila_0/CLK [get_nets [list wbClk ]]<br/>
		/// set_property port_width 32 [get_debug_ports u_ila_0/PROBE0]<br/>
		/// connect_debug_port u_ila_0/PROBE0 [get_nets [list {control_reg[0]}<br/>
		/// {control_reg[1]} {control_reg[2]} {control_reg[3]} {control_reg[4]} \<br/>
		/// {control_reg[5]} {control_reg[6]} {control_reg[7]} {control_reg[8]} \<br/>
		/// {control_reg[9]} {control_reg[10]} {control_reg[11]} {control_reg[12]}<br/>
		/// \<br/>
		/// {control_reg[13]} {control_reg[14]} {control_reg[15]} {control_reg[16]}<br/>
		/// \<br/>
		/// {control_reg[17]} {control_reg[18]} {control_reg[19]} {control_reg[20]}<br/>
		/// \<br/>
		/// {control_reg[21]} {control_reg[22]} {control_reg[23]} {control_reg[24]}<br/>
		/// \<br/>
		/// {control_reg[25]} {control_reg[26]} {control_reg[27]} {control_reg[28]}<br/>
		/// \<br/>
		/// {control_reg[29]} {control_reg[30]} {control_reg[31]} ]]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 255<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name of the new debug core instance</param>
		/// <param name="type">(Required) Type of the new debug core</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>new debug_core object</returns>
		public VivadoTCL create_debug_core(String name, String type, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_debug_core [-quiet] [-verbose] <name> <type>
			this.Entry(_builder.create_debug_core(name, type, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a new debug port<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_debug_port [-quiet] [-verbose] &lt;name&gt; &lt;type&gt;
		/// <br/>
		/// <para>
		/// Defines a new port to be added to an existing Vivado ILA debug core that was added to the<br/>
		/// design using the create_debug_core command. The port provides connection points on an<br/>
		/// ILA core to attach nets from the design for debugging.<br/>
		/// When a new debug core is created using the create_debug_core command, it includes a clk<br/>
		/// and probe port by default. However, you can add trigger input/output port types as well. Refer<br/>
		/// to the Vivado Design Suite User Guide: Programming and Debugging (UG908) for more information<br/>
		/// on port types and purpose.<br/>
		/// A port can have one or more connection points to support one or more nets to debug. As a<br/>
		/// default new ports are defined as having a width of 1, allowing only one net to be attached. You<br/>
		/// can change the port width of probe ports to support multiple signals using the set_property<br/>
		/// port_width command (see Examples).<br/>
		/// Note: clk, trig_in, trig_in_ack, trig_out, and trig_out_ack ports can only have a width of 1.<br/>
		/// You can connect signals to ports using the connect_debug_port command, modify existing<br/>
		/// probe connections using modify_debug_ports, and disconnect signals with the<br/>
		/// disconnect_debug_port command.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates a new debug core, and then adds an additional probe port to the<br/>
		/// core, then sets the width of that new port to 8, and connects signals to the probe port:<br/>
		/// create_debug_core myCore ila<br/>
		/// create_debug_port myCore probe<br/>
		/// set_property PORT_WIDTH 8 myCore/probe1<br/>
		/// connect_debug_port -channel_start_index 1 myCore/probe1 \<br/>
		/// {m1_cyc_i m1_ack_o m1_err_o m1_rty_o}<br/>
		/// Note: Recall that the ILA core is created with a clk and probe port by default, so the new probe port is<br/>
		/// automatically numbered as probe1.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 258<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name of the debug core instance</param>
		/// <param name="type">(Required) Type of the new debug port</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>new debug_port object</returns>
		public VivadoTCL create_debug_port(String name, String type, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_debug_port [-quiet] [-verbose] <name> <type>
			this.Entry(_builder.create_debug_port(name, type, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a user defined DRC rule<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_drc_check [-hiername &lt;arg&gt;] -name &lt;arg&gt; [-desc &lt;arg&gt;] [-msg &lt;arg&gt;] -rule_body &lt;arg&gt; [-severity &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Create a new user-defined DRC rule check, drc_check, for use by the tool when running<br/>
		/// report_drc.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This command allows you to define a unique name or abbreviation for the user-defined rule<br/>
		/// check, optionally group the rule into a special hierarchy and provide a description of the rule,<br/>
		/// define a general placeholder message for the check when violations are encountered, and refer<br/>
		/// to the Tcl code associated with the design rule check to be run during the report_drc<br/>
		/// command.<br/>
		/// The general placeholder message defined in this command is populated with specific information<br/>
		/// related to the design objects and violations found by the Tcl checker procedure, and by the<br/>
		/// create_drc_violation command.<br/>
		/// The process in brief is:<br/>
		/// • Write a Tcl checker procedure to define the method applied when checking the user-defined<br/>
		/// rule, and the objects to check against the rule. The Tcl checker procedure is defined in a<br/>
		/// separate Tcl script that must be loaded by the source command prior to running<br/>
		/// report_drc.<br/>
		/// • Use create_drc_violation in the Tcl checker to identify and flag violations found when<br/>
		/// checking the rule against a design.<br/>
		/// • Define a user-defined DRC rule check using the create_drc_check command that calls the<br/>
		/// Tcl checker proc from the -rule_body.<br/>
		/// • Create a rule deck using the create_drc_ruledeck command, and add the user-defined<br/>
		/// rule check to the rule deck using the add_drc_checks command.<br/>
		/// • Run report_drc, and specify either the rule deck, or the user-defined rule check to check<br/>
		/// for violations.<br/>
		/// If a drc_check of the specified name is already defined in the tool, an error is returned. In this<br/>
		/// case, to overwrite or redefine and existing drc_check, you must first delete the check using the<br/>
		/// delete_drc_check command.<br/>
		/// The DRC rule check object features the is_enabled property that can be set to TRUE or<br/>
		/// FALSE using the set_property command. When a new rule check is created, the<br/>
		/// is_enabled property is set to TRUE as a default. Set the is_enabled property to FALSE to<br/>
		/// disable the rule check from being used when report_drc is run. This lets you create new DRC<br/>
		/// checks, add them to rule decks using add_drc_checks, and then enable them or disable them<br/>
		/// as needed without having to remove them from the rule deck.<br/>
		/// Each user defined DRC rule check has the 'USER_DEFINED' property, which lets you quickly<br/>
		/// identify and select user-defined rule checks.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example defines a new design rule check named RAMW-1, with the hierarchy<br/>
		/// name and description defined, using the default severity of Warning, and calling the<br/>
		/// dataWidthCheck procedure when the check is run:<br/>
		/// create_drc_check -name {RAMW-1} -hiername {RAMB} \<br/>
		/// -desc {Data Width Check} -rule_body dataWidthCheck -severity Advisory<br/>
		/// The following Tcl script defines the dataWidthCheck procedure which is called by the -<br/>
		/// rule_body argument of the RAMW-1 check. This Tcl script file must be loaded into the tool<br/>
		/// using the source command, prior to running the report_drc command.<br/>
		/// # This is a simplistic check -- report BRAM cells with WRITE_WIDTH_B<br/>
		/// # wider than 36.<br/>
		/// proc dataWidthCheck {} {<br/>
		/// # list to hold violations<br/>
		/// set vios {}<br/>
		/// # iterate through the objects to be checked<br/>
		/// foreach bram [get_cells -hier -filter {PRIMITIVE_SUBGROUP == bram}] {<br/>
		/// set bwidth [get_property WRITE_WIDTH_B $bram]<br/>
		/// if { $bwidth &gt; 36} {<br/>
		/// # define the message to report when violations are found<br/>
		/// set msg "On cell %ELG, WRITE_WIDTH_B is $bwidth"<br/>
		/// set vio [ create_drc_violation -name {RAMW-1} -msg $msg $bram ]<br/>
		/// lappend vios $vio<br/>
		/// }<br/>
		/// }<br/>
		/// if {[llength $vios] &gt; 0} {<br/>
		/// return -code error $vios<br/>
		/// } else {<br/>
		/// return {}<br/>
		/// }<br/>
		/// }<br/>
		/// create_drc_check -name {RAMW-1} -hiername {RAMB Checks} \<br/>
		/// -desc {Data Width Check} -rule_body dataWidthCheck \<br/>
		/// -severity Advisory<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Note: The script file can contain both the Tcl checker procedure, and the create_drc_check command<br/>
		/// that defines it for use by report_drc command. In this case, when the Tcl script file is sourced, both the<br/>
		/// dataWidthCheck proc and the RAMW-1 design rule check are loaded into the tool.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 261<br/>
		/// </para>
		/// </summary>
		/// <param name="name">
		/// <para>
		/// (Required)<br/>
		/// Specify the name for this rule. This must be of the form<br/>
		/// PREFIX-id where XXXX is a 4-6 letter abbreviation and id is an<br/>
		/// integer identifying a particular rule. Similar checks should<br/>
		/// have the same abbreviation and each a unique id.<br/>
		/// </para>
		/// </param>
		/// <param name="rule_body">
		/// <para>
		/// (Required)<br/>
		/// The string representing the body of the rule. This can be a<br/>
		/// tcl proc name or any string of tcl code to be evaluated.<br/>
		/// </para>
		/// </param>
		/// <param name="hiername">
		/// <para>
		/// (Optional)<br/>
		/// Specify the hiername for this rule. When the DRC UI panel is<br/>
		/// created, this is used to place the new rule in the menu<br/>
		/// hierarchy. Use a dot (.) to separate layers in the menu<br/>
		/// hierarchy. It is optional and will default to User Defined.<br/>
		/// Default: User Defined<br/>
		/// </para>
		/// </param>
		/// <param name="desc">
		/// <para>
		/// (Optional)<br/>
		/// Specify the short description for this rule. It is optional and<br/>
		/// will default to &lt;User rule - default description&gt;. Default:<br/>
		/// User rule - default description<br/>
		/// </para>
		/// </param>
		/// <param name="msg">
		/// <para>
		/// (Optional)<br/>
		/// Specify the full description for this rule. Including the<br/>
		/// substitutions. Values are: %MSG_STRING<br/>
		/// %NETLIST_ELEMENT %SITE_GROUP %CLOCK_REGION<br/>
		/// %BANK %BEL_GROUP.<br/>
		/// </para>
		/// </param>
		/// <param name="severity">
		/// <para>
		/// (Optional)<br/>
		/// Specify severity level for a DRC rule. Default: Warning.<br/>
		/// Values: Error, Critical Warning, Warning, Advisory.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL create_drc_check(String name, String rule_body, String hiername = null, String desc = null, String msg = null, create_drc_check_severity? severity = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_drc_check [-hiername <arg>] -name <arg> [-desc <arg>] [-msg <arg>] -rule_body <arg> [-severity <arg>] [-quiet] [-verbose]
			this.Entry(_builder.create_drc_check(name, rule_body, hiername, desc, msg, severity, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create one or more user defined DRC rule deck objects<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_drc_ruledeck [-quiet] [-verbose] &lt;ruledecks&gt;...
		/// <br/>
		/// <para>
		/// Create one or more user-defined rule decks for use when running report_drc.<br/>
		/// A drc_ruledeck object is a collection of design rule checks, grouped for convenience, to be run at<br/>
		/// different stages of the FPGA design flow, such as during I/O planning or placement. The tool<br/>
		/// comes with a set of factory predefined rule decks. Use the get_drc_ruledecks command to<br/>
		/// return a list of the currently defined rule decks.<br/>
		/// The rule decks created by this command are empty, without any checks. You must add design<br/>
		/// rule checks to the rule deck using the add_drc_checks command. Checks can be removed<br/>
		/// from a rule deck using the remove_drc_checks command. To see a list of design rule checks<br/>
		/// that are available to include in the ruledeck, use the get_drc_checks command.<br/>
		/// This command returns the list of drc_ruledecks created.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates two new drc_ruledeck objects:<br/>
		/// create_drc_ruledeck my_rules project_rules<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 266<br/>
		/// </para>
		/// </summary>
		/// <param name="ruledecks">(Required) Names of DRC rule decks to create</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>drc_ruledeck</returns>
		public VivadoTCL create_drc_ruledeck(TCLParameterList ruledecks, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_drc_ruledeck [-quiet] [-verbose] <ruledecks>...
			this.Entry(_builder.create_drc_ruledeck(ruledecks, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a DRC violation<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_drc_violation -name &lt;arg&gt; [-severity &lt;arg&gt;] [-msg &lt;arg&gt;] [-quiet] [-verbose] [&lt;objects&gt;...]
		/// <br/>
		/// <para>
		/// Create a DRC violation object and manage the list of design objects associated with the violation<br/>
		/// for reporting by the report_drc command.<br/>
		/// The create_drc_violation command is specified as part of the Tcl checker procedure that<br/>
		/// defines and implements the checking feature of a user-defined design rule check created by the<br/>
		/// create_drc_check command. A violation object is created by the Tcl checker each time a<br/>
		/// violation of the design rule is encountered.<br/>
		/// The process in brief is:<br/>
		/// • Write a Tcl checker procedure to define the method applied when checking the user-defined<br/>
		/// rule, and the objects to check against the rule. The Tcl checker procedure is defined in a<br/>
		/// separate Tcl script that must be loaded by the source command prior to running<br/>
		/// report_drc.<br/>
		/// • Use create_drc_violation in the Tcl checker to identify and flag violations found when<br/>
		/// checking the rule against a design.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// • Define a user-defined DRC rule check using the create_drc_check command that calls the<br/>
		/// Tcl checker proc from the -rule_body.<br/>
		/// • Create a rule deck using the create_drc_ruledeck command, and add the user-defined<br/>
		/// rule check to the rule deck using the add_drc_checks command.<br/>
		/// • Run report_drc, and specify either the rule deck, or the user-defined rule check to check<br/>
		/// for violations.<br/>
		/// Violations are reported by the report_drc command, and violation objects can be returned by<br/>
		/// the get_drc_violations command. The design objects associated with a DRC violation<br/>
		/// object can be obtained using the -of_objects option of the appropriate get_* command,<br/>
		/// such as get_cells, get_nets, or get_ports for instance:<br/>
		/// get_ports -of_objects [get_drc_violations -name drc_1 NSTD*]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following Tcl script defines the dataWidthCheck procedure which is called by the -<br/>
		/// rule_body argument of the RAMW-1 check. This Tcl script file must be loaded into the tool<br/>
		/// using the source command, prior to running the report_drc command.<br/>
		/// Some features of the Tcl checker proc to notice are:<br/>
		/// • A list variable is created to store violations ($vios )<br/>
		/// • A violation object is created, and added to the list variable, each time a violation is found.<br/>
		/// • The placeholder key %ELG in the $msg string is dynamically substituted with the specific<br/>
		/// $bram cell associated with the violation.<br/>
		/// • The dataWidthCheck proc returns an error code when any violations are found ($vios &gt;0)<br/>
		/// to inform the report_drc command of the results of the check.<br/>
		/// • The list of violations is passed along with the return code, and the violations are reported by<br/>
		/// report_drc.<br/>
		/// # This is a simplistic check -- report BRAM cells with WRITE_WIDTH_B<br/>
		/// # wider than 36.<br/>
		/// proc dataWidthCheck {} {<br/>
		/// # list to hold violations<br/>
		/// set vios {}<br/>
		/// # iterate through the objects to be checked<br/>
		/// foreach bram [get_cells -hier -filter {PRIMITIVE_SUBGROUP == bram}] {<br/>
		/// set bwidth [get_property WRITE_WIDTH_B $bram]<br/>
		/// if { $bwidth &gt; 36} {<br/>
		/// # define the message to report when violations are found<br/>
		/// set msg "On cell %ELG, WRITE_WIDTH_B is $bwidth"<br/>
		/// set vio [ create_drc_violation -name {RAMW-1} -msg $msg $bram ]<br/>
		/// lappend vios $vio<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// }<br/>
		/// }<br/>
		/// if {[llength $vios] &gt; 0} {<br/>
		/// return -code error $vios<br/>
		/// } else {<br/>
		/// return {}<br/>
		/// }<br/>
		/// }<br/>
		/// create_drc_check -name {RAMW-1} -hiername {RAMB Checks} \<br/>
		/// -desc {Data Width Check} -rule_body dataWidthCheck \<br/>
		/// -severity Advisory<br/>
		/// Note: The script file can contain both the Tcl checker procedure, and the create_drc_check command<br/>
		/// that defines it for use by report_drc command. In this case, when the Tcl script file is sourced, both the<br/>
		/// dataWidthCheck proc and the RAMW-1 design rule check are loaded into the tool.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 268<br/>
		/// </para>
		/// </summary>
		/// <param name="name">
		/// <para>
		/// (Required)<br/>
		/// Specify the name for this rule. This is the typically a 4-6<br/>
		/// letter specification for your rule.<br/>
		/// </para>
		/// </param>
		/// <param name="severity">
		/// <para>
		/// (Optional)<br/>
		/// Specify severity level for a DRC rule. Default: WARNING.<br/>
		/// Values: FATAL, ERROR, CRITICAL WARNING, WARNING,<br/>
		/// ADVISORY.<br/>
		/// </para>
		/// </param>
		/// <param name="msg">(Optional) Specify your message string for this DRC rule.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">
		/// <para>
		/// (Optional)<br/>
		/// Cells, ports, pins, nets, clock regions, sites, package banks to<br/>
		/// query.<br/>
		/// </para>
		/// </param>
		public VivadoTCL create_drc_violation(String name, create_drc_violation_severity? severity = null, String msg = null, bool? quiet = null, bool? verbose = null, TCLParameterList objects = null)
		{
			// TCL Syntax: create_drc_violation -name <arg> [-severity <arg>] [-msg <arg>] [-quiet] [-verbose] [<objects>...]
			this.Entry(_builder.create_drc_violation(name, severity, msg, quiet, verbose, objects));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a new fileset<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_fileset [-constrset] [-simset] [-blockset] [-clone_properties &lt;arg&gt;] -define_from &lt;arg&gt; [-quiet] [-verbose] &lt;name&gt;
		/// <br/>
		/// <para>
		/// Defines a new fileset within a design project. Files can be added to a newly created fileset using<br/>
		/// the add_files command.<br/>
		/// A fileset is a list of files with a specific function within the project. One or more constraint files is<br/>
		/// a constraint set (-constrset); one or more simulation test benches is a simulation set (-<br/>
		/// simset). Only one fileset option can be specified when using the create_fileset command.<br/>
		/// As a default, the tool will create a constraint fileset if the type is not specified.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// You can also use the create_fileset -blockset command to configure an IP core, or<br/>
		/// hierarchical module of the design, as an out-of-context (OOC) block. The block fileset, or<br/>
		/// blockset, creates a hierarchical file collection for the IP or module specified with the -<br/>
		/// define_from option. The files related to the specified hierarchical module will be moved from<br/>
		/// their current fileset to the new blockset. When the blockset is created, the Vivado Design Suite<br/>
		/// also defines out-of-context synthesis and implementation runs for the block. The output<br/>
		/// products for the OOC module are stored in the blockset, including the synthesized design<br/>
		/// checkpoint (DCP) and any required structural simulation netlists. Stuctural simulation netlists are<br/>
		/// needed when a behavioral model for the block is not available, or is not available in the language<br/>
		/// supported by the target simulator. You can define an out-of-context constraint file for the IP or<br/>
		/// moduleif needed, and add the at to the block fileset as well.<br/>
		/// TIP: Refer to the Vivado Design Suite User Guide: Designing with IP (UG896) or the Vivado Design Suite<br/>
		/// User Guide: Hierarchical Design (UG905) for more information on out-of-context design.<br/>
		/// The create_fileset command returns the name of the newly created fileset, or will return an<br/>
		/// error message if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates a new constraint file set named constraints2:<br/>
		/// create_fileset -constrset -quiet constraints2<br/>
		/// Note: With -quiet specified, the tool will not return anything if it encounters an error in trying to create<br/>
		/// the specified fileset.<br/>
		/// The following example creates an out-of-context (OOC) blockset for the hierarchical module<br/>
		/// specified by the -define_from option:<br/>
		/// create_fileset -blockset -define_from dac_spi dac_spi<br/>
		/// The following example creates a new simulation fileset named sim_1:<br/>
		/// create_fileset -simset sim_1<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 272<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name of the fileset to be create</param>
		/// <param name="constrset">(Optional) Create fileset as constraints fileset (default)</param>
		/// <param name="simset">(Optional) Create fileset as simulation source fileset</param>
		/// <param name="blockset">(Optional) Create fileset as block source fileset</param>
		/// <param name="clone_properties">(Optional) Fileset to initialize properties from</param>
		/// <param name="define_from">(Optional) Name of the module in the source fileset to be the top of the blockset</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>new fileset object</returns>
		public VivadoTCL create_fileset(String name, bool? constrset = null, bool? simset = null, bool? blockset = null, String clone_properties = null, String define_from = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_fileset [-constrset] [-simset] [-blockset] [-clone_properties <arg>] -define_from <arg> [-quiet] [-verbose] <name>
			this.Entry(_builder.create_fileset(name, constrset, simset, blockset, clone_properties, define_from, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a generated clock object<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_generated_clock [-name &lt;arg&gt;] [-source &lt;args&gt;] [-edges &lt;args&gt;] [-divide_by &lt;arg&gt;] [-multiply_by &lt;arg&gt;] [-combinational] [-duty_cycle &lt;arg&gt;] [-invert] [-edge_shift &lt;args&gt;] [-add] [-master_clock &lt;args&gt;] [-quiet] [-verbose] &lt;objects&gt;
		/// <br/>
		/// <para>
		/// TIP: The XDC &gt; Timing Constraints language templates and the Timing Constraints Wizard in the Vivado<br/>
		/// IDE offer timing diagrams and additional details around defining specific timing constraints. You can refer<br/>
		/// to these sources for additional information.<br/>
		/// Generate a new clock object from an existing physical clock object in the design.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Clocks can be added to a design in one of three ways:<br/>
		/// • Primary physical or virtual clocks defined with the create_clock command.<br/>
		/// • Derived clocks defined with the create_generated_clock command generated from a<br/>
		/// primary physical clock.<br/>
		/// • Derived clocks automatically generated by the Vivado Design Suite when a clock propagates<br/>
		/// through an MMCM/PLL/BUFR.<br/>
		/// You can also use the create_generated_clock command to change the name of clocks that<br/>
		/// the Vivado tool has auto-derived from an MMCM/PLL/BUFR. In this case, a new clock is not<br/>
		/// created, but an existing clock defined on the specified source object is renamed to the provided<br/>
		/// name. This requires -name and &lt;object&gt; to be specified, and supports the use of -source<br/>
		/// and/or -master_clock to further identify the clock to rename when multiple clocks exist on<br/>
		/// the source object. Refer to the Vivado Design Suite User Guide: Using Constraints (UG903) for more<br/>
		/// information on renaming auto-derived clocks.<br/>
		/// IMPORTANT! You cannot rename a clock that is already in use by other constraints at the time of<br/>
		/// renaming. You must rename the clock prior to any other appearance or use of the clock in an XDC file.<br/>
		/// This command returns the name of the clock object that is created, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example defines a generated clock that is divided from the master clock found on<br/>
		/// the specified CLK pin. Since -name is not specified, the generated clock is assigned the same<br/>
		/// name as the pin it is assigned to:<br/>
		/// create_generated_clock -divide_by 2 -source \<br/>
		/// [get_pins clkgen/cpuClk] [get_nets fftEngine/CLK]<br/>
		/// The following example defines a generated clock named CLK1 from the specified source clock,<br/>
		/// specifying the edges of the master clock to use as transition points for the generated clock, with<br/>
		/// edges shifted by the specified amount. In this example, the -edges option indicates that the<br/>
		/// second edge of the source clock is the first rising edge of the generated clock, the third edge of<br/>
		/// the source clock is the first falling edge of the generated clock, and the eighth edge of the source<br/>
		/// clock is the second rising edge of the generated clock. These values determine the period of the<br/>
		/// generated clock as the time from edge 2 to edge 8 of the source clock, and the duty cycle as the<br/>
		/// percentage of the period between edge 2 and edge 3 of the source clock. In addition, each edge<br/>
		/// of the generated clock is shifted by the specified amount:<br/>
		/// create_generated_clock -name CLK1 -source CMB/CLKIN -edges {2 3 8} \<br/>
		/// -edge_shift {0 -1.0 -2.0} CMB/CLKOUT<br/>
		/// Note: The waveform pattern of the generated clock is repeated based on the transitions defined by the -<br/>
		/// edges argument.<br/>
		/// This example creates two generated clocks from the output of a MUX, using -master_clock<br/>
		/// to identify which clock to use, using -add to assign the generated clocks to the Q pin of a flip<br/>
		/// flop, and using -name to define a name for the generated clock, since the object it is assigned to<br/>
		/// has multiple clocks assigned:<br/>
		/// create_generated_clock -source [get_pins muxOut] -master_clock M_CLKA \<br/>
		/// -divide_by 2 -add -name gen_CLKA [get_pins flop_Q]<br/>
		/// create_generated_clock -source [get_pins muxOut] -master_clock M_CLKB \<br/>
		/// -divide_by 2 -add -name gen_CLKB [get_pins flop_Q]<br/>
		/// The following example renames the automatically named clock that is derived by the Vivado<br/>
		/// Design Suite on the MMCM clock output:<br/>
		/// create_generated_clock -name CLK_DIV2 [get_pins mmcm/CLKOUT1]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 275<br/>
		/// </para>
		/// </summary>
		/// <param name="objects">(Required) List of clock source ports, pins, or nets</param>
		/// <param name="name">(Optional) Generated clock name</param>
		/// <param name="source">(Optional) Master clock source object pin/port</param>
		/// <param name="edges">(Optional) Edge Specification</param>
		/// <param name="divide_by">(Optional) Period division factor: Value &gt;= 1 Default: 1</param>
		/// <param name="multiply_by">(Optional) Period multiplication factor: Value &gt;= 1 Default: 1</param>
		/// <param name="combinational">(Optional) Create a divide_by 1 clock through combinational logic</param>
		/// <param name="duty_cycle">(Optional) Duty cycle of clock period: Range: 0.0 to 100.0 Default: 50.0</param>
		/// <param name="invert">(Optional) Invert the signal</param>
		/// <param name="edge_shift">(Optional) Edge shift specification</param>
		/// <param name="add">(Optional) Add to the existing clock in source_objects</param>
		/// <param name="master_clock">(Optional) Use this clock if multiple clocks present at master pin</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>new clock object</returns>
		public VivadoTCL create_generated_clock(String objects, String name = null, TCLParameterList source = null, TCLParameterList edges = null, String divide_by = null, String multiply_by = null, bool? combinational = null, String duty_cycle = null, bool? invert = null, TCLParameterList edge_shift = null, bool? add = null, TCLParameterList master_clock = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_generated_clock [-name <arg>] [-source <args>] [-edges <args>] [-divide_by <arg>] [-multiply_by <arg>] [-combinational] [-duty_cycle <arg>] [-invert] [-edge_shift <args>] [-add] [-master_clock <args>] [-quiet] [-verbose] <objects>
			this.Entry(_builder.create_generated_clock(objects, name, source, edges, divide_by, multiply_by, combinational, duty_cycle, invert, edge_shift, add, master_clock, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a custom command in the GUI<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_gui_custom_command -name &lt;arg&gt; [-menu_name &lt;arg&gt;] [-description &lt;arg&gt;] [-show_on_toolbar] [-run_proc &lt;arg&gt;] [-toolbar_icon &lt;arg&gt;] [-command &lt;arg&gt;] [-tcl_file &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// This commands creates a GUI menu item for a user custom command. The menu command<br/>
		/// appears in the Tools → Custom Commands menu in the Vivado IDE.<br/>
		/// The custom GUI command can also be shown/hidden on the toolbar menu. When the GUI<br/>
		/// button is clicked the custom command is executed. A Tcl file can also be sourced when the GUI<br/>
		/// button is clicked.<br/>
		/// You can use the get_gui_custom_commands to determine the list of user-defined custom<br/>
		/// commands.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates a GUI custom command with name 'print_version', and adds it to<br/>
		/// the toolbar.<br/>
		/// create_gui_custom_command -name print_version -command "version" \<br/>
		/// -description "Gets tool version" -show_on_toolbar<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 280<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Unique name of the command to create.</param>
		/// <param name="menu_name">(Optional) Menu name for the custom command.</param>
		/// <param name="description">
		/// <para>
		/// (Optional)<br/>
		/// Display this text for the description of the menu item and<br/>
		/// optionally the toolbar button<br/>
		/// </para>
		/// </param>
		/// <param name="show_on_toolbar">(Optional) Add this command to the toolbar</param>
		/// <param name="run_proc">
		/// <para>
		/// (Optional)<br/>
		/// Needed when '-command' and 'tcl_file' options are both<br/>
		/// specified. If true, gui button will run command mentioned in<br/>
		/// '-command' option otherwise source script mentioned in '-<br/>
		/// tcl_file' option<br/>
		/// </para>
		/// </param>
		/// <param name="toolbar_icon">(Optional) The full path to the PNG or JPEG file to display on the toolbar button</param>
		/// <param name="command">(Optional) The command to execute</param>
		/// <param name="tcl_file">(Optional) The full path to the Tcl file to source</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL create_gui_custom_command(String name, String menu_name = null, String description = null, bool? show_on_toolbar = null, String run_proc = null, String toolbar_icon = null, String command = null, String tcl_file = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_gui_custom_command -name <arg> [-menu_name <arg>] [-description <arg>] [-show_on_toolbar] [-run_proc <arg>] [-toolbar_icon <arg>] [-command <arg>] [-tcl_file <arg>] [-quiet] [-verbose]
			this.Entry(_builder.create_gui_custom_command(name, menu_name, description, show_on_toolbar, run_proc, toolbar_icon, command, tcl_file, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a custom command argument for a custom command in the GUI<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_gui_custom_command_arg -command_name &lt;arg&gt; -arg_name &lt;arg&gt; [-default &lt;arg&gt;] [-comment &lt;arg&gt;] [-optional] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// This commands defines an argument for a specific custom GUI command.<br/>
		/// You can use the get_gui_custom_commands to determine the list of defined custom<br/>
		/// commands. You can use the get_gui_custom_command_args to determine the list of<br/>
		/// defined GUI custom command arguments of a particular GUI custom command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// This example creates an argument named 'quiet' for the custom GUI command<br/>
		/// print_version. The argument is defined as optional and its default value is -quiet.<br/>
		/// create_gui_custom_command_arg -command_name print_version -arg_name quiet \<br/>
		/// -default "-quiet" -comment "Ignore commands errors" -optional<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 282<br/>
		/// </para>
		/// </summary>
		/// <param name="command_name">
		/// <para>
		/// (Required)<br/>
		/// Unique name of the custom command for which an<br/>
		/// argument is being created.<br/>
		/// </para>
		/// </param>
		/// <param name="arg_name">(Required) Unique name of the custom command argument to create.</param>
		/// <param name="default">(Optional) Default value of the custom command argument.</param>
		/// <param name="comment">(Optional) Comment for the custom command argument.</param>
		/// <param name="optional">(Optional) Make the custom command argument optional.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL create_gui_custom_command_arg(String command_name, String arg_name, String @default = null, String comment = null, bool? optional = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_gui_custom_command_arg -command_name <arg> -arg_name <arg> [-default <arg>] [-comment <arg>] [-optional] [-quiet] [-verbose]
			this.Entry(_builder.create_gui_custom_command_arg(command_name, arg_name, @default, comment, optional, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create hardware AXI transaction object<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_hw_axi_txn [-address &lt;arg&gt;] [-data &lt;arg&gt;] [-size &lt;arg&gt;] -type &lt;arg&gt; [-len &lt;arg&gt;] [-burst &lt;arg&gt;] [-cache &lt;arg&gt;] [-id &lt;arg&gt;] [-force] [-quiet] [-verbose] &lt;name&gt; &lt;hw_axi&gt;
		/// <br/>
		/// <para>
		/// Define a read or write transaction for the JTAG to AXI Master core, hw_axi object, specified by<br/>
		/// the get_hw_axis command.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The JTAG to AXI Master is a customizable IP core that works as an AXI Master to drive AXI<br/>
		/// transactions and drive AXI signals that are internal to the hardware device. The JTAG-AXI core<br/>
		/// supports all memory-mapped AXI interfaces, except AXI4-Stream, and supports the AXI-Lite<br/>
		/// protocol. Detailed documentation on the IP core can be found in the LogiCORE IP JTAG to AXI<br/>
		/// Master Product Guide (PG174).<br/>
		/// AXI transactions are read/write burst transactions from the JTAG to AXI Master core onto AXI<br/>
		/// signals connected to the core. The AXI transaction lets you configure aspects of the read or write<br/>
		/// transaction such as the data to send and the address to send it to. These defined transactions are<br/>
		/// stored as properties of the specified hw_axi object, waiting to be run and reported using the<br/>
		/// run_hw_axi and report_hw_axi_txn commands.<br/>
		/// The command returns the name of the hw_axi_txn object created, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 284<br/>
		/// </para>
		/// </summary>
		/// <param name="type">(Required) READ or WRITE transaction.</param>
		/// <param name="name">(Required) Name of new object.</param>
		/// <param name="hw_axi">(Required) Associated hardware AXI core object.</param>
		/// <param name="address">(Optional) AXI read or write address. Default: Address zero</param>
		/// <param name="data">(Optional) Transaction data. Default: All zeroes</param>
		/// <param name="size">
		/// <para>
		/// (Optional)<br/>
		/// Deprecated. Data word size in bits. This is now automatically<br/>
		/// set based on the IP core properties.<br/>
		/// </para>
		/// </param>
		/// <param name="len">(Optional) Length of the transaction in data words. Default: 1</param>
		/// <param name="burst">(Optional) Burst type: INCR,FIXED or WRAP. Default: INCR</param>
		/// <param name="cache">(Optional) AXI cache type. Default: 3</param>
		/// <param name="id">(Optional) Address ID. Default: 0</param>
		/// <param name="force">
		/// <para>
		/// (Optional)<br/>
		/// Overwrite an existing transaction with the specified name if<br/>
		/// it exists, otherwise create a new transaction. Default: 0<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>New hardware AXI transaction object.</returns>
		public VivadoTCL create_hw_axi_txn(String type, String name, String hw_axi, String address = null, String data = null, String size = null, String len = null, String burst = null, String cache = null, String id = null, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_hw_axi_txn [-address <arg>] [-data <arg>] [-size <arg>] -type <arg> [-len <arg>] [-burst <arg>] [-cache <arg>] [-id <arg>] [-force] [-quiet] [-verbose] <name> <hw_axi>
			this.Entry(_builder.create_hw_axi_txn(type, name, hw_axi, address, data, size, len, burst, cache, id, force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Read bitstream file into memory<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_hw_bitstream -hw_device &lt;arg&gt; [-mask &lt;arg&gt;] [-nky &lt;arg&gt;] [-detect_partial] [-quiet] [-verbose] [&lt;file&gt;]
		/// <br/>
		/// <para>
		/// Read a bitstream file, created with the write_bitstream command, to create a hw_bitstream<br/>
		/// object, and associate that object with a hw_device object in the Hardware Manager feature of<br/>
		/// the Vivado Design Suite.<br/>
		/// The hw_bitstream object is associated with the specified hw_device through the<br/>
		/// PROGRAM.HW_BITSTREAM property on the device. This property is automatically set by the<br/>
		/// create_hw_bitstream command. The PROGRAM.FILE property is also set to reflect the file<br/>
		/// path of the specified bitstream file.<br/>
		/// Note: A hw_bitstream object is also automatically created and associated with a hw_device object when<br/>
		/// you use the program_hw_devices command.<br/>
		/// The mask file written with the bitstream file, using the write_bitstream -mask command, is<br/>
		/// associated through the MASK property on the hw_bitstream object. The encryption key file<br/>
		/// required for use with an encrypted bitstream is associated through the ENCRYPTION.FILE<br/>
		/// property on the hw_bitstream object. These files are associated with the hw_bitstream object<br/>
		/// using the -mask and -nky options.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The created hw_bitstream object can be removed with the delete_hw_bitstream command.<br/>
		/// This command returns the name of the hw_bitstream object created, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 288<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_device">(Required) Target hw_device connection</param>
		/// <param name="file">(Required) Bitstream filename</param>
		/// <param name="mask">(Optional) Mask file for hw device</param>
		/// <param name="nky">(Optional) Encryption file for hw device</param>
		/// <param name="detect_partial">(Optional) detects partial bitstream</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL create_hw_bitstream(String hw_device, String file, String mask = null, String nky = null, bool? detect_partial = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_hw_bitstream -hw_device <arg> [-mask <arg>] [-nky <arg>] [-detect_partial] [-quiet] [-verbose] [<file>]
			this.Entry(_builder.create_hw_bitstream(hw_device, file, mask, nky, detect_partial, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Read cfgmem file into memory<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_hw_cfgmem -hw_device &lt;arg&gt; [-quiet] [-verbose] &lt;mem_device&gt;
		/// <br/>
		/// <para>
		/// Create a hw_cfgmem object associated with the specified hw_device.<br/>
		/// The process whereby the bitstream data is loaded or programmed into the Xilinx® FPGA is called<br/>
		/// configuration. Configuration is designed to be flexible to accommodate different application<br/>
		/// needs and, wherever possible, to leverage existing system resources to minimize system costs.<br/>
		/// Xilinx FPGAs are configured by loading design-specific configuration data, in the form of a<br/>
		/// bitstream file, into the internal memory of the hw_device. The hw_cfgmem defines a flash<br/>
		/// memory device used for configuring and booting the Xilinx FPGA device. Once the hw_cfgmem<br/>
		/// object is created, and associated with the hw_device, the configuration memory can be<br/>
		/// programmed with the bitstream and other data using the program_hw_cfgmem command.<br/>
		/// The hw_cfgmem object is associated with the specified hw_device object through the<br/>
		/// PROGRAM.HW_CFGMEM property on the device object. Use the get_hw_cfgmems command<br/>
		/// to work with the hw_cfgmem object, or use the get_property command to obtain the object<br/>
		/// from the hw_device:<br/>
		/// get_property PROGRAM.HW_CFGMEM [current_hw_device]<br/>
		/// TIP: When creating a new hw_cfgmem object, you can also associate the object with a Tcl variable as<br/>
		/// shown in the example below. By referring to the variable, you can set properties on the object, and use the<br/>
		/// object with other Tcl commands like program_hw_cfgmem or readback_hw_cfgmem.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This command returns the created hw_cfgmem object, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 291<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_device">(Required) hw_device object with which to associate hw_cfgmem object</param>
		/// <param name="mem_device">(Required) name of flash memory device as returned by get_cfgmem_parts</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL create_hw_cfgmem(String hw_device, String mem_device, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_hw_cfgmem -hw_device <arg> [-quiet] [-verbose] <mem_device>
			this.Entry(_builder.create_hw_cfgmem(hw_device, mem_device, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a hw_device (jtag chain) on an open target<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_hw_device [-idcode &lt;arg&gt;] [-irlength &lt;arg&gt;] [-mask &lt;arg&gt;] [-part &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// The Vivado hardware manager supports programming of hardware devices through the use of<br/>
		/// Serial Vector Format (SVF) files. SVF files are ASCII files that contain both programming<br/>
		/// instructions and configuration data. These files are used by ATE machines and embedded<br/>
		/// controllers to perform boundary-scan operations. The SVF file captures the JTAG commands<br/>
		/// needed to program the bitstream directly into a Xilinx device, or indirectly into a flash memory<br/>
		/// device. The SVF file can be written using the write_hw_svf command, or applied to an open<br/>
		/// hw_target through the execute_hw_svf command. Refer to the Vivado Design Suite User Guide:<br/>
		/// Programming and Debugging (UG908) for more information.<br/>
		/// The specific process for creating the hw_svf file is:<br/>
		/// 1. Create an SVF target using create_hw_target.<br/>
		/// 2. Open the SVF target.<br/>
		/// 3. Create one or more devices on the SVF target using create_hw_device.<br/>
		/// 4. Program the devices using commands like program_hw_devices.<br/>
		/// 5. Write the SVF file of operation commands using write_hw_svf.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The create_hw_device command creates a hw_device object on an open SVF target, adding it<br/>
		/// to the JTAG chain. This device can be queried and programmed like other hw_targets using<br/>
		/// commands like get_hw_devices and program_hw_devices.<br/>
		/// You can create both Xilinx devices and user-defined parts to add to the JTAG chain on the open<br/>
		/// SVF hw_target. For Xilinx devices, simply specify a recognized part number and the Vivado tool<br/>
		/// will define it with the appropriate details. For user-defined parts you must specify the JTAG ID<br/>
		/// code, IR length, and mask details using the appropriate options. User-defined parts are added as<br/>
		/// space-holder devices to the JTAG chain as on the SVF hw_target. You can get the user-part with<br/>
		/// get_hw_devices command, and query the properties of the part with report_property,<br/>
		/// but you cannot program user-parts.<br/>
		/// IMPORTANT! You should create all the devices to define the JTAG chain for the SVF target, before<br/>
		/// performing any operations on the JTAG chain. If you mix create_hw_device commands with<br/>
		/// programming commands the JTAG chain referenced in the SVF file will be improperly defined and will not<br/>
		/// work during execute_hw_svf.<br/>
		/// After creating the hw_device on the SVF target, you can exercise the device with supported<br/>
		/// operations such as associating a bitstream file (.bit) and programming the device:<br/>
		/// set_property PROGRAM.FILE {C:/Data/design.bit} [current_hw_device]<br/>
		/// program_hw_devices [current_hw_device]<br/>
		/// The create_hw_device command returns nothing if successful, and returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates an SVF target, opens that target, and creates a new hw_device on<br/>
		/// the target:<br/>
		/// create_hw_target my_svf_target<br/>
		/// open_hw_target<br/>
		/// create_hw_device -part xc7k325t<br/>
		/// This example demonstrates the correct order of creating multiple devices on an SVF target. An<br/>
		/// SVF target is created and opened, then a Xilinx device, a user part, and a second Xilinx device are<br/>
		/// created on the current target. The bitstream properties are defined for the two Xilinx devices, the<br/>
		/// devices are programmed, and an SVF file is written:<br/>
		/// open_hw<br/>
		/// connect_hw_server<br/>
		/// create_hw_target my_svf_target<br/>
		/// open_hw_target<br/>
		/// create_hw_device -part xc7k325t<br/>
		/// create_hw_device -idcode 01234567 -irlength 8 -mask ffffffff -part<br/>
		/// userPart1<br/>
		/// create_hw_device -part xcku9p<br/>
		/// set_property PROGRAM.FILE {C:/Data/k7_design.bit} [lindex [get_hw_devices]<br/>
		/// 0]<br/>
		/// set_property PROGRAM.FILE {C:/Data/ku_design.bit} [lindex [get_hw_devices]<br/>
		/// 2]<br/>
		/// program_hw_devices [lindex [get_hw_devices] 0]<br/>
		/// program_hw_devices [lindex [get_hw_devices] 2]<br/>
		/// write_hw_svf C:/Data/myDesign.svf<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 294<br/>
		/// </para>
		/// </summary>
		/// <param name="idcode">(Optional) hexadecimal device id code</param>
		/// <param name="irlength">(Optional) decimal device ir length</param>
		/// <param name="mask">(Optional) hexadecimal device mask value</param>
		/// <param name="part">(Optional) part type of device to create</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL create_hw_device(String idcode = null, String irlength = null, String mask = null, String part = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_hw_device [-idcode <arg>] [-irlength <arg>] [-mask <arg>] [-part <arg>] [-quiet] [-verbose]
			this.Entry(_builder.create_hw_device(idcode, irlength, mask, part, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create hardware probe object<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_hw_probe [-no_gui_update] [-map &lt;arg&gt;] [-quiet] [-verbose] &lt;name&gt; &lt;core&gt;
		/// <br/>
		/// <para>
		/// This command creates a new user-defined probe on the specified ILA core to define triggers and<br/>
		/// view data in the Vivado Logic Analyzer. The new probe can combine specific bit values of existing<br/>
		/// probes to simplify or clarify the data presented in the waveform viewer. Captured data samples<br/>
		/// from the user-defined probe can be reported with the list_hw_samples command.<br/>
		/// User-defined probes can map bit values from a single physical probe on the ILA core, or can<br/>
		/// combine bit values from multiple physical probes onto a single user-defined probe. Probes that<br/>
		/// map bits from a single probe can be used to create triggers and view data. Probes that combine<br/>
		/// bits from multiple physical probes can only be used for viewing data in the Vivado Logic Analyzer.<br/>
		/// You can delete user-defined probes with the delete_hw_probe command.<br/>
		/// The create_hw_probe command returns the user-defined probe name when successful, or<br/>
		/// returns an error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example maps bits from multiple physical probes onto a new user-defined probe<br/>
		/// on the specified ILA core:<br/>
		/// create_hw_probe -map {0011 probe5[3:0] probe8 probe9} myProbeAR[9:0]<br/>
		/// hw_ila_1<br/>
		/// TIP: The -map option combines 10 bits onto the new probe, so the probe name specifies a matching port<br/>
		/// width.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example creates a hw_probe with copies of the most-significant bit to sign-extend<br/>
		/// a 30-bit signal to align it with other 32-bit signed signals:<br/>
		/// create_hw_probe -map {probe0[29] probe0[29] probe0[29:0]} \<br/>
		/// mySignExtendedProbe[31:0] [get_hw_ilas hw_ila_1]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 297<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name of new object. Bus probes have range appended.</param>
		/// <param name="core">(Required) Associated hardware ILA core object.</param>
		/// <param name="no_gui_update">(Optional) Defer GUI update.</param>
		/// <param name="map">(Optional) Declaration of bits. Default: 0</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>New hardware probe object.</returns>
		public VivadoTCL create_hw_probe(String name, String core, bool? no_gui_update = null, String map = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_hw_probe [-no_gui_update] [-map <arg>] [-quiet] [-verbose] <name> <core>
			this.Entry(_builder.create_hw_probe(name, core, no_gui_update, map, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a new link between hardware RX and TX endpoints. There must be at least one hardware<br/>
		/// TX or RX endpoint specified. If one is missing, the endpoint will be treated as Unknown. The<br/>
		/// unknown endpoint can be renamed in a link property.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_hw_sio_link [-description &lt;arg&gt;] [-quiet] [-verbose] [&lt;hw_sio_rx&gt;] [&lt;hw_sio_tx&gt;]
		/// <br/>
		/// <para>
		/// Define a communication links between transmitter (TX) and receiver (RX) objects on the GTs of<br/>
		/// the IBERT debug core implemented on the current hardware device.<br/>
		/// Vivado Serial I/O analyzer is a link-based analyzer, which lets you link between any transmitter<br/>
		/// and receiver within the IBERT design. The links define the communication paths and protocols<br/>
		/// between transmitters and receivers of the GigaBit transceivers on the device. You can configure<br/>
		/// the links by using the set_property command to specify property values on the link object.<br/>
		/// Refer to the Vivado Design Suite User Guide: Programming and Debugging (UG908) for more<br/>
		/// information on configuring links.<br/>
		/// This command returns the created hw_sio_link object, or returns an error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 300<br/>
		/// </para>
		/// </summary>
		/// <param name="description">(Optional) Description of link. Default: Link object name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_sio_rx">(Optional) RX endpoint. Default: None</param>
		/// <param name="hw_sio_tx">(Optional) TX endpoint. Default: None</param>
		/// <returns>The new hardware SIO link</returns>
		public VivadoTCL create_hw_sio_link(String description = null, bool? quiet = null, bool? verbose = null, String hw_sio_rx = null, String hw_sio_tx = null)
		{
			// TCL Syntax: create_hw_sio_link [-description <arg>] [-quiet] [-verbose] [<hw_sio_rx>] [<hw_sio_tx>]
			this.Entry(_builder.create_hw_sio_link(description, quiet, verbose, hw_sio_rx, hw_sio_tx));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a new hardware SIO link group.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_hw_sio_linkgroup [-description &lt;arg&gt;] [-quiet] [-verbose] &lt;hw_sio_links&gt;
		/// <br/>
		/// <para>
		/// Create a new group to associate the specified TX to RX communication links on the IBERT debug<br/>
		/// core implemented on the current device.<br/>
		/// Vivado Serial I/O analyzer is a link-based analyzer. The links define the communication paths and<br/>
		/// protocols between transmitters and receivers of the GigaBit transceivers on the device. Link<br/>
		/// groups, or hw_sio_linkgroup objects, let you associate links into related groups, to collectively<br/>
		/// configure properties and run scans.<br/>
		/// This command returns the name of the linkgroup created, or returns an error if the command<br/>
		/// fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 303<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_sio_links">(Required) hardware SIO links</param>
		/// <param name="description">(Optional) Description of link group. Default: Link group object name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The new hardware SIO link group</returns>
		public VivadoTCL create_hw_sio_linkgroup(String hw_sio_links, String description = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_hw_sio_linkgroup [-description <arg>] [-quiet] [-verbose] <hw_sio_links>
			this.Entry(_builder.create_hw_sio_linkgroup(hw_sio_links, description, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a new hardware SIO scan. If a Link object is passed in, it must have a RX Endpoint object.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_hw_sio_scan [-description &lt;arg&gt;] [-link_settings &lt;arg&gt;] [-quiet] [-verbose] &lt;scan_type&gt; &lt;hw_sio_object&gt;
		/// <br/>
		/// <para>
		/// Create a serial I/O analyzer scan object for the specified communication link on the IBERT debug<br/>
		/// core.<br/>
		/// To analyze the margin of a given link, it is often helpful to run a scan of the link using the<br/>
		/// specialized Eye Scan hardware of Xilinx UltraScale devices or 7 series FPGAs. The Vivado serial<br/>
		/// I/O analyzer feature lets you to create, run, and save link scans.<br/>
		/// This command creates and returns a link scan object that you can use with the<br/>
		/// run_hw_sio_scan command to run analysis on the specified links, or GT receivers. You can<br/>
		/// also save the scan to disk using the write_hw_sio_scan command.<br/>
		/// You can remove the created scan object using remove_hw_sio_scan.<br/>
		/// This command returns the hw_sio_scan object, or returns an error if the command fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 305<br/>
		/// </para>
		/// </summary>
		/// <param name="scan_type">(Required) Scan Type Options: 1d_bathtub, 2d_full_eye</param>
		/// <param name="hw_sio_object">(Required) RX endpoint or Link object to perform scan on.</param>
		/// <param name="description">(Optional) Description of scan Default: Scan object name</param>
		/// <param name="link_settings">
		/// <para>
		/// (Optional)<br/>
		/// List of Link properties and values to set before running the<br/>
		/// scan. Default: None<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The new hardware SIO scan</returns>
		public VivadoTCL create_hw_sio_scan(String scan_type, String hw_sio_object, String description = null, String link_settings = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_hw_sio_scan [-description <arg>] [-link_settings <arg>] [-quiet] [-verbose] <scan_type> <hw_sio_object>
			this.Entry(_builder.create_hw_sio_scan(scan_type, hw_sio_object, description, link_settings, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a new hardware SIO sweep. If a Link object is passed in, it must have a RX Endpoint<br/>
		/// object.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_hw_sio_sweep [-description &lt;arg&gt;] [-iteration_settings &lt;arg&gt;] [-quiet] [-verbose] &lt;scan_type&gt; [&lt;hw_sio_link&gt;]
		/// <br/>
		/// <para>
		/// Create a serial I/O analyzer link sweep object to run multiple scans across a range of values.<br/>
		/// To analyze the margin of a given link, it is often helpful to run a scan of the link using the<br/>
		/// specialized features of Xilinx® UltraScale™ devices or 7 series FPGAs. It can also be helpful to run<br/>
		/// multiple scans on a the link with different configuration settings for the GTs. This can help you<br/>
		/// determine which settings are best for your design. The Vivado® serial I/O analyzer feature<br/>
		/// enables you to define, run, and save link sweeps, or collections of link scans run across a range of<br/>
		/// values.<br/>
		/// This command creates and returns a link sweep object that you can use with the<br/>
		/// run_hw_sio_sweep command to run analysis on the specified links, or GT receivers. You can<br/>
		/// also save the sweep scan to disk using the write_hw_sio_sweep command.<br/>
		/// You can remove the created sweep object using remove_hw_sio_sweep.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This command returns the hw_sio_sweep object, or returns an error if the command fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 308<br/>
		/// </para>
		/// </summary>
		/// <param name="scan_type">(Required) Sweep Type Options: 1d_bathtub, 2d_full_eye</param>
		/// <param name="description">(Optional) Description of sweep Default: Sweep object name</param>
		/// <param name="iteration_settings">
		/// <para>
		/// (Optional)<br/>
		/// List of LINK_SETTINGS for each scan to set before running<br/>
		/// the sweep. Default: None<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_sio_link">(Optional) Link object to perform sweep on. Default: None</param>
		/// <returns>The new hardware SIO sweep</returns>
		public VivadoTCL create_hw_sio_sweep(String scan_type, String description = null, String iteration_settings = null, bool? quiet = null, bool? verbose = null, String hw_sio_link = null)
		{
			// TCL Syntax: create_hw_sio_sweep [-description <arg>] [-iteration_settings <arg>] [-quiet] [-verbose] <scan_type> [<hw_sio_link>]
			this.Entry(_builder.create_hw_sio_sweep(scan_type, description, iteration_settings, quiet, verbose, hw_sio_link));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a hw_target (jtag chain) and set its name<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_hw_target [-copy &lt;arg&gt;] [-quiet] [-verbose] &lt;target_name&gt;
		/// <br/>
		/// <para>
		/// The Vivado hardware manager supports programming of hardware devices through the use of<br/>
		/// Serial Vector Format (SVF) files. SVF files are ASCII files that contain both programming<br/>
		/// instructions and configuration data. These files are used by ATE machines and embedded<br/>
		/// controllers to perform boundary-scan operations. The SVF file captures the JTAG commands<br/>
		/// needed to program the bitstream directly into a Xilinx device, or indirectly into a flash memory<br/>
		/// device. The SVF file can be written using the write_hw_svf command, or applied to an open<br/>
		/// hw_target through the execute_hw_svf command. Refer to the Vivado Design Suite User Guide:<br/>
		/// Programming and Debugging (UG908) for more information.<br/>
		/// The specific process for creating the hw_svf file is:<br/>
		/// 1. Create an SVF target using create_hw_target.<br/>
		/// 2. Open the SVF target.<br/>
		/// 3. Create one or more devices on the SVF target using create_hw_device.<br/>
		/// 4. Program the devices using commands like program_hw_devices.<br/>
		/// 5. Write the SVF file of operation commands using write_hw_svf.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The create_hw_target command creates an SVF hw_target object on the current hw_server<br/>
		/// that can be used as a platform for programming devices, and exporting the programming<br/>
		/// commands in an SVF file. The SVF target, is a hw_target object that can be queried and managed<br/>
		/// like other hw_targets using commands like get_hw_targets and current_hw_target.<br/>
		/// Note: When using the SVF flow, Xilinx recommends that you connect to a local hw_server on your system,<br/>
		/// as the SVF target does not require connection to an actual hardware board or device.<br/>
		/// SVF hw_targets can be identified by the boolean IS_SVF property that can be returned by<br/>
		/// get_property or report_property commands. This property is TRUE for SVF targets.<br/>
		/// This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates a SVF hw_target object that is a copy of the specified hw_target:<br/>
		/// create_hw_target -copy [get_hw_targets *210203327996A] svfTarget<br/>
		/// The following example gets the currently defined SVF hw_target objects:<br/>
		/// get_hw_targets -filter {IS_SVF}<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example shows all of the steps needed for the SVF flow. First open the Vivado<br/>
		/// hardware manager and connect to a local hw_server; create and open an SVF hw_target; add a<br/>
		/// hw_device and program the bitstream into this device; and write the SVF file capturing the<br/>
		/// programming commands for the device:<br/>
		/// open_hw<br/>
		/// connect_hw_server<br/>
		/// create_hw_target my_svf_target<br/>
		/// open_hw_target<br/>
		/// create_hw_device -part xc7k325t<br/>
		/// set_property PROGRAM.FILE {C:/Data/k7_design.bit} [current_hw_device]<br/>
		/// program_hw_devices [current_hw_device]<br/>
		/// write_hw_svf my_xc7k325t.svf<br/>
		/// close_hw_target<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 311<br/>
		/// </para>
		/// </summary>
		/// <param name="target_name">(Required) name of hardware target to create</param>
		/// <param name="copy">(Optional) hardware target copy Default: copy of existing target</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>hardware targets</returns>
		public VivadoTCL create_hw_target(String target_name, String copy = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_hw_target [-copy <arg>] [-quiet] [-verbose] <target_name>
			this.Entry(_builder.create_hw_target(target_name, copy, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a new I/O port interface<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_interface [-parent &lt;arg&gt;] [-quiet] [-verbose] &lt;name&gt;
		/// <br/>
		/// <para>
		/// Creates a new interface for grouping scalar or differential I/O ports.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// Create a new USB interface:<br/>
		/// create_interface USB0<br/>
		/// Create an Ethernet interface within the specified parent interface:<br/>
		/// create_interface -parent Top_Int ENET0<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 314<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name for new I/O port interface</param>
		/// <param name="parent">(Optional) Assign new interface to this parent interface</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>new interface object</returns>
		public VivadoTCL create_interface(String name, String parent = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_interface [-parent <arg>] [-quiet] [-verbose] <name>
			this.Entry(_builder.create_interface(name, parent, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create an instance of a configurable IP and add it to the fileset<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_ip [-vlnv &lt;arg&gt;] -module_name &lt;arg&gt; [-dir &lt;arg&gt;] [-force] [-allow_hidden] [-vendor &lt;arg&gt;] [-library &lt;arg&gt;] [-name &lt;arg&gt;] [-version &lt;arg&gt;] [-revision &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// This command creates an XCI file for a configurable IP core from the IP catalog, and adds it to the<br/>
		/// source files of the current project. This creates an IP source object which must be instantiated<br/>
		/// into the HDL design to create an instance of the IP core in the netlist.<br/>
		/// For multiple instances of the same core, simply instantiate the core module into the HDL design<br/>
		/// as many times as needed. However, to use the same IP core with different customizations, use<br/>
		/// the create_ip command to create separate IP source objects.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The create_ip command is used to import IP cores from the current IP catalog. Use the<br/>
		/// import_ip command to read existing XCI and XCO files directly, without having to add IP to a<br/>
		/// catalog.<br/>
		/// This command returns a transcript of the IP generation process, concluding with the file path and<br/>
		/// name of the imported IP core file.<br/>
		/// Note: IP cores are native to Vivado, and can be customized and regenerated within that tool. The<br/>
		/// convert_ip command lets you to convert legacy IP to native IP supported by Vivado.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The example below imports the IP core specified by the -vlnv string, and gives it the specified<br/>
		/// module name in the current project:<br/>
		/// create_ip -vlnv xilinx.com:ip:c_addsub:11.0 -module_name test_addr<br/>
		/// The following example, from Vivado, creates an IP block with the specified -vendor, -<br/>
		/// library, -name, -version values, and assigns it the specified module name. After the IP is<br/>
		/// created, attributes of the IP are customized using set_property commands. Then the<br/>
		/// instantiation template and the synthesis targets are generated for the IP:<br/>
		/// create_ip -name c_addsub -version 11.0 -vendor xilinx.com -library ip \<br/>
		/// -module_name c_addsub_v11_0_0<br/>
		/// set_property CONFIG.COMPONENT_NAME c_addsub_v11_0_0 \<br/>
		/// [get_ips c_addsub_v11_0_0]<br/>
		/// set_property CONFIG.A_WIDTH 32 [get_ips c_addsub_v11_0_0]<br/>
		/// set_property CONFIG.B_WIDTH 32 [get_ips c_addsub_v11_0_0]<br/>
		/// set_property CONFIG.ADD_MODE Add_Subtract [get_ips c_addsub_v11_0_0]<br/>
		/// set_property CONFIG.C_IN true [get_ips c_addsub_v11_0_0]<br/>
		/// generate_target {instantiation_template synthesis} \<br/>
		/// [get_files C:/Data/c_addsub_v11_0_0/c_addsub_v11_0_0.xci \<br/>
		/// -of_objects [get_filesets sources_1]]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 316<br/>
		/// </para>
		/// </summary>
		/// <param name="module_name">(Required) Name for the new IP that will be added to the project</param>
		/// <param name="vlnv">
		/// <para>
		/// (Optional)<br/>
		/// VLNV string for the Catalog IP from which the new IP will be<br/>
		/// created (colon delimited Vendor, Library, Name, Version)<br/>
		/// </para>
		/// </param>
		/// <param name="dir">
		/// <para>
		/// (Optional)<br/>
		/// Directory path for remote IP to be created and managed<br/>
		/// outside the project<br/>
		/// </para>
		/// </param>
		/// <param name="force">(Optional) Overwrite existing IP instance; allowed only with -dir option</param>
		/// <param name="allow_hidden">(Optional) Allow hidden cores to be instantiated</param>
		/// <param name="vendor">(Optional) IP Vendor name</param>
		/// <param name="library">(Optional) IP Library name</param>
		/// <param name="name">(Optional) IP Name</param>
		/// <param name="version">(Optional) IP Version</param>
		/// <param name="revision">(Optional) (Optional) IP core revision</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of file objects that were added</returns>
		public VivadoTCL create_ip(String module_name, String vlnv = null, String dir = null, bool? force = null, bool? allow_hidden = null, String vendor = null, String library = null, String name = null, String version = null, String revision = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_ip [-vlnv <arg>] -module_name <arg> [-dir <arg>] [-force] [-allow_hidden] [-vendor <arg>] [-library <arg>] [-name <arg>] [-version <arg>] [-revision <arg>] [-quiet] [-verbose]
			this.Entry(_builder.create_ip(module_name, vlnv, dir, force, allow_hidden, vendor, library, name, version, revision, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Creates a run for the given IP.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_ip_run [-force] [-quiet] [-verbose] &lt;objects&gt;
		/// <br/>
		/// <para>
		/// Defines a synthesis and implementation run for a single IP object as specified by the get_ips<br/>
		/// command, or for the specified IP core file (XCI) as specified by the get_files command.<br/>
		/// The IP run is used to generate the synthesis design checkpoint file (DCP) to support the out-of-context (OOC) IP flow, or to synthesize and implement an IP module in the OOC hierarchical<br/>
		/// design flow.<br/>
		/// Two runs are created: one for synthesis, and one for implementation. The runs are named after<br/>
		/// the IP core and the run type, &lt;ip_name&gt;_synth_1 and &lt;ip_name&gt;_impl_1.<br/>
		/// The IP source files required to synthesize the run are copied into the IP run directory. The<br/>
		/// attributes of the run can be configured with the use of the set_property command.<br/>
		/// This command returns the name of the synthesis run created for the IP module.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates synthesis and implementation runs for the specified IP module:<br/>
		/// create_ip_run [get_ips add1]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 319<br/>
		/// </para>
		/// </summary>
		/// <param name="objects">
		/// <para>
		/// (Required)<br/>
		/// All of the IP objects (from get_ips or get_files) for which a<br/>
		/// run needs to be generated for.<br/>
		/// </para>
		/// </param>
		/// <param name="force">(Optional) Force regeneration of products of the given IP.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL create_ip_run(String objects, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_ip_run [-force] [-quiet] [-verbose] <objects>
			this.Entry(_builder.create_ip_run(objects, force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a Macro<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_macro [-quiet] [-verbose] &lt;name&gt;
		/// <br/>
		/// <para>
		/// Create a macro for the relative placement of cells.<br/>
		/// Macros are primarily used to place small groups of associated cells together to improve resource<br/>
		/// efficiency and enable faster interconnections. The create_macro command lets you define<br/>
		/// macros in an open synthesized or implemented design for relative placement by place_design,<br/>
		/// like RPMs defined by the RLOC constraint in RTL source files. Refer to the Vivado Design Suite<br/>
		/// User Guide: Implementation (UG904) for more information on defining relatively placed macros.<br/>
		/// After creating the macro, specific cells can be assigned to the macro using the update_macro<br/>
		/// command. To change a currently defined macro, you must delete the macro with<br/>
		/// delete_macro, recreate the macro, and update the macro with the new contents. You cannot<br/>
		/// simply overwrite an existing macro.<br/>
		/// Use delete_macro to delete a defined macro. Use get_macros to return a list of currently<br/>
		/// defined macros in the design.<br/>
		/// This command operates silently and does not return anything.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates a macro called usbMacro1:<br/>
		/// create_macro usbMacro1<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 321<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Macro to create.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL create_macro(String name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_macro [-quiet] [-verbose] <name>
			this.Entry(_builder.create_macro(name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create nets in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_net [-from &lt;arg&gt;] [-to &lt;arg&gt;] [-quiet] [-verbose] &lt;nets&gt;...
		/// <br/>
		/// <para>
		/// Create new nets in the current netlist of an open Synthesized or Implemented Design.<br/>
		/// Note: You cannot add nets to library macros, or macro-primitives.<br/>
		/// Nets can be created hierarchically from the top-level of the design, or within any level of the<br/>
		/// hierarchy by specifying the hierarchical net name.<br/>
		/// Bus nets can be created with increasing or decreasing bus indexes, using negative and positive<br/>
		/// index values.<br/>
		/// New nets are unconnected in the netlist at the time of creation. You must connect nets as<br/>
		/// desired using the connect_net command. Connected nets can be unconnected using the<br/>
		/// disconnect_net command, and can be removed from the netlist using the remove_net<br/>
		/// command.<br/>
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not<br/>
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made<br/>
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or<br/>
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*<br/>
		/// command.<br/>
		/// Note: Netlist editing is not allowed on the elaborated RTL design.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 323<br/>
		/// </para>
		/// </summary>
		/// <param name="nets">(Required) Names of nets to create</param>
		/// <param name="from">(Optional) Starting bus index</param>
		/// <param name="to">(Optional) Ending bus index</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL create_net(TCLParameterList nets, String from = null, String to = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_net [-from <arg>] [-to <arg>] [-quiet] [-verbose] <nets>...
			this.Entry(_builder.create_net(nets, from, to, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create new PartitionDef<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_partition_def -name &lt;arg&gt; -module &lt;arg&gt; [-library &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// IMPORTANT! You must first define the project as a Partial Reconfiguration (PR) project by setting the<br/>
		/// PR_FLOW property on the project to TRUE, or by using the Tools → Enable Partial Reconfiguration<br/>
		/// command.<br/>
		/// The Partial Reconfiguration flow lets you create Partition Definitions (partitionDefs) from<br/>
		/// hierarchical cells in a design, and to specify reconfigurable modules (RMs) to be assigned to these<br/>
		/// partitionDefs to create a unique configurations of the design based on the combination of the<br/>
		/// core design and one or more RMs. The PR design flow requires the implementation of each PR<br/>
		/// configuration, resulting in partial bitstreams for the RMs, but complete bitstreams for each<br/>
		/// integrated configuration. Refer to the Vivado Design Suite User Guide: Dynamic Function eXchange<br/>
		/// (UG909) for more information.<br/>
		/// The create_partition_def command defines a partitionDef object in a PR project from a<br/>
		/// specified hierarchical cell. The partitionDef defines a partition hierarchy that RMs can be<br/>
		/// assigned to for a specific PR configuration.<br/>
		/// This command returns the name of the newly created partitionDef, or returns an error if the<br/>
		/// command fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 325<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name of the PartitionDef</param>
		/// <param name="module">(Required) Module name of the PartitionDef</param>
		/// <param name="library">(Optional) Library name of the module of PartitionDef</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL create_partition_def(String name, String module, String library = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_partition_def -name <arg> -module <arg> [-library <arg>] [-quiet] [-verbose]
			this.Entry(_builder.create_partition_def(name, module, library, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a new Pblock<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_pblock [-quiet] [-verbose] &lt;name&gt;
		/// <br/>
		/// <para>
		/// Defines a Pblock to allow you to add logic instances for floorplanning purposes.<br/>
		/// You can add logic elements to the Pblock using the add_cells_to_pblock command, and<br/>
		/// then place the Pblocks onto the fabric of the FPGA using the resize_pblocks command. The<br/>
		/// resize_pblock command can also be used to manually move and resize Pblocks.<br/>
		/// You can nest one Pblock inside another for hierarchical floorplanning using the set_property<br/>
		/// command to define the PARENT property as shown in the second example.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates a Pblock called pb_cpuEngine, and then adds only the leaf-cells<br/>
		/// found in the cpuEngine module, clearing placement constraints for placed instances:<br/>
		/// create_pblock pb_cpuEngine<br/>
		/// add_cells_to_pblock pb_cpuEngine [get_cells cpuEngine/*] \<br/>
		/// -add_primitives -clear_locs<br/>
		/// The following example shows nesting Pblocks, by creating Pblocks called pb_usbEngine0 and<br/>
		/// pb_usbEngine1, and a third Pblock called pb_usbTop. Then pb_usbEngine0 and pb_usbEngine1<br/>
		/// are nested inside pb_usbTop using the set_property command:<br/>
		/// create_pblock pb_usbEngine0<br/>
		/// create_pblock pb_usbEngine1<br/>
		/// create_pblock pb_usbTop<br/>
		/// set_property PARENT pb_usbTop [get_pblocks {pb_usbEngine?}]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 327<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name of the new pblock</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>new pblock object</returns>
		public VivadoTCL create_pblock(String name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_pblock [-quiet] [-verbose] <name>
			this.Entry(_builder.create_pblock(name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a peripheral with a VLNV.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_peripheral [-dir &lt;arg&gt;] [-quiet] [-verbose] &lt;vendor&gt; &lt;library&gt; &lt;name&gt; &lt;version&gt;
		/// <br/>
		/// <para>
		/// Create an AXI peripheral to add to the IP repository with the specified VLNV attribute.<br/>
		/// The AXI peripheral that is created is just a framework until interfaces have been added to the<br/>
		/// peripheral using the add_peripheral_interface command, and the peripheral has been<br/>
		/// generated using the generate_peripheral command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 329<br/>
		/// </para>
		/// </summary>
		/// <param name="vendor">(Required) Vendor, for example xilinx.com</param>
		/// <param name="library">(Required) Library, for example ip</param>
		/// <param name="name">(Required) Name, for example myip</param>
		/// <param name="version">(Required) Version, for example 1.4</param>
		/// <param name="dir">
		/// <para>
		/// (Optional)<br/>
		/// Directory path for remote Peripheral to be created and<br/>
		/// managed outside the project<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL create_peripheral(String vendor, String library, String name, String version, String dir = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_peripheral [-dir <arg>] [-quiet] [-verbose] <vendor> <library> <name> <version>
			this.Entry(_builder.create_peripheral(vendor, library, name, version, dir, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create pins in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_pin [-from &lt;arg&gt;] [-to &lt;arg&gt;] -direction &lt;arg&gt; [-quiet] [-verbose] &lt;pins&gt;...
		/// <br/>
		/// <para>
		/// Add single pins or bus pins to the current netlist of an open Synthesized or Implemented Design.<br/>
		/// You may define attributes of the pin such as direction and bus width, as well as the pin name.<br/>
		/// Bus pins can be created with increasing or decreasing bus indexes, using negative and positive<br/>
		/// index values.<br/>
		/// The pins must be created on an existing cell instance, or it is considered a top-level pin which<br/>
		/// should be created using the create_port command. If the instance name of a cell is not<br/>
		/// specified as part of the pin name, an error will be returned.<br/>
		/// Note: You cannot add pins to library macros, or macro-primitives.<br/>
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not<br/>
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made<br/>
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or<br/>
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*<br/>
		/// command.<br/>
		/// Note: Netlist editing is not allowed on the elaborated RTL design.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates a new input pin on the cpuEngine module with the specified pin<br/>
		/// name:<br/>
		/// create_pin -direction IN cpuEngine/inPin<br/>
		/// The following example sets the hierarchy separator, creates a new black box instance of the<br/>
		/// reference cell, and creates a twenty-four bit bidirectional bus for that instance:<br/>
		/// set_hierarchy_separator |<br/>
		/// create_cell -reference dmaBlock -black_box usbEngine0|myDMA<br/>
		/// create_pin -direction INOUT -from 0 -to 23 usbEngine0|myDMA|dataBus<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 332<br/>
		/// </para>
		/// </summary>
		/// <param name="direction">(Required) Pin direction Values: IN, OUT, INOUT</param>
		/// <param name="pins">(Required) Names of pins to create</param>
		/// <param name="from">(Optional) Starting bus index</param>
		/// <param name="to">(Optional) Ending bus index</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL create_pin(create_pin_direction direction, TCLParameterList pins, String from = null, String to = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_pin [-from <arg>] [-to <arg>] -direction <arg> [-quiet] [-verbose] <pins>...
			this.Entry(_builder.create_pin(direction, pins, from, to, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create scalar or bus port<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_port -direction &lt;arg&gt; [-from &lt;arg&gt;] [-to &lt;arg&gt;] [-diff_pair] [-interface &lt;arg&gt;] [-quiet] [-verbose] &lt;name&gt; [&lt;negative_name&gt;]
		/// <br/>
		/// <para>
		/// Creates a port and specifies such parameters as direction, width, single-ended or differential, and<br/>
		/// optionally assigns it to an existing interface. New ports are added at the top-level of the design<br/>
		/// hierarchy.<br/>
		/// Bus ports can be created with increasing or decreasing bus indexes, using negative and positive<br/>
		/// index values.<br/>
		/// The create_port command can be used to create a new port in an I/O Planning project, or<br/>
		/// while editing the netlist of an open Synthesized or Implemented design.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not<br/>
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made<br/>
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or<br/>
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*<br/>
		/// command.<br/>
		/// Note: Netlist editing is not allowed on the elaborated RTL design.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates a new input port, named PORT0:<br/>
		/// create_port -direction IN PORT0<br/>
		/// The following example creates a new interface called Group1, and then creates a four-bit,<br/>
		/// differential pair output bus using the specified interface. Since the bus ports are defined as<br/>
		/// differential pairs, and only &lt;name&gt; is specified, the negative side ports are automatically named<br/>
		/// D_BUS_N:<br/>
		/// create_interface Group1<br/>
		/// create_port -direction OUT -from 0 -to 3 -diff_pair -interface Group1 D_BUS<br/>
		/// Note: This command results in the creation of eight ports: D_BUS[0] D_BUS_N[0] D_BUS[1] D_BUS_N[1]<br/>
		/// D_BUS[2] D_BUS_N[2] D_BUS[3] D_BUS_N[3]<br/>
		/// With only &lt;name&gt; specified, the following example creates differential pair output ports named<br/>
		/// data and data_N.<br/>
		/// create_port -direction OUT -diff_pair data<br/>
		/// With both &lt;name&gt; and &lt;negative_name&gt; specified, the following example creates differential<br/>
		/// pair output ports named data_P and data_N.<br/>
		/// create_port -direction OUT -diff_pair data_P data_N<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 335<br/>
		/// </para>
		/// </summary>
		/// <param name="direction">(Required) Direction of port. Valid arguments are IN, OUT and INOUT</param>
		/// <param name="name">(Required) Name of the port</param>
		/// <param name="from">(Optional) Beginning index of new bus</param>
		/// <param name="to">(Optional) Ending index of new bus</param>
		/// <param name="diff_pair">(Optional) Create differential pair of ports</param>
		/// <param name="interface">(Optional) Assign new port to this interface</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="negative_name">(Optional) Optional negative name of a diff-pair</param>
		/// <returns>list of port objects that were created</returns>
		public VivadoTCL create_port(String direction, String name, String from = null, String to = null, bool? diff_pair = null, String @interface = null, bool? quiet = null, bool? verbose = null, String negative_name = null)
		{
			// TCL Syntax: create_port -direction <arg> [-from <arg>] [-to <arg>] [-diff_pair] [-interface <arg>] [-quiet] [-verbose] <name> [<negative_name>]
			this.Entry(_builder.create_port(direction, name, from, to, diff_pair, @interface, quiet, verbose, negative_name));
			return this;
		}
		/// <summary>
		/// <para>
		/// Generate a port on a given reconfigurable cell<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_port_on_reconfigurable_module [-cell &lt;arg&gt;] [-port &lt;arg&gt;] [-direction &lt;arg&gt;] [-from &lt;arg&gt;] [-to &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 338<br/>
		/// </para>
		/// </summary>
		/// <param name="cell">(Optional) (Required) specify the HD.RECONFIGURABLE cell name for port punching</param>
		/// <param name="port">
		/// <para>
		/// (Optional)<br/>
		/// (Required) specify the newly added port name on given<br/>
		/// HD.RECONFIGURABLE cell<br/>
		/// </para>
		/// </param>
		/// <param name="direction">
		/// <para>
		/// (Optional)<br/>
		/// (Required) specify the direction of ports, it could be either<br/>
		/// INPUT, OUTPUT or INOUT<br/>
		/// </para>
		/// </param>
		/// <param name="from">(Optional) (Optional) specify the lower boundary of port bus Default: -1</param>
		/// <param name="to">(Optional) (Optional) specify the higher boundary of port bus Default: -1</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL create_port_on_reconfigurable_module(String cell = null, String port = null, String direction = null, String from = null, String to = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_port_on_reconfigurable_module [-cell <arg>] [-port <arg>] [-direction <arg>] [-from <arg>] [-to <arg>] [-quiet] [-verbose]
			this.Entry(_builder.create_port_on_reconfigurable_module(cell, port, direction, from, to, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a new Power Rail<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_power_rail [-power_sources &lt;args&gt;] [-direct] [-quiet] [-verbose] &lt;name&gt;
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 339<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name of the new power rail</param>
		/// <param name="power_sources">(Optional) List of power sources. Can be power rails and/or power supplies</param>
		/// <param name="direct">(Optional) Implies if the power is a direct rail</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>new power_rail object</returns>
		public VivadoTCL create_power_rail(String name, TCLParameterList power_sources = null, bool? direct = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_power_rail [-power_sources <args>] [-direct] [-quiet] [-verbose] <name>
			this.Entry(_builder.create_power_rail(name, power_sources, direct, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create new Configuration<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_pr_configuration -name &lt;arg&gt; [-partitions &lt;args&gt;] [-greyboxes &lt;args&gt;] [-use_netlist] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// IMPORTANT! You must first define the project as a Partial Reconfiguration (PR) project by setting the<br/>
		/// PR_FLOW property on the project to TRUE, or by using the Tools → Enable Partial Reconfiguration<br/>
		/// command.<br/>
		/// The Partial Reconfiguration flow lets you create Partition Definitions (partitionDefs) from<br/>
		/// hierarchical cells in a design, and to specify reconfigurable modules (RMs) to be assigned to these<br/>
		/// partitionDefs to create unique configurations of the design based on the combination of the core<br/>
		/// design and one or more RMs. The PR design flow requires the implementation of each PR<br/>
		/// configuration, resulting in partial bitstreams for the RMs, but complete bitstreams for each<br/>
		/// integrated configuration. Refer to the Vivado Design Suite User Guide: Dynamic Function eXchange<br/>
		/// (UG909) for more information.<br/>
		/// The create_pr_configuration command defines the combination of the static logic and<br/>
		/// the RM to create a unique configuration of the design. The PR configuration is the design that is<br/>
		/// implemented and the bitstream is generated for.<br/>
		/// You will also need to create implementation runs for the PR configuration using the<br/>
		/// create_run -pr_config command.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This command returns the name of the newly created PR configuration, or returns an error if the<br/>
		/// command fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 340<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name of the Configuration</param>
		/// <param name="partitions">(Optional) List of partition instances and reconfig modules pairs</param>
		/// <param name="greyboxes">(Optional) List of instances to which buffers need to be inserted for all ports</param>
		/// <param name="use_netlist">
		/// <para>
		/// (Optional)<br/>
		/// Use netlist for getting instances of partition_defs to creating<br/>
		/// configurations<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL create_pr_configuration(String name, TCLParameterList partitions = null, TCLParameterList greyboxes = null, bool? use_netlist = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_pr_configuration -name <arg> [-partitions <args>] [-greyboxes <args>] [-use_netlist] [-quiet] [-verbose]
			this.Entry(_builder.create_pr_configuration(name, partitions, greyboxes, use_netlist, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a new project<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_project [-part &lt;arg&gt;] [-force] [-in_memory] [-ip] [-rtl_kernel] [-quiet] [-verbose] [&lt;name&gt;] [&lt;dir&gt;]
		/// <br/>
		/// <para>
		/// Creates a Vivado Design Suite project file (.xpr), or a project file for the Vivado Lab Edition (.lpr),<br/>
		/// in the specified directory.<br/>
		/// For the Vivado Lab Edition: The create_project command has a different command syntax,<br/>
		/// with fewer options, in the Vivado Lab Edition. The options that are not supported in Vivado Lab<br/>
		/// Edition are:<br/>
		/// • -part - The Vivado Lab Edition project (.lpr) does not specify a target part because the<br/>
		/// current_hw_target and current_hw_device determine the target part.<br/>
		/// • -ip - The Vivado Lab Edition does not define projects for the Managed IP flow.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// For the Vivado Design Suite: The default project created for the Vivado Design Suite is an RTL<br/>
		/// project, which defines the project as holding and manage RTL source files in the source fileset.<br/>
		/// The type of project is determined by the DESIGN_MODE Property on the source fileset when the<br/>
		/// project is created. To change the project type, use the set_property command to set the<br/>
		/// DESIGN_MODE property on the current_fileset as follows:<br/>
		/// • RTL Project - set_property DESIGN_MODE RTL [current_fileset]<br/>
		/// • Netlist Project - set_property DESIGN_MODE GateLvl [current_fileset]<br/>
		/// • I/O Planning Project - set_property DESIGN_MODE PinPlanning<br/>
		/// [current_fileset]<br/>
		/// Refer to the Vivado Design Suite User Guide: System-Level Design Entry (UG895) for more<br/>
		/// information on the different types of projects.<br/>
		/// This command returns a transcript of its process and the name of the created project, or returns<br/>
		/// an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// When run from the Vivado Design Suite, the following example creates a project called<br/>
		/// project1.xpr in a directory called myDesigns:<br/>
		/// create_project project1 myDesigns<br/>
		/// Note: Because the &lt;dir&gt; is specified as the folder name only, the tool will create the project in the current<br/>
		/// working directory, or the directory from which the tool was launched.<br/>
		/// When run from the Vivado Lab Edition, this example creates a project called project1.lpr in<br/>
		/// a directory called myDesigns:<br/>
		/// create_project project1 myDesigns<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example creates a project called Proj1 in a directory called FPGA in C:/Designs. In<br/>
		/// addition, the tool will overwrite an existing project if one is found to exist in the specified<br/>
		/// location. In the second and third lines, the location of -force is changed to show the flexibility<br/>
		/// of argument placement.<br/>
		/// create_project Proj1 C:/Designs/FPGA -force<br/>
		/// -or-<br/>
		/// create_project Proj1 -force C:/Designs/FPGA<br/>
		/// -or-<br/>
		/// create_project -force Proj1 C:/Designs/FPGA<br/>
		/// Note: In all cases the first argument without a preceding keyword is interpreted as the &lt;name&gt; variable,<br/>
		/// and the second argument without a preceding keyword is the &lt;dir&gt; variable.<br/>
		/// The following example creates a project for the Manage IP flow in the specified directory:<br/>
		/// create_project -ip manageIP C:/Data<br/>
		/// The following example creates a new project called pin_project, and then sets the<br/>
		/// DESIGN_MODE property as required for an I/O Pin Planning project, and finally opens an IO<br/>
		/// design:<br/>
		/// create_project pin_project C:/Designs/PinPlanning<br/>
		/// set_property design_mode PinPlanning [current_fileset]<br/>
		/// open_io_design -name io_1<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 343<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Project name</param>
		/// <param name="part">(Optional) Target part</param>
		/// <param name="force">(Optional) Overwrite existing project directory</param>
		/// <param name="in_memory">(Optional) Create an in-memory project</param>
		/// <param name="ip">(Optional) Default GUI behavior is for a managed IP project</param>
		/// <param name="rtl_kernel">(Optional) Default GUI behavior is for a RTL Kernel project</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="dir">(Optional) Directory where the project file is saved Default: .</param>
		/// <returns>new project object</returns>
		public VivadoTCL create_project(String name, String part = null, bool? force = null, bool? in_memory = null, bool? ip = null, bool? rtl_kernel = null, bool? quiet = null, bool? verbose = null, String dir = null)
		{
			// TCL Syntax: create_project [-part <arg>] [-force] [-in_memory] [-ip] [-rtl_kernel] [-quiet] [-verbose] [<name>] [<dir>]
			this.Entry(_builder.create_project(name, part, force, in_memory, ip, rtl_kernel, quiet, verbose, dir));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create property for class of objects(s)<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_property [-description &lt;arg&gt;] [-type &lt;arg&gt;] [-enum_values &lt;args&gt;] [-default_value &lt;arg&gt;] [-file_types &lt;args&gt;] [-display_text &lt;arg&gt;] [-quiet] [-verbose] &lt;name&gt; &lt;class&gt;
		/// <br/>
		/// <para>
		/// Creates a new property of the &lt;type&gt; specified with the user-defined &lt;name&gt; for the specified<br/>
		/// &lt;class&gt; of objects. The property that is created can be assigned to an object of the specified class<br/>
		/// with the set_property command, but is not automatically associated with all objects of that<br/>
		/// class.<br/>
		/// The report_property -all command will not report the newly created property for an<br/>
		/// object of the specified class until the property has been assigned to that object.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example defines a property called PURPOSE for cell objects:<br/>
		/// create_property PURPOSE cell<br/>
		/// Note: Because the -type was not specified, the value will default to strings.<br/>
		/// The following example creates a pin property called COUNT which holds an Integer value:<br/>
		/// create_property -type int COUNT pin<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 347<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name of property to create</param>
		/// <param name="class">
		/// <para>
		/// (Required)<br/>
		/// Object type to create property for; valid values are: design,<br/>
		/// net, cell, pin, port, pblock, interface, fileset<br/>
		/// </para>
		/// </param>
		/// <param name="description">(Optional) Description of property</param>
		/// <param name="type">
		/// <para>
		/// (Optional)<br/>
		/// Type of property to create; valid values are: string, int, long,<br/>
		/// double, bool, enum, file Default: string<br/>
		/// </para>
		/// </param>
		/// <param name="enum_values">(Optional) Enumeration values</param>
		/// <param name="default_value">(Optional) Default value of type string</param>
		/// <param name="file_types">(Optional) File type extensions (without the dot)</param>
		/// <param name="display_text">(Optional) Text to display when selecting the file in file browser</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The property that was created if success, "" if failure</returns>
		public VivadoTCL create_property(String name, String @class, String description = null, String type = null, TCLParameterList enum_values = null, String default_value = null, TCLParameterList file_types = null, String display_text = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_property [-description <arg>] [-type <arg>] [-enum_values <args>] [-default_value <arg>] [-file_types <args>] [-display_text <arg>] [-quiet] [-verbose] <name> <class>
			this.Entry(_builder.create_property(name, @class, description, type, enum_values, default_value, file_types, display_text, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create new reconfig Module<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_reconfig_module -name &lt;arg&gt; [-top &lt;arg&gt;] [-gate_level] -partition_def &lt;arg&gt; [-define_from &lt;arg&gt;] [-define_from_file &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// IMPORTANT! You must first define the project as a Partial Reconfiguration (PR) project by setting the<br/>
		/// PR_FLOW property on the project to TRUE, or by using the Tools → Enable Partial Reconfiguration<br/>
		/// command.<br/>
		/// The create_reconfig_module command defines an reconfigurable module (RM) from a<br/>
		/// specified hierarchical cell, or design file, and assigns it to the specified Partition Definition<br/>
		/// (partitionDef) in the current project.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The Partial Reconfiguration flow allows RMs to be swapped into and out of a partitionDef to<br/>
		/// create a unique configuration of the design based on the combination of the core design and an<br/>
		/// RM. A single partitionDef can have multiple RMs to contain different netlists, constraints, or<br/>
		/// implementations. Each instance of the partitionDef in the design can be assigned a different RM<br/>
		/// to support many different configurations. The PR design flow requires the implementation of<br/>
		/// each PR configuration, resulting in partial bitstreams for the RMs, but complete bitstreams for<br/>
		/// each integrated configuration. Refer to the Vivado Design Suite User Guide: Dynamic Function<br/>
		/// eXchange (UG909) for more information.<br/>
		/// This command returns the hierarchical name of the newly created RM, or returns an error if the<br/>
		/// command failed.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The example below creates a reconfigurable module with the specified name:<br/>
		/// create_reconfig_module -name fftBottom -partition_def \<br/>
		/// [get_partition_defs partDef1 ] -top fftTop<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 350<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name of the Reconfig Module</param>
		/// <param name="partition_def">(Required) PartitionDef in which reconfig module will be created</param>
		/// <param name="top">(Optional) module name of the top module</param>
		/// <param name="gate_level">(Optional) Create Reconfig Module whcih alllows adding DCP/EDIF files only</param>
		/// <param name="define_from">(Optional) Name of the module in the source fileset to be the top of the blockset</param>
		/// <param name="define_from_file">
		/// <para>
		/// (Optional)<br/>
		/// full path of the top source file in the source fileset for which<br/>
		/// reconfigurable module to be created.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL create_reconfig_module(String name, String partition_def, String top = null, bool? gate_level = null, String define_from = null, String define_from_file = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_reconfig_module -name <arg> [-top <arg>] [-gate_level] -partition_def <arg> [-define_from <arg>] [-define_from_file <arg>] [-quiet] [-verbose]
			this.Entry(_builder.create_reconfig_module(name, partition_def, top, gate_level, define_from, define_from_file, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create Configurable Report objects.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_report_config [-report_name &lt;arg&gt;] [-report_type &lt;arg&gt;] -steps &lt;args&gt; -runs &lt;args&gt; [-options &lt;arg&gt;] [-copy_of &lt;args&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// This command lets you create configurable report objects to add to synthesis and<br/>
		/// implementation runs, or to add to Report Strategies. A report object defines the report type and<br/>
		/// options that are run every time a specified step of a synthesis or implementation design run is<br/>
		/// completed. A Report Strategy lets you define a collection of report objects to associate with<br/>
		/// many synthesis and implementation runs, and reuse at different stages of the design flow. See<br/>
		/// the Vivado Design Suite User Guide: Implementation (UG904) for more information.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Each report object has the 'OPTIONS.MORE_OPTIONS' property, which lets you specify<br/>
		/// command line options of the Tcl report_* command associated with the report object. These<br/>
		/// command line options are used when the report is generated during the synthesis or<br/>
		/// implementation run. You can specify the command line options using the -options argument as<br/>
		/// described below, or by manually setting the 'OPTIONS.MORE_OPTIONS' property of an existing<br/>
		/// report object using the set_property command. Refer to the specific report_* command for<br/>
		/// information on the available command line options.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example defines a new report object with the specified name and type and<br/>
		/// associates it with the route_design step of the impl_1 run:<br/>
		/// create_report_config -report_name post_route_datasheet -report_type<br/>
		/// report_datasheet \<br/>
		/// -steps route_design -runs impl_1<br/>
		/// This example is the same as the prior example, except it does not specify the name, and so the<br/>
		/// report object is named automatically as shown in the return value:<br/>
		/// create_report_config -report_type report_datasheet -steps route_design -<br/>
		/// runs impl_1<br/>
		/// impl_1_route_report_datasheet_0<br/>
		/// The following example creates a new report object for the timing summary report, with the<br/>
		/// specified command-line options, and associates the object with multiple steps of an<br/>
		/// implementation run:<br/>
		/// create_report_config -report_type report_timing_summary \<br/>
		/// -steps {opt_design place_design route_design} -runs {impl_2}\<br/>
		/// -options {-no_detailed_paths -report_unconstrained}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 353<br/>
		/// </para>
		/// </summary>
		/// <param name="steps">(Required) List of run step(s) for object(s) created</param>
		/// <param name="runs">(Required) List of run(s) for object(s) created</param>
		/// <param name="report_name">
		/// <para>
		/// (Optional)<br/>
		/// Name of configurable report object created. Can not be<br/>
		/// used when creating multiple objects<br/>
		/// </para>
		/// </param>
		/// <param name="report_type">
		/// <para>
		/// (Optional)<br/>
		/// Type of configurable report object(s) created. Not required<br/>
		/// with '-copy_of'<br/>
		/// </para>
		/// </param>
		/// <param name="options">
		/// <para>
		/// (Optional)<br/>
		/// options for report command to be set at creation of<br/>
		/// configurable report object, except with '-copy_of'<br/>
		/// </para>
		/// </param>
		/// <param name="copy_of">(Optional) configurable report object to be copied</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>List of configurable report objects</returns>
		public VivadoTCL create_report_config(TCLParameterList steps, TCLParameterList runs, String report_name = null, String report_type = null, String options = null, TCLParameterList copy_of = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_report_config [-report_name <arg>] [-report_type <arg>] -steps <args> -runs <args> [-options <arg>] [-copy_of <args>] [-quiet] [-verbose]
			this.Entry(_builder.create_report_config(steps, runs, report_name, report_type, options, copy_of, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// (User-written application) Creates and launches a new run based on the suggestions by<br/>
		/// report_qor_suggestions. This proc looks for 5 files in the directory specified by the user.<br/>
		/// 1.RQSPreSynth_&lt;newProjName&gt;.xdc 2.RQSImplCommon_&lt;newProjName&gt;.xdc<br/>
		/// 3.RQSPreImpl_&lt;newProjName&gt;.xdc 4.RQSPreImpl_&lt;newProjName&gt;.tcl<br/>
		/// 5.RQSImplCommon_&lt;newProjName&gt;.tcl. There are 2 flows. One is creating both synth and impl<br/>
		/// runs and the other is creating only impl run making user specified synth run as the parent for the<br/>
		/// newly created impl run. In the first flow, we create a new synth run based on the current impl<br/>
		/// run's parent run (i,e current synth run). We create a new constraint fileset and add the current<br/>
		/// synth run's constraint fileset's files to that. And we add RQSPreSynth_&lt;&gt;.xdc file to newly<br/>
		/// created constraint set. We create a impl run based on the current impl run. We create a impl run<br/>
		/// constraint (if it is not same as the one that has already been created), and add the current impl<br/>
		/// run's constraint fileset's files to that. We also add RQSImplCommon_&lt;&gt;.xdc to new impl<br/>
		/// constraint fileset. We set STEPS.OPT_DESIGN.TCL.PRE property of newly created impl run to<br/>
		/// RQSImplCommon_&lt;&gt;.tcl file. In this flow, we ignore RQSPreImpl_&lt;&gt;.xdc/tcl files. In the second<br/>
		/// flow, user specified synth run is used as parent for the newly created impl run. So there is no<br/>
		/// synth run creation. We create impl run based on current impl run and user specified synth run.<br/>
		/// We create a new impl constraint fileset and add fileset to that form the current impl run's<br/>
		/// constraint fileset. We also add RQSImplCommon_&lt;&gt;.xdc , RQSPreImpl_&lt;&gt;.xdc files. If<br/>
		/// RQSPreImpl_&lt;&gt;.tcl file is available, it is set as STEPS.OPT_DESIGN.TCL.PRE property for new<br/>
		/// impl run otherwise RQSImplCommon_&lt;&gt;.tcl is set. In both the flows adding or setting files is<br/>
		/// subject to availability of those files in the output directory.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_rqs_run -dir &lt;arg&gt; -new_name &lt;arg&gt; [-synth_name &lt;arg&gt;] [-opt_more_options &lt;arg&gt;] [-place_more_options &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Creates and launches a new implementation run based on the suggestions provided by<br/>
		/// report_qor_suggestions.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example will create and launch a new run, exp_1, using the constraints files from<br/>
		/// the specified directory:<br/>
		/// create_rqs_run -dir path_to_dir -new_name exp_1 -synth_name synth_1 \<br/>
		/// -opt_more_options optVal -place_more_options placeVal<br/>
		/// TIP: The constraints were previously created using the -output_dir option of the<br/>
		/// report_qor_suggestions command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 356<br/>
		/// </para>
		/// </summary>
		/// <param name="dir">
		/// <para>
		/// (Required)<br/>
		/// Specify the directory from where the xdc files and tcl files<br/>
		/// need to fetched.<br/>
		/// </para>
		/// </param>
		/// <param name="new_name">(Required) Specify the name of the new run</param>
		/// <param name="synth_name">
		/// <para>
		/// (Optional)<br/>
		/// Specify the name of the already existing synth run. This run<br/>
		/// will be the parent run for the newly created impl run<br/>
		/// Default: None<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Name Description<br/>
		/// </para>
		/// </param>
		/// <param name="opt_more_options">
		/// <para>
		/// (Optional)<br/>
		/// optional argument. Specify the value for opt_design step's<br/>
		/// more option property which will be set on newly created<br/>
		/// run. Default: None<br/>
		/// </para>
		/// </param>
		/// <param name="place_more_options">
		/// <para>
		/// (Optional)<br/>
		/// Specify the value for place_design step's more option<br/>
		/// property which will be set on newly created run. Default:<br/>
		/// None<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>None</returns>
		public VivadoTCL create_rqs_run(String dir, String new_name, String synth_name = null, String opt_more_options = null, String place_more_options = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_rqs_run -dir <arg> -new_name <arg> [-synth_name <arg>] [-opt_more_options <arg>] [-place_more_options <arg>] [-quiet] [-verbose]
			this.Entry(_builder.create_rqs_run(dir, new_name, synth_name, opt_more_options, place_more_options, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Define a synthesis or implementation run for the current project<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_run [-constrset &lt;arg&gt;] [-parent_run &lt;arg&gt;] [-part &lt;arg&gt;] -flow &lt;arg&gt; [-strategy &lt;arg&gt;] [-report_strategy &lt;arg&gt;] [-pr_config &lt;arg&gt;] [-quiet] [-verbose] &lt;name&gt;
		/// <br/>
		/// <para>
		/// Defines a synthesis or implementation run. The attributes of the run can be configured with the<br/>
		/// use of the set_property command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates a run named synth_1 referencing the Vivado synthesis tool flow:<br/>
		/// create_run -flow {Vivado Synthesis 2013} synth_1<br/>
		/// Note: The defaults of sources_1, constrs_1, and the default part for the project will be used in the synthesis<br/>
		/// run. In addition, since this is a synthesis run, the -parent_run argument is not required.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example creates an implementation run based on the Vivado Implementation 2013<br/>
		/// tool flow, and attaches it to the synth_1 synthesis run previously created:<br/>
		/// create_run impl_2 -parent_run synth_1 -flow {Vivado Implementation 2013}<br/>
		/// Note: The -parent_run argument is required in this example because it is an implementation of<br/>
		/// synthesized RTL sources.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 359<br/>
		/// </para>
		/// </summary>
		/// <param name="flow">(Required) Flow name</param>
		/// <param name="name">(Required) Name for new run</param>
		/// <param name="constrset">(Optional) Constraint fileset to use</param>
		/// <param name="parent_run">(Optional) Synthesis run to link to new implementation run</param>
		/// <param name="part">(Optional) Target part</param>
		/// <param name="strategy">(Optional) Strategy to apply to the run</param>
		/// <param name="report_strategy">(Optional) Report strategy to apply to the run</param>
		/// <param name="pr_config">(Optional) partition configuration to apply to the run</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>run object</returns>
		public VivadoTCL create_run(String flow, String name, String constrset = null, String parent_run = null, String part = null, String strategy = null, String report_strategy = null, String pr_config = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_run [-constrset <arg>] [-parent_run <arg>] [-part <arg>] -flow <arg> [-strategy <arg>] [-report_strategy <arg>] [-pr_config <arg>] [-quiet] [-verbose] <name>
			this.Entry(_builder.create_run(flow, name, constrset, parent_run, part, strategy, report_strategy, pr_config, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create histogram<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_slack_histogram [-to &lt;args&gt;] [-delay_type &lt;arg&gt;] [-num_bins &lt;arg&gt;] [-slack_less_than &lt;arg&gt;] [-slack_greater_than &lt;arg&gt;] [-group &lt;args&gt;] [-report_unconstrained] [-significant_digits &lt;arg&gt;] [-scale &lt;arg&gt;] [-name &lt;arg&gt;] [-cells &lt;args&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Create a slack histogram grouping paths into slack ranges, and displaying the results graphically.<br/>
		/// TIP: This command provides a graphical slack histogram that requires the tool to be running in GUI mode.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates a slack histogram of the current design, using the default values,<br/>
		/// and outputting the results to the named result set in the GUI:<br/>
		/// create_slack_histogram -name slack1<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 362<br/>
		/// </para>
		/// </summary>
		/// <param name="to">(Optional) To clock</param>
		/// <param name="delay_type">(Optional) Type of path delay: Values: max, min, min_max Default: max</param>
		/// <param name="num_bins">(Optional) Maximum number of bins: Valid Range (1-100) Default: 10</param>
		/// <param name="slack_less_than">(Optional) Display paths with slack less than this Default: 1e+30</param>
		/// <param name="slack_greater_than">(Optional) Display paths with slack greater than this Default: -1e+30</param>
		/// <param name="group">(Optional) Limit report to paths in this group(s)</param>
		/// <param name="report_unconstrained">(Optional) Report unconstrained end points</param>
		/// <param name="significant_digits">(Optional) Number of digits to display: Range: 0 to 3 Default: 3</param>
		/// <param name="scale">
		/// <para>
		/// (Optional)<br/>
		/// Type of scale on which to draw the histogram; Values:<br/>
		/// linear, logarithmic Default: linear<br/>
		/// </para>
		/// </param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="cells">(Optional) run create_slack_histogram on the specified cell(s)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL create_slack_histogram(TCLParameterList to = null, create_slack_histogram_delay_type? delay_type = null, Int32? num_bins = null, String slack_less_than = null, String slack_greater_than = null, TCLParameterList group = null, bool? report_unconstrained = null, Int32? significant_digits = null, create_slack_histogram_scale? scale = null, String name = null, TCLParameterList cells = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_slack_histogram [-to <args>] [-delay_type <arg>] [-num_bins <arg>] [-slack_less_than <arg>] [-slack_greater_than <arg>] [-group <args>] [-report_unconstrained] [-significant_digits <arg>] [-scale <arg>] [-name <arg>] [-cells <args>] [-quiet] [-verbose]
			this.Entry(_builder.create_slack_histogram(to, delay_type, num_bins, slack_less_than, slack_greater_than, group, report_unconstrained, significant_digits, scale, name, cells, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create DSP source for Xilinx System Generator and add to the source fileset<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_sysgen [-quiet] [-verbose] &lt;name&gt;
		/// <br/>
		/// <para>
		/// Create a DSP sub-module for use in the current project, and add it to the source files.<br/>
		/// This command will launch System Generator for DSP to let you design the hardware portion of<br/>
		/// your system design. System Generator is a DSP design tool from Xilinx that allows the RTL<br/>
		/// source files, Simulink® and MATLAB® software models, and C/C++ components of a DSP system<br/>
		/// to come together in a single simulation and implementation environment.<br/>
		/// For more information on using specific features of the tool refer to System Generator for DSP<br/>
		/// Getting Started Guide (UG639).<br/>
		/// You can also add existing DSP model files (.mdl) from System Generator into the current project<br/>
		/// using the add_files command.<br/>
		/// The command returns the name of the DSP module created and added to the project.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example launches System Generator and allows you to define and configure the<br/>
		/// specified DSP module:<br/>
		/// create_sysgen DSP_mod1<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 365<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Sub module name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Name for the new sub module</returns>
		public VivadoTCL create_sysgen(String name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_sysgen [-quiet] [-verbose] <name>
			this.Entry(_builder.create_sysgen(name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a DRC/METHODOLOGY/CDC message waiver<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_waiver [-type &lt;arg&gt;] [-id &lt;arg&gt;] [-objects &lt;args&gt;] [-from &lt;args&gt;] [-to &lt;args&gt;] [-strings &lt;args&gt;] [-of_objects &lt;args&gt;] [-user &lt;arg&gt;] -description &lt;arg&gt; [-tags &lt;arg&gt;] [-timestamp &lt;arg&gt;] [-scoped] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// After report_drc, report_methodology, or report_cdc commands are run, they return<br/>
		/// messages of specific violations or conditions found in the design. These violations can prevent<br/>
		/// the design from progressing until they have been resolved or addressed in some way. The<br/>
		/// create_waiver command lets you select individual violations or specific checks that can be<br/>
		/// waived for a design, letting you move forward in the design flow.<br/>
		/// IMPORTANT! Use caution when waiving violations. Waivers may let you proceed in the design flow, but<br/>
		/// also let you create a design that is fundamentally flawed.<br/>
		/// The user creating the waiver is required to provide a user ID and description in the<br/>
		/// create_waiver command in order to provide some history of the waiver.<br/>
		/// A waiver must be specified for an individual DRC or methodology violation, or for a specific DRC<br/>
		/// or methodology check, or for a CDC path. The waiver must be assigned to a specific object, or<br/>
		/// specific violation ID, or for paths using -from/-to arguments. The form of the<br/>
		/// create_waiver command varies depending on the check, violation, or object being waived, as<br/>
		/// shown in the examples below.<br/>
		/// TIP: Although many of the arguments are described as optional, some form of identifier is required to<br/>
		/// associate the waiver with its target.<br/>
		/// To save waivers from one design session to the next, you must use write_waivers to create<br/>
		/// an XDC file of the waiver commands, and read_xdc to read those waivers back into the design<br/>
		/// when it is reopened.<br/>
		/// After creating a waiver, you will need to rerun the DRC, methodology, or CDC report to have the<br/>
		/// waiver considered in the analysis. To see what waivers are in place in the current design you can<br/>
		/// use the report_waivers command. In addition, the report_drc, report_methodology,<br/>
		/// and report_cdc commands have options to run the reports on waived violations or checks.<br/>
		/// Use the delete_waivers command to remove waivers from the design.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// This example creates a waiver for a methodology check based on the specified ID:<br/>
		/// create_waiver -id TIMING-18 -user samwise -description {waive rule check}<br/>
		/// The following example creates a DRC check waiver for the indicated ID on the specified list of<br/>
		/// port objects, and provides the timestamp in local time:<br/>
		/// create_waiver -type DRC -id UCIO-1 -user samwise -desc {waiving DRC<br/>
		/// violation} \<br/>
		/// -objects [get_ports {src_in* dest_out*}] \<br/>
		/// -timestamp [clock format [clock seconds] -gmt 0]<br/>
		/// The following example creates a waiver for specific CDC paths in the design, defined by the -<br/>
		/// from/-to arguments:<br/>
		/// create_waiver -type CDC -id CDC-6 -user samwise \<br/>
		/// -description {Paths to be re-tested later}\<br/>
		/// -from [list [get_pins {inst_xpm_grey/src_gray_ff_reg[3]/C \<br/>
		/// inst_xpm_grey/src_gray_ff_reg[16]/C \<br/>
		/// inst_xpm_grey/src_gray_ff_reg[22]/C \<br/>
		/// inst_xpm_grey/src_gray_ff_reg[25]/C}] ] \<br/>
		/// -to [list [get_pins {inst_xpm_grey/dest_graysync_ff_reg[0][1]/D \<br/>
		/// inst_xpm_grey/dest_graysync_ff_reg[0][6]/D \<br/>
		/// inst_xpm_grey/dest_graysync_ff_reg[0][9]/D \<br/>
		/// inst_xpm_grey/dest_graysync_ff_reg[0][24]/D}] ]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 367<br/>
		/// </para>
		/// </summary>
		/// <param name="description">(Required) Description string of the cause for the waiver</param>
		/// <param name="type">(Optional) Type of waiver - DRC, METHODOLOGY, CDC</param>
		/// <param name="id">
		/// <para>
		/// (Optional)<br/>
		/// ID of the DRC/METHODOLOGY/CDC message being waived,<br/>
		/// not needed for -of_objects use<br/>
		/// </para>
		/// </param>
		/// <param name="objects">
		/// <para>
		/// (Optional)<br/>
		/// List of inserted message objects for which a DRC/<br/>
		/// METHODOLOGY waiver will be set (i.e. %ELG, %SIG, etc. for<br/>
		/// cells or nets, etc., sites, etc., or '*CELL', '*NET', '*SITE', etc.<br/>
		/// as wildcards<br/>
		/// </para>
		/// </param>
		/// <param name="from">
		/// <para>
		/// (Optional)<br/>
		/// List of source (driver) pins or ports (or '*PORT', '*PIN' as<br/>
		/// wildcard) for which a CDC waiver will be set<br/>
		/// </para>
		/// </param>
		/// <param name="to">
		/// <para>
		/// (Optional)<br/>
		/// List of target (load) pins or ports (or '*PORT', '*PIN' as<br/>
		/// wildcard) for which a CDC waiver will be set<br/>
		/// </para>
		/// </param>
		/// <param name="strings">
		/// <para>
		/// (Optional)<br/>
		/// List of inserted message string values for which a DRC/<br/>
		/// METHODOLOGY waiver will be set (i.e. %STR for strings, or<br/>
		/// '*' as wildcard)<br/>
		/// </para>
		/// </param>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// List of DRC/METHODOLOGY/CDC violation objects for which<br/>
		/// waiver(s) will be set<br/>
		/// </para>
		/// </param>
		/// <param name="user">
		/// <para>
		/// (Optional)<br/>
		/// Name of the user creating the waiver (required, but if not<br/>
		/// specified, the waivers will take the USER name from the<br/>
		/// environment if it is available)<br/>
		/// </para>
		/// </param>
		/// <param name="tags">
		/// <para>
		/// (Optional)<br/>
		/// Optional list of one or more tags to aid in subsequent<br/>
		/// waiver identification or categorization<br/>
		/// </para>
		/// </param>
		/// <param name="timestamp">
		/// <para>
		/// (Optional)<br/>
		/// Timestamp of waiver - for restaining the original time of a<br/>
		/// waiver being (re)created after being written<br/>
		/// </para>
		/// </param>
		/// <param name="scoped">
		/// <para>
		/// (Optional)<br/>
		/// Flag waiver to interpret object wildcards as scoped to the<br/>
		/// current_instance that is set<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">
		/// <para>
		/// (Optional)<br/>
		/// Suspend message limits during command execution<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// </param>
		/// <returns>waiver</returns>
		public VivadoTCL create_waiver(String description, String type = null, String id = null, TCLParameterList objects = null, TCLParameterList from = null, TCLParameterList to = null, TCLParameterList strings = null, TCLParameterList of_objects = null, String user = null, String tags = null, String timestamp = null, bool? scoped = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_waiver [-type <arg>] [-id <arg>] [-objects <args>] [-from <args>] [-to <args>] [-strings <args>] [-of_objects <args>] [-user <arg>] -description <arg> [-tags <arg>] [-timestamp <arg>] [-scoped] [-quiet] [-verbose]
			this.Entry(_builder.create_waiver(description, type, id, objects, from, to, strings, of_objects, user, tags, timestamp, scoped, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Creates a new wave config<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_wave_config [-quiet] [-verbose] [&lt;name&gt;]
		/// <br/>
		/// <para>
		/// Create a new wave configuration object in the current simulation, and open the waveform<br/>
		/// configuration in the Vivado IDE. This will make the new wave configuration object the current<br/>
		/// wave configuration.<br/>
		/// In the Vivado® simulator GUI, you can work with a waveform to analyze your design and debug<br/>
		/// your code. The Wave Config file contains the list of wave objects (signals, dividers, groups, virtual<br/>
		/// buses) to display, and their display properties, plus markers. A wave configuration displays with<br/>
		/// top-level HDL objects, and can be further populated using commands like add_wave and<br/>
		/// add_wave_divider. Any changes made to a wave configuration can be saved to a Wave<br/>
		/// Config file with the save_wave_config command.<br/>
		/// This command returns the name of the waveform configuration created, or an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates a new wave configuration object with the specified name:<br/>
		/// create_wave_config testbench1<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 371<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="name">
		/// <para>
		/// (Optional)<br/>
		/// Creates a new wave configuration of the specified name, or<br/>
		/// a default name if no name given. A new wave window<br/>
		/// showing that WCFG is also created and made the current<br/>
		/// wave window<br/>
		/// </para>
		/// </param>
		/// <returns>The new wave config</returns>
		public VivadoTCL create_wave_config(bool? quiet = null, bool? verbose = null, String name = null)
		{
			// TCL Syntax: create_wave_config [-quiet] [-verbose] [<name>]
			this.Entry(_builder.create_wave_config(quiet, verbose, name));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create embedded source for XPS and add to the source fileset (Not supported anymore. Please<br/>
		/// use Vivado IP integrator.)<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: create_xps [-quiet] [-verbose] &lt;name&gt;
		/// <br/>
		/// <para>
		/// Create an Embedded Processor source for use in the current project, and add it to the source<br/>
		/// files.<br/>
		/// This command will launch the Xilinx Platform Studio (XPS) to let you design the hardware portion<br/>
		/// of the embedded processor system. In XPS you can define and configure the microprocessor,<br/>
		/// peripherals, and the interconnection of these components. After you exit XPS, the created files<br/>
		/// for the Embedded Processor sub-design will be written to the local project directory<br/>
		/// (&lt;project_name&gt;.srcs/sources_1/edk/&lt;name&gt; ), and added to the source files.<br/>
		/// For more information on using specific features of XPS refer to EDK Concepts, Tools, and<br/>
		/// Techniques (UG683).<br/>
		/// You can also add existing Xilinx Microprocessor Project (.xmp) files from XPS in the current<br/>
		/// project using the add_files command.<br/>
		/// The command returns the name of the Embedded Processor sub-design created.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example launches XPS to define and configure the specified Embedded Processor<br/>
		/// sub-design:<br/>
		/// create_xps xpsTest1<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 373<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Source name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>source file name that was created</returns>
		public VivadoTCL create_xps(String name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: create_xps [-quiet] [-verbose] <name>
			this.Entry(_builder.create_xps(name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Set or get current design.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: current_bd_design [-quiet] [-verbose] [&lt;design&gt;]
		/// <br/>
		/// <para>
		/// Defines the current IP subsystem design for use with the IP integrator of the Vivado Design<br/>
		/// Suite, or returns the name of the current design in the active project.<br/>
		/// The current IP subsystem design and current IP subsystem instance are the target of most of the<br/>
		/// IP integrator Tcl commands and design changes made in the tool. The current IP subsystem<br/>
		/// instance can be defined using the current_bd_instance command.<br/>
		/// You can use the get_bd_designs command to get a list of open IP subsystem designs in the<br/>
		/// active project.<br/>
		/// A complete list of IP integrator Tcl commands can be returned using the following command from<br/>
		/// the Vivado Design Suite Tcl shell:<br/>
		/// load_features IPIntegrator<br/>
		/// help -category IPintegrator<br/>
		/// Note: The load_features command is only needed if the IP integrator is not currently loaded in the<br/>
		/// Vivado Design Suite.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example sets the IP subsystem design as the current design:<br/>
		/// current_bd_design design_1<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 375<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="design">(Optional) Name of current design to be set</param>
		/// <returns>The current design object, "" if failed.</returns>
		public VivadoTCL current_bd_design(bool? quiet = null, bool? verbose = null, String design = null)
		{
			// TCL Syntax: current_bd_design [-quiet] [-verbose] [<design>]
			this.Entry(_builder.current_bd_design(quiet, verbose, design));
			return this;
		}
		/// <summary>
		/// <para>
		/// Set or get current cell instance.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: current_bd_instance [-quiet] [-verbose] [&lt;instance&gt;]
		/// <br/>
		/// <para>
		/// Set or get the current hierarchical cell instance in the current IP integrator subsystem design, as<br/>
		/// defined by current_bd_design. The current instance is referenced from the top-level of the<br/>
		/// subsystem design hierarchy, or "/".<br/>
		/// This command returns the current IP integrator cell instance object, or returns nothing if the<br/>
		/// command failed.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example sets the current instance in the subsystem design to the specified module:<br/>
		/// current_bd_instance module2<br/>
		/// The following example returns the current instance:<br/>
		/// current_bd_instance .<br/>
		/// This example resets the current instance of the subsystem design to the top level of the<br/>
		/// hierarchy:<br/>
		/// current_instance /<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 377<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="instance">(Optional) Name of current cell instance to be set</param>
		/// <returns>The current cell instance object, "" if failed.</returns>
		public VivadoTCL current_bd_instance(bool? quiet = null, bool? verbose = null, String instance = null)
		{
			// TCL Syntax: current_bd_instance [-quiet] [-verbose] [<instance>]
			this.Entry(_builder.current_bd_instance(quiet, verbose, instance));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get the current board object<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: current_board [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Returns the board in use in the current project.<br/>
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite<br/>
		/// installation area, stores information regarding board attributes. The board provides a<br/>
		/// representation of the overall system that the Xilinx device is a part of, and can help define key<br/>
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.<br/>
		/// You can create custom boards by defining a custom Board Interface file, as described in the<br/>
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).<br/>
		/// The board can be specified:<br/>
		/// • When the project is created by selecting Boards from the Default Part dialog box.<br/>
		/// • By setting the BOARD_PART property on the current project as shown in the example.<br/>
		/// • By selecting the Project Device in the Settings dialog box in an open project in the Vivado IDE.<br/>
		/// Refer to the Vivado Design Suite User Guide: System-Level Design Entry (UG895) for information on<br/>
		/// creating projects, and on configuring project settings.<br/>
		/// IMPORTANT! When you specify the board with the set_property command, the target part is also<br/>
		/// changed to match the part required by the specified BOARD property.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The current_board command returns the Vendor:Board_Name:File_Version attributes<br/>
		/// of the current board, as defined in the BOARD_PART property. The command returns nothing<br/>
		/// when the project targets a Xilinx FPGA instead of a TRD and board, or when the BOARD_PART<br/>
		/// property has not been defined. The command returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 379<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>current board object</returns>
		public VivadoTCL current_board(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: current_board [-quiet] [-verbose]
			this.Entry(_builder.current_board(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get the current board_part object<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: current_board_part [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Return the Xilinx device used in the current project or design.<br/>
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite<br/>
		/// installation area, stores information regarding board attributes. The board provides a<br/>
		/// representation of the overall system that the Xilinx device is a part of, and can help define key<br/>
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.<br/>
		/// You can create custom boards by defining a custom Board Interface file, as described in the<br/>
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).<br/>
		/// The board part provides a representation of the Xilinx device in the context of the board-level<br/>
		/// system, and is represented by the part0 component in the Board Interface file.<br/>
		/// The board can be specified:<br/>
		/// • When the project is created by selecting Boards from the Default Part dialog box.<br/>
		/// • By setting the BOARD_PART property on the current project as shown in the example.<br/>
		/// • By selecting the Project Device in the Settings dialog box in an open project in the Vivado IDE.<br/>
		/// Refer to the Vivado Design Suite User Guide: System-Level Design Entry (UG895) for information on<br/>
		/// creating projects, and on configuring project settings.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// IMPORTANT! When you specify the board with the set_property command, the target part is also<br/>
		/// changed to match the part required by the specified BOARD_PART property.<br/>
		/// The current_board_part command returns the NAME property of the current board part.<br/>
		/// The command returns a warning when the project targets a Xilinx FPGA instead of a board, or<br/>
		/// when the BOARD_PART property has not been defined. The command returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 382<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>current board_part object</returns>
		public VivadoTCL current_board_part(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: current_board_part [-quiet] [-verbose]
			this.Entry(_builder.current_board_part(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Set or get the current design.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: current_design [-quiet] [-verbose] [&lt;design&gt;]
		/// <br/>
		/// <para>
		/// Defines the current design or returns the name of the current design in the active project.<br/>
		/// The current design and current instance are the target of most Tcl commands, design edits and<br/>
		/// constraint changes made in the tool. The current instance can be defined using the<br/>
		/// current_instance command.<br/>
		/// You can use the get_designs command to get a list of open designs in the active project, and<br/>
		/// use the get_projects command to get a list of open projects.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example sets the design rtl_1 as the current design:<br/>
		/// current_design rtl_1<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 385<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="design">(Optional) Name of current design to be set</param>
		/// <returns>design object</returns>
		public VivadoTCL current_design(bool? quiet = null, bool? verbose = null, String design = null)
		{
			// TCL Syntax: current_design [-quiet] [-verbose] [<design>]
			this.Entry(_builder.current_design(quiet, verbose, design));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get the current fileset (any type) or set the current fileset (applicable to simulation filesets only)<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: current_fileset [-constrset] [-simset] [-quiet] [-verbose] [&lt;fileset&gt;...]
		/// <br/>
		/// <para>
		/// Get the active source, constraint, or simulation fileset within the current project.<br/>
		/// When used without any options, current_fileset sets and returns the sources_1 set as the active<br/>
		/// fileset.<br/>
		/// This command can also be used to set the current simulation fileset.<br/>
		/// Note: Use set_property CONSTRSET to define the active constraint set on a synthesis or<br/>
		/// implementation run.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the name of the currently active constraint fileset:<br/>
		/// current_fileset -constrset<br/>
		/// The following example sets sim_2 as the active simulation set:<br/>
		/// current_fileset -simset sim_2<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 387<br/>
		/// </para>
		/// </summary>
		/// <param name="constrset">(Optional) Get the current constraints fileset</param>
		/// <param name="simset">(Optional) Get the current active simulation fileset</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="fileset">(Optional) Specify the simulation fileset to set as current (active); optional</param>
		/// <returns>current fileset (the current srcset by default)</returns>
		public VivadoTCL current_fileset(bool? constrset = null, bool? simset = null, bool? quiet = null, bool? verbose = null, TCLParameterList fileset = null)
		{
			// TCL Syntax: current_fileset [-constrset] [-simset] [-quiet] [-verbose] [<fileset>...]
			this.Entry(_builder.current_fileset(constrset, simset, quiet, verbose, fileset));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get index of the selected subprogram frame (default, top i.e. most recent subprogram call) in the<br/>
		/// call-stack of the HDL process scope (current_scope). Sets current stack frame for the subprogram<br/>
		/// call-stack of the current_scope.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: current_frame [-up] [-down] [-set &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Returns the index of the frame which is selected as the "current" frame in sub-program call-stack<br/>
		/// of the current HDL process-scope, or current_scope. By default, the most recently called<br/>
		/// subprogram-frame is the current frame, i.e. with frame-index "0" (zero) and marked with (-&gt;).<br/>
		/// Switches like -up,-down, and -set let you select other frames in the call-stack, rather than the<br/>
		/// current frame.<br/>
		/// IMPORTANT! The current_frame strictly follows the current_scope . If current_scope is<br/>
		/// not an HDL process scope waiting inside a sub-program, the current_frame command reports that<br/>
		/// the current process does not have an associated sub-program stack.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// Example design:<br/>
		/// module top;<br/>
		/// int i;<br/>
		/// function void f(input int in1);<br/>
		/// automatic int a;<br/>
		/// a = in1 + 7;<br/>
		/// $display($time, " in f :: a %d in1 %d ", a, in1);<br/>
		/// endfunction<br/>
		/// task automatic t(input int in2);<br/>
		/// int b;<br/>
		/// b = in2 + 10;<br/>
		/// $display($time, " in t :: in2 %d b %d ", in2, b);<br/>
		/// #5;<br/>
		/// f(b); // Case C<br/>
		/// $display($time, " Back in t : after wait and f(%d) ", b);<br/>
		/// endtask<br/>
		/// initial begin // "/top/Initial18_0"<br/>
		/// $display($time, " in initial 1 ");<br/>
		/// i = 200;<br/>
		/// t(i); // Case B<br/>
		/// $display($time, " Back in initial 1 after t(%d) ", i);<br/>
		/// end<br/>
		/// initial begin // "/top/Initial25_1"<br/>
		/// $display($time, " in initial 2 ");<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// #2;<br/>
		/// f(50); // Case A<br/>
		/// $display($time, " Back in initial 2 after f(50) ");<br/>
		/// end<br/>
		/// endmodule<br/>
		/// When simulation is stopped inside function "f" for its call at 'Case C', function "f" is called from<br/>
		/// task "t" at 'Case C' which itself is called from process "/top/Initial18_0" at 'Case B'<br/>
		/// &gt; current_scope<br/>
		/// /top/Initial18_0<br/>
		/// &gt; report_frames<br/>
		/// -&gt; 0 : f<br/>
		/// 1 : t<br/>
		/// 2: /top/Initial18_0<br/>
		/// 1. &gt; current_frame<br/>
		/// 0<br/>
		/// 2. &gt; current_frame -up<br/>
		/// 1<br/>
		/// &gt; report_frames<br/>
		/// 0 : f<br/>
		/// -&gt; 1 : t<br/>
		/// 2 : /top/Initial18_0<br/>
		/// 3. &gt; current_frame -down<br/>
		/// 0<br/>
		/// &gt; report_frames<br/>
		/// -&gt; 0 : f<br/>
		/// 1 : t<br/>
		/// 2: /top/Initial18_0<br/>
		/// 4. &gt; current_frame -set 1<br/>
		/// 1<br/>
		/// &gt; report_frames<br/>
		/// 0 : f<br/>
		/// -&gt; 1 : t<br/>
		/// 2 : /top/Initial18_0<br/>
		/// 5. &gt; current_frame -verbose<br/>
		/// -&gt; 0 : f @top.v:6<br/>
		/// 1 : t @top.v:15<br/>
		/// 2: /top/Initial18_0 @top.v:21<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 389<br/>
		/// </para>
		/// </summary>
		/// <param name="up">
		/// <para>
		/// (Optional)<br/>
		/// Selects stack frame of the caller subprogram/process as the<br/>
		/// current frame.<br/>
		/// </para>
		/// </param>
		/// <param name="down">(Optional) Selects stack frame of the callee subprogram as the current frame.</param>
		/// <param name="set">
		/// <para>
		/// (Optional)<br/>
		/// Selects stack frame with given index as the current frame of<br/>
		/// the call stack of current HDL process scope. Default: 0<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Returns index of the selected subprogram frame in the call stack of the current_scope.</returns>
		public VivadoTCL current_frame(bool? up = null, bool? down = null, String set = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: current_frame [-up] [-down] [-set <arg>] [-quiet] [-verbose]
			this.Entry(_builder.current_frame(up, down, set, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get or set the current hardware cfgmem<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: current_hw_cfgmem [-hw_device &lt;args&gt;] [-quiet] [-verbose] [&lt;hw_cfgmem&gt;]
		/// <br/>
		/// <para>
		/// Set or return the current hardware cfgmem object.<br/>
		/// The process whereby the design specific data is loaded or programmed into the Xilinx® FPGA is<br/>
		/// called configuration. The create_hw_cfgmem command defines a flash memory device used<br/>
		/// for configuring and booting the FPGA device.<br/>
		/// When a new hw_cfgmem object is created, it becomes the current hw_cfgmem object. You can<br/>
		/// use the current_hw_cfgmem to return the current hw_cfgmem object, or you can specify a<br/>
		/// hw_cfgmem object, as returned by get_hw_cfgmems, to change the current object.<br/>
		/// After the hw_cfgmem object is created, and associated with the hw_device, the configuration<br/>
		/// memory can be programmed with the bitstream and other data from a memory configuration file<br/>
		/// created with the write_cfgmem command.<br/>
		/// The hw_cfgmem object is programmed using the program_hw_cfgmem command.<br/>
		/// This command returns the current hardware cfgmem as an object, or returns an error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 392<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_device">(Optional) list of hardware devices</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_cfgmem">(Optional) list of hardware cfgmems Default: current hardware cfgmem</param>
		/// <returns>hardware cfgmem</returns>
		public VivadoTCL current_hw_cfgmem(TCLParameterList hw_device = null, bool? quiet = null, bool? verbose = null, String hw_cfgmem = null)
		{
			// TCL Syntax: current_hw_cfgmem [-hw_device <args>] [-quiet] [-verbose] [<hw_cfgmem>]
			this.Entry(_builder.current_hw_cfgmem(hw_device, quiet, verbose, hw_cfgmem));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get or set the current hardware device<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: current_hw_device [-quiet] [-verbose] [&lt;hw_device&gt;]
		/// <br/>
		/// <para>
		/// Set or return the current Xilinx FPGA targeted by the Hardware Manager in the Vivado Design<br/>
		/// Suite for programming and debug.<br/>
		/// The hardware target is a system board containing a JTAG chain of one or more Xilinx devices that<br/>
		/// you can program with a bitstream file, or use to debug your design. Connections between<br/>
		/// hardware targets on the system board and the Vivado Design Suite are managed by the<br/>
		/// hw_server application, and the connect_hw_server command. Refer to Vivado Design Suite<br/>
		/// User Guide: Programming and Debugging (UG908) for a list of supported JTAG download cables<br/>
		/// and devices.<br/>
		/// Each hardware target can have one or more Xilinx devices to program, or to use for debugging<br/>
		/// purposes. The current device is specified or returned by the current_hw_device command.<br/>
		/// To access a Xilinx FPGA through the Hardware Manager, you must use the following Tcl<br/>
		/// command sequence:<br/>
		/// 1. open_hw - Opens the Hardware Manager in the Vivado Design Suite.<br/>
		/// 2. connect_hw_server - Makes a connection to a local or remote Xilinx hardware server<br/>
		/// application.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// 3. current_hw_target - Defines the hardware target of the connected server.<br/>
		/// 4. open_hw_target - Opens a connection to the hardware target.<br/>
		/// 5. current_hw_device - Specifies the Xilinx FPGA to use for programming and debugging.<br/>
		/// After connecting to the appropriate hardware device, you can program the device with a<br/>
		/// bitstream file using the program_hw_device command, and debug the device using any of a<br/>
		/// number of Hardware Manager Tcl commands. To interactively debug the device open the<br/>
		/// Hardware Manager in the Vivado Design Suite IDE.<br/>
		/// IMPORTANT! You can use the current_hw_server , current_hw_target , and<br/>
		/// current_hw_device commands to set the hardware for programming and debugging the design. You<br/>
		/// should exercise care when using these commands to insure that the current server, target, and device are in<br/>
		/// sync. The current device should be found on the current target, which should be found on the current<br/>
		/// server.<br/>
		/// This command returns the current hardware device as an object, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 394<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_device">(Optional) hardware device to set as current; optional</param>
		/// <returns>hardware device</returns>
		public VivadoTCL current_hw_device(bool? quiet = null, bool? verbose = null, String hw_device = null)
		{
			// TCL Syntax: current_hw_device [-quiet] [-verbose] [<hw_device>]
			this.Entry(_builder.current_hw_device(quiet, verbose, hw_device));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get or set the current hardware ILA<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: current_hw_ila [-quiet] [-verbose] [&lt;hw_ila&gt;]
		/// <br/>
		/// <para>
		/// Set or return the current hardware ILA debug core targeted by the Hardware Manager in the<br/>
		/// Vivado Design Suite for programming and debug.<br/>
		/// The Integrated Logic Analyzer (ILA) debug core lets you perform in-system debug of<br/>
		/// implemented designs, or design bitstreams, on a programmed Xilinx FPGA. The ILA core includes<br/>
		/// many advanced features of modern logic analyzers, including boolean trigger equations, and edge<br/>
		/// transition triggers. You can use the ILA core to probe specific signals of the design, to trigger on<br/>
		/// programmed hardware events, and capture data from the Xilinx FPGA in real-time. Refer to<br/>
		/// LogiCORE IP Integrated Logic Analyzer (PG172) for details of the ILA core.<br/>
		/// ILA debug cores can be added to a design instantiating an ILA core from the IP catalog into the<br/>
		/// RTL design, or using the create_debug_core command to add the ILA core to the synthesized<br/>
		/// netlist. Refer to Vivado Design Suite User Guide: Programming and Debugging (UG908) for more<br/>
		/// information on adding ILA debug cores to the design.<br/>
		/// After generating a bitstream from the design, and programming the device with the<br/>
		/// program_hw_devices command, the ILA debug cores in the design are accessible from the<br/>
		/// Hardware Manager using the get_hw_ilas command. The debug probes assigned to the ILA<br/>
		/// debug cores in the design can be returned with the get_hw_probes command.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This command returns the current hardware ILA core as an object, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 397<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_ila">(Optional) hardware ILA</param>
		/// <returns>hardware ILA</returns>
		public VivadoTCL current_hw_ila(bool? quiet = null, bool? verbose = null, String hw_ila = null)
		{
			// TCL Syntax: current_hw_ila [-quiet] [-verbose] [<hw_ila>]
			this.Entry(_builder.current_hw_ila(quiet, verbose, hw_ila));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get or set the current hardware ILA data<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: current_hw_ila_data [-quiet] [-verbose] [&lt;hw_ila_data&gt;]
		/// <br/>
		/// <para>
		/// Set or return the current ILA debug core data object.<br/>
		/// The ILA data object is created in the Vivado logic analyzer using the upload_hw_ila_data<br/>
		/// command, or the read_hw_ila_data command. By default, the current hw_ila_data object is<br/>
		/// the latest one created by the Vivado logic analyzer. The current_hw_ila_data command can<br/>
		/// be used to change that object.<br/>
		/// The ILA debug core captures sample data in real-time as the hardware device runs, based on the<br/>
		/// event triggers or capture conditions defined on the hw_ila object. The hw_ila object triggers on<br/>
		/// the hw_device are armed by the run_hw_ila command.<br/>
		/// The ILA data object can be displayed in the waveform window of the Vivado tools logic analyzer<br/>
		/// using the display_hw_ila_data command. You can also write the ILA data to disk with the<br/>
		/// write_hw_ila_data command to save the ILA debug information for later user and analysis.<br/>
		/// This command returns the captured hardware ILA debug core data as an object, or returns an<br/>
		/// error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 399<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_ila_data">(Optional) hardware ILA data</param>
		/// <returns>hardware ILA data</returns>
		public VivadoTCL current_hw_ila_data(bool? quiet = null, bool? verbose = null, String hw_ila_data = null)
		{
			// TCL Syntax: current_hw_ila_data [-quiet] [-verbose] [<hw_ila_data>]
			this.Entry(_builder.current_hw_ila_data(quiet, verbose, hw_ila_data));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get or set the current hardware server<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: current_hw_server [-quiet] [-verbose] [&lt;hw_server&gt;]
		/// <br/>
		/// <para>
		/// Defines the current hardware server from the list of hardware servers that are connected to the<br/>
		/// Vivado Design Suite, or returns the currently connected hardware server object.<br/>
		/// Hardware servers are instances of the Xilinx hardware server (hw_server) application running<br/>
		/// remotely, or on the local machine. The hardware server manages connections to a hardware<br/>
		/// target, such as a hardware board containing a JTAG chain of one or more Xilinx devices to be<br/>
		/// used for programming and debugging your FPGA design.<br/>
		/// Hardware servers are connected to the Vivado Design Suite with the connect_hw_server<br/>
		/// command. The current hardware server, and the current hardware target and device are the<br/>
		/// focus of most Hardware Manager Tcl commands. The current target and device can be defined<br/>
		/// using the current_hw_target and current_hw_device commands.<br/>
		/// Note: There is usually a current hw_server defined, either the last connected hardware server, or one you<br/>
		/// have defined with this command. However, if you disconnect the current hardware server, you will need to<br/>
		/// define a new current hw_server object.<br/>
		/// You can get a list of connected hardware servers using the get_hw_servers command. You<br/>
		/// can get a list of available hardware targets and devices using the get_hw_targets and<br/>
		/// get_hw_devices commands respectively.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This command returns a hw_server object. If the &lt;hw_server&gt; is specified as part of the<br/>
		/// current_hw_server command, the specified server is defined as the current hardware server<br/>
		/// and that object is returned. If no server is specified, the current_hw_server command<br/>
		/// returns the current hardware server object.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 401<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_server">(Optional) hardware server</param>
		/// <returns>hardware server</returns>
		public VivadoTCL current_hw_server(bool? quiet = null, bool? verbose = null, String hw_server = null)
		{
			// TCL Syntax: current_hw_server [-quiet] [-verbose] [<hw_server>]
			this.Entry(_builder.current_hw_server(quiet, verbose, hw_server));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get or set the current hardware target<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: current_hw_target [-quiet] [-verbose] [&lt;hw_target&gt;]
		/// <br/>
		/// <para>
		/// After opening the Hardware Manager in the Vivado Design Suite, and connecting to the Xilinx<br/>
		/// hardware server (hw_server) using the connect_hw_server command, you will need to set<br/>
		/// the hardware target. This command sets or returns the current hardware target.<br/>
		/// The hardware target is a system board containing a JTAG chain of one or more Xilinx devices that<br/>
		/// you can program with a bitstream file, or use to debug your design. Connections between<br/>
		/// hardware targets on the system board and the Vivado Design Suite are managed by the<br/>
		/// hw_server object. Refer to Vivado Design Suite User Guide: Programming and Debugging (UG908)<br/>
		/// for a list of supported JTAG download cables and devices.<br/>
		/// The available hardware targets are defined when the Vivado tools Hardware Manager is<br/>
		/// connected to a hw_server. You can return a list of the available hardware targets using the<br/>
		/// get_hw_targets command, and define the current hardware target using the<br/>
		/// current_hw_target command.<br/>
		/// If the &lt;hw_target&gt; is specified as part of the current_hw_target command, the specified<br/>
		/// target is defined as the current hardware target and that object is returned. If no hardware target<br/>
		/// is specified, the current_hw_target command returns the current hardware target object.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Each hardware target can have one or more Xilinx devices to program, or to use for debugging<br/>
		/// purposes. The current device is specified or returned by the current_hw_device command.<br/>
		/// After specifying the current hardware target, you can open the connection through the hardware<br/>
		/// target, to the Xilinx device using the open _hw_target command.<br/>
		/// IMPORTANT! You can use the current_hw_server , current_hw_target , and<br/>
		/// current_hw_device commands to set the hardware for programming and debugging the design. You<br/>
		/// should exercise care when using these commands to insure that the current server, target, and device are in<br/>
		/// sync. The current device should be found on the current target, which should be found on the current<br/>
		/// server.<br/>
		/// This command returns the current hardware target as an object, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 403<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_target">(Optional) hardware target</param>
		/// <returns>hardware target</returns>
		public VivadoTCL current_hw_target(bool? quiet = null, bool? verbose = null, String hw_target = null)
		{
			// TCL Syntax: current_hw_target [-quiet] [-verbose] [<hw_target>]
			this.Entry(_builder.current_hw_target(quiet, verbose, hw_target));
			return this;
		}
		/// <summary>
		/// <para>
		/// Set or get the current instance<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: current_instance [-quiet] [-verbose] [&lt;instance&gt;]
		/// <br/>
		/// <para>
		/// Set the current instance in the design hierarchy to the specified instance cell or to the top of the<br/>
		/// current design. By default, current_instance points to the top module of the<br/>
		/// current_design, which is not an instantiated cell object. You can also set<br/>
		/// current_instance to reference an instantiated hierarchical cell in the design.<br/>
		/// IMPORTANT! Since the top module is not an instantiated object, current_instance returns an<br/>
		/// empty string rather than a design object, when set to the top-level of the current design.<br/>
		/// The current design and current instance are the target of most of the commands and design<br/>
		/// changes you will make. The current design can be defined using the current_design<br/>
		/// command.<br/>
		/// You must specify the &lt;instance&gt; name relative to the currently defined instance, and use the<br/>
		/// established hierarchy separator to define instance paths. You can determine the current hierarchy<br/>
		/// separator with the get_hierarchy_separator command.<br/>
		/// Use '..' to traverse up the hierarchical instance path when specifying the current instance.<br/>
		/// This command returns the name of the design object of the current_instance, or returns nothing<br/>
		/// when set to the top of current design.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example sets the current instance to the top module of the current design:<br/>
		/// current_instance<br/>
		/// INFO: [Vivado 12-618] Current instance is the top level of design<br/>
		/// 'netlist_1'.<br/>
		/// In this example you have selected an object in the Vivado IDE, and you want to set that selected<br/>
		/// object as the current instance:<br/>
		/// current_instance [lindex [get_selected_objects] 0]<br/>
		/// Note: get_selected_objects returns a list, even of one object, so you must use lindex to specify an<br/>
		/// object from that list.<br/>
		/// The following example first sets the hierarchy separator character, and then sets the current<br/>
		/// instance relative to the presently defined current instance:<br/>
		/// set_hierarchy_separator |<br/>
		/// current_instance ..|cpu_iwb_dat_o|buffer_fifo<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example returns the name of the presently defined current instance:<br/>
		/// current_instance .<br/>
		/// cpuEngine|cpu_iwb_dat_o|buffer_fifo<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 406<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="instance">(Optional) Name of instance</param>
		/// <returns>instance name</returns>
		public VivadoTCL current_instance(bool? quiet = null, bool? verbose = null, String instance = null)
		{
			// TCL Syntax: current_instance [-quiet] [-verbose] [<instance>]
			this.Entry(_builder.current_instance(quiet, verbose, instance));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of PartitionDefs<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: current_pr_configuration [-quiet] [-verbose] [&lt;config&gt;...]
		/// <br/>
		/// <para>
		/// Get or set the current PR configuration.<br/>
		/// In the Partial Reconfiguration (PR) design flow, the PR configuration lets you specify a<br/>
		/// reconfigurable module (RM) to assign to a specific instance of a Partition Definition<br/>
		/// (partitionDef). This flow lets you create unique configurations of the design based on the<br/>
		/// combination of the core design and one or more RMs. The PR design flow requires the<br/>
		/// implementation of each PR configuration, resulting in partial bitstreams for the RMs, but<br/>
		/// complete bitstreams for each integrated configuration. Refer to the Vivado Design Suite User<br/>
		/// Guide: Dynamic Function eXchange (UG909) for more information.<br/>
		/// The current_pr_configuration either returns the PR configuration that is the current or active<br/>
		/// configfuration in the design, or lets you specify a PR configuration to make active.<br/>
		/// This command returns the name of the current PR configuration, or returns an error if the<br/>
		/// command fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 409<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="config">(Optional) Specify the PR configuration to be set as current (active); optional</param>
		/// <returns>list of PartitionDef objects</returns>
		public VivadoTCL current_pr_configuration(bool? quiet = null, bool? verbose = null, TCLParameterList config = null)
		{
			// TCL Syntax: current_pr_configuration [-quiet] [-verbose] [<config>...]
			this.Entry(_builder.current_pr_configuration(quiet, verbose, config));
			return this;
		}
		/// <summary>
		/// <para>
		/// Set or get current project<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: current_project [-quiet] [-verbose] [&lt;project&gt;]
		/// <br/>
		/// <para>
		/// Specifies the current project or returns the current project when no project is specified.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example sets project_2 as the current project:<br/>
		/// current_project project_2<br/>
		/// This command makes the current project the focus of all the tool commands. In the GUI mode,<br/>
		/// the current project is defined automatically when switching the GUI between projects.<br/>
		/// The following example returns the name of the current project in the tool:<br/>
		/// current_project<br/>
		/// Note: The returned value is the name of the project and not the name or path of the project file.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 411<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="project">(Optional) Project to set as current</param>
		/// <returns>current or newly set project object</returns>
		public VivadoTCL current_project(bool? quiet = null, bool? verbose = null, String project = null)
		{
			// TCL Syntax: current_project [-quiet] [-verbose] [<project>]
			this.Entry(_builder.current_project(quiet, verbose, project));
			return this;
		}
		/// <summary>
		/// <para>
		/// Set or get the current run<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: current_run [-synthesis] [-implementation] [-quiet] [-verbose] [&lt;run&gt;]
		/// <br/>
		/// <para>
		/// Defines the current synthesis or implementation run, or returns the name of the current run. The<br/>
		/// current run is the one automatically selected when the Synthesize or Implement commands are<br/>
		/// launched.<br/>
		/// You can use the get_runs command to determine the list of defined runs in the current design.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example defines the synth_1 run as the current_run:<br/>
		/// current_run synth_1<br/>
		/// Note: The -synthesis and -implementation arguments are not required because the name allows the<br/>
		/// tool to identify the specific run of interest.<br/>
		/// The following command returns the name of the current implementation run:<br/>
		/// current_run -implementation -quiet<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 413<br/>
		/// </para>
		/// </summary>
		/// <param name="synthesis">(Optional) Set or get the current synthesis run</param>
		/// <param name="implementation">
		/// <para>
		/// (Optional)<br/>
		/// Set or get the current implementation run (default unless '-<br/>
		/// synthesis' is specified)<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="run">(Optional) Run to set as current; optional</param>
		/// <returns>run object</returns>
		public VivadoTCL current_run(bool? synthesis = null, bool? implementation = null, bool? quiet = null, bool? verbose = null, String run = null)
		{
			// TCL Syntax: current_run [-synthesis] [-implementation] [-quiet] [-verbose] [<run>]
			this.Entry(_builder.current_run(synthesis, implementation, quiet, verbose, run));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get the current scope or set the current scope<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: current_scope [-quiet] [-verbose] [&lt;hdl_scope&gt;]
		/// <br/>
		/// <para>
		/// Return the current scope in the current simulation, or set the current scope to the specified HDL<br/>
		/// scope.<br/>
		/// The current_scope command returns the name of the current simulation scope.<br/>
		/// If &lt;hdl_scope&gt; is supplied then, the current scope is set to the specified scope.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example sets the current scope to the specified HDL scope:<br/>
		/// current_scope /testbench/dut<br/>
		/// This example returns the current scope name to console:<br/>
		/// current_scope<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 415<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hdl_scope">(Optional) Default: NULL</param>
		/// <returns>The current scope</returns>
		public VivadoTCL current_scope(bool? quiet = null, bool? verbose = null, String hdl_scope = null)
		{
			// TCL Syntax: current_scope [-quiet] [-verbose] [<hdl_scope>]
			this.Entry(_builder.current_scope(quiet, verbose, hdl_scope));
			return this;
		}
		/// <summary>
		/// <para>
		/// Set the current simulation object or get the current simulation object<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: current_sim [-quiet] [-verbose] [&lt;simulationObject&gt;]
		/// <br/>
		/// <para>
		/// Get or set the current Vivado simulation object.<br/>
		/// This command can be used after the Vivado simulator has been launched to return or set the<br/>
		/// current simulation object.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example sets the curent simulation:<br/>
		/// current_sim simulation_2<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 417<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="simulationObject">
		/// <para>
		/// (Optional)<br/>
		/// Simulation Object to set the current simulation object to<br/>
		/// Default: NULL<br/>
		/// </para>
		/// </param>
		/// <returns>Returns the current simulation object</returns>
		public VivadoTCL current_sim(bool? quiet = null, bool? verbose = null, String simulationObject = null)
		{
			// TCL Syntax: current_sim [-quiet] [-verbose] [<simulationObject>]
			this.Entry(_builder.current_sim(quiet, verbose, simulationObject));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report current simulation time<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: current_time [-s] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Returns the current simulation time to the Tcl Console or Vivado Design Suite Tcl shell.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the current time of the current simulation:<br/>
		/// current_time<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 419<br/>
		/// </para>
		/// </summary>
		/// <param name="s">(Optional) Short -- suppress the space between numeric part and unit part</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Prints the current simulation time on the console in textual format</returns>
		public VivadoTCL current_time(bool? s = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: current_time [-s] [-quiet] [-verbose]
			this.Entry(_builder.current_time(s, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Return the current VCD object or make VCDObject the current VCD object<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: current_vcd [-quiet] [-verbose] [&lt;VCDObject&gt;]
		/// <br/>
		/// <para>
		/// Defines the current Value Change Dump (VCD) object, or returns the name of the current VCD<br/>
		/// object in the current simulation.<br/>
		/// A VCD file must be opened and assigned to a VCD object using the open_vcd command in<br/>
		/// order for there to be a current VCD object.<br/>
		/// This command returns the current VCD object.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example sets the specified VCD object as current:<br/>
		/// current_vcd vcd2<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 421<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="VCDObject">(Optional) VCDObject Default: NULL</param>
		public VivadoTCL current_vcd(bool? quiet = null, bool? verbose = null, String VCDObject = null)
		{
			// TCL Syntax: current_vcd [-quiet] [-verbose] [<VCDObject>]
			this.Entry(_builder.current_vcd(quiet, verbose, VCDObject));
			return this;
		}
		/// <summary>
		/// <para>
		/// Returns the vivado prefernces object.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: current_vivado_preferences [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 423<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL current_vivado_preferences(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: current_vivado_preferences [-quiet] [-verbose]
			this.Entry(_builder.current_vivado_preferences(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Gets the current WCFG object and sets it to the specified WCFG object if given<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: current_wave_config [-quiet] [-verbose] [&lt;wcfgObj&gt;]
		/// <br/>
		/// <para>
		/// Set or get the current wave configuration object for the current simulation.<br/>
		/// In the Vivado® simulator GUI, you can work with a waveform to analyze your design and debug<br/>
		/// your code. A wave configuration displays with top-level HDL objects, and can be further<br/>
		/// populated using commands like add_wave and add_wave_divider.<br/>
		/// This command returns the name of the current wave configuration object.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets the testbench wave config object and makes it the current wave<br/>
		/// configuration in the simulation:<br/>
		/// current_wave_config [get_wave_config testbench]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 424<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="wcfgObj">
		/// <para>
		/// (Optional)<br/>
		/// Sets the current WCFG object to the given value of wcfgObj.<br/>
		/// Defaults to current<br/>
		/// </para>
		/// </param>
		/// <returns>Returns the new or current wave configuration object</returns>
		public VivadoTCL current_wave_config(bool? quiet = null, bool? verbose = null, String wcfgObj = null)
		{
			// TCL Syntax: current_wave_config [-quiet] [-verbose] [<wcfgObj>]
			this.Entry(_builder.current_wave_config(quiet, verbose, wcfgObj));
			return this;
		}
		/// <summary>
		/// <para>
		/// Decrypt an AES-GCM encrypted bitstream<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: decrypt_bitstream -encrypted_file &lt;arg&gt; -keyfile &lt;arg&gt; [-force] [-quiet] [-verbose] &lt;file&gt;
		/// <br/>
		/// <para>
		/// During implementation of secure encrypted UltraScale architecture designs, bitstream-level<br/>
		/// verification must be performed on the final bitstream against the "golden" bitstream of the Xilinx<br/>
		/// tested Security Monitor (SecMon) IP.<br/>
		/// The decrypt_bitstream command takes an AES-GCM encrypted bitstream file (.bit<br/>
		/// or .rbt) from an implemented design that incorporates the SecMon IP, and an encryption key<br/>
		/// file (.nky or .nkz), and returns an unencrypted bitstream file. The decrypted bitstream can then<br/>
		/// be used to complete the bitstream verification process.<br/>
		/// This command returns the requested file if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 426<br/>
		/// </para>
		/// </summary>
		/// <param name="encrypted_file">(Required) Input AES-GCM encrypted bitstream (.bit or .rbt)</param>
		/// <param name="keyfile">(Required) File containing encryption keys</param>
		/// <param name="file">(Required) Output decrypted bitstream (.bit, .bin or .rbt)</param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL decrypt_bitstream(String encrypted_file, String keyfile, String file, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: decrypt_bitstream -encrypted_file <arg> -keyfile <arg> [-force] [-quiet] [-verbose] <file>
			this.Entry(_builder.decrypt_bitstream(encrypted_file, keyfile, file, force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Delete specified objects.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: delete_bd_objs [-quiet] [-verbose] &lt;objects&gt;...
		/// <br/>
		/// <para>
		/// Delete specified objects from the current IP integrator subsystem design.<br/>
		/// Objects must be passed directly to the delete_bd_objs command, and not simply referenced<br/>
		/// by the object name. Pins are passed to the command by get_bd_pins, for instance, rather than<br/>
		/// by pin name.<br/>
		/// This command returns nothing if it is successful, and returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 428<br/>
		/// </para>
		/// </summary>
		/// <param name="objects">(Required) The objects to be deleted</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Pass if successful in deleting objects</returns>
		public VivadoTCL delete_bd_objs(TCLParameterList objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_bd_objs [-quiet] [-verbose] <objects>...
			this.Entry(_builder.delete_bd_objs(objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Clear a set of clock networks results from memory<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: delete_clock_networks_results [-quiet] [-verbose] &lt;name&gt;
		/// <br/>
		/// <para>
		/// Clear the results of the specified report_clock_networks report from the named result set.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example clears the specified results set from memory:<br/>
		/// delete_clock_network_results ClkNets<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 430<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name for the set of results to clear</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL delete_clock_networks_results(String name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_clock_networks_results [-quiet] [-verbose] <name>
			this.Entry(_builder.delete_clock_networks_results(name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Deletes the gadgets from project summary dashboard<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: delete_dashboard_gadgets [-quiet] [-verbose] &lt;gadgets&gt;
		/// <br/>
		/// <para>
		/// This command removes the gadget from the Project Summary dashboard, and removes it from<br/>
		/// the project.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 432<br/>
		/// </para>
		/// </summary>
		/// <param name="gadgets">(Required) Gadgets to delete</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL delete_dashboard_gadgets(String gadgets, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_dashboard_gadgets [-quiet] [-verbose] <gadgets>
			this.Entry(_builder.delete_dashboard_gadgets(gadgets, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Delete a debug core<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: delete_debug_core [-quiet] [-verbose] &lt;cores&gt;...
		/// <br/>
		/// <para>
		/// Removes Vivado Lab Edition debug cores from the current project that were added by the<br/>
		/// create_debug_core command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following command deletes the myCore debug core from the current project:<br/>
		/// delete_debug_core myCore<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following command deletes all debug cores from the current project:<br/>
		/// delete_debug_core [get_debug_cores]<br/>
		/// Note: The get_debug_cores command returns all debug cores as a default.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 434<br/>
		/// </para>
		/// </summary>
		/// <param name="cores">(Required) Debug cores to delete</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL delete_debug_core(TCLParameterList cores, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_debug_core [-quiet] [-verbose] <cores>...
			this.Entry(_builder.delete_debug_core(cores, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Delete debug port<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: delete_debug_port [-quiet] [-verbose] &lt;ports&gt;...
		/// <br/>
		/// <para>
		/// Deletes ports from Vivado Lab Edition debug cores in the current project. You can disconnect a<br/>
		/// signal from a debug port using disconnect_debug_port, or remove the port altogether using<br/>
		/// this command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example deletes the DATA port from myCore:<br/>
		/// delete_debug_port myCore/DATA<br/>
		/// Note: Some ports cannot be deleted because an ILA port requires one CLK port and one TRIG port as a<br/>
		/// minimum.<br/>
		/// The following example deletes the trigger ports (TRIG) from the myCore debug core:<br/>
		/// delete_debug_port [get_debug_ports myCore/TRIG*]<br/>
		/// Note: This example will not delete all TRIG ports from myCore, because an ILA core must have at least one<br/>
		/// TRIG port. The effect of this command will be to delete the TRIG ports starting at TRIG0 and removing all<br/>
		/// of them except the last port.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 436<br/>
		/// </para>
		/// </summary>
		/// <param name="ports">(Required) Debug ports to delete</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL delete_debug_port(TCLParameterList ports, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_debug_port [-quiet] [-verbose] <ports>...
			this.Entry(_builder.delete_debug_port(ports, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Delete one or more user-defined DRC checks.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: delete_drc_check [-quiet] [-verbose] &lt;name&gt;...
		/// <br/>
		/// <para>
		/// Delete a single user-defined design rule check from the current project. User-defined design rule<br/>
		/// checks are created using the create_drc_checks command.<br/>
		/// Note: You cannot delete factory defined rule checks.<br/>
		/// Once it has been deleted there is no way to recover a rule check. The undo command will not<br/>
		/// work.<br/>
		/// Note: This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example deletes the specified design rule check:<br/>
		/// delete_drc_check LJH-1<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 438<br/>
		/// </para>
		/// </summary>
		/// <param name="name">
		/// <para>
		/// (Required)<br/>
		/// Specify the key for the check to remove. This is the typically<br/>
		/// of the form PREFIX-id where PREFIX is a 4-6 letter<br/>
		/// abbreviation and id is a unique identifier. Use<br/>
		/// get_drc_checks to determine the correct name to use. Only<br/>
		/// user-defined DRC checks may be deleted.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL delete_drc_check(TCLParameterList name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_drc_check [-quiet] [-verbose] <name>...
			this.Entry(_builder.delete_drc_check(name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Delete one or more user defined DRC rule deck objects<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: delete_drc_ruledeck [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Delete one or more user-defined drc_ruledeck objects from the current project. The rule deck<br/>
		/// does not have to be empty to be deleted, and once it is deleted there is no way to recover it. The<br/>
		/// undo command will not restore a deleted rule deck.<br/>
		/// Note: You cannot delete factory defined rule decks.<br/>
		/// A rule deck is a collection of design rule checks grouped for convenience, to be run with the<br/>
		/// report_drc command at different stages of the FPGA design flow, such as during I/O planning<br/>
		/// or placement. The tool comes with a set of factory defined rule decks, but you can also create<br/>
		/// new user-defined rule decks with the create_drc_ruledeck command.<br/>
		/// Note: This command returns nothing if successful, or returns an error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example deletes all user-defined rule decks from the current project:<br/>
		/// delete_drc_ruledeck<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 440<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'drc_ruledeck' objects against patterns. Default: *</param>
		/// <returns>drc_ruledeck</returns>
		public VivadoTCL delete_drc_ruledeck(bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: delete_drc_ruledeck [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.delete_drc_ruledeck(regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Delete a fileset<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: delete_fileset [-merge &lt;arg&gt;] [-quiet] [-verbose] &lt;fileset&gt;
		/// <br/>
		/// <para>
		/// Deletes the specified fileset. However, if the fileset cannot be deleted, then no message is<br/>
		/// returned.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example deletes the sim_2 fileset from the current project.<br/>
		/// delete_fileset sim_2<br/>
		/// Note: The fileset and all of its files are removed from the project. The files are not removed from the hard<br/>
		/// drive.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 443<br/>
		/// </para>
		/// </summary>
		/// <param name="fileset">(Required) Fileset to be deleted</param>
		/// <param name="merge">(Optional) Fileset to merge files from the deleted fileset into</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL delete_fileset(String fileset, String merge = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_fileset [-merge <arg>] [-quiet] [-verbose] <fileset>
			this.Entry(_builder.delete_fileset(fileset, merge, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Delete hardware AXI Transaction objects<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: delete_hw_axi_txn [-quiet] [-verbose] &lt;hw_axi_txns&gt;...
		/// <br/>
		/// <para>
		/// This command deletes the named AXI transaction objects, hw_axi_txn, from the specified hw_axi<br/>
		/// objects.<br/>
		/// The create_hw_axi_txn command cannot create an object of the same name as an existing<br/>
		/// object. Use this command to delete any existing objects prior to creating new AXI transaction<br/>
		/// objects.<br/>
		/// This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 445<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_axi_txns">(Required) hardware AXI Transaction object to delete</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL delete_hw_axi_txn(TCLParameterList hw_axi_txns, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_hw_axi_txn [-quiet] [-verbose] <hw_axi_txns>...
			this.Entry(_builder.delete_hw_axi_txn(hw_axi_txns, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Removes the HW Bitstream object from a list of hardware devices.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: delete_hw_bitstream [-of_objects &lt;args&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// This command deletes the hw_bitstream object from the specified hw_device objects.<br/>
		/// This clears the PROGRAM.HW_BITSTREAM and PROGRAM.FILE properties on the hw_device<br/>
		/// objects, and deletes the hw_bitstream object.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 447<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'hw_bitstream' objects of these types: 'hw_device'.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>hardware devices</returns>
		public VivadoTCL delete_hw_bitstream(TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_hw_bitstream [-of_objects <args>] [-quiet] [-verbose]
			this.Entry(_builder.delete_hw_bitstream(of_objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Removes hw_cfgmem object from memory<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: delete_hw_cfgmem [-quiet] [-verbose] &lt;cfgmem&gt;
		/// <br/>
		/// <para>
		/// Removes the specified hw_cfgmem object from the current hw_device.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 449<br/>
		/// </para>
		/// </summary>
		/// <param name="cfgmem">(Required) Valid hw_cfgmem object</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL delete_hw_cfgmem(String cfgmem, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_hw_cfgmem [-quiet] [-verbose] <cfgmem>
			this.Entry(_builder.delete_hw_cfgmem(cfgmem, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Delete hardware probe objects<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: delete_hw_probe [-quiet] [-verbose] &lt;hw_probes&gt;...
		/// <br/>
		/// <para>
		/// Delete a user-defined probe from the current hw_ila. The user-define probe must be created by<br/>
		/// the create_hw_probe command.<br/>
		/// This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example deletes a user-defined hw_probe object on the current ILA core:<br/>
		/// delete_hw_probe [get_hw_probe probeAR]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 451<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_probes">(Required) hardware probe objects to delete</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL delete_hw_probe(TCLParameterList hw_probes, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_hw_probe [-quiet] [-verbose] <hw_probes>...
			this.Entry(_builder.delete_hw_probe(hw_probes, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Delete a hw_target<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: delete_hw_target [-quiet] [-verbose] [&lt;target_object&gt;]
		/// <br/>
		/// <para>
		/// This command deletes a virtual hardware target from the current_hw_server.<br/>
		/// The hw_target object must be a virtual target created by the create_hw_target command, or<br/>
		/// an error will be returned.<br/>
		/// This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example deletes the specified hw_target:<br/>
		/// delete_hw_target [lindex [get_hw_targets] 1]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 453<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="target_object">(Optional) hardware target object to delete Default: current_hw_target</param>
		public VivadoTCL delete_hw_target(bool? quiet = null, bool? verbose = null, String target_object = null)
		{
			// TCL Syntax: delete_hw_target [-quiet] [-verbose] [<target_object>]
			this.Entry(_builder.delete_hw_target(quiet, verbose, target_object));
			return this;
		}
		/// <summary>
		/// <para>
		/// Delete I/O port interfaces from the project<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: delete_interface [-all] [-quiet] [-verbose] &lt;interfaces&gt;...
		/// <br/>
		/// <para>
		/// Deletes an existing interface and optionally deletes all of the associated ports and buses using<br/>
		/// the interface.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example deletes the specified interface and all of its associated ports and buses:<br/>
		/// delete_interface USB0<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 455<br/>
		/// </para>
		/// </summary>
		/// <param name="interfaces">(Required) I/O port interfaces to remove</param>
		/// <param name="all">(Optional) Also remove all of the ports and buses belonging to the interface</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL delete_interface(TCLParameterList interfaces, bool? all = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_interface [-all] [-quiet] [-verbose] <interfaces>...
			this.Entry(_builder.delete_interface(interfaces, all, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Deletes the block fileset and run associated with a given IP.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: delete_ip_run [-force] [-quiet] [-verbose] &lt;objects&gt;
		/// <br/>
		/// <para>
		/// Deletes the out-of-context (OOC) synthesis and implementation runs for the specified IP<br/>
		/// module.<br/>
		/// The contents of the run directory are deleted from the project as well as the run. However, the<br/>
		/// output products created by the run and copied to the IP sources folder, the DCP file and Verilog<br/>
		/// and VHDL structural netlists, are not deleted from the project. You must use the reset_target<br/>
		/// or generate_target command to update the IP output products.<br/>
		/// IMPORTANT! The command requires an IP object as specified by the get_ips or get_files<br/>
		/// command, and will not delete a run based on either the name of the run, or a run object as returned by<br/>
		/// get_runs.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example deletes the OOC synthesis and implementation runs from the specified IP<br/>
		/// module:<br/>
		/// delete_ip_run [get_ips add1]<br/>
		/// Note: In this example, all run results will also be removed from the run directory on the hard drive.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 457<br/>
		/// </para>
		/// </summary>
		/// <param name="objects">
		/// <para>
		/// (Required)<br/>
		/// All of the IP objects (from get_ips or get_files) for which the<br/>
		/// block fileset and run will be deleted.<br/>
		/// </para>
		/// </param>
		/// <param name="force">(Optional) Force the deletion of the block fileset and run.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL delete_ip_run(String objects, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_ip_run [-force] [-quiet] [-verbose] <objects>
			this.Entry(_builder.delete_ip_run(objects, force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Delete a list of macros<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: delete_macros [-quiet] [-verbose] &lt;macros&gt;
		/// <br/>
		/// <para>
		/// Delete one or more macro defined by the create_macro command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example deletes a macro called usbMacro1:<br/>
		/// delete_macros usbMacro1<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 459<br/>
		/// </para>
		/// </summary>
		/// <param name="macros">(Required) Macros to delete</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL delete_macros(String macros, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_macros [-quiet] [-verbose] <macros>
			this.Entry(_builder.delete_macros(macros, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Delete existing PartitionDefs<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: delete_partition_defs [-merge &lt;arg&gt;] [-quiet] [-verbose] &lt;partition_defs&gt;
		/// <br/>
		/// <para>
		/// Delete the specified Partition Definition (partitionDef) objects from the current project.<br/>
		/// This command returns a transcript of the file merge process, returns nothing without file merge,<br/>
		/// or returns an error if the command fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 461<br/>
		/// </para>
		/// </summary>
		/// <param name="partition_defs">(Required) List of PartitionDefs to delete</param>
		/// <param name="merge">
		/// <para>
		/// (Optional)<br/>
		/// Fileset to merge files into from the default RM of deleted<br/>
		/// Partition Def<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL delete_partition_defs(String partition_defs, String merge = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_partition_defs [-merge <arg>] [-quiet] [-verbose] <partition_defs>
			this.Entry(_builder.delete_partition_defs(partition_defs, merge, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Remove Pblock<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: delete_pblocks [-hier] [-quiet] [-verbose] &lt;pblocks&gt;...
		/// <br/>
		/// <para>
		/// Deletes the specified Pblocks from the design. Pblocks are created using the create_pblock<br/>
		/// command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example deletes the specified Pblock as well as any Pblocks nested inside:<br/>
		/// delete_pblocks -hier cpuEngine<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 463<br/>
		/// </para>
		/// </summary>
		/// <param name="pblocks">(Required) Pblocks to delete</param>
		/// <param name="hier">(Optional) Also delete all the children of Pblock</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL delete_pblocks(TCLParameterList pblocks, bool? hier = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_pblocks [-hier] [-quiet] [-verbose] <pblocks>...
			this.Entry(_builder.delete_pblocks(pblocks, hier, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Delete a Power Rail<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: delete_power_rails [-quiet] [-verbose] &lt;power_rail&gt;
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 465<br/>
		/// </para>
		/// </summary>
		/// <param name="power_rail">(Required) power rail to delete</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL delete_power_rails(String power_rail, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_power_rails [-quiet] [-verbose] <power_rail>
			this.Entry(_builder.delete_power_rails(power_rail, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Delete power results that were stored in memory under a given name.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: delete_power_results -name &lt;arg&gt; [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Deletes the power analysis results for the specified results set.<br/>
		/// Note: This command operates silently and does not return direct feedback of its operation<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example runs power analysis, and then clears the results:<br/>
		/// report_power -name my_set<br/>
		/// delete_power_results -name my_set<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 466<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name for the set of results to clear</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL delete_power_results(String name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_power_results -name <arg> [-quiet] [-verbose]
			this.Entry(_builder.delete_power_results(name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Delete existing configurations<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: delete_pr_configurations [-quiet] [-verbose] &lt;configs&gt;
		/// <br/>
		/// <para>
		/// Delete the specified PR configuration from the current project.<br/>
		/// This command returns nothing if successful, or returns an error if the command fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 468<br/>
		/// </para>
		/// </summary>
		/// <param name="configs">(Required) List of Configurations to delete</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL delete_pr_configurations(String configs, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_pr_configurations [-quiet] [-verbose] <configs>
			this.Entry(_builder.delete_pr_configurations(configs, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Deletes a list of available QoR suggestions<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: delete_qor_suggestions [-quiet] [-verbose] [&lt;IDs&gt;]
		/// <br/>
		/// <para>
		/// Removes QoR suggestion objects that are currently in memory. Suggestion objects are generated<br/>
		/// running the report_qor_suggestion command, without specifying -of_objects, and by<br/>
		/// reading an RQS file using the read_qor_suggestions command. You can get QoR objects by<br/>
		/// using the get_qor_suggestions command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following deletes all the suggestion objects in memory:<br/>
		/// delete_qor_suggestions [get_qor_suggestions]<br/>
		/// The following deletes only the Utilization suggestions:<br/>
		/// delete_qor_suggestions [get_qor_suggestions -filter {CATEGORY==Utilization}]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 470<br/>
		/// </para>
		/// </summary>
		/// <param name="IDs">(Required) Match suggestion names against given names</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL delete_qor_suggestions(String IDs, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_qor_suggestions [-quiet] [-verbose] [<IDs>]
			this.Entry(_builder.delete_qor_suggestions(IDs, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Delete existing reconfig modules<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: delete_reconfig_modules [-merge &lt;arg&gt;] [-quiet] [-verbose] &lt;rms&gt;
		/// <br/>
		/// <para>
		/// Delete the specified reconfigurable modules (RMs) from the current project.<br/>
		/// This command returns nothing if successful, or returns an error if the command fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 472<br/>
		/// </para>
		/// </summary>
		/// <param name="rms">(Required) List of Reconfig Modules to delete</param>
		/// <param name="merge">(Optional) Fileset to merge files into from the deleted Reconfig Module</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL delete_reconfig_modules(String rms, String merge = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_reconfig_modules [-merge <arg>] [-quiet] [-verbose] <rms>
			this.Entry(_builder.delete_reconfig_modules(rms, merge, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Delete a set of existing configurable report objects<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: delete_report_configs [-quiet] [-verbose] &lt;report_configs&gt;...
		/// <br/>
		/// <para>
		/// Removes specified report objects from the current project. The report objects are created by the<br/>
		/// create_report_config command.<br/>
		/// This command returns nothing if successful, or an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example deletes the specified report_config object:<br/>
		/// delete_report_configs [get_report_configs post_route_datasheet]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 474<br/>
		/// </para>
		/// </summary>
		/// <param name="report_configs">(Required) List of configurable report objects to delete</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL delete_report_configs(TCLParameterList report_configs, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_report_configs [-quiet] [-verbose] <report_configs>...
			this.Entry(_builder.delete_report_configs(report_configs, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Delete an RPM<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: delete_rpm [-quiet] [-verbose] &lt;rpm&gt;
		/// <br/>
		/// <para>
		/// Deletes the specified Relationally Placed Macro (RPM) from the design.<br/>
		/// An RPM is a list of logic elements (FFS, LUT, CY4, RAM, etc.) collected into a set (U_SET, H_SET,<br/>
		/// and HU_SET). The placement of each element within the set, relative to other elements of the<br/>
		/// set, is controlled by Relative Location Constraints (RLOCs). Logic elements with RLOC constraints<br/>
		/// and common set names are associated in an RPM. Refer to the Constraints Guide (UG625) for<br/>
		/// more information on defining these constraints.<br/>
		/// Only user-defined RPMs can be deleted from the design. RPMs defined by the hierarchy or<br/>
		/// defined in the netlist cannot be deleted by this command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example deletes the specified RPM (cs_ila_0/U0) from the design:<br/>
		/// delete_rpm cs_ila_0/U0<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 476<br/>
		/// </para>
		/// </summary>
		/// <param name="rpm">(Required) RPM to delete</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL delete_rpm(String rpm, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_rpm [-quiet] [-verbose] <rpm>
			this.Entry(_builder.delete_rpm(rpm, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Delete existing runs<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: delete_runs [-noclean_dir] [-quiet] [-verbose] &lt;runs&gt;
		/// <br/>
		/// <para>
		/// Deletes the specified runs from the project, and deletes all results of the run from the project<br/>
		/// directory on the hard drive unless otherwise specified.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example deletes the first_pass run from the project:<br/>
		/// delete_runs first_pass<br/>
		/// Note: In this example, all run results will also be removed from the project directory on the hard drive.<br/>
		/// The following command deletes the first_pass run, but leaves the run results on the hard drive:<br/>
		/// delete_runs -noclean_dir first_pass<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 478<br/>
		/// </para>
		/// </summary>
		/// <param name="runs">(Required) Run to modify</param>
		/// <param name="noclean_dir">(Optional) Do not remove all output files and directories from disk</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL delete_runs(String runs, bool? noclean_dir = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_runs [-noclean_dir] [-quiet] [-verbose] <runs>
			this.Entry(_builder.delete_runs(runs, noclean_dir, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Clear a set of timing results from memory<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: delete_timing_results [-type &lt;arg&gt;] [-quiet] [-verbose] &lt;name&gt;
		/// <br/>
		/// <para>
		/// Clear the specified timing results from the named result set. Both the type of the timing report,<br/>
		/// and the name of the timing report must be specified, or the command will fail.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example clears the specified results set from memory:<br/>
		/// delete_timing_results -type clock_interaction clkNets<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 480<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name for the set of results to clear</param>
		/// <param name="type">
		/// <para>
		/// (Optional)<br/>
		/// Type of timing results to clear; Values: bus_skew,<br/>
		/// check_timing, clock_interaction, clock_domain_crossings,<br/>
		/// config_timing, datasheet, pulse_width, slack_histogram,<br/>
		/// timing_path, timing_summary<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL delete_timing_results(String name, delete_timing_results_type? type = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_timing_results [-type <arg>] [-quiet] [-verbose] <name>
			this.Entry(_builder.delete_timing_results(name, type, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Delete utilization results that were stored in memory under a given name.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: delete_utilization_results -name &lt;arg&gt; [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Clear the specified utilization results from the named result set.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example clears the specified results set from memory:<br/>
		/// delete_utilization_results -name SSO1<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 482<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name for the set of results to clear</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL delete_utilization_results(String name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: delete_utilization_results -name <arg> [-quiet] [-verbose]
			this.Entry(_builder.delete_utilization_results(name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Delete one or more DRC/METHODOLOGY/CDC message waivers<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: delete_waivers [-scoped] [-quiet] [-verbose] [&lt;objects&gt;...]
		/// <br/>
		/// <para>
		/// After report_drc, report_methodology, or report_cdc commands are run, they return<br/>
		/// messages of specific violations or conditions found in the design. These violations can prevent<br/>
		/// the design from progressing until they have been resolved or addressed in some way. The<br/>
		/// create_waiver command lets you select individual violations or specific checks that can be<br/>
		/// waived for a design, letting you move forward in the design flow.<br/>
		/// Use the delete_waivers command to remove waivers from the design.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// This example deletes all the DRC waivers in the design:<br/>
		/// delete_waivers [get_waivers -type DRC]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 484<br/>
		/// </para>
		/// </summary>
		/// <param name="scoped">
		/// <para>
		/// (Optional)<br/>
		/// flag waiver to interpret object wildcards as scoped to the<br/>
		/// current_instance that is set<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">
		/// <para>
		/// (Optional)<br/>
		/// List of waiver objects, or a list of message objects (cells,<br/>
		/// nets, sites, etc.) for which DRC/METHODOLOGY waiver(s)<br/>
		/// were set<br/>
		/// </para>
		/// </param>
		public VivadoTCL delete_waivers(bool? scoped = null, bool? quiet = null, bool? verbose = null, TCLParameterList objects = null)
		{
			// TCL Syntax: delete_waivers [-scoped] [-quiet] [-verbose] [<objects>...]
			this.Entry(_builder.delete_waivers(scoped, quiet, verbose, objects));
			return this;
		}
		/// <summary>
		/// <para>
		/// Describe an HDL object (variable, signal, wire, or reg) by printing type and declaration<br/>
		/// information<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: describe [-quiet] [-verbose] &lt;hdl_object&gt;
		/// <br/>
		/// <para>
		/// Describe an HDL object (variable, signal, wire, or reg) by printing type and declaration<br/>
		/// information, as well as path, and file information for the HDL source of the specified objects.<br/>
		/// TIP: The describe command works for a single HDL object. Use the report_objects command for<br/>
		/// a brief report on multiple HDL objects.<br/>
		/// HDL objects include HDL signals, variables, or constants as defined in the Verilog or VHDL test<br/>
		/// bench and source files. An HDL signal includes Verilog wire or reg entities, and VHDL signals.<br/>
		/// Examples of HDL variables include Verilog real, realtime, time, and event. HDL constants include<br/>
		/// Verilog parameters and localparams, and VHDL generic and constants.<br/>
		/// The command returns the description of specified HDL objects, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// Verilog parameters and localparams, and VHDL generic and constants.<br/>
		/// The command returns the description of specified HDL objects, or returns an error if it fails.<br/>
		/// Arguments<br/>
		/// -quiet - (Optional) Execute the command quietly, returning no messages from the command.<br/>
		/// The command also returns TCL_OK regardless of any errors encountered during execution.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Note: Any errors encountered on the command-line, while launching the command, will be returned. Only<br/>
		/// errors occurring inside the command will be trapped.<br/>
		/// -verbose - (Optional) Temporarily override any message limits and return all messages from this<br/>
		/// command.<br/>
		/// Note: Message limits can be defined with the set_msg_config command.<br/>
		/// &lt;hdl_object&gt; - (Required) Specifies a single HDL object to describe.<br/>
		/// Note: Objects can be specified by name, or returned as objects by the get_objects command.<br/>
		/// Examples<br/>
		/// The following example shows how the objects description depends on the scope of the current<br/>
		/// simulation:<br/>
		/// current_scope testbench<br/>
		/// /testbench<br/>
		/// describe leds_n<br/>
		/// Signal: {leds_n[3:0]}<br/>
		/// Path: {/testbench/leds_n}<br/>
		/// Location: {File "C:/Data/ug937/sim/testbench.v" Line 9}<br/>
		/// current_scope dut<br/>
		/// /testbench/dut<br/>
		/// describe leds_n<br/>
		/// Port(OUT): {LEDS_n[3:0]}<br/>
		/// Path: {/testbench/dut/LEDS_n}<br/>
		/// Location: {File "C:/Data/sources/sinegen_demo.vhd" Line 42}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 486<br/>
		/// </para>
		/// </summary>
		/// <param name="hdl_object">(Required) The hdl_object or hdl_scope to describe</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The description of the selected objects</returns>
		public VivadoTCL describe(String hdl_object, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: describe [-quiet] [-verbose] <hdl_object>
			this.Entry(_builder.describe(hdl_object, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Automatically detect links between RX and TX endpoints. Create a new link group to contain the<br/>
		/// links.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: detect_hw_sio_links [-force] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Automatically detects existing or previously defined communication pathways between GT<br/>
		/// transmitters and receivers that are defined on the open hardware target.<br/>
		/// You can use this command if you change board connections while the serial I/O analyzer is<br/>
		/// running. The detection algorithm uses changing transmit patterns and detects links on received<br/>
		/// patterns to determine how GTs are connected to one another on the open hardware target.<br/>
		/// A transmitter or receiver of an individual GT on the IBERT debug core can only be used in one<br/>
		/// hw_sio_link at a time, so the command will not check GTs that are used in existing links. The -<br/>
		/// force option lets you clear all existing links before scanning the open hardware target to check<br/>
		/// all GTs.<br/>
		/// The detect_hw_sio_links command defines the found links, and creates a link group to<br/>
		/// associate the new links.<br/>
		/// This command returns the number of links found and the created hw_sio_linkgroup object, or<br/>
		/// returns an error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 488<br/>
		/// </para>
		/// </summary>
		/// <param name="force">(Optional) Remove all existing links before detecting links</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>A new hardware SIO link group of found links</returns>
		public VivadoTCL detect_hw_sio_links(bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: detect_hw_sio_links [-force] [-quiet] [-verbose]
			this.Entry(_builder.detect_hw_sio_links(force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Disconnect an intf_net.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: disconnect_bd_intf_net [-quiet] [-verbose] &lt;intf_net&gt; &lt;objects&gt;...
		/// <br/>
		/// <para>
		/// Disconnect a single interface net in the IP integrator subsystem design from the specified<br/>
		/// objects. An interface is a grouping of signals that share a common function in the IP integrator<br/>
		/// subsystem design.<br/>
		/// This command lets you disconnect the specified interface net from pins or ports in the IP<br/>
		/// subsystem design, without deleting the whole net. To delete the whole net, you should use the<br/>
		/// delete_bd_objs command.<br/>
		/// This command returns TCL_OK if it is successful, or TCL_ERROR if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 490<br/>
		/// </para>
		/// </summary>
		/// <param name="intf_net">(Required) The IntfNet that the objects connect to</param>
		/// <param name="objects">(Required) The objects to disconnect from the intf_net</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>TCL_OK, TCL_ERROR if failed.</returns>
		public VivadoTCL disconnect_bd_intf_net(String intf_net, TCLParameterList objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: disconnect_bd_intf_net [-quiet] [-verbose] <intf_net> <objects>...
			this.Entry(_builder.disconnect_bd_intf_net(intf_net, objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Disconnect a net from the object.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: disconnect_bd_net [-quiet] [-verbose] &lt;net&gt; &lt;objects&gt;...
		/// <br/>
		/// <para>
		/// Disconnect a single net in the IP integrator subsystem design from the specified objects.<br/>
		/// This command lets you disconnect the specified nets from pins or ports in the IP subsystem<br/>
		/// design, without deleting the whole net. To delete the whole net, you should use the<br/>
		/// delete_bd_objs command.<br/>
		/// This command returns TCL_OK if it is successful, or TCL_ERROR if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 492<br/>
		/// </para>
		/// </summary>
		/// <param name="net">(Required) The Net that the objects connect to</param>
		/// <param name="objects">(Required) The objects to disconnect from the net</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>TCL_OK, TCL_ERROR if failed.</returns>
		public VivadoTCL disconnect_bd_net(String net, TCLParameterList objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: disconnect_bd_net [-quiet] [-verbose] <net> <objects>...
			this.Entry(_builder.disconnect_bd_net(net, objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Disconnect nets and pins from debug port channels<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: disconnect_debug_port [-channel_index &lt;arg&gt;] [-quiet] [-verbose] &lt;port&gt;
		/// <br/>
		/// <para>
		/// Disconnect signals from the debug ports.<br/>
		/// Signals from the Netlist Design are connected to ports of a ILA debug core using the<br/>
		/// connect_debug_port command.<br/>
		/// A port can also be deleted from the debug core rather than simply disconnected by using the<br/>
		/// delete_debug_port command.<br/>
		/// If you need to determine the specific name of a port on a debug core, use the<br/>
		/// get_debug_ports command to list all ports on a core. You can also use the<br/>
		/// report_debug_core command to list all of the cores in the projects, and their specific<br/>
		/// parameters.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example disconnects only the specified channel index from the PROBE1 port of<br/>
		/// myCore:<br/>
		/// disconnect_debug_port -channel_index 2 myCore/PROBE1<br/>
		/// If you do not specify the channel_index, all of the channels of the specified port will be<br/>
		/// disconnected, as in the following example:<br/>
		/// disconnect_debug_port myCore/PROBE1<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 494<br/>
		/// </para>
		/// </summary>
		/// <param name="port">(Required) Debug port name</param>
		/// <param name="channel_index">(Optional) Disconnect the net at channel index</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL disconnect_debug_port(String port, String channel_index = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: disconnect_debug_port [-channel_index <arg>] [-quiet] [-verbose] <port>
			this.Entry(_builder.disconnect_debug_port(port, channel_index, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Close a connection to a hardware server<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: disconnect_hw_server [-quiet] [-verbose] [&lt;hw_server&gt;]
		/// <br/>
		/// <para>
		/// Disconnect the current or specified Vivado tools hardware server from the Vivado Design Suite.<br/>
		/// The current hardware server is either the last connected hardware server, or one you have<br/>
		/// manually defined with the current_hw_server command. If you disconnect the current<br/>
		/// hardware server, there will be no defined current hardware server until you define a new current<br/>
		/// hw_server object.<br/>
		/// This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 496<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_server">(Optional) hardware server Default: current hardware server</param>
		public VivadoTCL disconnect_hw_server(bool? quiet = null, bool? verbose = null, String hw_server = null)
		{
			// TCL Syntax: disconnect_hw_server [-quiet] [-verbose] [<hw_server>]
			this.Entry(_builder.disconnect_hw_server(quiet, verbose, hw_server));
			return this;
		}
		/// <summary>
		/// <para>
		/// Disconnect a net from pins or ports<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: disconnect_net [-prune] [-net &lt;arg&gt;] [-objects &lt;args&gt;] [-pinlist &lt;args&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// This command allows the user to disconnect a specified net from one or more pins or ports in the<br/>
		/// netlist of an open Synthesized or Implemented Design.<br/>
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not<br/>
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made<br/>
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or<br/>
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*<br/>
		/// command.<br/>
		/// Note: Netlist editing is not allowed on the elaborated RTL design.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 498<br/>
		/// </para>
		/// </summary>
		/// <param name="prune">
		/// <para>
		/// (Optional)<br/>
		/// When performing disconnect, remove the net and any<br/>
		/// pin/net chain up to the pin on any primitive instance as long<br/>
		/// as each object in the chain has only 1 remaining connection.<br/>
		/// </para>
		/// </param>
		/// <param name="net">
		/// <para>
		/// (Optional)<br/>
		/// Net to disconnect - optional, net attached to first pin or port<br/>
		/// object is used if not specified.<br/>
		/// </para>
		/// </param>
		/// <param name="objects">
		/// <para>
		/// (Optional)<br/>
		/// List of pin and port names to disconnect. String expressions<br/>
		/// are supported.<br/>
		/// </para>
		/// </param>
		/// <param name="pinlist">(Optional) List of pin and port objects to disconnect.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL disconnect_net(bool? prune = null, String net = null, TCLParameterList objects = null, TCLParameterList pinlist = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: disconnect_net [-prune] [-net <arg>] [-objects <args>] [-pinlist <args>] [-quiet] [-verbose]
			this.Entry(_builder.disconnect_net(prune, net, objects, pinlist, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Display hardware ILA data in viewer<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: display_hw_ila_data [-wcfg &lt;arg&gt;] [-reset] [-quiet] [-verbose] [&lt;hw_ila_data&gt;...]
		/// <br/>
		/// <para>
		/// This command is intended for use with the graphical user interface of the Vivado Design Suite<br/>
		/// logic analyzer feature. It displays the specified ILA debug core data object in a wave config<br/>
		/// window of the Vivado logic analyzer.<br/>
		/// The ILA debug sample data is acquired from a running device using the upload_hw_ila_data<br/>
		/// command. This creates a hw_ila_data object that can be written to a file on disk using the<br/>
		/// write_hw_ila_data command. This command reads that ILA data file.<br/>
		/// The display characteristics of the ILA debug core in the waveform window are determined by the<br/>
		/// Wave Config file. The Wave Config file contains just the list of wave objects (signals, dividers,<br/>
		/// groups, virtual buses) to display, and their display properties, plus markers.<br/>
		/// A wave configuration object is created in the Vivado logic analyzer with the<br/>
		/// create_wave_config command. A Wave Config file is written to disk by the use of the<br/>
		/// save_wave_config command, and can be opened with the open_wave_config command.<br/>
		/// The open_wave_config command opens a Wave Config file and maps it to the data source in<br/>
		/// the current simulation.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 501<br/>
		/// </para>
		/// </summary>
		/// <param name="wcfg">(Optional) Import alternate wave config file</param>
		/// <param name="reset">(Optional) Force reset wave config file to default configuration</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_ila_data">(Optional) List of hardware ILA data objects. Default: Current hardware ILA data</param>
		public VivadoTCL display_hw_ila_data(String wcfg = null, bool? reset = null, bool? quiet = null, bool? verbose = null, TCLParameterList hw_ila_data = null)
		{
			// TCL Syntax: display_hw_ila_data [-wcfg <arg>] [-reset] [-quiet] [-verbose] [<hw_ila_data>...]
			this.Entry(_builder.display_hw_ila_data(wcfg, reset, quiet, verbose, hw_ila_data));
			return this;
		}
		/// <summary>
		/// <para>
		/// Display an existing hardware SIO scan.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: display_hw_sio_scan [-quiet] [-verbose] &lt;hw_sio_scans&gt;
		/// <br/>
		/// <para>
		/// This command is intended for use with the graphical user interface of the Vivado Design Suite<br/>
		/// serial I/O analyzer feature. It displays the specified SIO scan data object, or objects, in a Scan<br/>
		/// Plots window of the Vivado IDE.<br/>
		/// The SIO scan data can be read from a file on disk using the read_hw_sio_scan command, or<br/>
		/// from a hw_sio_scan object created by the run_hw_sio_scan command. The type of plot<br/>
		/// displayed is determined by the &lt;scan_type&gt; of the hw_sio_scan object.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 503<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_sio_scans">(Required) hardware SIO scans</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL display_hw_sio_scan(String hw_sio_scans, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: display_hw_sio_scan [-quiet] [-verbose] <hw_sio_scans>
			this.Entry(_builder.display_hw_sio_scan(hw_sio_scans, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Encrypt files in place with a language specific key file in IEEE 1735. no default<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: encrypt [-key &lt;arg&gt;] -lang &lt;arg&gt; [-ext &lt;arg&gt;] [-quiet] [-verbose] &lt;files&gt;...
		/// <br/>
		/// <para>
		/// TIP: The encrypt command is provided with limited access, and requires a special license to use.<br/>
		/// Allows anyone with an encryption license to encrypt Verilog or VHDL files using the IEEE 1735<br/>
		/// encryption standard.<br/>
		/// Encrypted files can be provided by third-party IP providers to protect their intellectual property,<br/>
		/// while still enabling the Vivado Design Suite to read the encrypted files for synthesis and<br/>
		/// simulation. The data is in plain text prior to encryption.<br/>
		/// IMPORTANT! Unless the -ext option is used, the specified files are encrypted in place, overwriting the<br/>
		/// input files with the encrypted files.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 505<br/>
		/// </para>
		/// </summary>
		/// <param name="lang">(Required) HDL language of the input/output file</param>
		/// <param name="files">(Required) Files to be encrypted in place</param>
		/// <param name="key">(Optional) key file to be used to encrypt; if absent, use embedded keys</param>
		/// <param name="ext">
		/// <para>
		/// (Optional)<br/>
		/// extension to use for encrypted file; the original source files<br/>
		/// will be preserved.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL encrypt(String lang, TCLParameterList files, String key = null, String ext = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: encrypt [-key <arg>] -lang <arg> [-ext <arg>] [-quiet] [-verbose] <files>...
			this.Entry(_builder.encrypt(lang, files, key, ext, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// End a set of commands that can be undone/redone as a group<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: endgroup [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Ends a sequence of commands that can be undone or redone as a series. Use startgroup to<br/>
		/// start the sequence of commands.<br/>
		/// You can have multiple command groups to undo or redo, but you cannot nest command groups.<br/>
		/// You must use endgroup to end a command sequence before using startgroup to create a<br/>
		/// new command sequence.<br/>
		/// TIP: The startgroup /endgroup commands are provided to support sequences of related commands<br/>
		/// that can be undone via the undo command, or redone if needed using the redo command. However,<br/>
		/// some Tcl commands can trigger an endgroup unexpectedly, and certain commands do not support either<br/>
		/// UNDO or REDO. The limitations are not fully defined.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example defines a startgroup, executes a sequence of related commands, and<br/>
		/// then executes the endgroup. This sequence of commands can be undone as a group:<br/>
		/// startgroup<br/>
		/// create_pblock pblock_wbArbEngine<br/>
		/// create_pblock pblock_usbEng<br/>
		/// add_cells_to_pblock pblock_wbArbEngine \<br/>
		/// [get_cells [list wbArbEngine]] -clear_locs<br/>
		/// add_cells_to_pblock pblock_usbEng \<br/>
		/// [get_cells [list usbEngine1/usbEngineSRAM]] -clear_locs<br/>
		/// endgroup<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 507<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL endgroup(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: endgroup [-quiet] [-verbose]
			this.Entry(_builder.endgroup(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Exclude segment from an address space.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: exclude_bd_addr_seg [-target_address_space &lt;arg&gt;] [-quiet] [-verbose] [&lt;segment_to_exclude&gt;]
		/// <br/>
		/// <para>
		/// Exclude the specified AXI peripheral address segment from access by the AXI master it is<br/>
		/// mapped to, in order to support sparse connectivity and eliminate unneeded device resources.<br/>
		/// This command lets you exclude specific peripherals from being accessed by specific AXI masters.<br/>
		/// For example, in the case where AXI peripherals P0 and P1 are connected to two masters M0 and<br/>
		/// M1, you can use sparse connectivity to let M0 access both P0 and P1, and let M1 accesses P1,<br/>
		/// but exclude it from P0.<br/>
		/// In the IP integrator block design, address segments of AXI peripherals will have one of three<br/>
		/// states:<br/>
		/// • Unmapped - An AXI peripheral, or slave interface, is connected to an AXI master, but the<br/>
		/// peripheral has not been assigned an address segment in the master's address space and is not<br/>
		/// visible to the master.<br/>
		/// • Mapped - The AXI peripheral is mapped into the AXI master's address space, assigned an<br/>
		/// address segment or range, and is accessible through the master.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// • Excluded - The AXI peripheral is mapped to the AXI master, and has been assigned an address,<br/>
		/// but is not accessible to the master. The address segment that the AXI slave occupies within<br/>
		/// the master address space is also considered filled.<br/>
		/// The purpose of excluding the address segment is to restrict access to peripherals that are<br/>
		/// connected to multiple masters. The validate_bd_design command will return a critical<br/>
		/// warning if a peripheral interface is connected to a master, but not mapped to an address segment<br/>
		/// of that master. However, by excluding the peripheral after it is mapped, the resources required to<br/>
		/// connect and provide access between the AXI master and the peripheral (the muxes and decoding<br/>
		/// for example) can be eliminated to conserve resources on the implemented design.<br/>
		/// TIP: When running assign_bd_address, the IP integrator will map unmapped address segments into<br/>
		/// address spaces, but will not map excluded address spaces.<br/>
		/// This command offers two syntaxes, for a previously mapped address segment, and an unmapped<br/>
		/// address segment:<br/>
		/// exclude_bd_addr_seg &lt;master_addr_seg&gt;<br/>
		/// exclude_bd_addr_seg -target_address_space &lt;master_addr_space&gt;<br/>
		/// &lt;slave_addr_seg&gt;<br/>
		/// In the second command syntax, when a slave segment is specified, the slave will first be assigned<br/>
		/// or mapped to the specified AXI master address space, and then it will be excluded from access by<br/>
		/// the master.<br/>
		/// This command returns nothing if successful, or returns an error if it failed.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 509<br/>
		/// </para>
		/// </summary>
		/// <param name="target_address_space">(Optional) Target address space to exclude the slave segment from</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="segment_to_exclude">(Optional) segment to exclude</param>
		/// <returns>The newly excluded segment object, "" if failed.</returns>
		public VivadoTCL exclude_bd_addr_seg(String target_address_space = null, bool? quiet = null, bool? verbose = null, String segment_to_exclude = null)
		{
			// TCL Syntax: exclude_bd_addr_seg [-target_address_space <arg>] [-quiet] [-verbose] [<segment_to_exclude>]
			this.Entry(_builder.exclude_bd_addr_seg(target_address_space, quiet, verbose, segment_to_exclude));
			return this;
		}
		/// <summary>
		/// <para>
		/// Execute SVF file on current_hw_target<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: execute_hw_svf [-quiet] [-verbose] &lt;file_name&gt;
		/// <br/>
		/// <para>
		/// The Vivado hardware manager supports programming of hardware devices through the use of<br/>
		/// Serial Vector Format (SVF) files. SVF files are ASCII files that contain both programming<br/>
		/// instructions and configuration data. These files are used by ATE machines and embedded<br/>
		/// controllers to perform boundary-scan operations. The SVF file is an ASCII files that captures the<br/>
		/// JTAG commands needed to program the bitstream directly into a Xilinx device, or indirectly into a<br/>
		/// flash memory device. The SVF file can be written using the write_hw_svf command, or used<br/>
		/// to program a device through the execute_hw_svf command. Refer to the Vivado Design Suite<br/>
		/// User Guide: Programming and Debugging (UG908) for more information.<br/>
		/// The execute_hw_svf command converts the SVF commands into Vivado Tcl commands and<br/>
		/// executes them on the specified target. This process could take some time depending on how big<br/>
		/// the SVF file is. The command requires an open, current hw_target object, with a JTAG chain that<br/>
		/// matches the device chain specified in the SVF file.<br/>
		/// TIP: The execute_hw_svf command is not a general purpose SVF reader, and should only be used to<br/>
		/// read and execute SVF files written by the Vivado tools.<br/>
		/// This command returns a transcript of its process, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example executes the specified SVF command file in verbose mode to display all of<br/>
		/// the commands being run:<br/>
		/// open_hw_target {houdini26:3121/xilinx_tcf/Digilent/210203327996A}<br/>
		/// execute_hw_svf -verbose C:/Data/k7_design.svf<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 512<br/>
		/// </para>
		/// </summary>
		/// <param name="file_name">(Required) SVF filename</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL execute_hw_svf(String file_name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: execute_hw_svf [-quiet] [-verbose] <file_name>
			this.Entry(_builder.execute_hw_svf(file_name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Export current design as a static example design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: export_as_example_design -vlnv &lt;arg&gt; [-no_ip_version] [-force] [-quiet] [-verbose] -directory &lt;arg&gt;
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 514<br/>
		/// </para>
		/// </summary>
		/// <param name="vlnv">(Required) VLNV of the example design to be generated</param>
		/// <param name="directory">(Required) Destination directory in which example design needs to be generated</param>
		/// <param name="no_ip_version">
		/// <para>
		/// (Optional)<br/>
		/// Flag to not include the IP version as part of the IP VLNV in<br/>
		/// create_bd_cell commands.<br/>
		/// </para>
		/// </param>
		/// <param name="force">(Optional) create a directory if it does not exist</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL export_as_example_design(String vlnv, String directory, bool? no_ip_version = null, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: export_as_example_design -vlnv <arg> [-no_ip_version] [-force] [-quiet] [-verbose] -directory <arg>
			this.Entry(_builder.export_as_example_design(vlnv, directory, no_ip_version, force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// (User-written application) Create and write a single design checkpoint and stub files for a Block<br/>
		/// Design (BD), for use with third party synthesis tools. Perform synthesis as necessary.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: export_bd_synth [-force] [-keep] [-verbose] [-quiet] &lt;file&gt;
		/// <br/>
		/// <para>
		/// Runs synthesis for a block design (.bd), integrates the design along with any needed sub-designs<br/>
		/// (e.g. out-of-context synthesized IP), and writes out a single design checkpoint (.dcp) of the<br/>
		/// entire synthesized design, as well as HDL stub files, for use in other synthesis tools. The output<br/>
		/// files will be placed in the same directory as the source BD file.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following command will generate a synthesis checkpoint, with stub files, for the specified<br/>
		/// block design:<br/>
		/// export_bd_synth [get_files block_1.bd]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 515<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) The Block Design file to write a synthesized checkpoint for</param>
		/// <param name="force">(Optional) Overwrite existing design checkpoint and stub files</param>
		/// <param name="keep">(Optional) Keep the temporary directory and project</param>
		/// <param name="verbose">(Optional) Print verbose messaging</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <returns>(none) An error will be thrown if the command is not successful</returns>
		public VivadoTCL export_bd_synth(String file, bool? force = null, bool? keep = null, bool? verbose = null, bool? quiet = null)
		{
			// TCL Syntax: export_bd_synth [-force] [-keep] [-verbose] [-quiet] <file>
			this.Entry(_builder.export_bd_synth(file, force, keep, verbose, quiet));
			return this;
		}
		/// <summary>
		/// <para>
		/// (User-written application) Generate and export IP/IPI user files from a project. This can be<br/>
		/// scoped to work on one or more IPs.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: export_ip_user_files [-of_objects &lt;arg&gt;] [-ip_user_files_dir &lt;arg&gt;] [-ipstatic_source_dir &lt;arg&gt;] [-lib_map_path &lt;arg&gt;] [-no_script] [-sync] [-reset] [-force] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Export IP user files repository with static, dynamic, netlist, verilog/vhdl stubs and memory<br/>
		/// initializaton files.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following command will export the dynamic files for the char_fifo IP to &lt;project&gt;/<br/>
		/// &lt;project&gt;.ip_user_files/ip/char_fifo directory, and IP static files to &lt;project&gt;/<br/>
		/// &lt;project&gt;.ip_user_files/ipstatic directory:<br/>
		/// export_ip_user_files -of_objects [get_ips char_fifo]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 517<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">(Optional) IP,IPI or a fileset object Default: None</param>
		/// <param name="ip_user_files_dir">
		/// <para>
		/// (Optional)<br/>
		/// Directory path to simulation base directory (for static,<br/>
		/// dynamic, wrapper, netlist, script and MEM files) Default:<br/>
		/// None<br/>
		/// </para>
		/// </param>
		/// <param name="ipstatic_source_dir">(Optional) Directory path to the IP static files Default: None</param>
		/// <param name="lib_map_path">(Optional) Compiled simulation library directory path Default: Empty</param>
		/// <param name="no_script">(Optional) Do not export simulation scripts Default: 1</param>
		/// <param name="sync">(Optional) Delete IP/IPI dynamic and simulation script files</param>
		/// <param name="reset">(Optional) Delete all IP/IPI static, dynamic and simulation script files</param>
		/// <param name="force">(Optional) Overwrite files</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of files that were exported</returns>
		public VivadoTCL export_ip_user_files(String of_objects = null, String ip_user_files_dir = null, String ipstatic_source_dir = null, String lib_map_path = null, bool? no_script = null, bool? sync = null, bool? reset = null, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: export_ip_user_files [-of_objects <arg>] [-ip_user_files_dir <arg>] [-ipstatic_source_dir <arg>] [-lib_map_path <arg>] [-no_script] [-sync] [-reset] [-force] [-quiet] [-verbose]
			this.Entry(_builder.export_ip_user_files(of_objects, ip_user_files_dir, ipstatic_source_dir, lib_map_path, no_script, sync, reset, force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// (User-written application) Export a script and associated data files (if any) for driving standalone<br/>
		/// simulation using the specified simulator.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: export_simulation [-simulator &lt;arg&gt;] [-of_objects &lt;arg&gt;] [-ip_user_files_dir &lt;arg&gt;] [-ipstatic_source_dir &lt;arg&gt;] [-lib_map_path &lt;arg&gt;] [-script_name &lt;arg&gt;] [-directory &lt;arg&gt;] [-runtime &lt;arg&gt;] [-define &lt;arg&gt;] [-generic &lt;arg&gt;] [-include &lt;arg&gt;] [-use_ip_compiled_libs] [-absolute_path] [-export_source_files] [-generate_hier_access] [-32bit] [-force] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Export a simulation script file for the target simulator. Currently the Cadence Incisive Enterprise<br/>
		/// Simulator (ies) and the Synopsys VCS MX simulator (vcs_mx) are supported. The generated<br/>
		/// script will contain simulator commands for compiling, elaborating and simulating the design.<br/>
		/// The command will retrieve the simulation compile order of specified objects, and export this<br/>
		/// information in a text file with the compiler commands and default options for the target<br/>
		/// simulator. The specified object can be either a simulation fileset or an IP. If the object is not<br/>
		/// specified, then the export_simulation command will generate the script for the simulation<br/>
		/// top.<br/>
		/// Any verilog include directories or file paths for the files containing verilog define statements will<br/>
		/// be added to the compiler command line.<br/>
		/// By default, the design source file and include directory paths in the compiler command line will<br/>
		/// be set relative to the "reference_dir" variable that is defined in the generated script. To make<br/>
		/// these paths absolute, specify the -absolute_path option.<br/>
		/// The command will also copy data files (if any) from the fileset, or from an IP, to the output<br/>
		/// directory. If the design contains "Verilog" sources, then the generated script will also copy "glbl.v"<br/>
		/// from the software installation path to the output directory.<br/>
		/// A default ".do" file will be created in the output directory for the target simulator that will be<br/>
		/// referred in the compiler commands in the script.<br/>
		/// Note: In order to perform simulation with the generated script, the simulation libraries must be compiled<br/>
		/// first using the compile_simlib command, with the compiled library directory path specified, when<br/>
		/// generating this script. The generated simulation script will automatically include the setup files for the<br/>
		/// target simulator from the compiled library directory.<br/>
		/// This command returns nothing.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following command generates a simulation script file in the current directory for the "IES"<br/>
		/// simulator:<br/>
		/// export_simulation -simulator ies -directory .<br/>
		/// The following command overwrites an existing script file in the current directory:<br/>
		/// export_simulation -force -simulator ies -directory .<br/>
		/// The following command generates a simulation script file named test_ies.sh in the ./<br/>
		/// test_sim directory:<br/>
		/// export_simulation -simulator ies -directory ./test_sim \<br/>
		/// -script_name test_ies.sh<br/>
		/// The following command generates a script file named top_tb_sim_ies.sh in the ./<br/>
		/// test_sim directory for a project with simulation top set to "top_tb". The command will also<br/>
		/// copy any data files (.mif, .coe, .dat, etc) to the ./test_sim directory:<br/>
		/// export_simulation -simulator ies -directory ./test_sim<br/>
		/// The following command generates a script file accum_0_sim_ies.sh for the "accum_0" IP in<br/>
		/// the specified output directory for the "IES" simulator:<br/>
		/// export_simulation -of_objects [get_files accum_0.xci] \<br/>
		/// -simulator ies -directory test_sim<br/>
		/// The following command generates a script file accum_0_sim_vcs_mx.sh for the "accum_0" IP<br/>
		/// in the specified output directory for the "VCS_MX" simulator:<br/>
		/// export_simulation -of_objects [get_ips accum_0] -simulator vcs_mx \<br/>
		/// -directory test_sim<br/>
		/// The following command generates a script file fifo_tb_sim_vcs_mx.sh for the simulation<br/>
		/// fileset "sim_fifo_test" whose top is set to "fifo_tb" in the specified output directory for the "IES"<br/>
		/// simulator:<br/>
		/// export_simulation -of_objects [get_filesets sim_fifo_test] \<br/>
		/// -simulator ies -directory test_sim<br/>
		/// The following command exports a script file top_tb_sim_vcs_mx.sh for the "VCS_MX"<br/>
		/// simulator in the specified output directory with the design source files compiled for 32 bit<br/>
		/// version of the simulator compiler (no 64 bit option will be added to the command line):<br/>
		/// export_simulation -force -32bit -simulator vcs_mx -directory test_bft_vcs_mx<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example will include /sim_libs/ius/lin64/lib/cds.lib file path in the ./<br/>
		/// test_sim/cds.lib file ("INCLUDE /sim_libs/ius/lin64/lib/cds.lib") for referencing the<br/>
		/// compiled libraries for "IES" simulator:<br/>
		/// export_simulation -lib_map_path "/sim_libs/ius/lin64/lib" \<br/>
		/// -simulator ies -directory "test_sim"<br/>
		/// The following example will include /sim_libs/vcs/lin64/lib/synopsys_sim.setup file<br/>
		/// path in the ./test_sim/synopsys_sim.setup file ("OTHERS=/sim_libs/vcs/lin64/lib/<br/>
		/// synopsys_sim.setup") for refrencing the compiled libraries for the "VCS_MX" simulator:<br/>
		/// export_simulation -lib_map_path "/sim_libs/vcs/lin64/lib" \<br/>
		/// -simulator vcs_mx -directory "test_sim"<br/>
		/// The following example generates a script file in ./test_sim/ies directory and then compiles,<br/>
		/// elaborates and simulates the design in "IES" simulator:<br/>
		/// export_simulation -lib_map_path "/sim_libs/ies/lin64/lib" \<br/>
		/// -simulator ies -directory "./test_sim/ies"<br/>
		/// cd test_sim/ies<br/>
		/// ./top_tb_sim_ies.sh<br/>
		/// The following example generates a script file in ./test_sim/vcs_mx directory and then<br/>
		/// compile, elaborate and simulate the design in "VCS_MX" simulator:<br/>
		/// export_simulation -lib_map_path "/sim_libs/vcs/lin64/lib" \<br/>
		/// -simulator vcs_mx -directory "./test_sim/vcs_mx"<br/>
		/// cd test_sim/vcs_mx<br/>
		/// ./top_tb_sim_vcs_mx.sh<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 519<br/>
		/// </para>
		/// </summary>
		/// <param name="simulator">
		/// <para>
		/// (Optional)<br/>
		/// Simulator for which the simulation script will be created<br/>
		/// (value=all|xsim|modelsim|questa|ies|xceliu m|vcs|<br/>
		/// riviera|activehdl) Default: all<br/>
		/// </para>
		/// </param>
		/// <param name="of_objects">(Optional) Export simulation script for the specified object Default: None</param>
		/// <param name="ip_user_files_dir">
		/// <para>
		/// (Optional)<br/>
		/// Directory path to the exported IP/BD (Block Design) user<br/>
		/// files (for static, dynamic and data files) Default: Empty<br/>
		/// </para>
		/// </param>
		/// <param name="ipstatic_source_dir">(Optional) Directory path to the exported IP/BD static files Default: Empty</param>
		/// <param name="lib_map_path">
		/// <para>
		/// (Optional)<br/>
		/// Precompiled simulation library directory path. If not<br/>
		/// specified, then please follow the instructions in the<br/>
		/// generated script header to manually provide the simulation<br/>
		/// library mapping information. Default: Empty<br/>
		/// </para>
		/// </param>
		/// <param name="script_name">
		/// <para>
		/// (Optional)<br/>
		/// Output script filename. If not specified, then a file with a<br/>
		/// default name will be created. Default: top_module.sh<br/>
		/// </para>
		/// </param>
		/// <param name="directory">
		/// <para>
		/// (Optional)<br/>
		/// Directory where the simulation script will be generated<br/>
		/// Default: export_sim<br/>
		/// </para>
		/// </param>
		/// <param name="runtime">
		/// <para>
		/// (Optional)<br/>
		/// Run simulation for this time (default:full simulation run or<br/>
		/// until a logical break or finish condition) Default: Empty<br/>
		/// </para>
		/// </param>
		/// <param name="define">
		/// <para>
		/// (Optional)<br/>
		/// Read verilog defines from the list specified with this switch<br/>
		/// Default: Empty<br/>
		/// </para>
		/// </param>
		/// <param name="generic">
		/// <para>
		/// (Optional)<br/>
		/// Read vhdl generics from the list specified with this switch<br/>
		/// Default: Empty<br/>
		/// </para>
		/// </param>
		/// <param name="include">
		/// <para>
		/// (Optional)<br/>
		/// Read include directory paths from the list specified with this<br/>
		/// switch Default: Empty<br/>
		/// </para>
		/// </param>
		/// <param name="use_ip_compiled_libs">
		/// <para>
		/// (Optional)<br/>
		/// Reference pre-compiled IP static library during compilation.<br/>
		/// This switch requires -ip_user_files_dir and -<br/>
		/// ipstatic_source_dir switches as well for generating scripts<br/>
		/// using pre-compiled IP library.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Name Description<br/>
		/// </para>
		/// </param>
		/// <param name="absolute_path">(Optional) Make all file paths absolute</param>
		/// <param name="export_source_files">(Optional) Copy IP/BD design files to output directory</param>
		/// <param name="generate_hier_access">(Optional) Extract path for hierarchical access simulation</param>
		/// <param name="_32bit">(Optional) Perform 32bit compilation</param>
		/// <param name="force">(Optional) Overwrite previous files</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>None</returns>
		public VivadoTCL export_simulation(String simulator = null, String of_objects = null, String ip_user_files_dir = null, String ipstatic_source_dir = null, String lib_map_path = null, String script_name = null, String directory = null, String runtime = null, String define = null, String generic = null, String include = null, bool? use_ip_compiled_libs = null, bool? absolute_path = null, bool? export_source_files = null, bool? generate_hier_access = null, bool? _32bit = null, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: export_simulation [-simulator <arg>] [-of_objects <arg>] [-ip_user_files_dir <arg>] [-ipstatic_source_dir <arg>] [-lib_map_path <arg>] [-script_name <arg>] [-directory <arg>] [-runtime <arg>] [-define <arg>] [-generic <arg>] [-include <arg>] [-use_ip_compiled_libs] [-absolute_path] [-export_source_files] [-generate_hier_access] [-32bit] [-force] [-quiet] [-verbose]
			this.Entry(_builder.export_simulation(simulator, of_objects, ip_user_files_dir, ipstatic_source_dir, lib_map_path, script_name, directory, runtime, define, generic, include, use_ip_compiled_libs, absolute_path, export_source_files, generate_hier_access, _32bit, force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Extract files from a core container to disk<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: extract_files [-base_dir &lt;arg&gt;] [-force] [-no_ip_dir] [-no_paths] [-quiet] [-verbose] &lt;files&gt;...
		/// <br/>
		/// <para>
		/// Extract the files from an IP in core container format.<br/>
		/// The core container format for IP is a compressed zip file that reduces the file structure in the<br/>
		/// design, and increases tool performance.<br/>
		/// This command returns a list of files extracted from the core container IP, or returns an error if it<br/>
		/// fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example extracts the files from the specified core container format IP to the<br/>
		/// specified base directory:<br/>
		/// extract_files -base_dir C:/Data [get_files char_fifo.xcix]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 524<br/>
		/// </para>
		/// </summary>
		/// <param name="files">(Required) Name of the file(s) to be extracted</param>
		/// <param name="base_dir">(Optional) Base directory for extracted files Default: ip_files</param>
		/// <param name="force">(Optional) Overwrite existing files</param>
		/// <param name="no_ip_dir">(Optional) Don't include the IP dir as part of the extract directory</param>
		/// <param name="no_paths">(Optional) Don't include directories when extracting files</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of files that were extracted with the new paths</returns>
		public VivadoTCL extract_files(TCLParameterList files, String base_dir = null, bool? force = null, bool? no_ip_dir = null, bool? no_paths = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: extract_files [-base_dir <arg>] [-force] [-no_ip_dir] [-no_paths] [-quiet] [-verbose] <files>...
			this.Entry(_builder.extract_files(files, base_dir, force, no_ip_dir, no_paths, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Filter a list, resulting in new list<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: filter [-regexp] [-nocase] [-quiet] [-verbose] [&lt;objects&gt;] [&lt;filter&gt;]
		/// <br/>
		/// <para>
		/// Takes a list of objects, and returns a reduced list of objects that match the specified filter search<br/>
		/// pattern.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns a list of parts filtered for the specified speed grade:<br/>
		/// filter [get_parts] {speed == -3}<br/>
		/// The following example filters parts based according to speed grade -3 OR speed grade -2. All<br/>
		/// parts matching either speed grade will be returned.<br/>
		/// filter [get_parts] {speed == -3 || speed == -2}<br/>
		/// The following example uses regular expression and returns a list of VStatus ports in the design,<br/>
		/// with zero or more wildcards, and the numbers 0 to 9 appearing one or more times within square<br/>
		/// brackets:<br/>
		/// filter -regexp [get_ports] {NAME =~ VStatus.*\[[0-9]+\]}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 526<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Operators =~ and !~ use regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">(Optional) List of objects to filter</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <returns>new list</returns>
		public VivadoTCL filter(bool? regexp = null, bool? nocase = null, bool? quiet = null, bool? verbose = null, String objects = null, String filter = null)
		{
			// TCL Syntax: filter [-regexp] [-nocase] [-quiet] [-verbose] [<objects>] [<filter>]
			this.Entry(_builder.filter(regexp, nocase, quiet, verbose, objects, filter));
			return this;
		}
		/// <summary>
		/// <para>
		/// Find a list of pins, ports or interfaces with a given relationship to the given object.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: find_bd_objs -relation &lt;arg&gt; [-boundary_type &lt;arg&gt;] [-thru_hier] [-stop_at_interconnect] [-stop_at_container] [-end_type &lt;arg&gt;] [-quiet] [-verbose] &lt;objects&gt;...
		/// <br/>
		/// <para>
		/// Find a list of pins, ports or interfaces with a given relationship to the specified objects.<br/>
		/// This command returns a list of pins, ports or interface objects if successful, or returns an error if<br/>
		/// it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 529<br/>
		/// </para>
		/// </summary>
		/// <param name="relation">
		/// <para>
		/// (Required)<br/>
		/// Relation to the input objs: connected_to, addressable_slave,<br/>
		/// addressing_master. 'connected_to' will find corresponding<br/>
		/// pins, ports or interfaces that are connected to the given<br/>
		/// source objects, across hierarchy boundaries.<br/>
		/// </para>
		/// </param>
		/// <param name="objects">
		/// <para>
		/// (Required)<br/>
		/// One or more source object to start finding from<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// </param>
		/// <param name="boundary_type">
		/// <para>
		/// (Optional)<br/>
		/// Used when source object is an hierarchical block's pin or<br/>
		/// interface pin. Valid values are empty string for same level<br/>
		/// (default), 'lower', or 'all'. If 'lower' boundary, searches from<br/>
		/// within hierarchy. This option is only valid for relation:<br/>
		/// connected_to<br/>
		/// </para>
		/// </param>
		/// <param name="thru_hier">
		/// <para>
		/// (Optional)<br/>
		/// Flag used to ignore boundary of hierarchical blocks. If used<br/>
		/// used with boundary_type 'lower', flag will only affect the<br/>
		/// hierarchical blocks within parent hierarchical block.<br/>
		/// </para>
		/// </param>
		/// <param name="stop_at_interconnect">
		/// <para>
		/// (Optional)<br/>
		/// Flag used to stop at the axi_interconnect's boundary when -<br/>
		/// thru_hier is used.<br/>
		/// </para>
		/// </param>
		/// <param name="stop_at_container">
		/// <para>
		/// (Optional)<br/>
		/// Flag used to stop at the container's boundary when -<br/>
		/// thru_hier is used.<br/>
		/// </para>
		/// </param>
		/// <param name="end_type">
		/// <para>
		/// (Optional)<br/>
		/// Only to be used with objects that are pins or ports and bus<br/>
		/// interface pins or ports. For pins/ports - Default is to return<br/>
		/// the sink objects for a given source object and to return the<br/>
		/// source object for a given sink object. If 'all' is used for a<br/>
		/// given sink object, will return both source and other sink<br/>
		/// objectst that are connected to the source object. For bus<br/>
		/// interface pins/ports - Default is to return the end<br/>
		/// connection that is non-monitor interfaces. If 'monitor' is<br/>
		/// used, will only return the monitor interfaces. If 'all' is used,<br/>
		/// will return both end connection and monitor interfaces. If<br/>
		/// 'master', will return master interfaces and if 'slave', will<br/>
		/// return slave interfaces.This option is only valid for relation:<br/>
		/// connected_to<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>List of pins, ports or interface objects, "" if failed.</returns>
		public VivadoTCL find_bd_objs(String relation, TCLParameterList objects, String boundary_type = null, bool? thru_hier = null, bool? stop_at_interconnect = null, bool? stop_at_container = null, String end_type = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: find_bd_objs -relation <arg> [-boundary_type <arg>] [-thru_hier] [-stop_at_interconnect] [-stop_at_container] [-end_type <arg>] [-quiet] [-verbose] <objects>...
			this.Entry(_builder.find_bd_objs(relation, objects, boundary_type, thru_hier, stop_at_interconnect, stop_at_container, end_type, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Find a routing path between two nodes.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: find_routing_path [-allow_overlap] [-max_nodes &lt;arg&gt;] [-min_nodes &lt;arg&gt;] [-from &lt;args&gt;] [-to &lt;args&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Finds a routing solution between two nodes on an unrouted, or partially routed net, in an<br/>
		/// implemented design.<br/>
		/// This command can be used to define a routing path to assign to the FIXED_ROUTE property of a<br/>
		/// net, which can be saved to the XDC file for later reuse. Refer to Vivado Design Suite Tutorial:<br/>
		/// Implementation (UG986) for an example of manual routing and the use of the FIXED_ROUTE<br/>
		/// property.<br/>
		/// You must define nodes for the start and end points of the routing path, and can specify the<br/>
		/// maximum and minimum number of nodes to use for the route path, including the start and end<br/>
		/// points. The nodes must be specified as objects returned by the get_nodes command. For<br/>
		/// unrouted net objects, since nodes have not been assigned to the net, the nodes can be found by<br/>
		/// association of the net to the bel_pin or site_pin:<br/>
		/// • Net &gt; Bel_Pin &gt; Bel &gt; Tile &gt; Node<br/>
		/// • Net &gt; Site_Pin &gt; Tile &gt; Node<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// For partially routed nets, the nodes can be found associated directly to the net. Refer to the<br/>
		/// Vivado Design Suite Properties Reference Guide (UG912) for more information on the relationship<br/>
		/// between these objects.<br/>
		/// The find_routing_path command returns a list of nodes representing the route path found<br/>
		/// from the start point to the end point, or returns "no path found" if the command runs but has no<br/>
		/// result, or returns an error if the command fails to run.<br/>
		/// The returned list of nodes can be assigned to the FIXED_ROUTE property using the<br/>
		/// set_property command as shown in the example.<br/>
		/// TIP: The report_property command does not return the string of the FIXED_ROUTE property. Use<br/>
		/// the get_property command instead.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example finds a routing path for the specified net, using one end as the -from<br/>
		/// point and the other end as the -to point, and assigns that path to the specified Tcl variable. Then<br/>
		/// it uses that Tcl variable to assign the path to the FIXED_ROUTE property of the net:<br/>
		/// set fndPath [find_routing_path -from [lindex [get_nodes -of \<br/>
		/// [get_site_pins -of [get_nets wbOutputData_OBUF[14]]]] 0] -to \<br/>
		/// [lindex [get_nodes -of [get_site_pins -of \<br/>
		/// [get_nets wbOutputData_OBUF[14]]]] 1]]<br/>
		/// set_property FIXED_ROUTE $fndPath [get_nets wbOutputData_OBUF[14]]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 532<br/>
		/// </para>
		/// </summary>
		/// <param name="allow_overlap">(Optional) Solution may include nodes used in existing routes.</param>
		/// <param name="max_nodes">
		/// <para>
		/// (Optional)<br/>
		/// Specifies the maximum number of nodes (including from<br/>
		/// and to nodes) allowed in solution. Default: 100<br/>
		/// </para>
		/// </param>
		/// <param name="min_nodes">
		/// <para>
		/// (Optional)<br/>
		/// Specifies the minimum number of nodes (including from<br/>
		/// and to nodes) allowed in solution. Default: 2<br/>
		/// </para>
		/// </param>
		/// <param name="from">(Optional) -from &lt;start node&gt; Start of routing path.</param>
		/// <param name="to">(Optional) -to &lt;end node&gt; End of routing path.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL find_routing_path(bool? allow_overlap = null, Int32? max_nodes = null, Int32? min_nodes = null, TCLParameterList from = null, TCLParameterList to = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: find_routing_path [-allow_overlap] [-max_nodes <arg>] [-min_nodes <arg>] [-from <args>] [-to <args>] [-quiet] [-verbose]
			this.Entry(_builder.find_routing_path(allow_overlap, max_nodes, min_nodes, from, to, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Find top module candidates in the supplied files, fileset, or active fileset. Returns a rank ordered<br/>
		/// list of candidates.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: find_top [-fileset &lt;arg&gt;] [-files &lt;args&gt;] [-return_file_paths] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Find the most likely candidates for the top module in the files defined in the current fileset, or in<br/>
		/// the specified fileset, or in the specified list of files.<br/>
		/// The command returns an ordered list of modules that the tool identifies as the best candidates<br/>
		/// for the top-level of the design. You can use the lindex command, and choose index 0 to select<br/>
		/// the best candidate for the top module.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example chooses the best top module of the current design for synthesis:<br/>
		/// synth_design -top [lindex [find_top] 0]<br/>
		/// Note: Since find_top returns multiple possible candidates, choosing index 0 chooses the best top<br/>
		/// candidate for synthesis.<br/>
		/// The following example returns the best top module candidate from the specified list of files:<br/>
		/// find_top -files [get_files -filter {NAME =~ *or1200*}]<br/>
		/// The following example sets the results of find_top into the variable $topVar, then uses that<br/>
		/// variable to define the top module in the current fileset using the set_property command:<br/>
		/// set topVar [ find_top -files [get_files -filter {NAME =~ *usbf*} ] ]<br/>
		/// usbf_top<br/>
		/// set_property top $topVar [current_fileset]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 535<br/>
		/// </para>
		/// </summary>
		/// <param name="fileset">(Optional) Fileset to parse to search for top candidates</param>
		/// <param name="files">(Optional) Files to parse to search for top candidates</param>
		/// <param name="return_file_paths">
		/// <para>
		/// (Optional)<br/>
		/// For each top returned, also include the associated file path.<br/>
		/// The returned value will be a single list of strings, alternating<br/>
		/// top names and file paths.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL find_top(String fileset = null, TCLParameterList files = null, bool? return_file_paths = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: find_top [-fileset <arg>] [-files <args>] [-return_file_paths] [-quiet] [-verbose]
			this.Entry(_builder.find_top(fileset, files, return_file_paths, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Flush VCD simulation output to the VCD output file (equivalent of $dumpflush verilog system<br/>
		/// task)<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: flush_vcd [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Flush HDL signal information currently in memory into the specified Value Change Dump (VCD)<br/>
		/// file.<br/>
		/// VCD is an ASCII file containing header information, variable definitions, and the value change<br/>
		/// details of a set of HDL signals. The VCD file can be used to view simulation results in a VCD<br/>
		/// viewer, or to estimate the power consumption of the design.<br/>
		/// Note: You must run the open_vcd command to open a VCD file to write to before using the flush_vcd<br/>
		/// command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example flushes the VCD buffer into the current VCD file:<br/>
		/// flush_vcd<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 537<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL flush_vcd(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: flush_vcd [-quiet] [-verbose]
			this.Entry(_builder.flush_vcd(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Generate a base platform based on a given routed checkpoint<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: generate_base_platform [-source &lt;arg&gt;] [-reconfig_platform &lt;arg&gt;] [-base_platform &lt;arg&gt;] [-reconfig_platform_prefix &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 539<br/>
		/// </para>
		/// </summary>
		/// <param name="source">(Optional) (Required) Specify routed checkpoint path</param>
		/// <param name="reconfig_platform">(Optional) (Required) Specify reconfigurable platform module name</param>
		/// <param name="base_platform">
		/// <para>
		/// (Optional)<br/>
		/// (Optional) Specify the output file name, the default file<br/>
		/// name is 'base_platform'<br/>
		/// </para>
		/// </param>
		/// <param name="reconfig_platform_prefix">
		/// <para>
		/// (Optional)<br/>
		/// (Optional) Specify wrapper port name prefix from<br/>
		/// reconfigurable platform module, the default prefix is 'RL_'<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL generate_base_platform(String source = null, String reconfig_platform = null, String base_platform = null, String reconfig_platform_prefix = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: generate_base_platform [-source <arg>] [-reconfig_platform <arg>] [-base_platform <arg>] [-reconfig_platform_prefix <arg>] [-quiet] [-verbose]
			this.Entry(_builder.generate_base_platform(source, reconfig_platform, base_platform, reconfig_platform_prefix, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// (User-written application) Generate sources for hierarchical access simulation<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: generate_hier_access [-bypass &lt;arg&gt;] [-driver &lt;arg&gt;] [-directory &lt;arg&gt;] [-pseudo_top &lt;arg&gt;] [-testbench &lt;arg&gt;] [-log &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Generates sources for hierarchical access simulation.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 540<br/>
		/// </para>
		/// </summary>
		/// <param name="bypass">(Optional) Hierarchical access module name Default: xil_dut_bypass</param>
		/// <param name="driver">(Optional) Signal driver template module name Default: xil_bypass_driver</param>
		/// <param name="directory">
		/// <para>
		/// (Optional)<br/>
		/// Output directory for the generated sources Default: current<br/>
		/// working directory<br/>
		/// </para>
		/// </param>
		/// <param name="pseudo_top">(Optional) Top-level pseudo testbench module name Default: None</param>
		/// <param name="testbench">(Optional) User design testbench module name Default: None</param>
		/// <param name="log">
		/// <para>
		/// (Optional)<br/>
		/// Simulator log containing hierarchical path information<br/>
		/// (required for the non-Vivado standalone flow only) Default:<br/>
		/// None<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>None</returns>
		public VivadoTCL generate_hier_access(String bypass = null, String driver = null, String directory = null, String pseudo_top = null, String testbench = null, String log = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: generate_hier_access [-bypass <arg>] [-driver <arg>] [-directory <arg>] [-pseudo_top <arg>] [-testbench <arg>] [-log <arg>] [-quiet] [-verbose]
			this.Entry(_builder.generate_hier_access(bypass, driver, directory, pseudo_top, testbench, log, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Write all the simulation .mem files.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: generate_mem_files [-force] [-quiet] [-verbose] &lt;directory&gt;
		/// <br/>
		/// <para>
		/// For embedded processor based designs, with associated Executable Linkable Files (ELF) from the<br/>
		/// Software Development Kit (SDK), this command merges the Block Memory Map (BMM) for the<br/>
		/// design with the program data in the ELF file to generate memory (MEM) files for use during<br/>
		/// simulation.<br/>
		/// The MEM file is a text file that describes how individual Block RAMs on the Xilinx device are<br/>
		/// grouped together to form a contiguous address space called an Address Block, with the ELF data<br/>
		/// mapped into the memory.<br/>
		/// The file names and the number of MEM files generated is determined by the memory map data<br/>
		/// specified by the processor system IP cores, or IP integrator block designs.<br/>
		/// This command returns the directory where the MEM files are written, or returns an error if it<br/>
		/// fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 542<br/>
		/// </para>
		/// </summary>
		/// <param name="directory">
		/// <para>
		/// (Required)<br/>
		/// Directory for exporting .mem files. Values: A directory with<br/>
		/// alphanumeric characters.<br/>
		/// </para>
		/// </param>
		/// <param name="force">(Optional) Overwrite existing .mem files</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The name of the directory</returns>
		public VivadoTCL generate_mem_files(String directory, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: generate_mem_files [-force] [-quiet] [-verbose] <directory>
			this.Entry(_builder.generate_mem_files(directory, force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Generate PBLOCK by exclude static<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: generate_pblock [-cell &lt;arg&gt;] [-inverse_pblock &lt;arg&gt;] [-nested_pblock &lt;arg&gt;] [-nested_width &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 544<br/>
		/// </para>
		/// </summary>
		/// <param name="cell">(Optional) Specify cell to add to pblock.</param>
		/// <param name="inverse_pblock">
		/// <para>
		/// (Optional)<br/>
		/// Specify name of the inverse pblock. The pblock will cover<br/>
		/// everything that the static pblock does not.<br/>
		/// </para>
		/// </param>
		/// <param name="nested_pblock">
		/// <para>
		/// (Optional)<br/>
		/// Specify name of nested pblock inside inverse_pblock left<br/>
		/// adjacent to static pblock.<br/>
		/// </para>
		/// </param>
		/// <param name="nested_width">
		/// <para>
		/// (Optional)<br/>
		/// Specify the width of the nested pblock. The nested pblock<br/>
		/// height is the same as the adjacent static pblock. Default: 3<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL generate_pblock(String cell = null, String inverse_pblock = null, String nested_pblock = null, String nested_width = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: generate_pblock [-cell <arg>] [-inverse_pblock <arg>] [-nested_pblock <arg>] [-nested_width <arg>] [-quiet] [-verbose]
			this.Entry(_builder.generate_pblock(cell, inverse_pblock, nested_pblock, nested_width, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Generate output products for peripheral object.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: generate_peripheral [-driver] [-example_design] [-bfm_example_design] [-debug_hw_example_design] [-enable_interrupt] [-force] [-quiet] [-verbose] &lt;peripheral&gt;
		/// <br/>
		/// <para>
		/// Generate the output products for the specified peripheral object. The output products are<br/>
		/// written to the IP repository location specified when the IP is created by the<br/>
		/// create_peripheral command, under the name of the IP as specified at creation.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 545<br/>
		/// </para>
		/// </summary>
		/// <param name="peripheral">(Required) peripheral object</param>
		/// <param name="driver">(Optional) Generate driver for peripheral.</param>
		/// <param name="example_design">(Optional) Generate all supported example designs for peripheral.</param>
		/// <param name="bfm_example_design">(Optional) Generate bfm simulation example design for peripheral.</param>
		/// <param name="debug_hw_example_design">(Optional) Generate debug hardware example design for peripheral.</param>
		/// <param name="enable_interrupt">(Optional) Generate peripheral with interrupt suppport.</param>
		/// <param name="force">(Optional) Overwrite the existing IP in the repository.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL generate_peripheral(String peripheral, bool? driver = null, bool? example_design = null, bool? bfm_example_design = null, bool? debug_hw_example_design = null, bool? enable_interrupt = null, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: generate_peripheral [-driver] [-example_design] [-bfm_example_design] [-debug_hw_example_design] [-enable_interrupt] [-force] [-quiet] [-verbose] <peripheral>
			this.Entry(_builder.generate_peripheral(peripheral, driver, example_design, bfm_example_design, debug_hw_example_design, enable_interrupt, force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Generate a set of configurable report objects<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: generate_reports [-jobs &lt;arg&gt;] [-quiet] [-verbose] &lt;report_configs&gt;...
		/// <br/>
		/// <para>
		/// Generates specified report objects as created by the create_report_config command.<br/>
		/// Because the report objects are associated with specific steps of synthesis or implementation<br/>
		/// runs, those steps must be completed prior to the generation of the report. If a step is not<br/>
		/// completed, or the report is not enabled, then the generate_report command will return an<br/>
		/// error.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example generates the specified report object:<br/>
		/// generate_report [get_report_configs post_route_datasheet]<br/>
		/// TIP: If the report is already GENERATED according to the STATE property, the report will not be<br/>
		/// regenerated.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 548<br/>
		/// </para>
		/// </summary>
		/// <param name="report_configs">(Required) List of configurable report objects to generate</param>
		/// <param name="jobs">(Optional) Number of jobs Default: 1</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL generate_reports(TCLParameterList report_configs, Int32? jobs = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: generate_reports [-jobs <arg>] [-quiet] [-verbose] <report_configs>...
			this.Entry(_builder.generate_reports(report_configs, jobs, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Generate new platform based on base platform and wrapper module<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: generate_rl_platform [-use_source &lt;arg&gt;] [-reconfig_platform &lt;arg&gt;] [-base_platform &lt;arg&gt;] [-platform &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 550<br/>
		/// </para>
		/// </summary>
		/// <param name="use_source">(Optional) Specify wrapper checkpoint path</param>
		/// <param name="reconfig_platform">(Optional) (Required) Specify reconfigurable platform module name</param>
		/// <param name="base_platform">(Optional) (Required) Specify base platform checkpoint path</param>
		/// <param name="platform">
		/// <para>
		/// (Optional)<br/>
		/// (Optional) Specify new platform checkpoint path, the default<br/>
		/// file name is 'rl_platform.dcp'<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL generate_rl_platform(String use_source = null, String reconfig_platform = null, String base_platform = null, String platform = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: generate_rl_platform [-use_source <arg>] [-reconfig_platform <arg>] [-base_platform <arg>] [-platform <arg>] [-quiet] [-verbose]
			this.Entry(_builder.generate_rl_platform(use_source, reconfig_platform, base_platform, platform, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Move HD.RECONFIGURABLE and related properties to sub-cells<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: generate_shx_platform [-base_platform &lt;arg&gt;] [-wrapper &lt;arg&gt;] [-output &lt;arg&gt;] [-reconfig_platform &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 551<br/>
		/// </para>
		/// </summary>
		/// <param name="base_platform">(Optional) Specify Base Platform DCP path.</param>
		/// <param name="wrapper">(Optional) Specify wrapper DCP path</param>
		/// <param name="output">(Optional) Specify output DCP name.</param>
		/// <param name="reconfig_platform">(Optional) Specify reconfigurable platform name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL generate_shx_platform(String base_platform = null, String wrapper = null, String output = null, String reconfig_platform = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: generate_shx_platform [-base_platform <arg>] [-wrapper <arg>] [-output <arg>] [-reconfig_platform <arg>] [-quiet] [-verbose]
			this.Entry(_builder.generate_shx_platform(base_platform, wrapper, output, reconfig_platform, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Generate target data for the specified source<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: generate_target [-force] [-quiet] [-verbose] &lt;name&gt; &lt;objects&gt;
		/// <br/>
		/// <para>
		/// This command generates target data for the specified IP objects (get_ips) or source file for IP<br/>
		/// cores (.xci and .xco), DSP modules (.slx or .mdl), or block designs (.bd). The target data<br/>
		/// that is generated are the files necessary to support the IP or block design through the FPGA<br/>
		/// design flow.<br/>
		/// The instantiation template, synthesis netlist, and simulation netlist are standard targets. However,<br/>
		/// each IP in the catalog may also support its own set of targets. You can view the available targets<br/>
		/// on an object by examining the SUPPORTED_TARGETS property, or you can use the<br/>
		/// list_targets command to list the targets for design source file.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// This example generates the change log for all of the IP cores in the current project, forcing<br/>
		/// regeneration of any targets that are up-to-date:<br/>
		/// generate_target changelog [get_ips] -force<br/>
		/// The following example generates the instantiation template and synthesis targets for all of the IP<br/>
		/// cores in the current project:<br/>
		/// generate_target {instantiation_template synthesis} [get_ips]<br/>
		/// TIP: Note the use of the braces to pass the list of targets to the command. The absence of the -force<br/>
		/// option means that only out-of-date targets will be regenerated.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example generates all targets for the specified block design:<br/>
		/// generate_target all \<br/>
		/// [get_files C:/Data/project_mb/project_mb.srcs/sources_1/bd/base_mb/<br/>
		/// base_mb.bd]<br/>
		/// IMPORTANT! The use of get_ips is not supported to generate targets for individual IP within block<br/>
		/// designs. The tool will return an error.<br/>
		/// The following queries the SUPPORTED_TARGETS property of the specified IP object, and then<br/>
		/// generates the example project for the IP:<br/>
		/// get_property SUPPORTED_TARGETS [get_ips blk_mem*]<br/>
		/// open_example_project -dir C:/Data/examples -force [get_ips blk_mem*]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 552<br/>
		/// </para>
		/// </summary>
		/// <param name="name">
		/// <para>
		/// (Required)<br/>
		/// List of targets to be generated, or 'all' to generate all<br/>
		/// supported targets<br/>
		/// </para>
		/// </param>
		/// <param name="objects">(Required) The objects for which data needs to be generated</param>
		/// <param name="force">(Optional) Force target data regeneration</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL generate_target(String name, String objects, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: generate_target [-force] [-quiet] [-verbose] <name> <objects>
			this.Entry(_builder.generate_target(name, objects, force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of segments<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_bd_addr_segs [-regexp] [-hierarchical] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-excluded] [-addressed] [-unaddressed] [-addressing] [-addressables] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Get a list of address segments in the current IP integrator subsystem design.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets the address segments of the specified address spaces:<br/>
		/// get_bd_addr_segs -of_objects [get_bd_addr_spaces -of_objects \<br/>
		/// [get_bd_cells /microblaze_1]]<br/>
		/// /microblaze_1/Data/SEG1<br/>
		/// /microblaze_1/Data/SEG3<br/>
		/// /microblaze_1/Instruction/SEG2<br/>
		/// Note: If there are no objects matching the pattern you will get a warning.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 555<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="hierarchical">(Optional) Hierarchical cells included</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get segments of these segments, interfaces, or registers</param>
		/// <param name="excluded">(Optional) Get excluded mapped segments -of_objects</param>
		/// <param name="addressed">(Optional) Get addressed segments of given -of_objects</param>
		/// <param name="unaddressed">(Optional) Get unaddressed segments of given objects</param>
		/// <param name="addressing">(Optional) Get addressing segments of given -of_objects</param>
		/// <param name="addressables">(Optional) Get addressable segments of given -of_objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match engine names against patterns Default: *</param>
		/// <returns>List of segment objects, "" if failed.</returns>
		public VivadoTCL get_bd_addr_segs(bool? regexp = null, bool? hierarchical = null, String filter = null, TCLParameterList of_objects = null, bool? excluded = null, bool? addressed = null, bool? unaddressed = null, bool? addressing = null, bool? addressables = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_bd_addr_segs [-regexp] [-hierarchical] [-filter <arg>] [-of_objects <args>] [-excluded] [-addressed] [-unaddressed] [-addressing] [-addressables] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_bd_addr_segs(regexp, hierarchical, filter, of_objects, excluded, addressed, unaddressed, addressing, addressables, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of addr_spaces<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_bd_addr_spaces [-regexp] [-hierarchical] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Get a list of address spaces in the current IP integrator subsystem design.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example lists all of the address spaces in the current IP integrator subsystem<br/>
		/// design, listing one per line:<br/>
		/// join [get_bd_addr_spaces] \n<br/>
		/// /mdm_1/S_AXI<br/>
		/// /microblaze_1/Data<br/>
		/// /microblaze_1/Instruction<br/>
		/// /microblaze_1_axi_intc/s_axi<br/>
		/// /microblaze_1_local_memory/dlmb_bram_if_cntlr/SLMB<br/>
		/// /microblaze_1_local_memory/dlmb_bram_if_cntlr/SLMB1<br/>
		/// /microblaze_1_local_memory/dlmb_bram_if_cntlr/SLMB2<br/>
		/// /microblaze_1_local_memory/dlmb_bram_if_cntlr/SLMB3<br/>
		/// /microblaze_1_local_memory/dlmb_bram_if_cntlr/S_AXI_CTRL<br/>
		/// /microblaze_1_local_memory/ilmb_bram_if_cntlr/SLMB<br/>
		/// /microblaze_1_local_memory/ilmb_bram_if_cntlr/SLMB1<br/>
		/// /microblaze_1_local_memory/ilmb_bram_if_cntlr/SLMB2<br/>
		/// /microblaze_1_local_memory/ilmb_bram_if_cntlr/SLMB3<br/>
		/// /microblaze_1_local_memory/ilmb_bram_if_cntlr/S_AXI_CTRL<br/>
		/// /microblaze_1_local_memory/lmb_bram/S_1<br/>
		/// Note: If there are no objects matching the pattern you will get a warning.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example returns all of the properties attached to the third in a list, or index 2, of all<br/>
		/// address spaces in the current subsystem design:<br/>
		/// report_property -all [lindex [get_bd_addr_spaces] 2 ]<br/>
		/// Property Type Read-only Visible Value<br/>
		/// CLASS string true true bd_addr_space<br/>
		/// NAME string false true /microblaze_1/Instruction<br/>
		/// OFFSET string false true<br/>
		/// PATH string true true /microblaze_1/Instruction<br/>
		/// RANGE string false true -1<br/>
		/// TYPE string false true<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 559<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="hierarchical">(Optional) Hierarchical cells included</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get addr_spaces of these segments or interfaces</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match engine names against patterns Default: *</param>
		/// <returns>List of addr_space objects, "" if failed.</returns>
		public VivadoTCL get_bd_addr_spaces(bool? regexp = null, bool? hierarchical = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_bd_addr_spaces [-regexp] [-hierarchical] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_bd_addr_spaces(regexp, hierarchical, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of block diagram cells<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_bd_cells [-regexp] [-hierarchical] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Get a list of cells in the current IP integrator subsystem design, or current subsystem instance. IP<br/>
		/// integrator subsystem cells are either IP cores drawn from the IP integrator catalog, or hierarchical<br/>
		/// modules created in the subsystem design with the create_bd_cell command.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets a list of cells that include the specified IP integrator subsystem pin,<br/>
		/// and sorts the list to remove duplicate entries:<br/>
		/// lsort -unique [get_bd_cells -of_objects [get_bd_pins -hierarchical *aclk*]]<br/>
		/// Note: If there are no cells matching the pattern you will get a warning.<br/>
		/// The following example gets a list of all cells in all levels of the subsystem design hierarchy, and<br/>
		/// then filters the list to include only those cells whose name includes the specified text, or<br/>
		/// hierarchy:<br/>
		/// get_bd_cells -hierarchical -filter {NAME=~"/newMod1/*"}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 563<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="hierarchical">(Optional) Hierarchical cells included</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get cells of these pins or nets</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match engine names against patterns Default: *</param>
		/// <returns>List of block diagram cell objects, "" if failed.</returns>
		public VivadoTCL get_bd_cells(bool? regexp = null, bool? hierarchical = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_bd_cells [-regexp] [-hierarchical] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_bd_cells(regexp, hierarchical, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of designs<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_bd_designs [-regexp] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;...]
		/// <br/>
		/// <para>
		/// Gets a list of IP subsystem designs open in the current project that match a specified search<br/>
		/// pattern. The default command gets a list of all open IP subsystem designs in the project.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets all open IP subsystem designs in the current project:<br/>
		/// get_bd_designs<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 567<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get diagrams of these bd-cells or pins or nets</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match engine names against patterns Default: *</param>
		/// <returns>List of design objects, "" if failed.</returns>
		public VivadoTCL get_bd_designs(bool? regexp = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, TCLParameterList patterns = null)
		{
			// TCL Syntax: get_bd_designs [-regexp] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
			this.Entry(_builder.get_bd_designs(regexp, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of intf_nets<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_bd_intf_nets [-regexp] [-hierarchical] [-filter &lt;arg&gt;] [-boundary_type &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of interface nets in the current IP integrator subsystem design that match a specified<br/>
		/// search pattern. The default command gets a list of all interface nets in the subsystem design.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets the interface net attached to the specified pin of an IP integrator<br/>
		/// hierarchical module, and returns both the net at the level of the hierarchical module, and the net<br/>
		/// inside the hierarchical module:<br/>
		/// get_bd_intf_nets -boundary_type both -of_objects [get_bd_pins /newMod1/aclk]<br/>
		/// Note: If there are no interface nets matching the pattern you will get a warning.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example returns a list of all interface nets at all levels of the IP integrator<br/>
		/// subsystem design hierarchy:<br/>
		/// get_bd_intf_nets -hierarchical<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 570<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="hierarchical">(Optional) Hierarchical cells included</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="boundary_type">
		/// <para>
		/// (Optional)<br/>
		/// Used when source object is on a hierarchical block's<br/>
		/// interface pin. Valid values are 'upper', 'lower', or 'both'. If<br/>
		/// 'lower' boundary, searches from the lower level of hierarchy<br/>
		/// onwards. This option is only valid for connected_to relations.<br/>
		/// </para>
		/// </param>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// One or a list of cells or interface pins/ports objects. List<br/>
		/// must be of one object type.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match engine names against patterns Default: *</param>
		/// <returns>List of pin objects, "" if failed.</returns>
		public VivadoTCL get_bd_intf_nets(bool? regexp = null, bool? hierarchical = null, String filter = null, String boundary_type = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_bd_intf_nets [-regexp] [-hierarchical] [-filter <arg>] [-boundary_type <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_bd_intf_nets(regexp, hierarchical, filter, boundary_type, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of intf_pins<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_bd_intf_pins [-regexp] [-hierarchical] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of interface pin objects on the current IP subsystem design that match a specified<br/>
		/// search pattern. The default command gets a list of all interface pins in the subsystem design.<br/>
		/// The external connections of an IP integrator cell, or hierarchical module, are pins and interface<br/>
		/// pins. The external connections in an IP subsystem design are ports, or interface ports. Use the<br/>
		/// get_bd_ports and get_bd_intf_ports commands to select the port objects.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets a list of interface pins attached to the specified cell:<br/>
		/// get_bd_intf_pins -of [get_bd_cells new_vidOut_1]<br/>
		/// Note: If there are no interface pins matching the pattern, the tool will return a warning.<br/>
		/// The following example gets a list of all interface pins, throughout the hierarchy of the IP<br/>
		/// integrator subsystem design, which match the specified name pattern:<br/>
		/// get_bd_intf_pins -hierarchical m_apb*<br/>
		/// The following example gets a list of interface pins attached to the specified subsystem net:<br/>
		/// get_bd_intf_pins -of [get_bd_intf_nets vidout_1_vtg_ce]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 574<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="hierarchical">(Optional) Hierarchical cells included</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// One or a list of cells, interface nets or pins objects. List must<br/>
		/// be of one object type.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match engine names against patterns Default: *</param>
		/// <returns>List of pin objects, "" if failed.</returns>
		public VivadoTCL get_bd_intf_pins(bool? regexp = null, bool? hierarchical = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_bd_intf_pins [-regexp] [-hierarchical] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_bd_intf_pins(regexp, hierarchical, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of intf_ports<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_bd_intf_ports [-regexp] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of interface port objects in the current IP integrator subsystem design that match a<br/>
		/// specified search pattern. The default command gets a list of all interface ports in the subsystem<br/>
		/// design.<br/>
		/// The external connections in an IP subsystem design are ports, or interface ports. The external<br/>
		/// connections in an IP integrator cell, or hierarchical module, are pins and interface pins. Use the<br/>
		/// get_bd_pins and get_bd_intf_pins commands to select the pin objects.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets the interface ports in the subsystem design that operate in Master<br/>
		/// mode:<br/>
		/// get_bd_intf_ports -filter {MODE=="master"}<br/>
		/// Note: If there are no interface ports matching the pattern, the tool will return a warning.<br/>
		/// This example returns the block design interface port that the specified bd_port is part of:<br/>
		/// get_bd_intf_ports -of [get_bd_ports sys_diff_clock_clk_n]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 578<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) One or a list of interface nets or ports objects.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match engine names against patterns Default: *</param>
		/// <returns>List of port objects, "" if failed.</returns>
		public VivadoTCL get_bd_intf_ports(bool? regexp = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_bd_intf_ports [-regexp] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_bd_intf_ports(regexp, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of nets<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_bd_nets [-regexp] [-hierarchical] [-filter &lt;arg&gt;] [-boundary_type &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of nets in the current IP integrator subsystem design that match a specified search<br/>
		/// pattern. The default command gets a list of all nets in the subsystem design.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets the net attached to the specified pin of an IP integrator hierarchical<br/>
		/// module, and returns both the net at the level of the hierarchical module, and the net inside the<br/>
		/// hierarchical module:<br/>
		/// get_bd_nets -boundary_type both -of_objects [get_bd_pins /newMod1/aclk]<br/>
		/// Note: If there are no nets matching the pattern you will get a warning.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example returns a list of all nets at all levels of the IP integrator subsystem design<br/>
		/// hierarchy:<br/>
		/// get_bd_nets -hierarchical<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 581<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="hierarchical">(Optional) Hierarchical cells included</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="boundary_type">
		/// <para>
		/// (Optional)<br/>
		/// Used when source object is on a hierarchical block's pin.<br/>
		/// Valid values are 'upper', 'lower', or 'both'. If 'lower'<br/>
		/// boundary, searches from the lower level of hierarchy<br/>
		/// onwards. This option is only valid for connected_to relations.<br/>
		/// </para>
		/// </param>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// One or a list of cells or pins/ports objects. List must be of<br/>
		/// one object type.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match engine names against patterns Default: *</param>
		/// <returns>List of pin objects, "" if failed.</returns>
		public VivadoTCL get_bd_nets(bool? regexp = null, bool? hierarchical = null, String filter = null, String boundary_type = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_bd_nets [-regexp] [-hierarchical] [-filter <arg>] [-boundary_type <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_bd_nets(regexp, hierarchical, filter, boundary_type, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of pins<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_bd_pins [-regexp] [-hierarchical] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of pin objects on the current IP subsystem design that match a specified search<br/>
		/// pattern. The default command gets a list of all pins in the subsystem design.<br/>
		/// The external connections in an IP integrator cell, or hierarchical module, are pins and interface<br/>
		/// pins. The external connections in an IP subsystem design are ports, or interface ports. Use the<br/>
		/// get_bd_ports and get_bd_intf_ports commands to select the port objects.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets a list of pins attached to the specified cell:<br/>
		/// get_bd_pins -of [get_bd_cells new_vidOut_1]<br/>
		/// Note: If there are no pins matching the pattern, the tool will return a warning.<br/>
		/// The following example gets a list of all pins, throughout the hierarchy of the IP integrator<br/>
		/// subsystem design, which match the specified name pattern:<br/>
		/// get_bd_pins -hierarchical LMB*<br/>
		/// The following example gets a list of pins attached to the specified subsystem net:<br/>
		/// get_bd_pins -of [get_bd_nets vidout_1_vtg_ce]<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 585<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="hierarchical">(Optional) Hierarchical cells included</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// One or a list of cells, nets or interface pins objects. List must<br/>
		/// be of one object type.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match engine names against patterns Default: *</param>
		/// <returns>List of pin objects, "" if failed.</returns>
		public VivadoTCL get_bd_pins(bool? regexp = null, bool? hierarchical = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_bd_pins [-regexp] [-hierarchical] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_bd_pins(regexp, hierarchical, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of ports<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_bd_ports [-regexp] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of port objects in the current IP integrator subsystem design that match a specified<br/>
		/// search pattern. The default command gets a list of all ports in the subsystem design.<br/>
		/// The external connections in an IP subsystem design are ports, or interface ports. The external<br/>
		/// connections in an IP integrator cell, or hierarchical module, are pins and interface pins. Use the<br/>
		/// get_bd_pins and get_bd_intf_pins commands to select the pin objects.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets the ports connected to the specified IP subsystem net:<br/>
		/// get_bd_ports -of_objects [get_bd_nets bridge_1_apb_m]<br/>
		/// Note: If there are no ports matching the pattern, the tool will return a warning.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 589<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) One or a list of nets or interface ports objects.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match engine names against patterns Default: *</param>
		/// <returns>List of port objects, "" if failed.</returns>
		public VivadoTCL get_bd_ports(bool? regexp = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_bd_ports [-regexp] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_bd_ports(regexp, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of registers<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_bd_regs [-of_objects &lt;args&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Get a list of registers using the objects of address segments, interface pins, and external interface<br/>
		/// ports. The register objects will provide the register's display name and the memory offset<br/>
		/// address. There is no default behavior for this command as it requires the use of -of_objects<br/>
		/// argument with a valid value that is an object of the address segments, interface pins, or external<br/>
		/// interface ports. The command will get the registers directly from the address segment objects or<br/>
		/// from address segments associated with the specified interface pin or interface port objects.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates an external interface pin, assigns an address space, and then gets<br/>
		/// the registers associated with that address space:<br/>
		/// % create_bd_cell -type ip -vlnv xilinx.com:ip:axi_gpio:2.0 axi_gpio_0<br/>
		/// % make_bd_intf_pins_external [get_bd_intf_pins axi_gpio_0/S_AXI]<br/>
		/// % assign_bd_address<br/>
		/// % get_bd_addr_segs<br/>
		/// /axi_gpio_0/S_AXI/Reg /S_AXI_0/SEG_axi_gpio_0_Reg<br/>
		/// % set seg [get_bd_addr_segs /axi_gpio_0/S_AXI/Reg]<br/>
		/// /axi_gpio_0/S_AXI/Reg<br/>
		/// % get_bd_regs -of_objects $seg<br/>
		/// GPIO_DATA GPIO_TRI GPIO2_DATA GPIO2_TRI GIER IP_IER IP_ISR<br/>
		/// %set regs [get_bd_regs -of_objects $seg]<br/>
		/// GPIO_DATA GPIO_TRI GPIO2_DATA GPIO2_TRI GIER IP_IER IP_ISR<br/>
		/// % set reg [lindex $regs 0]<br/>
		/// GPIO_DATA<br/>
		/// % report_property $reg<br/>
		/// Property Type Read-only Visible Value<br/>
		/// CLASS string true true bd_reg<br/>
		/// DISPLAYNAME string true true Channel_1_GPIO_DATA<br/>
		/// NAME string true true GPIO_DATA<br/>
		/// OFFSET string true true 0x0<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 592<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">(Required) Get registers of segments, interface pins, external interface ports</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>List of register objects, "" if failed.</returns>
		public VivadoTCL get_bd_regs(TCLParameterList of_objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_bd_regs [-of_objects <args>] [-quiet] [-verbose]
			this.Entry(_builder.get_bd_regs(of_objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of bel_pins. If a design is loaded, gets the constructed site type bels.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_bel_pins [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Returns a list of pins on the specified BELs, or matching a specified search pattern.<br/>
		/// The default command gets a list of all pins on all BELs on the device.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the pins of the specified BELs associated with the specified range<br/>
		/// of sites on the device:<br/>
		/// get_bel_pins -of_objects [get_bels -of_objects [get_sites \<br/>
		/// -range {SLICE_X0Y0 SLICE_X1Y1}] ]<br/>
		/// The following example returns the clock enable (CE) pins of all BELs on the device:<br/>
		/// get_bel_pins *CE<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 594<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get the bel_pin of these bels, sites, pins, or nets.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match bel_pin against patterns Default: *</param>
		/// <returns>bel_pin</returns>
		public VivadoTCL get_bel_pins(bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_bel_pins [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_bel_pins(regexp, nocase, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of bels. If a design is loaded, gets the constructed site type bels.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_bels [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-include_routing_bels] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Basic Elements, or BELs, are building blocks of logic, such as flip-flops, LUTs, and carry logic, that<br/>
		/// make up a SLICE. This command returns a list of BELs on the target part that match a specified<br/>
		/// search pattern in an open design.<br/>
		/// The default command gets a list of all BELs on the device.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the total number of BELs on the target part:<br/>
		/// llength [get_bels]<br/>
		/// The following example returns the BELs associated with the specified site:<br/>
		/// get_bels -of_objects [get_sites PHASER_IN_PHY_X0Y5]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 597<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get the bels of these slr, tiles, sites, cells, clock_regions or nets.</param>
		/// <param name="include_routing_bels">(Optional) Also look for and include matching rbels.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match bels against patterns Default: *</param>
		/// <returns>bels</returns>
		public VivadoTCL get_bels(bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, bool? include_routing_bels = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_bels [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-include_routing_bels] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_bels(regexp, nocase, filter, of_objects, include_routing_bels, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Gets the list of board bus net objects<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_board_bus_nets [-regexp] [-nocase] [-all] [-filter &lt;arg&gt;] -of_objects &lt;args&gt; [-quiet] [-verbose] [&lt;patterns&gt;...]
		/// <br/>
		/// <para>
		/// Gets a list of individual connection bus nets of the specified connection bus object, or the board<br/>
		/// component or board component pin objects.<br/>
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite<br/>
		/// installation area, stores information regarding board attributes. The board provides a<br/>
		/// representation of the overall system that the Xilinx device is a part of, and can help define key<br/>
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.<br/>
		/// You can create custom boards by defining a custom Board Interface file, as described in the<br/>
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Connection buses define the connections between the Xilinx device (part0) and other<br/>
		/// components on the board. Bus nets define individual connections of the connection bus.<br/>
		/// This command returns a list of connection bus nets, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets the connection bus nets associated with the specified component of<br/>
		/// the current board:<br/>
		/// get_board_bus_nets -of_objects [get_board_components {*iic_main*}]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 600<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">
		/// <para>
		/// (Required)<br/>
		/// Get 'board_bus_net' objects of these types: 'board_bus<br/>
		/// board_component board_component_pin'.<br/>
		/// </para>
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="all">(Optional) Returns all enabled as well as disabled buses</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// <para>
		/// (Optional)<br/>
		/// match board net names against patterns Default: * Values:<br/>
		/// The default search pattern is the wildcard *, or .* when -<br/>
		/// regexp is specified.<br/>
		/// </para>
		/// </param>
		/// <returns>list of bus nets in the board</returns>
		public VivadoTCL get_board_bus_nets(TCLParameterList of_objects, bool? regexp = null, bool? nocase = null, bool? all = null, String filter = null, bool? quiet = null, bool? verbose = null, TCLParameterList patterns = null)
		{
			// TCL Syntax: get_board_bus_nets [-regexp] [-nocase] [-all] [-filter <arg>] -of_objects <args> [-quiet] [-verbose] [<patterns>...]
			this.Entry(_builder.get_board_bus_nets(of_objects, regexp, nocase, all, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Gets the list of board bus objects<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_board_buses [-regexp] [-nocase] [-all] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;...]
		/// <br/>
		/// <para>
		/// Gets a list of connection buses defined on the current board, as defined in the Board Interface<br/>
		/// file.<br/>
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite<br/>
		/// installation area, stores information regarding board attributes. The board provides a<br/>
		/// representation of the overall system that the Xilinx device is a part of, and can help define key<br/>
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.<br/>
		/// You can create custom boards by defining a custom Board Interface file, as described in the<br/>
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Connection buses define the connections between the Xilinx device (part0) and other<br/>
		/// components on the board.<br/>
		/// This command returns a list of buses, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets the connection buses associated with the specified component of<br/>
		/// the current board:<br/>
		/// get_board_buses -of_objects [get_board_components sgmii]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 603<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="all">(Optional) Returns all enabled as well as disabled buses</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get 'board_bus' objects of these types: 'board<br/>
		/// board_component board_bus_net'.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// <para>
		/// (Optional)<br/>
		/// match board bus names against patterns Default: * Values:<br/>
		/// The default search pattern is the wildcard *, or .* when -<br/>
		/// regexp is specified.<br/>
		/// </para>
		/// </param>
		/// <returns>list of buses in the board</returns>
		public VivadoTCL get_board_buses(bool? regexp = null, bool? nocase = null, bool? all = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, TCLParameterList patterns = null)
		{
			// TCL Syntax: get_board_buses [-regexp] [-nocase] [-all] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
			this.Entry(_builder.get_board_buses(regexp, nocase, all, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Gets the list of interfaces in the board components that implement busdef specified by VLNV<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_board_component_interfaces [-regexp] [-nocase] [-all] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;...]
		/// <br/>
		/// <para>
		/// Gets a list of interfaces defined on the components found on the current board, as defined in the<br/>
		/// Board Interface file.<br/>
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite<br/>
		/// installation area, stores information regarding board attributes. The board provides a<br/>
		/// representation of the overall system that the Xilinx device is a part of, and can help define key<br/>
		/// aspects of the design, such as clock constraints, I/O port assignments, defined components and<br/>
		/// supported interfaces. You can create custom boards by defining a custom Board Interface file, as<br/>
		/// described in the Vivado Design Suite User Guide: System-Level Design Entry (UG895).<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The component interface defines related groups of signals that are found on a component, or a<br/>
		/// component mode.<br/>
		/// This command returns a list of component interfaces, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets the component interfaces defined in the Board Interface file for the<br/>
		/// specified board component:<br/>
		/// get_board_component_interfaces -of_objects [get_board_components *part0*]<br/>
		/// The following example gets the component interfaces defined in the Board Interface file, and<br/>
		/// then uses that information to create interfaces in the current project:<br/>
		/// #Get and Create Interfaces for I/O Ports<br/>
		/// foreach x [get_board_component_interfaces] {<br/>
		/// create_interface $x }<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 606<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="all">(Optional) Returns all enabled as well as disabled interfaces</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get 'board_component_interface' objects of these types:<br/>
		/// 'board board_component'.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// <para>
		/// (Optional)<br/>
		/// Match Bus Interface names against patterns Default: *<br/>
		/// Values: The default search pattern is the wildcard *, or .*<br/>
		/// when -regexp is specified.<br/>
		/// </para>
		/// </param>
		/// <returns>list of bus interfaces</returns>
		public VivadoTCL get_board_component_interfaces(bool? regexp = null, bool? nocase = null, bool? all = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, TCLParameterList patterns = null)
		{
			// TCL Syntax: get_board_component_interfaces [-regexp] [-nocase] [-all] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
			this.Entry(_builder.get_board_component_interfaces(regexp, nocase, all, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Gets the list of component mode objects<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_board_component_modes [-regexp] [-nocase] [-all] [-filter &lt;arg&gt;] -of_objects &lt;args&gt; [-quiet] [-verbose] [&lt;patterns&gt;...]
		/// <br/>
		/// <para>
		/// Gets a list of various component modes defined on the current board, as defined in the Board<br/>
		/// Interface file.<br/>
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite<br/>
		/// installation area, stores information regarding board attributes. The board provides a<br/>
		/// representation of the overall system that the Xilinx device is a part of, and can help define key<br/>
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.<br/>
		/// You can create custom boards by defining a custom Board Interface file, as described in the<br/>
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The component mode defines various modes of operations that the components on a board may<br/>
		/// have, and the interfaces and preferred IP of those modes.<br/>
		/// This command returns a list of component modes, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets the component modes defined in the Board Interface file of the<br/>
		/// specified board:<br/>
		/// get_board_component_modes -of_objects [get_board_components *part0*]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 609<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">(Required) Get 'board_component_mode' objects of these types: 'board_component'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="all">(Optional) Returns all enabled as well as disabled interfaces</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// <para>
		/// (Optional)<br/>
		/// match board component modes against patterns Default: *<br/>
		/// Values: The default search pattern is the wildcard *, or .*<br/>
		/// when -regexp is specified.<br/>
		/// </para>
		/// </param>
		/// <returns>list of component modes in the board</returns>
		public VivadoTCL get_board_component_modes(TCLParameterList of_objects, bool? regexp = null, bool? nocase = null, bool? all = null, String filter = null, bool? quiet = null, bool? verbose = null, TCLParameterList patterns = null)
		{
			// TCL Syntax: get_board_component_modes [-regexp] [-nocase] [-all] [-filter <arg>] -of_objects <args> [-quiet] [-verbose] [<patterns>...]
			this.Entry(_builder.get_board_component_modes(of_objects, regexp, nocase, all, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Gets the list of board_part pins object<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_board_component_pins [-regexp] [-nocase] [-filter &lt;arg&gt;] -of_objects &lt;args&gt; [-quiet] [-verbose] [&lt;patterns&gt;...]
		/// <br/>
		/// <para>
		/// Gets a list of individual board component pins of the specified board component object of the<br/>
		/// current_board.<br/>
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite<br/>
		/// installation area, stores information regarding board attributes. The board provides a<br/>
		/// representation of the overall system that the Xilinx device is a part of, and can help define key<br/>
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.<br/>
		/// You can create custom boards by defining a custom Board Interface file, as described in the<br/>
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).<br/>
		/// Board components define the list of components found on the board defined by the Board<br/>
		/// Interface file. Component pins enumerate the individual pins of the component.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This command returns a list of component pin objects, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets the component pins associated with the specified Xilinx device<br/>
		/// (part0) component object of the current board:<br/>
		/// get_board_component_pins -of_objects [get_board_components *part0*]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 612<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">
		/// <para>
		/// (Required)<br/>
		/// Get 'board_component_pin' objects of these types:<br/>
		/// 'board_component board_bus_net'.<br/>
		/// </para>
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// <para>
		/// (Optional)<br/>
		/// match board component pin names against patterns<br/>
		/// Default: * Values: The default search pattern is the wildcard<br/>
		/// *, or .* when -regexp is specified.<br/>
		/// </para>
		/// </param>
		/// <returns>list of pins in the board_part</returns>
		public VivadoTCL get_board_component_pins(TCLParameterList of_objects, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, TCLParameterList patterns = null)
		{
			// TCL Syntax: get_board_component_pins [-regexp] [-nocase] [-filter <arg>] -of_objects <args> [-quiet] [-verbose] [<patterns>...]
			this.Entry(_builder.get_board_component_pins(of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get the list of components available in the board<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_board_components [-regexp] [-nocase] [-all] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;...]
		/// <br/>
		/// <para>
		/// Gets a list of components defined on the current board, as defined in the Board Interface file.<br/>
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite<br/>
		/// installation area, stores information regarding board attributes. The board provides a<br/>
		/// representation of the overall system that the Xilinx device is a part of, and can help define key<br/>
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.<br/>
		/// You can create custom boards by defining a custom Board Interface file, as described in the<br/>
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).<br/>
		/// This command returns a list of components, or returns an error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets the components defined in the Board Interface file of the specified<br/>
		/// board:<br/>
		/// get_board_components -of_objects [get_boards zed]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 615<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="all">(Optional) Returns all enabled as well as disabled components</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get 'board_component' objects of these types: 'board<br/>
		/// board_bus board_component_pin'.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// <para>
		/// (Optional)<br/>
		/// Match component names against patterns Default: *<br/>
		/// Values: The default search pattern is the wildcard *, or .*<br/>
		/// when -regexp is specified.<br/>
		/// </para>
		/// </param>
		/// <returns>list of component objects</returns>
		public VivadoTCL get_board_components(bool? regexp = null, bool? nocase = null, bool? all = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, TCLParameterList patterns = null)
		{
			// TCL Syntax: get_board_components [-regexp] [-nocase] [-all] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
			this.Entry(_builder.get_board_components(regexp, nocase, all, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Gets the list of interface ports object<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_board_interface_ports [-regexp] [-nocase] [-filter &lt;arg&gt;] -of_objects &lt;args&gt; [-quiet] [-verbose] [&lt;patterns&gt;...]
		/// <br/>
		/// <para>
		/// Gets a list of various physical ports assigned to the component interfaces defined on the current<br/>
		/// board, as defined in the Board Interface file. The interface ports can be returned from component<br/>
		/// interfaces as specified by the get_board_component_interfaces command, or from the<br/>
		/// component pins returned by get_board_component_pins.<br/>
		/// The Board Interface file, board.xml located in the data/boards folder of the Vivado Design<br/>
		/// Suite installation area, stores information regarding board attributes. The board provides a<br/>
		/// representation of the overall system that the Xilinx device is a part of, and can help define key<br/>
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.<br/>
		/// You can create custom boards by defining a custom Board Interface file, as described in the<br/>
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// In the Board Interface file, a component interface includes a map of the logical ports, that are<br/>
		/// defined in the interface file, with a physical port that relates to the component pin or pins on the<br/>
		/// Xilinx device (part0).<br/>
		/// This command returns a list of the physical ports of the specified component interface, or returns<br/>
		/// an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets the board interface ports defined in the Board Interface file for the<br/>
		/// specified board component:<br/>
		/// get_board_interface_ports -of_objects \<br/>
		/// [get_board_component_interfaces *gmii*]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 618<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">
		/// <para>
		/// (Required)<br/>
		/// Get 'board_component_pin' objects of these types:<br/>
		/// 'board_component_interface board_component_pin'.<br/>
		/// </para>
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// <para>
		/// (Optional)<br/>
		/// match interface port names against patterns Default: *<br/>
		/// Values: The default search pattern is the wildcard *, or .*<br/>
		/// when -regexp is specified.<br/>
		/// </para>
		/// </param>
		/// <returns>list of ports in the given interface</returns>
		public VivadoTCL get_board_interface_ports(TCLParameterList of_objects, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, TCLParameterList patterns = null)
		{
			// TCL Syntax: get_board_interface_ports [-regexp] [-nocase] [-filter <arg>] -of_objects <args> [-quiet] [-verbose] [<patterns>...]
			this.Entry(_builder.get_board_interface_ports(of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Gets the list of ip preference objects<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_board_ip_preferences [-regexp] [-nocase] [-filter &lt;arg&gt;] -of_objects &lt;args&gt; [-quiet] [-verbose] [&lt;patterns&gt;...]
		/// <br/>
		/// <para>
		/// Gets a list of IP preferences defined on the current board, as defined in the Board Interface file.<br/>
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite<br/>
		/// installation area, stores information regarding board attributes. The board provides a<br/>
		/// representation of the overall system that the Xilinx device is a part of, and can help define key<br/>
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.<br/>
		/// You can create custom boards by defining a custom Board Interface file, as described in the<br/>
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).<br/>
		/// IP preferences define the preferred IP to connect a component interface to in the Board Interface<br/>
		/// file.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This command returns a list of preferred IP for specified component interfaces, or component<br/>
		/// modes, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets the IP preferences of the specified component interfaces:<br/>
		/// get_board_ip_preferences -of_objects \<br/>
		/// [get_board_component_interfaces *clock*]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 621<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">
		/// <para>
		/// (Required)<br/>
		/// Get 'ip_preference' objects of these types:<br/>
		/// 'board_component_mode board_component_interface'.<br/>
		/// </para>
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// <para>
		/// (Optional)<br/>
		/// match ip preferences against patterns Default: * Values: The<br/>
		/// default search pattern is the wildcard *, or .* when -regexp<br/>
		/// is specified.<br/>
		/// </para>
		/// </param>
		/// <returns>list of ip preferences for the component</returns>
		public VivadoTCL get_board_ip_preferences(TCLParameterList of_objects, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, TCLParameterList patterns = null)
		{
			// TCL Syntax: get_board_ip_preferences [-regexp] [-nocase] [-filter <arg>] -of_objects <args> [-quiet] [-verbose] [<patterns>...]
			this.Entry(_builder.get_board_ip_preferences(of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Gets the list of board jumper objects<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_board_jumpers [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;...]
		/// <br/>
		/// <para>
		/// Gets a list of jumpers defined on the current board, as defined in the Board Interface file.<br/>
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite<br/>
		/// installation area, stores information regarding board attributes. The board provides a<br/>
		/// representation of the overall system that the Xilinx device is a part of, and can help define key<br/>
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.<br/>
		/// You can create custom boards by defining a custom Board Interface file, as described in the<br/>
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).<br/>
		/// The jumpers defined in the board file can be used to enable specific component modes and<br/>
		/// interfaces of the board.<br/>
		/// This command returns a list of jumpers, or returns an error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets the jumpers defined in the Board Interface file of the specified board:<br/>
		/// get_board_jumpers -of_objects [get_boards kc705]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 624<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get 'board_jumper' objects of these types: 'board'.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// <para>
		/// (Optional)<br/>
		/// match jumper names against patterns Default: * Values:<br/>
		/// The default search pattern is the wildcard *, or .* when -<br/>
		/// regexp is specified.<br/>
		/// </para>
		/// </param>
		/// <returns>list of jumpers in the board</returns>
		public VivadoTCL get_board_jumpers(bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, TCLParameterList patterns = null)
		{
			// TCL Syntax: get_board_jumpers [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
			this.Entry(_builder.get_board_jumpers(regexp, nocase, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Gets the list of board parameter objects<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_board_parameters [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;...]
		/// <br/>
		/// <para>
		/// Gets a list of parameters defined on the current board, as defined in the Board Interface file.<br/>
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite<br/>
		/// installation area, stores information regarding board attributes. The board provides a<br/>
		/// representation of the overall system that the Xilinx device is a part of, and can help define key<br/>
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.<br/>
		/// You can create custom boards by defining a custom Board Interface file, as described in the<br/>
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).<br/>
		/// The parameters defined in the board file specify custom or user-defined characteristics of the<br/>
		/// board.<br/>
		/// This command returns a list of board parameters, or returns an error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets the parameters defined in the Board Interface file of the current<br/>
		/// board:<br/>
		/// get_board_parameters<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 627<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get 'board_parameter' objects of these types: 'board<br/>
		/// board_component board_component_interface'.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// <para>
		/// (Optional)<br/>
		/// match parameter names against patterns Default: * Values:<br/>
		/// The default search pattern is the wildcard *, or .* when -<br/>
		/// regexp is specified.<br/>
		/// </para>
		/// </param>
		/// <returns>list of parameters in the board</returns>
		public VivadoTCL get_board_parameters(bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, TCLParameterList patterns = null)
		{
			// TCL Syntax: get_board_parameters [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
			this.Entry(_builder.get_board_parameters(regexp, nocase, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Gets the list of interfaces in the board_part that implement busdef specified by VLNV<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_board_part_interfaces [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;...]
		/// <br/>
		/// <para>
		/// Gets a list of interfaces defined on the Xilinx device, or current board part as defined by the<br/>
		/// BOARD_PART property, on the board in use by the current project or open design.<br/>
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite<br/>
		/// installation area, stores information regarding board attributes. The board provides a<br/>
		/// representation of the overall system that the Xilinx device is a part of, and can help define key<br/>
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.<br/>
		/// You can create custom boards by defining a custom Board Interface file, as described in the<br/>
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The board part provides a representation of the Xilinx device in the context of the board-level<br/>
		/// system, and is represented by the part0 component in the Board Interface file. The<br/>
		/// current_board_part command returns the board part in use by the current project.<br/>
		/// The interfaces defined on the current board part define related groups of signals that can be used<br/>
		/// to quickly connect the elements of a block design in Vivado IP integrator, or configure IP from<br/>
		/// the Xilinx IP catalog. The interfaces available on the current_board_part can be used to<br/>
		/// define the interfaces required in an IP subsystem design, using create_bd_interface_port<br/>
		/// or create_bd_port. It can also be used to define the interfaces available in the overall FPGA<br/>
		/// design using create_interface and create_port.<br/>
		/// This command returns a list of available interfaces on the current board part, or returns an error<br/>
		/// if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets a list of all interfaces defined on the current board part:<br/>
		/// join [get_board_part_interfaces] \n<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 630<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get 'board_component_interface' objects of these types:<br/>
		/// 'board board_component'.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// <para>
		/// (Optional)<br/>
		/// Match Bus Interface names against patterns Default: *<br/>
		/// Values: The default search pattern is the wildcard *, or .*<br/>
		/// when -regexp is specified.<br/>
		/// </para>
		/// </param>
		/// <returns>list of bus interfaces</returns>
		public VivadoTCL get_board_part_interfaces(bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, TCLParameterList patterns = null)
		{
			// TCL Syntax: get_board_part_interfaces [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
			this.Entry(_builder.get_board_part_interfaces(regexp, nocase, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Gets the list of board_part pins object<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_board_part_pins [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;...]
		/// <br/>
		/// <para>
		/// Gets a list of component pin objects on the current board part in use by the current project or<br/>
		/// design.<br/>
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite<br/>
		/// installation area, stores information regarding board attributes. The board provides a<br/>
		/// representation of the overall system that the Xilinx device is a part of, and can help define key<br/>
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.<br/>
		/// You can create custom boards by defining a custom Board Interface file, as described in the<br/>
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The board part provides a representation of the Xilinx device in the context of the board-level<br/>
		/// system, and is represented by the part0 component in the Board Interface file. The<br/>
		/// current_board_part command returns the board part in use by the current project.<br/>
		/// The board part pin represents the component pin of an implemented interface on the Xilinx<br/>
		/// device. The component pin includes properties like LOC, IOSTANDARD, and SLEW. Board part<br/>
		/// pins can be scalar or vector, so it is always represented as bitwise.<br/>
		/// The board part pins can be used to define and place PORTS in the top-level FPGA design, using<br/>
		/// the create_port and set_property PACKAGE_PIN commands.<br/>
		/// This command returns a list of component pins, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// This example returns the physical pins of the specified board part interface:<br/>
		/// get_board_part_pins -of [get_board_part_interfaces push_buttons_5bits]<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example assigns the PACKAGE_PIN and IOSTANDARD properties on the specified<br/>
		/// port in the current design according to the properties on the leds_8bits pins in the current board:<br/>
		/// set_property PACKAGE_PIN [get_property LOC \<br/>
		/// [get_board_part_pins leds_8bits_TRI_O[1]]] [get_ports LEDS_n[1]]<br/>
		/// set_property IOSTANDARD [get_property IOSTANDARD \<br/>
		/// [get_board_part_pins leds_8bits_TRI_O[1]]] [get_ports LEDS_n[1]]<br/>
		/// The following example gets a list of board part pins assigned to the leds_8bits board part<br/>
		/// interface; stores those pins in a Tcl variable $boardPins, and then prints the LOC property for<br/>
		/// each of those pins:<br/>
		/// set boardPins [get_board_part_pins -of \<br/>
		/// [get_board_part_interfaces -filter {NAME == led_8bits}]]<br/>
		/// foreach pin $boardPins {puts "The location of $pin is: \<br/>
		/// [get_property LOC $pin]"}<br/>
		/// The location of leds_8bits_tri_o[0] is: AB8<br/>
		/// The location of leds_8bits_tri_o[1] is: AA8<br/>
		/// The location of leds_8bits_tri_o[2] is: AC9<br/>
		/// The location of leds_8bits_tri_o[3] is: AB9<br/>
		/// The location of leds_8bits_tri_o[4] is: AE26<br/>
		/// The location of leds_8bits_tri_o[5] is: G19<br/>
		/// The location of leds_8bits_tri_o[6] is: E18<br/>
		/// The location of leds_8bits_tri_o[7] is: F16<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 634<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get 'board_component_pin' objects of these types:<br/>
		/// 'board_component_interface board_interface_port'.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// <para>
		/// (Optional)<br/>
		/// match board_part pin names against patterns Default: *<br/>
		/// Values: The default search pattern is the wildcard *, or .*<br/>
		/// when -regexp is specified.<br/>
		/// </para>
		/// </param>
		/// <returns>list of pins in the board_part</returns>
		public VivadoTCL get_board_part_pins(bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, TCLParameterList patterns = null)
		{
			// TCL Syntax: get_board_part_pins [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
			this.Entry(_builder.get_board_part_pins(regexp, nocase, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get the list of board_part available in the project<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_board_parts [-regexp] [-nocase] [-latest_file_version] [-latest_hw_revision] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;...]
		/// <br/>
		/// <para>
		/// Gets a list of available board parts in the board repository, as defined by the Board Interface files<br/>
		/// available for use by the current project or design.<br/>
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite<br/>
		/// installation area, stores information regarding board attributes. The board provides a<br/>
		/// representation of the overall system that the Xilinx device is a part of, and can help define key<br/>
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.<br/>
		/// You can create custom boards by defining a custom Board Interface file, as described in the<br/>
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The board part provides a representation of the Xilinx device in the context of the board-level<br/>
		/// system, and is represented by the part0 component in the Board Interface file. The<br/>
		/// current_board_part command returns the board part in use by the current project. Refer to<br/>
		/// the current_board_part command for the different methods of defining the board in use.<br/>
		/// This command returns the list of available Xilinx devices (part0) in the Board Interface files<br/>
		/// defined in the current board repository, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the board parts matching the specified filter search pattern:<br/>
		/// get_board_parts -filter {BOARD_NAME=~z*}<br/>
		/// The following example returns all board parts matching the specified search patterns:<br/>
		/// get_board_parts {*av* *kc*}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 638<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="latest_file_version">(Optional) Show only latest board parts by file version</param>
		/// <param name="latest_hw_revision">(Optional) Show only latest board parts by board revision</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// <para>
		/// (Optional)<br/>
		/// Match Board Part names against patterns Default: * Values:<br/>
		/// The default search pattern is the wildcard *, or .* when -<br/>
		/// regexp is specified.<br/>
		/// </para>
		/// </param>
		/// <returns>list of board_part objects</returns>
		public VivadoTCL get_board_parts(bool? regexp = null, bool? nocase = null, bool? latest_file_version = null, bool? latest_hw_revision = null, String filter = null, bool? quiet = null, bool? verbose = null, TCLParameterList patterns = null)
		{
			// TCL Syntax: get_board_parts [-regexp] [-nocase] [-latest_file_version] [-latest_hw_revision] [-filter <arg>] [-quiet] [-verbose] [<patterns>...]
			this.Entry(_builder.get_board_parts(regexp, nocase, latest_file_version, latest_hw_revision, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get the list of boards available in the project<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_boards [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;...]
		/// <br/>
		/// <para>
		/// Gets a list of evaluation boards available for use by the current project.<br/>
		/// The board file, board.xml located in the data/boards folder of the Vivado Design Suite<br/>
		/// installation area, stores information regarding board attributes. The board provides a<br/>
		/// representation of the overall system that the Xilinx device is a part of, and can help define key<br/>
		/// aspects of the design, such as clock constraints, I/O port assignments, and supported interfaces.<br/>
		/// You can create custom boards by defining a custom Board Interface file, as described in the<br/>
		/// Vivado Design Suite User Guide: System-Level Design Entry (UG895).<br/>
		/// The board in use by the project is returned by the current_board_part command.<br/>
		/// The board can be specified:<br/>
		/// • When the project is created by selecting Boards from the Default Part dialog box.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// • By setting the BOARD property on the current project as shown in the example.<br/>
		/// • By selecting the Project Device in the Settings dialog box in an open project in the Vivado IDE.<br/>
		/// Refer to the Vivado Design Suite User Guide: System-Level Design Entry (UG895) for information on<br/>
		/// creating projects, and on configuring project settings.<br/>
		/// IMPORTANT! When you specify the board with the set_property command, the target part is also<br/>
		/// changed to match the part required by the specified BOARD property.<br/>
		/// This command returns a list of boards that are available for use by the current project, or returns<br/>
		/// an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports the properties of the specified evaluation board:<br/>
		/// report_property [get_boards -filter {LIBRARY_NAME==artix7}]<br/>
		/// The following example returns all boards matching the specified search patterns:<br/>
		/// get_boards {*ar* *kc*}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 642<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get 'board' objects of these types: 'board_component'.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// <para>
		/// (Optional)<br/>
		/// Match Board names against patterns Default: * Values: The<br/>
		/// default search pattern is the wildcard *, or .* when -regexp<br/>
		/// is specified.<br/>
		/// </para>
		/// </param>
		/// <returns>list of board objects</returns>
		public VivadoTCL get_boards(bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, TCLParameterList patterns = null)
		{
			// TCL Syntax: get_boards [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
			this.Entry(_builder.get_boards(regexp, nocase, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of CDC violations from a previous report_cdc run<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_cdc_violations [-name &lt;arg&gt;] [-regexp] [-filter &lt;arg&gt;] [-nocase] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of violation objects found in the design when the report_cdc command is run. The<br/>
		/// properties of individual violation objects can be queried using report_property or<br/>
		/// list_property commands for details of the violation.<br/>
		/// Violation objects are associated with the clock-domain crossing paths in the current design. The<br/>
		/// design objects associated with a methodology violation object can be obtained using the -<br/>
		/// of_objects option of the appropriate get_* command, such as get_cells, or get_nets<br/>
		/// for instance.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports the CDC violations found in the current design, then returns a list<br/>
		/// of all those violations:<br/>
		/// report_cdc<br/>
		/// get_cdc_violations<br/>
		/// The following example generates list of violations in the named CDC report, and then gets the<br/>
		/// pins associated with any violations found:<br/>
		/// report_cdc -name cdc_1<br/>
		/// get_pins -of_objects [get_cdc_violations -name cdc_1]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 645<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Optional) Get the results with this name</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// <para>
		/// (Optional)<br/>
		/// Match CDC violations against patterns Default: * Values: The<br/>
		/// default search pattern is the wildcard *, or .* when -regexp<br/>
		/// is specified.<br/>
		/// </para>
		/// </param>
		/// <returns>list of CDC violation objects</returns>
		public VivadoTCL get_cdc_violations(String name = null, bool? regexp = null, String filter = null, bool? nocase = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_cdc_violations [-name <arg>] [-regexp] [-filter <arg>] [-nocase] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_cdc_violations(name, regexp, filter, nocase, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of cells in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_cells [-hsc &lt;arg&gt;] [-hierarchical] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-match_style &lt;arg&gt;] [-include_replicated_objects] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of cell objects in the current design that match a specified search pattern. The default<br/>
		/// command returns a list of all cells in the current_instance of the open design, as specified by the<br/>
		/// current_instance command.<br/>
		/// You can use the -hierarchical option to extract cells from the hierarchy of the current<br/>
		/// design.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The get_cells command also includes an option to get all replicated cells that are added to a<br/>
		/// design during physical optimization, or phys_opt_design. The use of the -<br/>
		/// include_replicated_objects option returns the replicated cells of an object when the<br/>
		/// original cell is returned. You can use this option to ensure that constraints or properties that are<br/>
		/// applied to a cell are also applied to its replicated cells.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example uses regular expression to return cells in the BFT example design that<br/>
		/// match the filter expressions for NAME and REF_NAME. In the first command the NAME is<br/>
		/// specified in the search pattern, while the second command filters on the NAME property. These<br/>
		/// commands return the same results:<br/>
		/// get_cells -regexp -filter { REF_NAME =~ FD.* } .*validFor.*<br/>
		/// get_cells -regexp -filter { NAME =~ .*validFor.* &amp;&amp; REF_NAME =~ FD.* }<br/>
		/// The following example searches all levels of the hierarchy for cells beginning with cpu, or fft, and<br/>
		/// joins each cell returned with the newline character to put it on a separate line:<br/>
		/// join [get_cells -hier {cpu* fft*}] \n<br/>
		/// This example gets a list of properties and property values attached to the second object of the<br/>
		/// list returned by get_cells:<br/>
		/// report_property [lindex [get_cells] 1]<br/>
		/// Note: If there are no cells matching the pattern you will get a warning.<br/>
		/// This example prints a list of the library cells instantiated into the design at all levels of the<br/>
		/// hierarchy, sorting the list for unique names so that each cell is only printed one time:<br/>
		/// foreach cell [lsort -unique [get_property LIB_CELL [get_cells -hier \<br/>
		/// -filter {IS_PRIMITIVE==1}]]] {puts $cell}<br/>
		/// The following example demonstrates the effect of -hierarchical searches, without and with<br/>
		/// -regexp:<br/>
		/// get_cells -hierarchical *mmcm*<br/>
		/// mmcm_replicator_inst_1<br/>
		/// mmcm_replicator_inst_1/mmcm_stage[0].mmcm_channel[0].mmcm<br/>
		/// get_cells -hierarchical -regexp .*mmcm.*<br/>
		/// mmcm_replicator_inst_1<br/>
		/// mmcm_replicator_inst_1/mmcm_stage[0].mmcm_channel[0].mmcm<br/>
		/// mmcm_replicator_inst_1/mmcm_stage[0].mmcm_channel[0].mmcm/GND<br/>
		/// mmcm_replicator_inst_1/mmcm_stage[0].mmcm_channel[0].mmcm/MMCM_Base<br/>
		/// Note: The last two cells (GND and MMCM_Base) were not returned in the first example (without -<br/>
		/// regexp) because the cell names do not match the search pattern, as it is applied to each level of the<br/>
		/// hierarchy.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example runs the report_drc command on the current design, and returns any<br/>
		/// cells associated with DRC violations:<br/>
		/// report_drc -name drc_1<br/>
		/// get_cells -of_objects [get_drc_violations]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 648<br/>
		/// </para>
		/// </summary>
		/// <param name="hsc">(Optional) Hierarchy separator Default: /</param>
		/// <param name="hierarchical">(Optional) Search level-by-level in current instance</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get cells of these pins, timing paths, nets, bels, clock<br/>
		/// regions, sites, or drc violations<br/>
		/// </para>
		/// </param>
		/// <param name="match_style">(Optional) Style of pattern matching Default: sdc Values: ucf, sdc</param>
		/// <param name="include_replicated_objects">
		/// <para>
		/// (Optional)<br/>
		/// Include replicated objects when searching for patterns. This<br/>
		/// option is valid only when patterns is specified.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match cell names against patterns Default: *</param>
		/// <returns>list of cell objects</returns>
		public VivadoTCL get_cells(String hsc = null, bool? hierarchical = null, bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, get_cells_match_style? match_style = null, bool? include_replicated_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_cells [-hsc <arg>] [-hierarchical] [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-match_style <arg>] [-include_replicated_objects] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_cells(hsc, hierarchical, regexp, nocase, filter, of_objects, match_style, include_replicated_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of cfgmem_parts available in the software<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_cfgmem_parts [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Get a list of configuration flash memory devices supported by the Vivado Design Suite or Vivado<br/>
		/// Lab Edition.<br/>
		/// Xilinx® FPGAs can be configured from an external nonvolatile memory device, or they can be<br/>
		/// configured by an external smart source, such as a microprocessor, DSP processor,<br/>
		/// microcontroller, PC, or board tester. The two configuration datapaths include a serial datapath<br/>
		/// that is used to minimize the device pin requirements for configuration, and a parallel 8-bit, 16-bit,<br/>
		/// or 32-bit datapath used for higher performance or link to industry-standard interfaces ideal for<br/>
		/// external data sources like processors, or x8- or x16-parallel flash memory.<br/>
		/// The process whereby the design specific data is loaded or programmed into the Xilinx FPGA is<br/>
		/// called configuration. The create_hw_cfgmem command defines a flash memory device used<br/>
		/// for configuring and booting the hardware device.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// After the hw_cfgmem object is created, and associated with the hw_device, the configuration<br/>
		/// memory can be programmed with the bitstream and other data from a memory configuration file<br/>
		/// created with the write_cfgmem command. The hw_cfgmem object is programmed using the<br/>
		/// program_hw_cfgmem command.<br/>
		/// The configuration memory part can be used to define the hardware configuration memory in the<br/>
		/// Hardware Manager of the Vivado Design Suite, to enable programming and debugging the design<br/>
		/// in the FPGA hardware. Use the create_hw_cfgmem command to define the configuration<br/>
		/// memory for use with the current hardware device.<br/>
		/// This command returns a list of cfgmem_part objects that match the specified search criteria, or<br/>
		/// returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 653<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get 'cfgmem_part' objects of these types: 'part hw_device'.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'cfgmem_part' objects against patterns. Default: *</param>
		/// <returns>list of cfgmem_part objects</returns>
		public VivadoTCL get_cfgmem_parts(bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_cfgmem_parts [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_cfgmem_parts(regexp, nocase, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get the clock regions for the current device.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_clock_regions [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of clock regions on the target part that match a specified search pattern. The default<br/>
		/// command gets a list of all clock regions on the device in an open design.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the clock regions matching the search pattern:<br/>
		/// get_clock_regions X0*<br/>
		/// The following example returns the clock regions filtered by the specified property:<br/>
		/// get_clock_regions -filter {LOW_X==0}<br/>
		/// Note: These two examples return the same set of clock regions.<br/>
		/// The following example returns the clock regions that the specified ILA debug core trigger is<br/>
		/// assigned to, or placed in:<br/>
		/// get_clock_regions -of_objects [get_cells -hierarchical basic_trigger*]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 657<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions.</param>
		/// <param name="nocase">
		/// <para>
		/// (Optional)<br/>
		/// Perform case-insensitive matching. (valid only when -regexp<br/>
		/// specified).<br/>
		/// </para>
		/// </param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get the clock_regions of these tiles, sites, slrs, cells, or<br/>
		/// package bank<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match objects' name against patterns. Default: *</param>
		/// <returns>clock_regions</returns>
		public VivadoTCL get_clock_regions(bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_clock_regions [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_clock_regions(regexp, nocase, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of clocks in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_clocks [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-match_style &lt;arg&gt;] [-include_generated_clocks] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of clocks in the current design that match a specified search pattern. The default<br/>
		/// command gets a list of all clocks in the design, like the all_clocks command.<br/>
		/// Clocks can be created using the create_clock or the create_generated_clock<br/>
		/// commands, or can be automatically generated by the tool, at the output of an MMCM for<br/>
		/// instance.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets a list of clocks matching the various search patterns:<br/>
		/// get_clocks {*clock *ck *Clk}<br/>
		/// Note: If there are no clocks matching the pattern you will get a warning.<br/>
		/// The following example gets the master clock object, and all generated clocks derived from that<br/>
		/// clock:<br/>
		/// get_clocks -include_generated_clocks wbClk<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example gets all properties and property values attached to the specified clock:<br/>
		/// report_property -all [get_clocks wbClk]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 660<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get clocks of these pins, nets, or cells</param>
		/// <param name="match_style">(Optional) Style of pattern matching, valid values are ucf, sdc Default: sdc</param>
		/// <param name="include_generated_clocks">(Optional) Include auto-inferred/generated_clocks also.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match clock names against patterns Default: *</param>
		/// <returns>list of clocks</returns>
		public VivadoTCL get_clocks(bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, String match_style = null, bool? include_generated_clocks = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_clocks [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-match_style <arg>] [-include_generated_clocks] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_clocks(regexp, nocase, filter, of_objects, match_style, include_generated_clocks, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Returns all cluster configuration objects<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_cluster_configurations [-filter &lt;arg&gt;] [-regexp] [-nocase] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of cluster configurations that includes Vivado default cluster configurations and cluster<br/>
		/// configurations created using the create_cluster_configuration command.<br/>
		/// Vivado supports the following cluster management tools.<br/>
		/// • Load Sharing Facility (LSF)<br/>
		/// • Sun Grid Engine (SGE)<br/>
		/// • Simple Linux Utility For Resource Management (SLURM)<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets the list of all cluster configurations.<br/>
		/// get_cluster_configurations<br/>
		/// The following example gets the cluster configuration with name 'lsf'.<br/>
		/// get_cluster_configurations lsf<br/>
		/// The following example gets the list of all default cluster configurations.<br/>
		/// get_cluster_configurations -filter {IS_DEFAULT}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 664<br/>
		/// </para>
		/// </summary>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match cluster configuration against patterns Default: *</param>
		public VivadoTCL get_cluster_configurations(String filter = null, bool? regexp = null, bool? nocase = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_cluster_configurations [-filter <arg>] [-regexp] [-nocase] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_cluster_configurations(filter, regexp, nocase, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create the Project summary dashboard<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_dashboard_gadgets [-quiet] [-verbose] [&lt;patterns&gt;...]
		/// <br/>
		/// <para>
		/// Gets a list of the dashboard gadgets in the current project.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the dashboard gadgets in the current project:<br/>
		/// get_dashboard_gadgets<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 667<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// <para>
		/// (Optional)<br/>
		/// Match gadget names against patterns Default: * Values: The<br/>
		/// default search pattern is the wildcard *<br/>
		/// </para>
		/// </param>
		public VivadoTCL get_dashboard_gadgets(bool? quiet = null, bool? verbose = null, TCLParameterList patterns = null)
		{
			// TCL Syntax: get_dashboard_gadgets [-quiet] [-verbose] [<patterns>...]
			this.Entry(_builder.get_dashboard_gadgets(quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of debug cores in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_debug_cores [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of Vivado Lab Edition debug cores in the current project that match a specified search<br/>
		/// pattern. The default command gets a list of all debug cores in the project.<br/>
		/// Debug cores are added to the project with the create_debug_core command. When a ILA<br/>
		/// debug core (labtools_ila_v3) is added to the project, it is contained within a Debug Hub core<br/>
		/// (labtools_xsdbmasterlib_v2), and includes a CLK port and a PROBE port as a default. Additional<br/>
		/// ports can be added to the debug core with the use of the create_debug_port command.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following command gets a list of the Vivado Lab Edition debug cores in the current project:<br/>
		/// get_debug_cores<br/>
		/// Note: A Debug Hub core is returned as one of the debug cores in the project. You cannot directly create<br/>
		/// this core, but it is automatically added by the tool when you add any ILA cores to the project.<br/>
		/// The following example gets the properties of the specified debug core:<br/>
		/// report_property [get_debug_cores myCore]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 669<br/>
		/// </para>
		/// </summary>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get cores of these debug ports or nets</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match debug cores against patterns Default: *</param>
		/// <returns>list of debug_core objects</returns>
		public VivadoTCL get_debug_cores(String filter = null, TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_debug_cores [-filter <arg>] [-of_objects <args>] [-regexp] [-nocase] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_debug_cores(filter, of_objects, regexp, nocase, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of debug ports in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_debug_ports [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of ports defined on ILA debug cores in the current project that match a specified<br/>
		/// search pattern. The default command gets a list of all debug ports in the project.<br/>
		/// Debug ports are defined when ILA debug cores are created with the create_debug_core<br/>
		/// command. Ports can be added to existing debug cores with the create_debug_port<br/>
		/// command.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following command gets a list of the ports from the ILA debug cores in the current project,<br/>
		/// with a PORT_WIDTH property of 8:<br/>
		/// get_debug_ports -filter {PORT_WIDTH==8}<br/>
		/// The following example gets the properties attached to the specified debug port:<br/>
		/// report_property [get_debug_ports myCore/PROBE1]<br/>
		/// Note: The debug port is defined by the core_name/port_name combination.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 672<br/>
		/// </para>
		/// </summary>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get ports of these debug cores</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match debug ports against patterns Default: *</param>
		/// <returns>list of debug_port objects</returns>
		public VivadoTCL get_debug_ports(String filter = null, TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_debug_ports [-filter <arg>] [-of_objects <args>] [-regexp] [-nocase] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_debug_ports(filter, of_objects, regexp, nocase, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of designs in the current project<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_designs [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of open designs in the current project that match a specified search pattern. The<br/>
		/// default command gets a list of all open designs in the project.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets all open designs in the current project:<br/>
		/// get_designs<br/>
		/// The following example gets the assigned properties of an open design matching the search<br/>
		/// pattern:<br/>
		/// report_property [get_designs r*]<br/>
		/// Note: If there are no designs matching the pattern you will get a warning.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 675<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match design names against patterns Default: *</param>
		/// <returns>list of design objects</returns>
		public VivadoTCL get_designs(bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_designs [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_designs(regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of DRC rule check objects<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_drc_checks [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-abbrev &lt;arg&gt;] [-ruledecks &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of the currently defined DRC checks. This list includes both factory defined design rule<br/>
		/// checks, and user-defined checks created by the create_drc_check command.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following command gets a list of all AVAL design rule checks:<br/>
		/// get_drc_checks AVAL*<br/>
		/// The following example gets the checks associated with the specified rule deck:<br/>
		/// get_drc_checks -of_objects [get_drc_ruledecks placer_checks]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 678<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'rule_check' objects of these types: 'drc_ruledeck'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="abbrev">(Optional) Get the largest ID for this abbrev</param>
		/// <param name="ruledecks">(Optional) Containers of Report DRC rule checks Default: default</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'rule_check' objects against patterns. Default: *</param>
		/// <returns>list of DRC rule_check objects</returns>
		public VivadoTCL get_drc_checks(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, String abbrev = null, TCLParameterList ruledecks = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_drc_checks [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-abbrev <arg>] [-ruledecks <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_drc_checks(of_objects, regexp, nocase, filter, abbrev, ruledecks, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of DRC rule deck objects<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_drc_ruledecks [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of currently defined rule decks for use with the report_drc command.<br/>
		/// A rule deck is a collection of design rule checks grouped for convenience, to be run at different<br/>
		/// stages of the FPGA design flow, such as during I/O planning or placement. The tool comes with a<br/>
		/// set of factory defined rule decks, but you can also create new user-defined rule decks with the<br/>
		/// create_drc_ruledeck command, and add checks to the rule deck using the<br/>
		/// add_drc_checks command.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets a list of rule decks defined in the current project:<br/>
		/// get_drc_ruledecks<br/>
		/// The following example lists each of the checks associated with the placer_checks rule deck on a<br/>
		/// separate line:<br/>
		/// foreach rule [get_drc_checks -of_objects \<br/>
		/// [get_drc_ruledecks placer_checks]] {puts $rule}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 681<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'drc_ruledeck' objects of these types: 'rule_check'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'drc_ruledeck' objects against patterns. Default: *</param>
		/// <returns>drc_ruledeck</returns>
		public VivadoTCL get_drc_ruledecks(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_drc_ruledecks [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_drc_ruledecks(of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of DRC violations from a previous report_drc run<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_drc_violations [-name &lt;arg&gt;] [-regexp] [-filter &lt;arg&gt;] [-nocase] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of violation objects found in the design when the report_drc command is run.<br/>
		/// Violation objects are created at the time DRC is run, either by the internal design rule checks<br/>
		/// provided by the Vivado tools, or created by the create_drc_violation command in user-defined DRC checks. The properties of individual violation objects can be queried using<br/>
		/// report_property or list_property commands for details of the violation.<br/>
		/// Violation objects are associated with the cells, nets, pins, or ports in the current design, or sites<br/>
		/// on the current device. The design objects associated with a DRC violation object can be obtained<br/>
		/// using the -of_objects option of the appropriate get_* command, such as get_cells, or<br/>
		/// get_nets for instance.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports the DRC violations found in the current design, then returns a list<br/>
		/// of all those violations:<br/>
		/// report_drc<br/>
		/// get_drc_violations<br/>
		/// The following example gets the properties of the specified DRC violation:<br/>
		/// report_property [lindex [get_drc_violations] 0]<br/>
		/// The following example returns the list of violations in the specified DRC report of the current<br/>
		/// design, and then returns the ports associated with any violations of the unspecified I/O Standard<br/>
		/// rule (NSTD):<br/>
		/// get_drc_violations -name drc_1<br/>
		/// get_ports -of_objects [get_drc_violations -name drc_1 NSTD*]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 684<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Optional) Get the results with this name</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// <para>
		/// (Optional)<br/>
		/// Match drc_violations against patterns Default: * Values: The<br/>
		/// default search pattern is the wildcard *, or .* when -regexp<br/>
		/// is specified.<br/>
		/// </para>
		/// </param>
		/// <returns>list of DRC violation objects</returns>
		public VivadoTCL get_drc_violations(String name = null, bool? regexp = null, String filter = null, bool? nocase = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_drc_violations [-name <arg>] [-regexp] [-filter <arg>] [-nocase] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_drc_violations(name, regexp, filter, nocase, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of example designs<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_example_designs [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;...]
		/// <br/>
		/// <para>
		/// The command returns a list of example designs available in the current release of the Vivado<br/>
		/// Design Suite, or returns an error if it fails.<br/>
		/// Example designs can be opened, or instantiated into the Vivado Design Suite, onto specific target<br/>
		/// hardware devices or boards.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns reports the properties of each of the example designs in the<br/>
		/// current release:<br/>
		/// foreach x [get_example_designs] {<br/>
		/// puts "********* Design $x **************"<br/>
		/// report_property -all $x}<br/>
		/// Note: The reported properties include the PARTS property which lists the compatible parts for the example<br/>
		/// design.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 688<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// <para>
		/// (Optional)<br/>
		/// The patterns to match against Default: * Values: The default<br/>
		/// search pattern is the wildcard *, or .* when -regexp is<br/>
		/// specified.<br/>
		/// </para>
		/// </param>
		/// <returns>list of design objects</returns>
		public VivadoTCL get_example_designs(bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, TCLParameterList patterns = null)
		{
			// TCL Syntax: get_example_designs [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>...]
			this.Entry(_builder.get_example_designs(regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of source files<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_files [-regexp] [-nocase] [-filter &lt;arg&gt;] [-compile_order &lt;arg&gt;] [-used_in &lt;arg&gt;] [-references] [-all] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of files in the current project that match a specified search pattern. The default<br/>
		/// command gets a list of all files in the project.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The get_files command returns a machine readable list of files in the project, in a design, or in<br/>
		/// a sub-design such as an IP core or block design. You can filter the results returned by<br/>
		/// get_files using one of the command arguments such as -of_objects, -compile_order,<br/>
		/// -used_in, and -filter.<br/>
		/// The -compile_order and -used_in options must be used together to return a list of files<br/>
		/// from the sources or constraints filesets used in synthesis, simulation, or implementation, sorted<br/>
		/// according to the order of evaluation by the Vivado tools. The -compile_order and -used_in<br/>
		/// options use complex file ordering rules that can change based on header files, include files, or<br/>
		/// other language options. You can also filter files returned by get_files according to the<br/>
		/// USED_IN property, using the -filter option instead of the -used_in option.<br/>
		/// You can use the report_compile_order command to generate a report of all files in the<br/>
		/// sources or constraints filesets, used in synthesis, simulation, AND implementation, sorted into<br/>
		/// different sections.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the VHDL files in the design that are used in simulation:<br/>
		/// get_files -filter {FILE_TYPE == VHDL &amp;&amp; USED_IN =~ simulation*}<br/>
		/// This example returns the design source files that are used in simulation:<br/>
		/// get_files -compile_order sources -used_in simulation<br/>
		/// This example gets a list of files associated with the specified IP core composite file (ip.xci), from<br/>
		/// the sources_1 fileset that are used in synthesis:<br/>
		/// get_files -compile_order sources -used_in synthesis -of [get_files ip.xci]<br/>
		/// The following example gets a list of the files found in the sources_1 and constrs_1 filesets:<br/>
		/// get_files -of [get_filesets {sources_1 constrs_1}]<br/>
		/// Note: If there are no files matching the pattern you will get a warning.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 691<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="compile_order">(Optional) Get files by type and in compilation order (must use with - used_in)</param>
		/// <param name="used_in">(Optional) Get files used in a specific step (must use with - compile_order)</param>
		/// <param name="references">
		/// <para>
		/// (Optional)<br/>
		/// Get files referenced in the provided objects (must use with -<br/>
		/// of_objects)<br/>
		/// </para>
		/// </param>
		/// <param name="all">(Optional) Include all internal files.</param>
		/// <param name="of_objects">(Optional) Get 'file' objects of these types: 'file fileset ip reconfig_module'.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match file names against patterns Default: *</param>
		/// <returns>list of file objects</returns>
		public VivadoTCL get_files(bool? regexp = null, bool? nocase = null, String filter = null, String compile_order = null, String used_in = null, bool? references = null, bool? all = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_files [-regexp] [-nocase] [-filter <arg>] [-compile_order <arg>] [-used_in <arg>] [-references] [-all] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_files(regexp, nocase, filter, compile_order, used_in, references, all, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of filesets in the current project<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_filesets [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of filesets in the current project that match a specified search pattern. The default<br/>
		/// command gets a list of all filesets in the project.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the source files in the Source Set:<br/>
		/// get_files -of_objects [get_filesets sources_1]<br/>
		/// The following example makes project_2 the active project, and then gets a list of filesets<br/>
		/// beginning with the letter s or the letter r:<br/>
		/// current_project project_2<br/>
		/// get_filesets s* r* -quiet<br/>
		/// Note: If there are no filesets matching the pattern, such as r*, you will get a warning that no filesets<br/>
		/// matched the specified pattern. However, in the above example the use of -quiet will suppress that<br/>
		/// warning message.<br/>
		/// The following example gets filesets beginning with the letter C, using a case insensitive regular<br/>
		/// expression:<br/>
		/// get_filesets C.* -regexp -nocase<br/>
		/// In the above example, constrs_1 and constrs_2 constraint sets would be returned if defined in<br/>
		/// the current project.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 695<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get 'fileset' objects of these types: 'reconfig_module'.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match fileset names against patterns Default: *</param>
		/// <returns>list of fileset objects</returns>
		public VivadoTCL get_filesets(bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_filesets [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_filesets(regexp, nocase, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of generated clocks in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_generated_clocks [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-match_style &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of generated clocks in the current project that match a specified search pattern. The<br/>
		/// default command gets a list of all generated clocks in the project.<br/>
		/// A generated clock can be added to the design using the create_generated_clock<br/>
		/// command, or can be automatically generated by the tool, at the output of an MMCM for<br/>
		/// instance.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets the names of all generated clocks in the current project:<br/>
		/// get_generated_clocks<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 698<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get generated clocks of these pins, ports or nets</param>
		/// <param name="match_style">(Optional) Style of pattern matching, valid values are ucf, sdc Default: sdc</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match generated clock names against patterns Default: *</param>
		/// <returns>list of clocks</returns>
		public VivadoTCL get_generated_clocks(bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, String match_style = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_generated_clocks [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-match_style <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_generated_clocks(regexp, nocase, filter, of_objects, match_style, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get custom command arguments<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_gui_custom_command_args -command_name &lt;arg&gt; [-regexp] [-nocase] [-quiet] [-verbose] [&lt;patterns&gt;...]
		/// <br/>
		/// <para>
		/// Returns the list of GUI custom command argument names for a particular GUI custom command.<br/>
		/// You can use the get_gui_custom_commands to determine the list of defined custom<br/>
		/// commands.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns a list of command arguments for the GUI custom command abc:<br/>
		/// get_gui_custom_command_args -command_name abc<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 701<br/>
		/// </para>
		/// </summary>
		/// <param name="command_name">
		/// <para>
		/// (Required)<br/>
		/// Unique name of the custom command whose arguments<br/>
		/// need to be displayed.<br/>
		/// </para>
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the custom command argument names against patterns Default: *</param>
		/// <returns>list of custom command argument names</returns>
		public VivadoTCL get_gui_custom_command_args(String command_name, bool? regexp = null, bool? nocase = null, bool? quiet = null, bool? verbose = null, TCLParameterList patterns = null)
		{
			// TCL Syntax: get_gui_custom_command_args -command_name <arg> [-regexp] [-nocase] [-quiet] [-verbose] [<patterns>...]
			this.Entry(_builder.get_gui_custom_command_args(command_name, regexp, nocase, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get custom commands<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_gui_custom_commands [-regexp] [-nocase] [-quiet] [-verbose] [&lt;patterns&gt;...]
		/// <br/>
		/// <para>
		/// Returns the list of GUI custom commands.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns a list of all the GUI custom commands which has names starting<br/>
		/// with 'p':<br/>
		/// get_gui_custom_commands p*<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 703<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the custom command names against patterns Default: *</param>
		/// <returns>list of custom command names</returns>
		public VivadoTCL get_gui_custom_commands(bool? regexp = null, bool? nocase = null, bool? quiet = null, bool? verbose = null, TCLParameterList patterns = null)
		{
			// TCL Syntax: get_gui_custom_commands [-regexp] [-nocase] [-quiet] [-verbose] [<patterns>...]
			this.Entry(_builder.get_gui_custom_commands(regexp, nocase, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get hierarchical separator character<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_hierarchy_separator [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Gets the character currently used for separating levels of hierarchy in the design. You can set the<br/>
		/// hierarchy separator using the set_hierarchy_separator command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets the currently defined hierarchy separator:<br/>
		/// get_hierarchy_separator<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 705<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL get_hierarchy_separator(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_hierarchy_separator [-quiet] [-verbose]
			this.Entry(_builder.get_hierarchy_separator(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get highlighted objects<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_highlighted_objects [-color_index &lt;arg&gt;] [-rgb &lt;args&gt;] [-color &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Gets the highlighted objects in the current design open in the Vivado IDE. Objects can be<br/>
		/// highlighted with the highlight_objects command.<br/>
		/// You can get all highlighted objects in the design, or specify highlighted objects by color, by color<br/>
		/// index, or by RGB value.<br/>
		/// Note: This Tcl command works only when Vivado is run in GUI mode.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets all the highlighted objects in the current design:<br/>
		/// get_highlighted_objects<br/>
		/// The following example gets the object in the current design that are highlighted in the specified<br/>
		/// color:<br/>
		/// get_highlighted_objects -color cyan<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 706<br/>
		/// </para>
		/// </summary>
		/// <param name="color_index">(Optional) Color index</param>
		/// <param name="rgb">(Optional) RGB color index list</param>
		/// <param name="color">(Optional) Valid values are red green blue magenta yellow cyan and orange</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of highlighted objects</returns>
		public VivadoTCL get_highlighted_objects(String color_index = null, TCLParameterList rgb = null, String color = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_highlighted_objects [-color_index <arg>] [-rgb <args>] [-color <arg>] [-quiet] [-verbose]
			this.Entry(_builder.get_highlighted_objects(color_index, rgb, color, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of hardware AXI transactions.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_hw_axi_txns [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Returns the read or write transactions for the specified JTAG to AXI Master core, hw_axi object.<br/>
		/// The JTAG to AXI Master is a customizable IP core that works as an AXI Master to drive AXI<br/>
		/// transactions and drive AXI signals that are internal to the hardware device. This IP can be used in<br/>
		/// Vivado® IP integrator or can be instantiated in HDL in a Vivado project.<br/>
		/// The JTAG-AXI core supports all memory-mapped AXI interfaces, except AXI4-Stream, and<br/>
		/// supports the AXI-Lite protocol. The AXI interface can be selected as a property of the core. The<br/>
		/// width of AXI data bus is customizable. This IP can drive any AXI4-Lite or Memory Mapped Slave<br/>
		/// directly, and can also be connected as the AXI Master to the interconnect. Run-time interaction<br/>
		/// with this core requires the use of the Vivado logic analyzer feature. Detailed documentation on<br/>
		/// the IP core can be found in the LogiCORE IP JTAG to AXI Master Product Guide (PG174). A tutorial<br/>
		/// showing its use can be found in the Vivado Design Suite Tutorial: Programming and Debugging<br/>
		/// (UG936).<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The JTAG to AXI Master core must be instantiated in the RTL code, from the Xilinx IP catalog.<br/>
		/// AXI transactions are defined as complete READ or WRITE transactions between the AXI master<br/>
		/// and various slaves.<br/>
		/// This command returns a list of hw_axi_txn objects on the hw_device, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 708<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'hw_axi_txn' objects of these types: 'hw_axi'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_axi_txn' objects against patterns. Default: *</param>
		/// <returns>hw_axi_txns</returns>
		public VivadoTCL get_hw_axi_txns(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_hw_axi_txns [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_hw_axi_txns(of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of hardware AXI objects.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_hw_axis [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Returns the JTAG to AXI Master core objects, or hw_axi objects, defined on the current hardware<br/>
		/// device.<br/>
		/// The JTAG to AXI Master is a customizable IP core that works as an AXI Master to drive AXI<br/>
		/// transactions and drive AXI signals that are internal to the hardware device. This IP can be used in<br/>
		/// Vivado® IP integrator or can be instantiated from the Xilinx® IP catalog into the HDL of a Vivado<br/>
		/// project. Run-time interaction with this core requires the use of the Vivado logic analyzer feature.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The JTAG-AXI core supports all memory-mapped AXI interfaces, except AXI4-Stream, and<br/>
		/// supports the AXI-Lite protocol. The AXI interface can be defined as a property of the core. The<br/>
		/// width of the AXI data bus is customizable. This IP can drive any AXI4-Lite or Memory Mapped<br/>
		/// Slave directly, and can also be connected as the AXI Master to the interconnect. Detailed<br/>
		/// documentation on the IP core can be found in the LogiCORE IP JTAG to AXI Master Product Guide<br/>
		/// (PG174). A tutorial showing its use can be found in the Vivado Design Suite Tutorial: Programming<br/>
		/// and Debugging (UG936).<br/>
		/// AXI cores can be found in the synthesized or implemented design netlist using the<br/>
		/// get_debug_cores command. This will return instances of the debug cores in the design that<br/>
		/// are related to the hw_axi objects, and other debug cores on the hw_device.<br/>
		/// This command returns a list of AXI Master core objects, hw_axis, on the hw_device, or returns an<br/>
		/// error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 711<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'hw_axi' objects of these types: 'hw_device'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_axi' objects against patterns. Default: *</param>
		/// <returns>hw_axi</returns>
		public VivadoTCL get_hw_axis(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_hw_axis [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_hw_axis(of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of hardware cfgmems.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_hw_cfgmems [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Get a list of hardware configuration memory (hw_cfgmem) objects created for the current<br/>
		/// hw_device.<br/>
		/// Xilinx FPGAs are configured by loading design-specific configuration data, in the form of a<br/>
		/// bitstream file, into the internal memory of the hw_device. The hw_cfgmem defines a flash<br/>
		/// memory device used for configuring and booting the Xilinx FPGA device. Once the hw_cfgmem<br/>
		/// object is created, and associated with the hw_device, the configuration memory can be<br/>
		/// programmed with the bitstream and other data using the program_hw_cfgmem command.<br/>
		/// The hw_cfgmem object is associated with the specified hw_device object through the<br/>
		/// PROGRAM.HW_CFGMEM property on the device object. The get_hw_cfgmems command lets<br/>
		/// you work with the hw_cfgmem object.<br/>
		/// This command returns a list of hw_cfgmem objects that match the specified search criteria, or<br/>
		/// returns an error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 714<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_cfgmem' objects against patterns. Default: *</param>
		/// <returns>hardware cfgmems</returns>
		public VivadoTCL get_hw_cfgmems(bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_hw_cfgmems [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_hw_cfgmems(regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get list of Versal integrated and soft DDRMC cores.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_hw_ddrmcs [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Xilinx Versal devices include integrated DDR Memory Controllers (DDRMC), as well as fabric<br/>
		/// based memory controllers. Refer to the LogiCore IP Product Guide: Versal ACAP Network on Chip<br/>
		/// and Integrated Memory Controller (PG313) for more information on the integrated controller core.<br/>
		/// Refer to Versal ACAP Soft DDR4 Memory IP (PG353) for more information on the fabric based<br/>
		/// memory controller. The memory controllers contain memory configuration and memory<br/>
		/// calibration data that can be accessed from the Xilinx Vivado Hardware Manager. The calibration<br/>
		/// and margin data are organized and presented in a graphical format for ease of analysis.<br/>
		/// The get_hw_ddrmc command returns a list of memory cores on the current hardware device.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the HBM with the specified DISPLAY_NAME:<br/>
		/// get_hw_hbms -filter {DISPLAY_NAME == HBM_2}<br/>
		/// The following example returns the DDRMC with the specified DISPLAY_NAME:<br/>
		/// get_hw_ddrmcs -filter {DISPLAY_NAME == DDRMC_1}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 717<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get 'hw_ddrmc' objects of these types: 'hw_server<br/>
		/// hw_target hw_device'.<br/>
		/// </para>
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_ddrmc' objects against patterns. Default: *</param>
		/// <returns>integrated and soft DDRMC cores</returns>
		public VivadoTCL get_hw_ddrmcs(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_hw_ddrmcs [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_hw_ddrmcs(of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of hardware devices.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_hw_devices [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Returns the hardware devices on the open target of a connected hardware server.<br/>
		/// Each hardware target can have one or more Xilinx devices to program, or to use for debugging<br/>
		/// purposes. The current device is specified or returned by the current_hw_device command.<br/>
		/// This command returns a list of available hardware device objects, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 720<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'hw_device' objects of these types: 'hw_target'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_device' objects against patterns. Default: *</param>
		/// <returns>hardware devices</returns>
		public VivadoTCL get_hw_devices(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_hw_devices [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_hw_devices(of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get list of hardware HBM cores.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_hw_hbms [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Certain Xilinx® UltraScale+ devices include an integrated High-Bandwidth Memory (HBM)<br/>
		/// controller. Refer to the LogiCore IP Product Guide: AXI High Bandwidth Memory Controller<br/>
		/// (PG276) for more information on this core. The HBM controller and memory stacks contain both<br/>
		/// performance counters and temperature sensors that can be accessed through an HBM activity<br/>
		/// monitor (amon) from within the Xilinx Vivado hardware manager. The HBM activity monitor can<br/>
		/// be used to gain real-time access to performance monitoring and temperature sensors on the<br/>
		/// physical device. The Vivado hardware manager displays read, write, and overall throughput of<br/>
		/// data, as well as the device temperature. The activity monitor displays, captures, and exports data<br/>
		/// to a CSV file when it is running.<br/>
		/// The get_hw_hbms command returns a list of HBM cores on the current hardware target.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the HBM with the specified DISPLAY_NAME:<br/>
		/// get_hw_hbms -filter {DISPLAY_NAME == HBM_2}<br/>
		/// This example returns all the HBM objects in the current device:<br/>
		/// get_hw_hbms<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 723<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'hw_hbm' objects of these types: 'hw_server hw_target hw_device'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_hbm' objects against patterns. Default: *</param>
		/// <returns>hardware HBM cores</returns>
		public VivadoTCL get_hw_hbms(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_hw_hbms [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_hw_hbms(of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of hardware ILA data objects.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_hw_ila_datas [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Returns the ILA data objects in the Vivado logic analyzer.<br/>
		/// The upload_hw_ila_data command creates a hw_ila_data object in the process of moving<br/>
		/// the captured data from the ILA debug core, hw_ila, on the physical FPGA device, hw_device. The<br/>
		/// read_hw_ila_data command can also create a hw_ila_data object when reading an ILA data<br/>
		/// file from disk.<br/>
		/// The hw_ila_data object can be viewed in the waveform viewer of the Vivado logic analyzer by<br/>
		/// using the display_hw_ila_data command, and can be written to disk using the<br/>
		/// write_hw_ila_data command.<br/>
		/// This command returns a list of available hardware ILA data objects, or returns an error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 726<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'hw_ila_data' objects of these types: 'hw_ila hw_device'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_ila_data' objects against patterns. Default: *</param>
		/// <returns>hardware ILA data</returns>
		public VivadoTCL get_hw_ila_datas(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_hw_ila_datas [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_hw_ila_datas(of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of hardware ILA.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_hw_ilas [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Returns the ILA debug core objects defined on the current hardware device.<br/>
		/// The Integrated Logic Analyzer (ILA) debug core lets you perform in-system debug of<br/>
		/// implemented designs, or design bitstreams, on a programmed Xilinx FPGA. The ILA core includes<br/>
		/// many advanced features of modern logic analyzers, including boolean trigger equations, and edge<br/>
		/// transition triggers. You can use the ILA core to probe specific signals of the design, to trigger on<br/>
		/// programmed hardware events, and capture data from the Xilinx FPGA in real-time. Refer to<br/>
		/// LogiCORE IP Integrated Logic Analyzer (PG172) for details of the ILA core.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// You can add ILA debug cores into the RTL source files of a design, or in the synthesized netlist<br/>
		/// using the create_debug_core command. Refer to the Vivado Design Suite User Guide: Vivado<br/>
		/// Programming and Debugging (UG908) for more information on adding debug cores and signal<br/>
		/// probes to the design. You can get the debug cores in the synthesized netlist by using the<br/>
		/// get_debug_core commands. However, though they are related, the design debug cores are<br/>
		/// separate from the hardware debug cores found in the Hardware Manager feature of the Vivado<br/>
		/// Design Suite.<br/>
		/// Debug cores and probes are written to the probes file (.ltx) using the write_debug_probes<br/>
		/// command and associated with the hardware device, along with the bitstream file (.bit), using<br/>
		/// the PROBES.FILE and PROGRAM.FILE properties of the hw_device object. The hardware device<br/>
		/// is programmed with this information using the program_hw_devices command.<br/>
		/// The steps to debug your design in hardware using an ILA debug core are:<br/>
		/// 1. Connect to the hardware server and target using connect_hw_server and<br/>
		/// open_hw_target.<br/>
		/// 2. Program the FPGA with the bitstream (.bit) and probes (.ltx) files using<br/>
		/// program_hw_devices.<br/>
		/// 3. Set up the ILA debug core trigger and capture controls using set_property to set<br/>
		/// properties of the ILA.<br/>
		/// 4. Arm the ILA debug core trigger using run_hw_ila.<br/>
		/// 5. View the captured data from the ILA debug core in the Waveform window of the Vivado<br/>
		/// logic analyzer feature using display_hw_ila_data.<br/>
		/// 6. Optionally use the VIO debug core to drive control signals and/or view design status signals.<br/>
		/// See get_hw_vios for more information.<br/>
		/// 7. Optionally use the JTAG-to-AXI Master debug core to run transactions to interact with<br/>
		/// various AXI slave cores in your design. See get_hw_axis for more information.<br/>
		/// This command returns a list of ILA debug core objects on the device, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 729<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'hw_ila' objects of these types: 'hw_device'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_ila' objects against patterns. Default: *</param>
		/// <returns>hardware ILAs</returns>
		public VivadoTCL get_hw_ilas(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_hw_ilas [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_hw_ilas(of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get list of hardware Migs cores.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_hw_migs [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Returns the hw_mig objects on the current hardware device.<br/>
		/// Memory IP included in the Xilinx IP catalog are used to generate memory controllers and<br/>
		/// interfaces for Xilinx® devices. Memory IP includes different IP cores from the Xilinx IP catalog<br/>
		/// depending on the device architecture and memory interface specified. Refer to Zynq-7000 SoC<br/>
		/// and 7 Series Devices Memory Interface Solutions (UG586), or UltraScale Architecture-Based FPGAs<br/>
		/// Memory Interface Solutions (PG150), for details of the available memory IP.<br/>
		/// When added to a design, the memory IP needs to be implemented into the design. This occurs<br/>
		/// after the design is synthesized, during the design optimization phase of implementation, or<br/>
		/// opt_design, or can be done manually with the implement_mig_cores command.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// A memory controller can be debug enabled when added into the design from the Xilinx IP<br/>
		/// catalog. In the Vivado logic analyzer, or the Vivado Lab Edition, memory controllers implemented<br/>
		/// into a design are associated with hw_mig objects, one hw_mig object per debug-enabled memory<br/>
		/// controller. The hw_mig object will have all the properties needed to get the calibration status and<br/>
		/// draw the per-bit eye margin views.<br/>
		/// In the Vivado logic analyzer, or Vivado Lab Edition, the hw_mig object lets you verify the<br/>
		/// calibration and read window margins in your memory interface design. You can use the hardware<br/>
		/// manager GUI to check the calibration status, verify the read margin for both rising and falling<br/>
		/// edges of the clock or DQS. You can also use an ILA core to verify the data integrity for the read<br/>
		/// and write operations.<br/>
		/// This command returns a list of hw_mig objects on the current hardware device, or returns an<br/>
		/// error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 733<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'hw_mig' objects of these types: 'hw_server hw_target hw_device'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_mig' objects against patterns. Default: *</param>
		/// <returns>hardware migs cores</returns>
		public VivadoTCL get_hw_migs(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_hw_migs [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_hw_migs(of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get list of soft PCIe core(s).<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_hw_pcies [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-patterns &lt;arg&gt;] [-filter &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Get all the Peripheral Component Interconnect Express (PCIe) debug core objects, hw_pcie's,<br/>
		/// defined on the current hardware device.<br/>
		/// The customizable LogiCORE IP PCIe core for Xilinx ACAPs is designed for evaluating and<br/>
		/// monitoring the PCIe Link Training and Status State Machine (LTSSM) running on the Gigabit<br/>
		/// Transceivers (GTs). In the Vivado Hardware Manager, Versal PCIe soft cores implemented in the<br/>
		/// design, are represented as hw_pcie objects. You can use these PCIe debug cores to solve a range<br/>
		/// of debug and validation problems; from viewing the PCIe link info to the LTSSM state transition<br/>
		/// diagram.<br/>
		/// This command returns a list of PCIe debug core objects on the device, or returns an error if it<br/>
		/// fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns all the available PCIe cores<br/>
		/// get_hw_pcies<br/>
		/// The following example returns PCIe core with the specified DISPLAY_NAME<br/>
		/// get_hw_pcies -filter {NAME == "PCIe_0"}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 737<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'hw_pcie' objects of these types: 'hw_server hw_target hw_device'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="patterns">(Optional) Match the 'hw_pcie' objects against patterns. Default: *</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>PCIe core(s)</returns>
		public VivadoTCL get_hw_pcies(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String patterns = null, String filter = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_hw_pcies [-of_objects <args>] [-regexp] [-nocase] [-patterns <arg>] [-filter <arg>] [-quiet] [-verbose]
			this.Entry(_builder.get_hw_pcies(of_objects, regexp, nocase, patterns, filter, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of hardware probes.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_hw_probes [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Returns the hw_probe objects in the Hardware Manager that are defined on signals in the design,<br/>
		/// or that are assigned to the specified ILA or VIO debug cores.<br/>
		/// You can add ILA and VIO debug cores in the RTL source files of a design by customizing the core<br/>
		/// from the IP catalog, or add ILA debug cores into the synthesized netlist using the<br/>
		/// create_debug_core command.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Signals in the design can be probed to monitor signal values and track hardware events on the<br/>
		/// FPGA device. Debug probes can be added to ILA debug cores in the synthesized netlist design<br/>
		/// using the create_debug_port command, and connected to signals in the design using<br/>
		/// connect_debug_port. Probes can only be added to VIO debug cores when the IP core is<br/>
		/// customized, or re-customized, from the IP catalog, and signals connected to it in the RTL design.<br/>
		/// Refer to the Vivado Design Suite User Guide: Vivado Programming and Debugging (UG908) for more<br/>
		/// information on adding ILA and VIO debug cores and signal probes to the design.<br/>
		/// Debug cores and probes are written to a probes file (.ltx) with write_debug_probes, and<br/>
		/// associated with the hardware device, along with the bitstream file (.bit), using the PROBES.FILE<br/>
		/// and PROGRAM.FILE properties of the hw_device object. The hardware device is programmed<br/>
		/// with this information using the program_hw_devices command.<br/>
		/// This command returns a list of debug probe objects on the device, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 740<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'hw_probe' objects of these types: 'hw_interface hw_ila hw_vio'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_probe' objects against patterns. Default: *</param>
		/// <returns>hardware probes</returns>
		public VivadoTCL get_hw_probes(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_hw_probes [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_hw_probes(of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of hardware servers.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_hw_servers [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// IMPORTANT! You must use the open_hw command to open the Hardware Manager in the Vivado<br/>
		/// Design Suite before using this command.<br/>
		/// This command returns hardware server objects that are connected to the current instance of the<br/>
		/// Vivado Design Suite through the use of the connect_hw_server command.<br/>
		/// Hardware servers are instances of the Xilinx hardware server (hw_server) application running<br/>
		/// remotely, or on the local machine. The hardware server manages connections to a hardware<br/>
		/// target, for instance a hardware board containing a JTAG chain of one or more Xilinx devices to be<br/>
		/// used for programming and debugging your FPGA design.<br/>
		/// This command returns a list of connected hardware server objects.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 744<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_server' objects against patterns. Default: *</param>
		/// <returns>hardware servers</returns>
		public VivadoTCL get_hw_servers(bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_hw_servers [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_hw_servers(regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get list of hardware SIO GT commons.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_hw_sio_commons [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Returns the QPLL objects, hw_sio_commons, defined on the IBERT debug core on the current<br/>
		/// hardware device.<br/>
		/// For each serial transceiver channel, there is a ring PLL called Channel PLL (CPLL). In Xilinx<br/>
		/// UltraScale and 7 series FPGAs, the high-speed transceivers have an additional common or shared<br/>
		/// PLL per quad, or Quad PLL (QPLL). This QPLL is a shared LC PLL to support high speed, high<br/>
		/// performance, and low power multi-lane applications.<br/>
		/// On the device, the GTXE2_CHANNEL component has the serial transceiver and CPLL units and<br/>
		/// the GTXE2_COMMON has the QPLL unit.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This command returns a list of QPLL objects on the device as hw_sio_common objects, or returns<br/>
		/// an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 747<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get 'hw_sio_common' objects of these types: 'hw_server<br/>
		/// hw_target hw_device hw_sio_ibert hw_sio_gtgroup<br/>
		/// hw_sio_pll'.<br/>
		/// </para>
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_sio_common' objects against patterns. Default: *</param>
		/// <returns>hardware SIO GT commons</returns>
		public VivadoTCL get_hw_sio_commons(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_hw_sio_commons [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_hw_sio_commons(of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get list of hardware SIO GT groups.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_hw_sio_gtgroups [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Returns the groups of GTs, hw_sio_gtgroups, as they relate to the quads that are in use on the<br/>
		/// IBERT debug core on the current hardware device.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// GT groups, relate to the IO Banks on the hardware device, with the number of available banks<br/>
		/// and GT pins determined by the target device. On the Kintex-7 xc7k325 part, for example, there<br/>
		/// are four quads, each containing four differential GT pins, and two differential REFCLK pins. Each<br/>
		/// GT pin has its own transmitter, TX, and receiver, RX. Quads can also include one shared PLL per<br/>
		/// quad, or Quad PLL. The quads are defined on the IBERT debug core, and can be customized with<br/>
		/// a number of user settings when the IBERT is added into the RTL design. Refer to the LogiCORE IP<br/>
		/// Integrated Bit Error Ratio Tester (IBERT) for 7 Series GTX Transceivers v3.0 (PG132)or to 7 Series<br/>
		/// FPGAs GTX/GTH Transceivers User Guide (UG476) or UltraScale Architecture GTH Transceivers User<br/>
		/// Guide (UG576) for more information.<br/>
		/// This command returns a list of GT group objects on the IBERT debug core, or returns an error if it<br/>
		/// fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 750<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get 'hw_sio_gtgroup' objects of these types: 'hw_server<br/>
		/// hw_target hw_device hw_sio_ibert hw_sio_common<br/>
		/// hw_sio_pll hw_sio_gt hw_sio_tx hw_sio_rx'.<br/>
		/// </para>
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_sio_gtgroup' objects against patterns. Default: *</param>
		/// <returns>hardware SIO GT groups.</returns>
		public VivadoTCL get_hw_sio_gtgroups(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_hw_sio_gtgroups [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_hw_sio_gtgroups(of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get list of hardware SIO GTs.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_hw_sio_gts [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Returns the Gigabit Transceiver objects (GTs), hw_sio_gt, that are in use on the IBERT debug core<br/>
		/// on the current hardware device.<br/>
		/// The customizable LogiCORE™ IP Integrated Bit Error Ratio Tester (IBERT) core for Xilinx® FPGAs<br/>
		/// is designed for evaluating and monitoring the Gigabit Transceivers (GTs). The IBERT core enables<br/>
		/// in-system serial I/O validation and debug, letting you measure and optimize your high-speed<br/>
		/// serial I/O links in your FPGA-based system. Refer to the LogiCORE IP Integrated Bit Error Ratio<br/>
		/// Tester (IBERT) for 7 Series GTX Transceivers v3.0 (PG132)or to 7 Series FPGAs GTX/GTH Transceivers<br/>
		/// User Guide (UG476) or UltraScale Architecture GTH Transceivers User Guide (UG576) for more<br/>
		/// information.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Using the IBERT debug core you can configure and tune the GT transmitters and receivers<br/>
		/// through the Dynamic Reconfiguration Port (DRP) port of the GTX transceiver. This lets you<br/>
		/// change property settings on the GTs, as well as registers that control the values on the ports.<br/>
		/// This command returns a list of GT objects on the IBERT debug core, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 754<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get 'hw_sio_gt' objects of these types: 'hw_server hw_target<br/>
		/// hw_device hw_sio_ibert hw_sio_gtgroup hw_sio_pll hw_sio_tx<br/>
		/// hw_sio_rx hw_sio_link'.<br/>
		/// </para>
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_sio_gt' objects against patterns. Default: *</param>
		/// <returns>hardware SIO GTs</returns>
		public VivadoTCL get_hw_sio_gts(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_hw_sio_gts [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_hw_sio_gts(of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get list of hardware SIO IBERT cores.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_hw_sio_iberts [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Returns the Integrated Bit Error Ratio Tester (IBERT) debug core objects, hw_sio_ibert, defined<br/>
		/// on the current hardware device.<br/>
		/// The customizable LogiCORE™ IP Integrated Bit Error Ratio Tester (IBERT) core for Xilinx® FPGAs<br/>
		/// is designed for evaluating and monitoring the Gigabit Transceivers (GTs). The IBERT core enables<br/>
		/// in-system serial I/O validation and debug, letting you measure and optimize your high-speed<br/>
		/// serial I/O links in your FPGA-based system. Refer to the LogiCORE IP Integrated Bit Error Ratio<br/>
		/// Tester (IBERT) for 7 Series GTX Transceivers v3.0 (PG132) for more information.<br/>
		/// The IBERT debug core lets you configure and control the major features of GTs on the device,<br/>
		/// including:<br/>
		/// • TX pre-emphasis and post-emphasis<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// • TX differential swing<br/>
		/// • RX equalization<br/>
		/// • Decision Feedback Equalizer (DFE)<br/>
		/// • Phase-Locked Loop (PLL) divider settings<br/>
		/// You can use the IBERT core when you are interested in addressing a range of in-system debug<br/>
		/// and validation problems; from simple clocking and connectivity issues to complex margin analysis<br/>
		/// and channel optimization issues.<br/>
		/// This command returns a list of IBERT debug core objects on the device, or returns an error if it<br/>
		/// fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 757<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get 'hw_sio_ibert' objects of these types: 'hw_server<br/>
		/// hw_target hw_device hw_sio_gtgroup hw_sio_gt<br/>
		/// hw_sio_common hw_sio_pll hw_sio_tx hw_sio_rx hw_sio_link'.<br/>
		/// </para>
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_sio_ibert' objects against patterns. Default: *</param>
		/// <returns>hardware SIO IBERT cores.</returns>
		public VivadoTCL get_hw_sio_iberts(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_hw_sio_iberts [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_hw_sio_iberts(of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get list of hardware SIO link groups.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_hw_sio_linkgroups [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Returns the defined groups, or associations of communication links between TX and RX objects<br/>
		/// on the GTs of the IBERT debug core defined on the current hardware device.<br/>
		/// Vivado Serial I/O analyzer is a link-based analyzer. The links define the communication paths and<br/>
		/// protocols between transmitters and receivers of the GigaBit transceivers on the device. Link<br/>
		/// groups, or hw_sio_linkgroup objects, let you associate links into related groups, to collectively<br/>
		/// configure properties and run scans.<br/>
		/// This command returns a list of linkgroups on the IBERT debug core, or returns an error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 761<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'hw_sio_linkgroup' objects of these types: 'hw_sio_link'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_sio_linkgroup' objects against patterns. Default: *</param>
		/// <returns>hardware SIO link groups</returns>
		public VivadoTCL get_hw_sio_linkgroups(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_hw_sio_linkgroups [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_hw_sio_linkgroups(of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get list of hardware SIO links.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_hw_sio_links [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Returns the communication links between TX and RX objects on the GTs of the IBERT debug<br/>
		/// core defined on the current hardware device.<br/>
		/// Vivado Serial I/O analyzer is a link-based analyzer, which lets you link between any transmitter<br/>
		/// and receiver within the IBERT design. The links define the communication paths and protocols<br/>
		/// between transmitters and receivers of the GigaBit transceivers on the device. You can configure<br/>
		/// the links by using the set_property command to specify property values on the link object.<br/>
		/// This command returns a list of link objects on the IBERT debug core, or returns an error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 764<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get 'hw_sio_link' objects of these types: 'hw_server<br/>
		/// hw_target hw_device hw_sio_ibert hw_sio_gtgroup hw_sio_gt<br/>
		/// hw_sio_tx hw_sio_rx hw_sio_linkgroup'.<br/>
		/// </para>
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_sio_link' objects against patterns. Default: *</param>
		/// <returns>hardware SIO links</returns>
		public VivadoTCL get_hw_sio_links(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_hw_sio_links [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_hw_sio_links(of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get list of hardware SIO PLLs.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_hw_sio_plls [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Returns the PLL objects, hw_sio_pll, defined on the IBERT debug core on the current hardware<br/>
		/// device.<br/>
		/// For each serial transceiver channel, there is a ring PLL called Channel PLL (CPLL). In Xilinx<br/>
		/// UltraScale and 7 series FPGAs, the GTX has an additional shared PLL per quad, or Quad PLL<br/>
		/// (QPLL). This QPLL is a shared LC PLL to support high speed, high performance, and low power<br/>
		/// multi-lane applications.<br/>
		/// On the device, the GTXE2_CHANNEL component has the serial transceiver and CPLL units and<br/>
		/// the GTXE2_COMMON has the QPLL unit.<br/>
		/// This command returns a list of all PLL objects, both CPLLs and QPLLs on the device, or returns an<br/>
		/// error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 767<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get 'hw_sio_pll' objects of these types: 'hw_server hw_target<br/>
		/// hw_device hw_sio_ibert hw_sio_gtgroup hw_sio_gt<br/>
		/// hw_sio_common'.<br/>
		/// </para>
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_sio_pll' objects against patterns. Default: *</param>
		/// <returns>hardware SIO PLLs</returns>
		public VivadoTCL get_hw_sio_plls(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_hw_sio_plls [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_hw_sio_plls(of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get list of hardware SIO RXs.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_hw_sio_rxs [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Returns the receiver objects, hw_sio_rx, of the Gigabit Transceivers (GTs) that are in use on the<br/>
		/// IBERT debug core on the current hardware device.<br/>
		/// On the hardware device, each GT includes an independent receiver, which consists of a PCS and<br/>
		/// a PMA. High-speed serial data flows from traces on the board into the PMA of the GTX/GTH<br/>
		/// transceiver RX, into the PCS, and finally into the FPGA logic.<br/>
		/// This command returns a list of receiver objects on the device, or returns an error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 770<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get 'hw_sio_rx' objects of these types: 'hw_server hw_target<br/>
		/// hw_device hw_sio_ibert hw_sio_gtgroup hw_sio_gt<br/>
		/// hw_sio_link'.<br/>
		/// </para>
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_sio_rx' objects against patterns. Default: *</param>
		/// <returns>hardware SIO RXs</returns>
		public VivadoTCL get_hw_sio_rxs(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_hw_sio_rxs [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_hw_sio_rxs(of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get list of hardware SIO scans.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_hw_sio_scans [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Returns serial I/O analyzer scan objects for the IBERT debug core.<br/>
		/// To analyze the margin of a given link, it is often helpful to run a scan of the link using the<br/>
		/// specialized Eye Scan hardware of Xilinx UltraScale devices or 7 Series FPGAs. The Vivado serial<br/>
		/// I/O analyzer feature lets you to create, run, and save link scans.<br/>
		/// This command returns one or more hw_sio_scan objects, or returns an error if he command fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 773<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get 'hw_sio_scan' objects of these types: 'hw_sio_rx<br/>
		/// hw_sio_link hw_sio_sweep'.<br/>
		/// </para>
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_sio_scan' objects against patterns. Default: *</param>
		/// <returns>hardware SIO scans</returns>
		public VivadoTCL get_hw_sio_scans(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_hw_sio_scans [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_hw_sio_scans(of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get list of hardware SIO sweeps.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_hw_sio_sweeps [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Return the serial I/O analyzer link sweep objects defined on the IBERT debug core.<br/>
		/// To analyze the margin of a given link, it is often helpful to run a scan of the link using the<br/>
		/// specialized features of Xilinx UltraScale devices or 7 series FPGAs. It can also be helpful to run<br/>
		/// multiple scans on a the link with different configuration settings for the GTs. This can help you<br/>
		/// determine which settings are best for your design. The Vivado serial I/O analyzer feature enables<br/>
		/// you to define, run, and save link sweeps, or collections of link scans run across a range of values.<br/>
		/// This command returns a link sweep object that you can use with the run_hw_sio_sweep<br/>
		/// command to run analysis on the specified links, or GT receivers. You can also save the sweep<br/>
		/// scan to disk using the write_hw_sio_sweep command.<br/>
		/// You can remove the created sweep object using remove_hw_sio_sweep.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This command returns one or more hw_sio_sweep objects, or returns an error if the command<br/>
		/// fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 776<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'hw_sio_sweep' objects of these types: 'hw_sio_link hw_sio_scan'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_sio_sweep' objects against patterns. Default: *</param>
		/// <returns>hardware SIO sweeps</returns>
		public VivadoTCL get_hw_sio_sweeps(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_hw_sio_sweeps [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_hw_sio_sweeps(of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get list of hardware SIO TXs.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_hw_sio_txs [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Returns the transmitter objects, hw_sio_tx, of the Gigabit Transceivers (GTs) that are in use on the<br/>
		/// IBERT debug core on the current hardware device.<br/>
		/// On the hardware device, each GT includes an independent transmitter, which consists of a PCS<br/>
		/// and a PMA. Parallel data flows from the device logic into the FPGA TX interface, through the PCS<br/>
		/// and PMA, and then out the TX driver as high-speed serial data.<br/>
		/// This command returns a list of transmitter objects on the device, or returns an error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 780<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get 'hw_sio_tx' objects of these types: 'hw_server hw_target<br/>
		/// hw_device hw_sio_ibert hw_sio_gtgroup hw_sio_gt<br/>
		/// hw_sio_link'.<br/>
		/// </para>
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_sio_tx' objects against patterns. Default: *</param>
		/// <returns>hardware SIO TXs</returns>
		public VivadoTCL get_hw_sio_txs(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_hw_sio_txs [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_hw_sio_txs(of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get list of Versal soft memory controller cores.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_hw_softmcs [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 783<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get 'hw_softmc' objects of these types: 'hw_server<br/>
		/// hw_target hw_device'.<br/>
		/// </para>
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_softmc' objects against patterns. Default: *</param>
		/// <returns>soft memory controller cores</returns>
		public VivadoTCL get_hw_softmcs(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_hw_softmcs [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_hw_softmcs(of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get the system monitor register value<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_hw_sysmon_reg [-quiet] [-verbose] &lt;hw_sysmon&gt; &lt;hexaddress&gt;
		/// <br/>
		/// <para>
		/// Returns the hex value of the system monitor register defined at the specified address of the<br/>
		/// specified hw_sysmon object.<br/>
		/// The System Monitor (SYSMON) Analog-to-Digital Converter (ADC) is used to measure die<br/>
		/// temperature and voltage on the hw_device. The sysmon monitors the physical environment via<br/>
		/// on-chip temperature and supply sensors. The ADC can access up to 17 external analog input<br/>
		/// channels.<br/>
		/// Data for the system monitor is stored in dedicated registers, called status and control registers,<br/>
		/// accessible through the hw_sysmon_reg object. Refer to the Register Interface in UltraScale<br/>
		/// Architecture System Monitor User Guide (UG580), or 7 Series FPGAs and Zynq-7000 SoC XADC Dual<br/>
		/// 12-Bit 1 MSPS Analog-to-Digital Converter User Guide (UG480) for more information on the<br/>
		/// addresses of specific system monitor registers.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Although the get_hw_sysmon_reg command lets you directly access the values stored in<br/>
		/// registers of the hw_sysmon object, the recommended procedure is to retrieve the values of<br/>
		/// registers as formatted properties of the hw_sysmon object. For example, the following code<br/>
		/// retrieves the TEMPERATURE on the system monitor as a formatted property of the hw_sysmon<br/>
		/// object rather than accessing the hex value of the sysmon register:<br/>
		/// set opTemp [get_property TEMPERATURE [get_hw_sysmons]<br/>
		/// The get_property command returns the TEMPERATURE as a formatted value in degrees<br/>
		/// Celsius, Fahrenheit, or Kelvin as determined by the TEMPERATURE_SCALE property on the<br/>
		/// hw_sysmon object.<br/>
		/// TIP: You can also be sure the property value on the object is current by issuing the<br/>
		/// refresh_hw_sysmon command prior to get_property.<br/>
		/// The get_hw_sysmon_reg command returns the unformatted hex value of the hw_sysmon_reg<br/>
		/// object on the specified hw_sysmons at the specified address, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 784<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_sysmon">(Required) hw_sysmon object</param>
		/// <param name="hexaddress">(Required) Hex address to read from</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Register value in Hex.</returns>
		public VivadoTCL get_hw_sysmon_reg(String hw_sysmon, String hexaddress, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_hw_sysmon_reg [-quiet] [-verbose] <hw_sysmon> <hexaddress>
			this.Entry(_builder.get_hw_sysmon_reg(hw_sysmon, hexaddress, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get list of hardware SysMons.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_hw_sysmons [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Returns the Sysmon debug core objects defined on the current hardware device.<br/>
		/// The System Monitor (SYSMON) Analog-to-Digital Converter (ADC) is used to measure die<br/>
		/// temperature and voltage on the hw_device. The Sysmon monitors the physical environment via<br/>
		/// on-chip temperature and supply sensors. The ADC provides a high-precision analog interface for<br/>
		/// a range of applications. The ADC can access up to 17 external analog input channels. Refer to<br/>
		/// UltraScale Architecture System Monitor User Guide (UG580), or 7 Series FPGAs and Zynq-7000 SoC<br/>
		/// XADC Dual 12-Bit 1 MSPS Analog-to-Digital Converter User Guide (UG480) for more information on<br/>
		/// a specific device architecture.<br/>
		/// The hw_sysmon data is stored in dedicated registers called status registers accessible through the<br/>
		/// hw_sysmon_reg object. The values of the system monitor registers can be returned by the<br/>
		/// get_hw_sysmon_reg command.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Every device that supports the system monitor will automatically have one or more hw_sysmon<br/>
		/// objects created when refresh_hw_device is called. When the hw_sysmon object is created, it<br/>
		/// is assigned a property for all the temperature and voltage registers, as well as the control<br/>
		/// registers. On the hw_sysmon object, the values assigned to the temperature and voltage registers<br/>
		/// are already translated to Celsius/Fahrenheit and Voltage.<br/>
		/// Although you can use the get_hw_sysmon_reg command to access the hex values stored in<br/>
		/// registers of a system monitor, you can also retrieve values of certain registers as formatted<br/>
		/// properties of the hw_sysmon object. For example, the following code retrieves the<br/>
		/// TEMPERATURE property of the specified hw_sysmon object rather than directly accessing the<br/>
		/// hex value of the register:<br/>
		/// set opTemp [get_property TEMPERATURE [get_hw_sysmons]<br/>
		/// This command returns a list of hw_sysmon objects on the current or specified hw_device, or<br/>
		/// returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 787<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get 'hw_sysmon' objects of these types: 'hw_server<br/>
		/// hw_target hw_device'.<br/>
		/// </para>
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_sysmon' objects against patterns. Default: *</param>
		/// <returns>hardware sysmons</returns>
		public VivadoTCL get_hw_sysmons(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_hw_sysmons [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_hw_sysmons(of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of hardware targets.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_hw_targets [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Returns the available hardware targets of the connected hardware servers.<br/>
		/// The hardware target is a system board containing a JTAG chain of one or more Xilinx devices that<br/>
		/// you can program with a bitstream file, or use to debug your design. Connections between<br/>
		/// hardware targets on the system board and the Vivado Design Suite are managed by the Xilinx<br/>
		/// hardware server application, and the connect_hw_server command. Refer to Vivado Design<br/>
		/// Suite User Guide: Programming and Debugging (UG908) for a list of supported JTAG download<br/>
		/// cables and devices.<br/>
		/// Use the open_hw_target command to open a connection to one of the available hardware<br/>
		/// targets. The open target is automatically defined as the current hardware target. Alternatively,<br/>
		/// you can define the current target with the current_hw_target command, and then open a<br/>
		/// connection to the current target. The Vivado Design Suite directs programming and debug<br/>
		/// commands to the open target through the hardware server connection.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This command returns a list of available hardware targets through all connected hardware<br/>
		/// servers, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 791<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'hw_target' objects of these types: 'hw_server'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_target' objects against patterns. Default: *</param>
		/// <returns>hardware targets</returns>
		public VivadoTCL get_hw_targets(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_hw_targets [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_hw_targets(of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of hardware VIOs.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_hw_vios [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Returns the Virtual Input/Output (VIO) debug core objects that are defined on the current<br/>
		/// hardware device, hw_device.<br/>
		/// The Virtual Input/Output (VIO) debug core can both monitor and drive internal signals on a<br/>
		/// programmed Xilinx FPGA in real time. In the absence of physical access to the target hardware,<br/>
		/// you can use this debug feature to drive and monitor signals that are present on the physical<br/>
		/// device.<br/>
		/// The VIO core has hardware probes, hw_probe objects, to monitor and drive specific signals on<br/>
		/// the design. Input probes monitor signals as inputs to the VIO core. Output probes drive signals to<br/>
		/// specified values from the VIO core. Values on the debug core are driven onto the signals at the<br/>
		/// probe using the commit_hw_vio command.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The VIO debug core needs to be instantiated in the RTL code, therefore you need to know what<br/>
		/// nets you want monitor and drive prior to debugging the design. The IP catalog provides the VIO<br/>
		/// core under the Debug category. Detailed documentation on the VIO core can be found in the<br/>
		/// LogiCORE IP Virtual Input/Output Product Guide (PG159).<br/>
		/// This command returns a list of VIO debug core objects on the device, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 794<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'hw_vio' objects of these types: 'hw_device'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'hw_vio' objects against patterns. Default: *</param>
		/// <returns>hardware VIOs</returns>
		public VivadoTCL get_hw_vios(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_hw_vios [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_hw_vios(of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of I/O port interfaces in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_interfaces [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of IO interfaces in the current project that match a specified search pattern. The<br/>
		/// default command gets a list of all IO interfaces in the project.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets a list of all interfaces in the project:<br/>
		/// get_interfaces<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 797<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get interfaces of these pins or nets</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match I/O port interfaces against patterns Default: *</param>
		/// <returns>list of interface objects</returns>
		public VivadoTCL get_interfaces(bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_interfaces [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_interfaces(regexp, nocase, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of IO standards.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_io_standards [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Get a list of IOSTANDARDs available for use on the target device.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets a list of differential IOSTANDARDs available for use on the target<br/>
		/// device:<br/>
		/// get_io_standards -filter {IS_DIFFERENTIAL}<br/>
		/// Note: If there are no objects matching the pattern you will get a warning.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 800<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get the IO standards of these bels, sites, package_pins,<br/>
		/// io_banks, ports.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match IO standards against patterns Default: *</param>
		/// <returns>IO standards</returns>
		public VivadoTCL get_io_standards(bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_io_standards [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_io_standards(regexp, nocase, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of iobanks.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_iobanks [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of I/O Banks on the target device in the current project that match a specified search<br/>
		/// pattern. The default command gets a list of all I/O Banks on the target device.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the I/O Bank of the specified package pin:<br/>
		/// get_iobanks -of_objects [get_package_pins H4]<br/>
		/// This example returns the GT Banks on the device:<br/>
		/// get_iobanks -filter {BANK_TYPE == BT_MGT}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 803<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get the iobanks of these package_pins, ports, clock regions,<br/>
		/// slrs or sites.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match iobanks against patterns Default: *</param>
		/// <returns>iobanks</returns>
		public VivadoTCL get_iobanks(bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_iobanks [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_iobanks(regexp, nocase, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of results for IP upgrades during the current project<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_ip_upgrade_results [-srcset &lt;arg&gt;] [-quiet] [-verbose] [&lt;objects&gt;...]
		/// <br/>
		/// <para>
		/// Returns the names of the upgrade_log files for the specified IPs.<br/>
		/// This command is used by the Vivado IDE to populate the IP Status Report window with<br/>
		/// information from the upgrade_log file. You can use the command to quickly obtain the<br/>
		/// upgrade_log file name, and then use the appropriate file commands, to read or display the<br/>
		/// contents.<br/>
		/// This command returns the upgrade_log file names of the specified IP objects, or returns an error<br/>
		/// if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 806<br/>
		/// </para>
		/// </summary>
		/// <param name="srcset">
		/// <para>
		/// (Optional)<br/>
		/// (Optional) Specifies the source file set containing the<br/>
		/// upgraded IP Default: The current source fileset Values:<br/>
		/// Source set name<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">
		/// <para>
		/// (Optional)<br/>
		/// IP to be upgraded Values: IP instance(s) within the design,<br/>
		/// as returned by 'get_ips &lt;instance name&gt;' or 'get_bd_cells<br/>
		/// &lt;cell name&gt;'<br/>
		/// </para>
		/// </param>
		/// <returns>list of IP upgrade results</returns>
		public VivadoTCL get_ip_upgrade_results(String srcset = null, bool? quiet = null, bool? verbose = null, TCLParameterList objects = null)
		{
			// TCL Syntax: get_ip_upgrade_results [-srcset <arg>] [-quiet] [-verbose] [<objects>...]
			this.Entry(_builder.get_ip_upgrade_results(srcset, quiet, verbose, objects));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of IP from the current IP Catalog<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_ipdefs [-name] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-all] [-quiet] [-verbose] [&lt;patterns&gt;...]
		/// <br/>
		/// <para>
		/// Get a list of IP cores defined in the IP catalog of the current project, based on the specified<br/>
		/// search pattern. The default is to return all IP cores defined in the Vivado tools IP catalog.<br/>
		/// By default, the search is based on the VLNV property of the IP cores in the catalog. You can<br/>
		/// specify the -name option to search on the display name of IP cores instead.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns a list of all IP cores with NAME property matching the specified<br/>
		/// pattern:<br/>
		/// get_ipdefs -filter {NAME=~*agilent*}<br/>
		/// TIP: The filter operator '=~' loosely matches the specified pattern.<br/>
		/// The following example returns a list of all AXI compliant IP cores:<br/>
		/// get_ipdefs -filter {IS_AXI==1}<br/>
		/// The following example returns IP from both the Vivado tools standard IP catalog and the IP<br/>
		/// integrator IP catalog:<br/>
		/// get_ipdefs -all *axi_interconnect*<br/>
		/// The following example filters the above results with the DESIGN_TOOL_CONTEXTS property to<br/>
		/// return only the IP integrator IP:<br/>
		/// get_ipdefs -all *axi_interconnect* -filter {DESIGN_TOOL_CONTEXTS =~*IPI*}<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// TIP: By filtering on the DESIGN_TOOL_CONTEXTS property, you can identify IP from the IP integrator<br/>
		/// catalog instead of the Vivado tools standard catalog.<br/>
		/// In some cases, where multiple versions of an IP are returned, you can also filter on the<br/>
		/// UPGRADE_VERSIONS property to get as specific version or the latest IP version, as shown in the<br/>
		/// following example:<br/>
		/// get_ipdefs -all *axi_interconnect* -filter {UPGRADE_VERSIONS == ""}<br/>
		/// TIP: The {UPGRADE_VERSIONS == ""} filter returns IP defs that have no upgrade, and so are the latest<br/>
		/// version.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 808<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Optional) Match the pattern against IP display name instead of VLNV</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get the IPDefs of the objects specified: IP inst or XCI file.</param>
		/// <param name="all">(Optional) Return hidden IP</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// <para>
		/// (Optional)<br/>
		/// The patterns to match against Default: * Values: The default<br/>
		/// search pattern is the wildcard *, or .* when -regexp is<br/>
		/// specified.<br/>
		/// </para>
		/// </param>
		/// <returns>List of Catalog IP objects</returns>
		public VivadoTCL get_ipdefs(bool? name = null, bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, bool? all = null, bool? quiet = null, bool? verbose = null, TCLParameterList patterns = null)
		{
			// TCL Syntax: get_ipdefs [-name] [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-all] [-quiet] [-verbose] [<patterns>...]
			this.Entry(_builder.get_ipdefs(name, regexp, nocase, filter, of_objects, all, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of IPs in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_ips [-regexp] [-nocase] [-all] [-filter &lt;arg&gt;] [-exclude_bd_ips] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;...]
		/// <br/>
		/// <para>
		/// Get a list of IP cores in the current project based on the specified search pattern. The default<br/>
		/// command returns a list of all IPs in the project.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns a list of IP cores with names beginning with the string "EDK":<br/>
		/// get_ips EDK*<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 812<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching</param>
		/// <param name="all">(Optional) Include subcore IP in search</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="exclude_bd_ips">(Optional) Exclude all IP owned by a block design.</param>
		/// <param name="of_objects">(Optional) Get 'ip' objects of these types: 'ip file'.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// <para>
		/// (Optional)<br/>
		/// Match IP names against patterns Default: * Values: The<br/>
		/// default search pattern is the wildcard *, or .* when -regexp<br/>
		/// is specified.<br/>
		/// </para>
		/// </param>
		/// <returns>list of IP objects</returns>
		public VivadoTCL get_ips(bool? regexp = null, bool? nocase = null, bool? all = null, String filter = null, bool? exclude_bd_ips = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, TCLParameterList patterns = null)
		{
			// TCL Syntax: get_ips [-regexp] [-nocase] [-all] [-filter <arg>] [-exclude_bd_ips] [-of_objects <args>] [-quiet] [-verbose] [<patterns>...]
			this.Entry(_builder.get_ips(regexp, nocase, all, filter, exclude_bd_ips, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of Library Cells<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_lib_cells [-regexp] [-filter &lt;arg&gt;] [-nocase] [-include_unsupported] [-of_objects &lt;args&gt;] [-quiet] [-verbose] &lt;patterns&gt;
		/// <br/>
		/// <para>
		/// Get a list of cells in the library for the target part of the current design. Use this command to<br/>
		/// query and look for a specific library cell, or type of cell and to get the properties of the cells.<br/>
		/// This command requires a hierarchical name which includes the library name as well as the cell<br/>
		/// name: lib_name/cell_name.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets the number of the cells in the library for the target part in the current<br/>
		/// design, and then gets the number of AND type cells in that library:<br/>
		/// llength [get_lib_cells [get_libs]/*]<br/>
		/// 795<br/>
		/// llength [get_lib_cells [get_libs]/AND*]<br/>
		/// 18<br/>
		/// The following example gets the library cell for the specified cell object:<br/>
		/// get_lib_cells -of_objects [lindex [get_cells] 1]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 815<br/>
		/// </para>
		/// </summary>
		/// <param name="patterns">(Required) Match library cell names against patterns.</param>
		/// <param name="regexp">(Optional) Patterns are regular expressions.</param>
		/// <param name="filter">(Optional) Filter list with expression.</param>
		/// <param name="nocase">
		/// <para>
		/// (Optional)<br/>
		/// Perform case-insensitive matching when a pattern has been<br/>
		/// specified. This argument applies to the use of -regexp only.<br/>
		/// </para>
		/// </param>
		/// <param name="include_unsupported">(Optional) Include test-only library cells.</param>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get the library cells of the objects passed in here. Valid<br/>
		/// objects are cells or instances (ie, get_cells), cell pins (ie,<br/>
		/// get_pins) and library pins (ie, get_lib_pins).<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of library cells</returns>
		public VivadoTCL get_lib_cells(String patterns, bool? regexp = null, String filter = null, bool? nocase = null, bool? include_unsupported = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_lib_cells [-regexp] [-filter <arg>] [-nocase] [-include_unsupported] [-of_objects <args>] [-quiet] [-verbose] <patterns>
			this.Entry(_builder.get_lib_cells(patterns, regexp, filter, nocase, include_unsupported, of_objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of Library Cell Pins<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_lib_pins [-regexp] [-filter &lt;arg&gt;] [-nocase] [-of_objects &lt;args&gt;] [-quiet] [-verbose] &lt;patterns&gt;
		/// <br/>
		/// <para>
		/// Gets a list of the pins on a specified cell of the cell library for the target part in the current design.<br/>
		/// Note: This command requires a hierarchical name which includes the library name and cell name as well as<br/>
		/// the pins: lib_name/cell_name/pins.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets a list of all library cell pins:<br/>
		/// get_lib_pins xt_virtex6/AND2/*<br/>
		/// The following example gets a list of all pins, of all cells in the cell library for the target device:<br/>
		/// get_lib_pins [get_libs]/*/*<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 818<br/>
		/// </para>
		/// </summary>
		/// <param name="patterns">
		/// <para>
		/// (Required)<br/>
		/// Match library cell pin names against patterns of the form<br/>
		/// &lt;library cell pattern&gt;/&lt;library pin pattern&gt;.<br/>
		/// </para>
		/// </param>
		/// <param name="regexp">(Optional) Patterns are regular expressions</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="nocase">
		/// <para>
		/// (Optional)<br/>
		/// Perform case-insensitive matching when a pattern has been<br/>
		/// specified. This argument applies to the use of -regexp only.<br/>
		/// </para>
		/// </param>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get the library cell pins of the objects passed in here. Valid<br/>
		/// objects are cells or instances (ie, get_cells), cell pins (ie,<br/>
		/// get_pins) and library cells (ie get_lib_cells).<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of library cell pins</returns>
		public VivadoTCL get_lib_pins(String patterns, bool? regexp = null, String filter = null, bool? nocase = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_lib_pins [-regexp] [-filter <arg>] [-nocase] [-of_objects <args>] [-quiet] [-verbose] <patterns>
			this.Entry(_builder.get_lib_pins(patterns, regexp, filter, nocase, of_objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of Libraries<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_libs [-regexp] [-filter &lt;arg&gt;] [-nocase] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets the cell library for the target device in the current design. There is a library for each device<br/>
		/// family because there are primitives that may be available in one device family but not in others.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets the cell library for the target part:<br/>
		/// get_libs<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 821<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are regular expressions</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="nocase">
		/// <para>
		/// (Optional)<br/>
		/// Perform case-insensitive matching when a pattern has been<br/>
		/// specified. This argument applies to the use of -regexp only.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match library names against patterns. Default: *</param>
		/// <returns>list of libraries</returns>
		public VivadoTCL get_libs(bool? regexp = null, String filter = null, bool? nocase = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_libs [-regexp] [-filter <arg>] [-nocase] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_libs(regexp, filter, nocase, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of macros in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_macros [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of macros in the current design that match a specified search pattern. The default<br/>
		/// command returns a list of all macros in the design.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the properties currently assigned to the macro matching the<br/>
		/// specified search pattern:<br/>
		/// report_property [get_macro *Macro1]<br/>
		/// Note: If there are no macros matching the pattern you will get a warning.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 824<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get macros of these cells</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match macro names against patterns Default: *</param>
		/// <returns>list of macro objects</returns>
		public VivadoTCL get_macros(bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_macros [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_macros(regexp, nocase, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get marked objects<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_marked_objects [-rgb &lt;args&gt;] [-color &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Get the marked objects in the current design open in the Vivado IDE. Objects can be marked<br/>
		/// with the mark_objects command.<br/>
		/// You can get all marked objects in the design, or specify marked objects by color, or by RGB value.<br/>
		/// Note: This Tcl command works only when Vivado is run in GUI mode.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets all the marked objects in the current design:<br/>
		/// get_marked_objects<br/>
		/// The following example gets the object in the current design that are marked in the specified<br/>
		/// color:<br/>
		/// get_marked_objects -color yellow<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 827<br/>
		/// </para>
		/// </summary>
		/// <param name="rgb">(Optional) RGB color index list</param>
		/// <param name="color">(Optional) Valid values are red green blue magenta yellow cyan and orange</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of marked objects</returns>
		public VivadoTCL get_marked_objects(TCLParameterList rgb = null, String color = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_marked_objects [-rgb <args>] [-color <arg>] [-quiet] [-verbose]
			this.Entry(_builder.get_marked_objects(rgb, color, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of Methodology rule check objects<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_methodology_checks [-regexp] [-nocase] [-filter &lt;arg&gt;] [-abbrev &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of the currently defined methodology checks. This list includes the factory defined<br/>
		/// methodology checks for process and timing.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following command gets a list of all synthesis methodology checks:<br/>
		/// get_methodology_checks SYNTH*<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 829<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="abbrev">(Optional) Get the largest ID for this abbrev</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'rule_check' objects against patterns. Default: *</param>
		/// <returns>list of Methodology rule_check objects</returns>
		public VivadoTCL get_methodology_checks(bool? regexp = null, bool? nocase = null, String filter = null, String abbrev = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_methodology_checks [-regexp] [-nocase] [-filter <arg>] [-abbrev <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_methodology_checks(regexp, nocase, filter, abbrev, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of Methodology violations from a previous report_methodology run<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_methodology_violations [-name &lt;arg&gt;] [-regexp] [-filter &lt;arg&gt;] [-nocase] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of violation objects found in the design when the report_methodology command<br/>
		/// is run. The properties of individual violation objects can be queried using report_property or<br/>
		/// list_property commands for details of the violation.<br/>
		/// Violation objects are associated with the cells, nets, pins, or ports in the current design, or sites<br/>
		/// on the current device. The design objects associated with a methodology violation object can be<br/>
		/// obtained using the -of_objects option of the appropriate get_* command, such as<br/>
		/// get_cells, or get_nets for instance.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports the methodology violations found in the current design, then<br/>
		/// returns a list of all those violations:<br/>
		/// report_methodology<br/>
		/// get_methodology_violations<br/>
		/// The following example generates list of violations in the named methodology report, and then<br/>
		/// gets the pins associated with any violations found:<br/>
		/// report_methodology -name method_1<br/>
		/// get_pins -of_objects [get_methodology_violations -name method_1]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 832<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Optional) Get the results with this name</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// <para>
		/// (Optional)<br/>
		/// Match methodology_violations against patterns Default: *<br/>
		/// Values: The default search pattern is the wildcard *, or .*<br/>
		/// when -regexp is specified.<br/>
		/// </para>
		/// </param>
		/// <returns>list of Methodology violation objects</returns>
		public VivadoTCL get_methodology_violations(String name = null, bool? regexp = null, String filter = null, bool? nocase = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_methodology_violations [-name <arg>] [-regexp] [-filter <arg>] [-nocase] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_methodology_violations(name, regexp, filter, nocase, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Returns the current message count, limit, or the message configuration rules previously defined<br/>
		/// by the set_msg_config command.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_msg_config [-id &lt;arg&gt;] [-severity &lt;arg&gt;] [-rules] [-limit] [-count] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Returns the current message limit or count applied to a specified message ID or severity, or<br/>
		/// returns all message configuration rules defined in the current project. Message configuration<br/>
		/// rules are defined using the set_msg_config command.<br/>
		/// When used with -count this command will display the total number of messages that have<br/>
		/// been generated with the matching message id, or for the specified severity.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// IMPORTANT! The get_msg_config command reports the message count for the original CPU process<br/>
		/// from which Vivado was launched. Any sub-processes that the Vivado Design Suite launches, such as sub-processes used by the launch_runs command to launch synthesis and implementation runs, will not be<br/>
		/// reported in the message count. This can create confusion when the message count returned by<br/>
		/// get_msg_config -count is different from what is displayed in the Vivado IDE for instance, or<br/>
		/// different from what you expect. For this reason, the -count option is best used for non-project based<br/>
		/// designs.<br/>
		/// When used with -limit this command will display the current limit of messages with the<br/>
		/// matching message id, or for the specified severity.<br/>
		/// When used with -rules, it will display a table of all message configuration rules currently in<br/>
		/// effect.<br/>
		/// Note: You can only return the limit, the count, or the rules in a single get_msg_config command. An<br/>
		/// error is returned if more than one action is attempted.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets the current count of the specified INFO message:<br/>
		/// get_msg_config -id "Common 17-81" -count<br/>
		/// The following example returns the message configuration rules in the current project:<br/>
		/// get_msg_config -rules<br/>
		/// This example changes the severity of messages with the specified message ID, gets the current<br/>
		/// message configuration rules, and then shows two different command forms to reset the specific<br/>
		/// rule and restore the message:<br/>
		/// set_msg_config -id "Common 17-361" -severity INFO -new_severity WARNING<br/>
		/// get_msg_config -rules<br/>
		/// ---------------------<br/>
		/// Message control rules currently in effect are:<br/>
		/// Rule Name Rule Current<br/>
		/// Message Count<br/>
		/// 1 set_msg_config -ruleid {1} -id {Common 17-361} -severity {INFO} -<br/>
		/// new_severity {WARNING} 0<br/>
		/// ---------------------<br/>
		/// reset_msg_config -id "Common 17-361" -default_severity<br/>
		/// reset_msg_config -ruleid {1}<br/>
		/// TIP: In the preceding example, only one of the reset_msg_config commands is needed to reset the<br/>
		/// message.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 835<br/>
		/// </para>
		/// </summary>
		/// <param name="id">
		/// <para>
		/// (Optional)<br/>
		/// The message id to match. Should be used in conjunction<br/>
		/// with -limit or -count Default: empty<br/>
		/// </para>
		/// </param>
		/// <param name="severity">
		/// <para>
		/// (Optional)<br/>
		/// The message severity to match. Should be used in<br/>
		/// conjunction with -limit or -count Default: empty<br/>
		/// </para>
		/// </param>
		/// <param name="rules">
		/// <para>
		/// (Optional)<br/>
		/// Show a table displaying all message control rules for the<br/>
		/// current project<br/>
		/// </para>
		/// </param>
		/// <param name="limit">
		/// <para>
		/// (Optional)<br/>
		/// Show the limit for the number of messages matching either<br/>
		/// -id or -severity that will be displayed<br/>
		/// </para>
		/// </param>
		/// <param name="count">
		/// <para>
		/// (Optional)<br/>
		/// Show the number of messages matching either -id or -<br/>
		/// severity that have been displayed<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL get_msg_config(String id = null, String severity = null, bool? rules = null, bool? limit = null, bool? count = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_msg_config [-id <arg>] [-severity <arg>] [-rules] [-limit] [-count] [-quiet] [-verbose]
			this.Entry(_builder.get_msg_config(id, severity, rules, limit, count, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get the routed or estimated delays in picoseconds on a net from the driver to each load pin.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_net_delays -of_objects &lt;args&gt; [-regexp] [-nocase] [-patterns &lt;arg&gt;] [-filter &lt;arg&gt;] [-to &lt;args&gt;] [-interconnect_only] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Get delay objects for the specified nets in the current design, from the driver to each load pin, or<br/>
		/// to specified load pins, through specific pins.<br/>
		/// The delay object contains properties defining the maximum and minimum delays for the fast and<br/>
		/// slow process corners. Use the get_property command to extract the property of interest from<br/>
		/// the delay object. Delay property values on the delay object are specified in picoseconds.<br/>
		/// TIP: In most cases the Vivado tools return delay values specified in nanoseconds, but the delay object uses<br/>
		/// picoseconds.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The values returned are calculated or estimated depending upon whether the net is routed.<br/>
		/// Delay values can include the actual delay of routed interconnect, or estimated net delays for<br/>
		/// unrouted nets. The net delay can also include delay through logic elements or device sites, or just<br/>
		/// include the interconnect delay.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// The get_net_delays command returns the delay objects for the specified nets, or returns an<br/>
		/// error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets the interconnect delay values for the specified net, and returns it in<br/>
		/// the form of a delay object:<br/>
		/// report_property -all [lindex [get_net_delays -interconnect_only \<br/>
		/// -of_objects [get_nets control_reg[*]]] 16 ]<br/>
		/// TIP: The FAST_MAX, FAST_MIN, SLOW_MAX, and SLOW_MIN properties on the delay object are<br/>
		/// reported in picoseconds.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 838<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">(Required) Get 'net_delay' objects of these types: 'net'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="patterns">(Optional) Match the 'net_delay' objects against patterns. Default: *</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="to">(Optional) Get the delay of the net to the given terminal(s) or port(s).</param>
		/// <param name="interconnect_only">
		/// <para>
		/// (Optional)<br/>
		/// Include only interconnect delays. The default is to include<br/>
		/// the intra-site delay.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>net_delays</returns>
		public VivadoTCL get_net_delays(TCLParameterList of_objects, bool? regexp = null, bool? nocase = null, String patterns = null, String filter = null, TCLParameterList to = null, bool? interconnect_only = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_net_delays -of_objects <args> [-regexp] [-nocase] [-patterns <arg>] [-filter <arg>] [-to <args>] [-interconnect_only] [-quiet] [-verbose]
			this.Entry(_builder.get_net_delays(of_objects, regexp, nocase, patterns, filter, to, interconnect_only, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of nets in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_nets [-hsc &lt;arg&gt;] [-hierarchical] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-match_style &lt;arg&gt;] [-top_net_of_hierarchical_group] [-segments] [-boundary_type &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of nets in the current design that match a specified search pattern. The default<br/>
		/// command gets a list of all nets in the current_instance of the open design, as specified by the<br/>
		/// current_instance command.<br/>
		/// You can use the -hierarchical option to extract nets from the hierarchy of the current<br/>
		/// design.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example runs the report_drc command on the current design, returns the list of<br/>
		/// violations in the specified DRC report, and then returns any nets associated with the driverless<br/>
		/// net rule (NDRV):<br/>
		/// report_drc -name drc_1<br/>
		/// get_drc_violations -name drc_1<br/>
		/// get_nets -of_objects [get_drc_violations -name drc_1 NDRV*]<br/>
		/// The following example returns a list of nets that have been marked for debug with the<br/>
		/// connect_debug_port command:<br/>
		/// get_nets -hier -filter {MARK_DEBUG==1}<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This example returns the net attached to the specified hierarchical pin object, then returns the<br/>
		/// net segments attached to the pin object, then returns the top-level net segment attached to the<br/>
		/// pin object:<br/>
		/// get_nets \<br/>
		/// -of [get_pins cpuEngine/or1200_cpu/or1200_sprs/esr_reg[9]_i_3/I0]<br/>
		/// get_nets -segments \<br/>
		/// -of [get_pins cpuEngine/or1200_cpu/or1200_sprs/esr_reg[9]_i_3/I0]<br/>
		/// get_nets -top -segments \<br/>
		/// -of [get_pins cpuEngine/or1200_cpu/or1200_sprs/esr_reg[9]_i_3/I0]<br/>
		/// In the following example, the first command applies the -filter to find nets that have the<br/>
		/// IS_INTERNAL property, and then -segment is applied to return the segments of those nets. This<br/>
		/// command returns 0 net segments (and a warning). The second command, returns the segments<br/>
		/// of all nets, and filters the results to find the segments that have the IS_INTERNAL property, of<br/>
		/// which there are 448:<br/>
		/// llength [get_nets -segments -filter {IS_INTERNAL}]<br/>
		/// WARNING: [Vivado 12-1023] No nets matched for command 'get_nets -segments<br/>
		/// -filter IS_INTERNAL'.<br/>
		/// 0<br/>
		/// llength [filter [get_nets -segments] {IS_INTERNAL}]<br/>
		/// 448<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 842<br/>
		/// </para>
		/// </summary>
		/// <param name="hsc">(Optional) Hierarchy separator Default: /</param>
		/// <param name="hierarchical">(Optional) Search level-by-level in current instance</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get nets of these pins, ports, cells, timing paths or clocks,<br/>
		/// drc violations<br/>
		/// </para>
		/// </param>
		/// <param name="match_style">(Optional) Style of pattern matching, valid values are ucf, sdc Default: sdc</param>
		/// <param name="top_net_of_hierarchical_group">
		/// <para>
		/// (Optional)<br/>
		/// Return net segment(s) which belong(s) to the high level of a<br/>
		/// hierarchical net<br/>
		/// </para>
		/// </param>
		/// <param name="segments">(Optional) Return all segments of a net across the hierarchy</param>
		/// <param name="boundary_type">
		/// <para>
		/// (Optional)<br/>
		/// Return net segment connected to a hierarchical pin which<br/>
		/// resides at the same level as the pin (upper) or at the level<br/>
		/// below (lower), or both. Valid values are : upper, lower, both<br/>
		/// Default: upper<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match net names against patterns Default: *</param>
		/// <returns>list of net objects</returns>
		public VivadoTCL get_nets(String hsc = null, bool? hierarchical = null, bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, String match_style = null, bool? top_net_of_hierarchical_group = null, bool? segments = null, String boundary_type = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_nets [-hsc <arg>] [-hierarchical] [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-match_style <arg>] [-top_net_of_hierarchical_group] [-segments] [-boundary_type <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_nets(hsc, hierarchical, regexp, nocase, filter, of_objects, match_style, top_net_of_hierarchical_group, segments, boundary_type, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of nodes in the device.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_nodes [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-uphill] [-downhill] [-flyover] [-from &lt;args&gt;] [-to &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Returns a list of nodes on the device that match a specified search pattern in an open design.<br/>
		/// The default command gets a list of all nodes on the device.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the nodes associated with the specified tile:<br/>
		/// get_nodes -of_objects [get_tiles CLBLM_R_X11Y158]<br/>
		/// The following example returns the nodes downhill from the specified node:<br/>
		/// get_nodes -downhill -of_objects [get_nodes LIOB33_SING_X0Y199/IOB_PADOUT0]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 847<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get 'node' objects of these types: 'net tile node bel_pin<br/>
		/// site_pin wire pip speed_model'.<br/>
		/// </para>
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="uphill">
		/// <para>
		/// (Optional)<br/>
		/// Get the nodes uphill (driver) from the site_pin, pip, node or<br/>
		/// tile(s) provided in the -of_objects.<br/>
		/// </para>
		/// </param>
		/// <param name="downhill">
		/// <para>
		/// (Optional)<br/>
		/// Get the nodes downhill (loads) from the site_pin, pip, node<br/>
		/// or tile(s) provided in the -of_objects.<br/>
		/// </para>
		/// </param>
		/// <param name="flyover">(Optional) Get the nodes that fly over the given tile(s).</param>
		/// <param name="from">
		/// <para>
		/// (Optional)<br/>
		/// -from &lt;pip/site pin&gt; Return the nodes beginning at this pip<br/>
		/// or site pin. May be used in combination with uphill. Default<br/>
		/// is downhill. -all is implied.<br/>
		/// </para>
		/// </param>
		/// <param name="to">
		/// <para>
		/// (Optional)<br/>
		/// -to &lt;pip/site pin&gt; Return the nodes ending at this wire or<br/>
		/// site pin. May be used in combination with uphill. Default is<br/>
		/// downhill. -all is implied.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'node' objects against patterns. Default: *</param>
		/// <returns>nodes</returns>
		public VivadoTCL get_nodes(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? uphill = null, bool? downhill = null, bool? flyover = null, TCLParameterList from = null, TCLParameterList to = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_nodes [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-uphill] [-downhill] [-flyover] [-from <args>] [-to <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_nodes(of_objects, regexp, nocase, filter, uphill, downhill, flyover, from, to, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of HDL objects in one or more HDL scopes as per the specified pattern<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_objects [-filter &lt;arg&gt;] [-r] [-local] [-regexp] [-nocase] [-quiet] [-verbose] [&lt;patterns&gt;...]
		/// <br/>
		/// <para>
		/// Returns a list of HDL objects matching the specified search pattern in one or more HDL scopes.<br/>
		/// HDL objects include HDL signals, variables, or constants as defined in the Verilog or VHDL test<br/>
		/// bench and source files. An HDL signal includes Verilog wire or reg entities, and VHDL signals.<br/>
		/// Examples of HDL variables include Verilog real, realtime, time, and event. HDL constants include<br/>
		/// Verilog parameters and localparams, and VHDL generic and constants.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The HDL scope, or scope, is defined by a declarative region in the HDL code such as a module,<br/>
		/// function, task, process, or begin-end blocks in Verilog. VHDL scopes include entity/architecture<br/>
		/// definitions, block, function, procedure, and process blocks.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// Verilog parameters and localparams, and VHDL generic and constants.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The HDL scope, or scope, is defined by a declarative region in the HDL code such as a module,<br/>
		/// function, task, process, or begin-end blocks in Verilog. VHDL scopes include entity/architecture<br/>
		/// definitions, block, function, procedure, and process blocks.<br/>
		/// Arguments<br/>
		/// -r - (Optional) Apply the command to the current scope, and all sub-scopes of the current scope.<br/>
		/// -regexp - (Optional) Specifies that the search &lt;patterns&gt; are written as regular expressions.<br/>
		/// Both search &lt;patterns&gt; and -filter expressions must be written as regular expressions when<br/>
		/// this argument is used. Xilinx regular expression Tcl commands are always anchored to the start of<br/>
		/// the search string. You can add ".*" to the beginning or end of a search string to widen the search<br/>
		/// to include a substring. See http://perldoc.perl.org/perlre.html for help with regular expression<br/>
		/// syntax.<br/>
		/// Note: The Tcl built-in command regexp is not anchored, and works as a standard Tcl command. For more<br/>
		/// information refer to http://www.tcl.tk/man/tcl8.5/TclCmd/regexp.htm.<br/>
		/// -nocase - (Optional) Perform case-insensitive matching when a pattern has been specified. This<br/>
		/// argument applies to the use of -regexp only.<br/>
		/// -filter &lt;args&gt; - (Optional) Filter the results list with the specified expression. The -filter<br/>
		/// argument filters the list of objects returned by get_objects based on property values on the<br/>
		/// objects. You can find the properties on an object with the report_property or<br/>
		/// list_property commands. In the case of the HDL object, "NAME", "SCOPE" and "TYPE" are<br/>
		/// some of the properties that can be used to filter results.<br/>
		/// The filter search pattern should be quoted to avoid having to escape special characters that may<br/>
		/// be found in net, pin, or cell names, or other properties. String matching is case-sensitive and is<br/>
		/// always anchored to the start and to the end of the search string. The wildcard “*” character can<br/>
		/// be used at the beginning or at the end of a search string to widen the search to include a<br/>
		/// substring of the property value.<br/>
		/// Note: The filter returns an object if a specified property exists on the object, and the specified pattern<br/>
		/// matches the property value on the object. In the case of the "*" wildcard character, this will match a<br/>
		/// property with a defined value of "".<br/>
		/// For string comparison, the specific operators that can be used in filter expressions are "equal"<br/>
		/// (==), "not-equal" (!=), "match" (=~), and "not-match" (!~). Numeric comparison operators &lt;, &gt;, &lt;=,<br/>
		/// and &gt;= can also be used. Multiple filter expressions can be joined by AND and OR (&amp;&amp; and ||).<br/>
		/// The following gets input pins that do NOT contain the “RESET” substring within their name:<br/>
		/// get_pins * -filter {DIRECTION == IN &amp;&amp; NAME !~ "*RESET*"}<br/>
		/// Boolean (bool) type properties can be directly evaluated in filter expressions as true or not true:<br/>
		/// -filter {IS_PRIMITIVE &amp;&amp; !IS_LOC_FIXED}<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// -quiet - (Optional) Execute the command quietly, returning no messages from the command.<br/>
		/// The command also returns TCL_OK regardless of any errors encountered during execution.<br/>
		/// Note: Any errors encountered on the command-line, while launching the command, will be returned. Only<br/>
		/// errors occurring inside the command will be trapped.<br/>
		/// -verbose - (Optional) Temporarily override any message limits and return all messages from this<br/>
		/// command.<br/>
		/// Note: Message limits can be defined with the set_msg_config command.<br/>
		/// &lt;patterns&gt; - (Optional) Match HDL objects against the specified patterns. The default pattern is<br/>
		/// the wildcard '*' which returns all the children in the current scope. The search pattern can be<br/>
		/// defined in two ways:<br/>
		/// • &lt;patterns&gt; - Specifies only the search pattern for the objects to get. This method returns all<br/>
		/// objects in the current scope (and any sub-scopes when -recursive is used).<br/>
		/// • &lt;scope&gt;/&lt;pattern&gt; - Specifies the scope of interest, relative to the current scope, and the<br/>
		/// pattern for objects to locate. In this case, the specified &lt;scope&gt;, and any sub-scopes of it if -<br/>
		/// recursive is used, are identified starting from the current scope. Then all objects matching<br/>
		/// the search &lt;pattern&gt; are identified and returned.<br/>
		/// Examples<br/>
		/// The following example specifies the current_scope, then gets all HDL objects in that scope:<br/>
		/// current_scope ./cpuEngine<br/>
		/// get_objects<br/>
		/// The following example returns the count of all objects in the current scope, and then returns the<br/>
		/// count of all objects in the current scope, and all sub-scopes of it:<br/>
		/// llength [get_objects]<br/>
		/// 182<br/>
		/// llength [get_objects -recursive ]<br/>
		/// 2182<br/>
		/// The following example specifies the &lt;scope&gt;/&lt;pattern&gt; search pattern as discussed above.<br/>
		/// Notice that the cpuEngine scope and various sub-scopes of it are identified, then objects<br/>
		/// matching the cl* pattern in those scopes are returned:<br/>
		/// get_objects -recursive -filter {type == internal_signal} cpuEngine/cl*<br/>
		/// /top/cpuEngine/clk_i<br/>
		/// /top/cpuEngine/iwb_biu/clk<br/>
		/// /top/cpuEngine/iwb_biu/clmode<br/>
		/// /top/cpuEngine/or1200_cpu/clk<br/>
		/// ...<br/>
		/// /top/cpuEngine/or1200_immu_top/or1200_immu_tlb/itlb_mr_ram/clk<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Search the current scope, and all sub-scopes, for any internal signals whose names start with cl<br/>
		/// or ma:<br/>
		/// get_objects -recursive -filter {type == internal_signal} ma* cl*<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 851<br/>
		/// </para>
		/// </summary>
		/// <param name="filter">
		/// <para>
		/// (Optional)<br/>
		/// filters &lt;patterns&gt; according to the specified property-matching expressions<br/>
		/// </para>
		/// </param>
		/// <param name="r">(Optional) Searches recursively for objects</param>
		/// <param name="local">
		/// <para>
		/// (Optional)<br/>
		/// Searches objects in the subprogram frame selected for the<br/>
		/// current scope<br/>
		/// </para>
		/// </param>
		/// <param name="regexp">
		/// <para>
		/// (Optional)<br/>
		/// Search using regular expressions, search design objects<br/>
		/// from which to create wave objects by design object name.<br/>
		/// The application supplying the design objects determines<br/>
		/// how the match is to be performed. Items must be strings.<br/>
		/// </para>
		/// </param>
		/// <param name="nocase">(Optional) Perform a case insensitive match (only used with regexp)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// <para>
		/// (Optional)<br/>
		/// Patterns to search for. Default is * where all HDL objects are<br/>
		/// returned<br/>
		/// </para>
		/// </param>
		/// <returns>Returns all the objects found given the specified pattern</returns>
		public VivadoTCL get_objects(String filter = null, bool? r = null, bool? local = null, bool? regexp = null, bool? nocase = null, bool? quiet = null, bool? verbose = null, TCLParameterList patterns = null)
		{
			// TCL Syntax: get_objects [-filter <arg>] [-r] [-local] [-regexp] [-nocase] [-quiet] [-verbose] [<patterns>...]
			this.Entry(_builder.get_objects(filter, r, local, regexp, nocase, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of package pins<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_package_pins [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of the pins on the selected package for the target device. The default command gets a<br/>
		/// list of all pins on the package.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets a list of the package pins associated with the specified bytegroup of<br/>
		/// an UltraScale device:<br/>
		/// get_package_pins -of [get_pkgpin_bytegroups BANK44_BYTE0]<br/>
		/// The following example gets the number of clock capable (CC) pins on the package:<br/>
		/// llength [get_package_pins -filter {IS_CLK_CAPABLE==1}]<br/>
		/// Note: If there are no pins matching the pattern you will get a warning.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 855<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get the list of package pin objects of these sites, bels,<br/>
		/// iobanks, pkgpin_bytegroups, pkgpin_nibbles, or ports.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match list of package pin objects against patterns Default: *</param>
		/// <returns>list of package pin objects</returns>
		public VivadoTCL get_package_pins(bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_package_pins [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_package_pins(regexp, nocase, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a parameter value<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_param [-quiet] [-verbose] &lt;name&gt;
		/// <br/>
		/// <para>
		/// This command gets the currently defined value for a specified tool parameter. These parameters<br/>
		/// are user-definable configuration settings that control various behaviors within the tool. Refer to<br/>
		/// report_param for a description of what each parameter configures or controls.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the current value of the MaxThreads parameter used for multi-threaded processes:<br/>
		/// get_param general.MaxThreads<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 858<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Parameter name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>parameter value</returns>
		public VivadoTCL get_param(String name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_param [-quiet] [-verbose] <name>
			this.Entry(_builder.get_param(name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of PartitionDefs<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_partition_defs [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// IMPORTANT! You must first define the project as a Partial Reconfiguration (PR) project by setting the<br/>
		/// PR_FLOW property on the project to TRUE, or by using the Tools → Enable Partial Reconfiguration<br/>
		/// command.<br/>
		/// Get a list of all Partition Definition (partitionDef) objects in the current design, or the<br/>
		/// partitionDefs that match a specified search pattern.<br/>
		/// The Partial Reconfiguration flow lets you create Partition Definitions (partitionDefs) from<br/>
		/// hierarchical cells in a design, and to specify reconfigurable modules (RMs) to be assigned to these<br/>
		/// partitionDefs to create a unique configurations of the design based on the combination of the<br/>
		/// core design and one or more RMs. The PR design flow requires the implementation of each PR<br/>
		/// configuration, resulting in partial bitstreams for the RMs, but complete bitstreams for each<br/>
		/// integrated configuration. Refer to the Vivado Design Suite User Guide: Dynamic Function eXchange<br/>
		/// (UG909) for more information.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This command returns a list of partitionDef objects, or returns an error if the command fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 860<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match partition definition names against patterns Default: *</param>
		/// <returns>list of PartitionDef objects</returns>
		public VivadoTCL get_partition_defs(bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_partition_defs [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_partition_defs(regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of parts available in the software<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_parts [-regexp] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of parts that match a specified search pattern. The default command gets a list of all<br/>
		/// parts.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets a list of 7vx485t parts, speed grade -1:<br/>
		/// get_parts -filter {DEVICE =~ xc7vx485t* &amp;&amp; speed == -1}<br/>
		/// The following example gets the number of 7 series and 6 series Virtex parts:<br/>
		/// llength [get_parts -regexp {xc7v.* xc6V.*} -nocase]<br/>
		/// Note: If there are no parts matching the pattern, the tool will return a warning.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 863<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get the parts of the objects specified: project, design, or run.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// <para>
		/// (Optional)<br/>
		/// Match part names against patterns Default: * Values: The<br/>
		/// default search pattern is the wildcard *, or .* when -regexp<br/>
		/// is specified.<br/>
		/// </para>
		/// </param>
		/// <returns>list of part objects</returns>
		public VivadoTCL get_parts(bool? regexp = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_parts [-regexp] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_parts(regexp, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of path groups in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_path_groups [-regexp] [-nocase] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of timing path groups in the current project that match a specified search pattern. The<br/>
		/// default command gets a list of all path groups in the design.<br/>
		/// Path groups are automatically created when a new clock is created in the design, containing all<br/>
		/// paths in that clocks domain. Path groups can also be manually created with the use of the<br/>
		/// group_path command.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets a list of all the path groups in the design.<br/>
		/// get_path_groups<br/>
		/// The following example gets all path groups with the string "Clk" somewhere in the name:<br/>
		/// get_path_groups *Clk*<br/>
		/// Note: If no path groups match the pattern you will get a warning.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 866<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match path group names against patterns Default: *</param>
		/// <returns>list of path groups</returns>
		public VivadoTCL get_path_groups(bool? regexp = null, bool? nocase = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_path_groups [-regexp] [-nocase] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_path_groups(regexp, nocase, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of Pblocks in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_pblocks [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-include_nested_pblocks] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of Pblocks defined in the current project that match a specific pattern. The default<br/>
		/// command gets a list of all Pblocks in the project.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets a list of all Pblocks in the current project:<br/>
		/// get_pblocks<br/>
		/// This example gets a list of all Pblocks which do not have a Slice Range defined:<br/>
		/// get_pblocks -filter {GRIDTYPES !~ SLICE}<br/>
		/// The following example gets the Pblock assignments of the specified cell:<br/>
		/// get_pblocks -of [get_cells CORE/BR_TOP/RLD67_MUX/REG_PMBIST_C1]<br/>
		/// This example returns the specified Pblock, including any nested Pblocks:<br/>
		/// get_pblocks -include_nested_pblocks usbTop<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 868<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get Pblocks of these cells</param>
		/// <param name="include_nested_pblocks">(Optional) Display the the list of nested pblocks</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match Pblock names against patterns Default: *</param>
		/// <returns>list of Pblock objects</returns>
		public VivadoTCL get_pblocks(bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, bool? include_nested_pblocks = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_pblocks [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-include_nested_pblocks] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_pblocks(regexp, nocase, filter, of_objects, include_nested_pblocks, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of pins in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_pins [-hsc &lt;arg&gt;] [-hierarchical] [-regexp] [-nocase] [-leaf] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-match_style &lt;arg&gt;] [-include_replicated_objects] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of pin objects in the current design that match a specified search pattern. The default<br/>
		/// command gets a list of all pins in the current_instance of the open design, as specified by the<br/>
		/// current_instance command. You can use the -hierarchical option to extract pins from<br/>
		/// the hierarchy of the current design.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// IMPORTANT! Because there are so many pins in the design, the get_pins command can cause<br/>
		/// performance issues, and add significant time to processing design constraints. In many cases, a design<br/>
		/// constraint that is written with the get_pins command can be rewritten using the get_cells<br/>
		/// command, as shown in the examples, to significantly improve constraint processing and performance of the<br/>
		/// Vivado tool.<br/>
		/// The get_pins command also includes an option to get all replicated pins that are added to a<br/>
		/// design during physical optimization, or phys_opt_design. The use of the -<br/>
		/// include_replicated_objects option returns the pins on replicated cells when the pins of<br/>
		/// an original cell are returned. You can use this option to ensure that constraints or properties that<br/>
		/// are applied to the pins of a cell are also applied to the pins of its replicated cells.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets a list of pins attached to the specified cells:<br/>
		/// get_pins -of_objects [get_cells usb*]<br/>
		/// Note: If there are no pins matching the pattern, the tool will return a warning.<br/>
		/// This example shows how using get_cells can improve the performance of the get_pins<br/>
		/// command:<br/>
		/// [get_pins -hier * -filter {NAME=~xx*/yy*}]<br/>
		/// can be rewritten as:<br/>
		/// [get_pins -filter {REF_PIN_NAME=~yy*} -of [get_cells -hier xx*]]<br/>
		/// The following shows how rewriting the set_max_delay constraint can significantly improve<br/>
		/// performance:<br/>
		/// set_max_delay 15 -from [get_pins -hier \<br/>
		/// -filter name=~*/aclk_dpram_reg*/*/CLK] \<br/>
		/// -to [get_cells -hier -filter name=~*/bclk_dout_reg*] -datapath_only<br/>
		/// can be rewritten as:<br/>
		/// set_max_delay 15 -from [get_pins -of \<br/>
		/// [get_cells -hier -filter name=~*aclk_dpram_reg*/*] \<br/>
		/// -filter {REF_PIN_NAME == CLK}] \<br/>
		/// -to [get_pins -of [get_cells -hier -filter {name =~ */bclk_dout_reg*}]<br/>
		/// \<br/>
		/// -filter {REF_PIN_NAME == D}] -datapath_only<br/>
		/// TIP: Although the second command syntax is more complex, the performance gains can be significant.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This example runs the report_drc command on the current design, and then returns any pins<br/>
		/// associated with DRC violations:<br/>
		/// report_drc -name drc_1<br/>
		/// get_pins -of_objects [get_drc_violations]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 871<br/>
		/// </para>
		/// </summary>
		/// <param name="hsc">(Optional) Hierarchy separator Default: /</param>
		/// <param name="hierarchical">(Optional) Search level-by-level in current instance</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="leaf">(Optional) Get leaf/global pins of nets with -of_objects</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get pins of these cells, nets, timing paths, clocks, drc violations</param>
		/// <param name="match_style">(Optional) Style of pattern matching, valid values are ucf, sdc Default: sdc</param>
		/// <param name="include_replicated_objects">
		/// <para>
		/// (Optional)<br/>
		/// Include replicated objects when searching for patterns. This<br/>
		/// option is valid only when patterns is specified.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match pin names against patterns Default: *</param>
		/// <returns>list of pin objects</returns>
		public VivadoTCL get_pins(String hsc = null, bool? hierarchical = null, bool? regexp = null, bool? nocase = null, bool? leaf = null, String filter = null, TCLParameterList of_objects = null, String match_style = null, bool? include_replicated_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_pins [-hsc <arg>] [-hierarchical] [-regexp] [-nocase] [-leaf] [-filter <arg>] [-of_objects <args>] [-match_style <arg>] [-include_replicated_objects] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_pins(hsc, hierarchical, regexp, nocase, leaf, filter, of_objects, match_style, include_replicated_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of programmable interconnect points (pips) on the current device.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_pips [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-uphill] [-downhill] [-from &lt;args&gt;] [-to &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Programmable interconnect points, or PIPs, provide the physical routing paths on the device used<br/>
		/// to connect logic networks. This command returns a list of PIPs on the device that match a<br/>
		/// specified search pattern. The command requires a design to be open.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The default command gets a list of all PIPs on the device. However, this is not a recommended<br/>
		/// use of the command due to the number of pips on a device. You should specify the -<br/>
		/// of_objects argument to limit the number of pips returned.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the PIPs associated with the specified tile:<br/>
		/// get_pips -of_object [get_tiles DSP_R_X9Y75]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 876<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get the pips of these sites, tiles, wires, nodes, pips, or nets.</param>
		/// <param name="uphill">(Optional) Get the pips uphill from the provided wire or pip.</param>
		/// <param name="downhill">(Optional) Get the pips downhill from the provided wire or pip.</param>
		/// <param name="from">
		/// <para>
		/// (Optional)<br/>
		/// -from &lt;pip/site pin&gt; Return the ordered list of pips<br/>
		/// beginning at this pip or site pin. May be used in<br/>
		/// combination with uphill. Default is downhill. -all is implied.<br/>
		/// </para>
		/// </param>
		/// <param name="to">
		/// <para>
		/// (Optional)<br/>
		/// -to &lt;pip/site pin&gt; Return the ordered list of pips ending at<br/>
		/// this wire or site pin. May be used in combination with uphill.<br/>
		/// Default is downhill. -all is implied.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match pips against patterns Default: *</param>
		/// <returns>pips</returns>
		public VivadoTCL get_pips(bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, bool? uphill = null, bool? downhill = null, TCLParameterList from = null, TCLParameterList to = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_pips [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-uphill] [-downhill] [-from <args>] [-to <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_pips(regexp, nocase, filter, of_objects, uphill, downhill, from, to, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of package pin byte groups.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_pkgpin_bytegroups [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of the byte groups on the I/O banks of the current Xilinx UltraScale device.<br/>
		/// For 7 series devices, the hierarchy of IO Banks is divided into two object types: I/O Banks and<br/>
		/// Package Pins. For Xilinx UltraScale FPGA devices, the IO Bank hierarchy includes two additional<br/>
		/// divisions: Byte groups and Nibbles.<br/>
		/// The relationships of these objects on an UltraScale device are defined as follows:<br/>
		/// • An iobank has 2 or 4 bytegroups.<br/>
		/// • Each pkgpin_bytegroup has 2 nibbles, an upper and lower, and has 13 package pins.<br/>
		/// • Each pkgpin_nibble has 6 or 7 pins, and is the upper or lower nibble of the pkgpin_bytegroup.<br/>
		/// • A package_pin is one pin of an iobank, a pkgpin_bytegroup, or a pkgpin_nibble.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets a list of all pins on the package of the target device:<br/>
		/// get_pkgpin_bytegroups -of [get_iobanks 44]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 880<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get the pin_group of these package_pins, iobank, site, or port.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match pin_group against patterns Default: *</param>
		/// <returns>pin_group</returns>
		public VivadoTCL get_pkgpin_bytegroups(bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_pkgpin_bytegroups [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_pkgpin_bytegroups(regexp, nocase, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of pkgpin nibbles.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_pkgpin_nibbles [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Return a list of nibbles, or half-bytes, on the I/O banks of the current Xilinx UltraScale device.<br/>
		/// For 7 series devices, the hierarchy of IO Banks is divided into two object types: I/O Banks and<br/>
		/// Package Pins. For Xilinx UltraScale FPGA devices, the IO Bank hierarchy includes two additional<br/>
		/// divisions: Byte groups and Nibbles.<br/>
		/// The relationships of these objects on an UltraScale device are defined as follows:<br/>
		/// • An iobank has 2 or 4 bytegroups.<br/>
		/// • Each pkgpin_bytegroup has 2 nibbles, an upper and lower, and has 13 package pins.<br/>
		/// • Each pkgpin_nibble has 6 or 7 pins, and is the upper or lower nibble of the pkgpin_bytegroup.<br/>
		/// • A package_pin is one pin of an iobank, a pkgpin_bytegroup, or a pkgpin_nibble.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the Upper nibbles associated with the specified IO bank:<br/>
		/// get_pkgpin_nibbles -of [get_iobanks 44] -filter {TYPE == U}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 883<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get the pin_nibble of these package_pins, iobank, site, or port.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match pin_nibble against patterns Default: *</param>
		/// <returns>pin_nibble</returns>
		public VivadoTCL get_pkgpin_nibbles(bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_pkgpin_nibbles [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_pkgpin_nibbles(regexp, nocase, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of ports in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_ports [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-match_style &lt;arg&gt;] [-scoped_to_current_instance] [-no_traverse] [-prop_thru_buffers] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of port objects in the current design that match a specified search pattern. The default<br/>
		/// command gets a list of all ports in the design.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets a list of pins attached to the specified cell:<br/>
		/// get_ports -of_objects [lindex [get_cells] 1]<br/>
		/// Note: If there are no ports matching the pattern, the tool will return a warning.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example runs the report_drc command on the current design, returns the list of<br/>
		/// violations in the specified DRC report, and then returns the ports associated with any violations<br/>
		/// of the unspecified I/O Standard rule (NSTD):<br/>
		/// report_drc -name drc_1<br/>
		/// get_drc_violations -name drc_1<br/>
		/// get_ports -of_objects [get_drc_violations -name drc_1 NSTD*]<br/>
		/// This example specifies a cell for the current instance, returns the pins scoped to the current<br/>
		/// instance, and returns the top-level ports connected to those pins:<br/>
		/// current_instance [get_cells dac_spi*]<br/>
		/// get_ports -scoped_to_current_instance<br/>
		/// get_ports -scoped_to_current_instance -prop_thru_buffers<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 886<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get ports of these nets, instances, sites, clocks, timing paths,<br/>
		/// io standards, io banks, package pins, drc violations<br/>
		/// </para>
		/// </param>
		/// <param name="match_style">(Optional) Style of pattern matching, valid values are ucf, sdc Default: sdc</param>
		/// <param name="scoped_to_current_instance">
		/// <para>
		/// (Optional)<br/>
		/// Match patterns on instance pins specified using current<br/>
		/// instance, and then find top level connected ports.<br/>
		/// </para>
		/// </param>
		/// <param name="no_traverse">(Optional) Do not traverse to find top level terminals.</param>
		/// <param name="prop_thru_buffers">
		/// <para>
		/// (Optional)<br/>
		/// Allow propagate through buffers when traversing to find<br/>
		/// top level terminals connected to pins of scoped instance.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match port names against patterns Default: *</param>
		/// <returns>list of port objects</returns>
		public VivadoTCL get_ports(bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, String match_style = null, bool? scoped_to_current_instance = null, bool? no_traverse = null, bool? prop_thru_buffers = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_ports [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-match_style <arg>] [-scoped_to_current_instance] [-no_traverse] [-prop_thru_buffers] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_ports(regexp, nocase, filter, of_objects, match_style, scoped_to_current_instance, no_traverse, prop_thru_buffers, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of Power Rails in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_power_rails [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 890<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match Power rail names against patterns Default: *</param>
		/// <returns>list of power rail objects</returns>
		public VivadoTCL get_power_rails(bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_power_rails [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_power_rails(regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Internal TCL task for reporting PPLOCs on pins or nets: (1) -nets option returns PPLOCs on given<br/>
		/// nets; (2) -pins option returns PPLOCs on given pins; (3) if option -nets and option -pins are both<br/>
		/// not specificed, it returns all PPLOCs in the design.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_pplocs -nets &lt;args&gt; -pins &lt;args&gt; [-count] [-unlocked] [-locked] [-level &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 891<br/>
		/// </para>
		/// </summary>
		/// <param name="nets">(Required) List of nets to report its PPLOCs</param>
		/// <param name="pins">(Required) List of pins to report its PPLOCs</param>
		/// <param name="count">(Optional) Count number of PPLOCs;; Do not report PPLOC or node names.</param>
		/// <param name="unlocked">(Optional) Report unlocked/unfixed PPLOCs only</param>
		/// <param name="locked">(Optional) Report locked/fixed PPLOCs only; use -level to specify locked level.</param>
		/// <param name="level">
		/// <para>
		/// (Optional)<br/>
		/// Specify locked level; Valid values are placement and routing.<br/>
		/// Default: placement<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>PPLOC nodes or number of PPLOCs</returns>
		public VivadoTCL get_pplocs(TCLParameterList nets, TCLParameterList pins, bool? count = null, bool? unlocked = null, bool? locked = null, String level = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_pplocs -nets <args> -pins <args> [-count] [-unlocked] [-locked] [-level <arg>] [-quiet] [-verbose]
			this.Entry(_builder.get_pplocs(nets, pins, count, unlocked, locked, level, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of partition configurations<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_pr_configurations [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Get a list of PR configuration objects in the current project.<br/>
		/// In the Partial Reconfiguration (PR) design flow, the PR configuration lets you specify a<br/>
		/// reconfigurable module (RM) to assign to a specific instance of a Partition Definition<br/>
		/// (partitionDef). This flow lets you create unique configurations of the design based on the<br/>
		/// combination of the core design and one or more RMs. The PR design flow requires the<br/>
		/// implementation of each PR configuration, resulting in partial bitstreams for the RMs, but<br/>
		/// complete bitstreams for each integrated configuration. Refer to the Vivado Design Suite User<br/>
		/// Guide: Dynamic Function eXchange (UG909) for more information.<br/>
		/// This command returns a list of PR configuration objects, or returns an error if the command fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 892<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match partition configuration names against patterns Default: *</param>
		/// <returns>list of Configuration objects</returns>
		public VivadoTCL get_pr_configurations(bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_pr_configurations [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_pr_configurations(regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of available unisim primitives for a part<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_primitives [-regexp] [-nocase] [-filter &lt;arg&gt;] [-part &lt;arg&gt;] [-retarget] [-macro] [-hierarchy] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Get a list of all supported primitives for the specified device. This command can be used on an<br/>
		/// open elaborated, synthesized, or implemented design, in which case it will get the PART from the<br/>
		/// current design. You can also specify the -part option to return the primitives for any device.<br/>
		/// By default the command always returns native primitives that can be placed on the target part<br/>
		/// without modification. The -retarget, -macro, and -hierarchy options add additional<br/>
		/// primitives to the list returned.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets the native primitives for the current part, and includes macro<br/>
		/// primitives:<br/>
		/// get_primitives -macro<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 895<br/>
		/// </para>
		/// </summary>
		/// <param name="patterns">(Required) Match primitive types against patterns Default: *</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="part">(Optional) Part to get primitives for</param>
		/// <param name="retarget">
		/// <para>
		/// (Optional)<br/>
		/// Include primitive types that will be automatically retargeted<br/>
		/// to the current (or specified) part<br/>
		/// </para>
		/// </param>
		/// <param name="macro">
		/// <para>
		/// (Optional)<br/>
		/// Include primitive types that always convert into more basic,<br/>
		/// natively supported primitives, such as logic gates<br/>
		/// </para>
		/// </param>
		/// <param name="hierarchy">
		/// <para>
		/// (Optional)<br/>
		/// Include primitive types that will be automatically expanded<br/>
		/// into a hierarchy of leaf cells during implementation<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>primitive types</returns>
		public VivadoTCL get_primitives(String patterns, bool? regexp = null, bool? nocase = null, String filter = null, String part = null, bool? retarget = null, bool? macro = null, bool? hierarchy = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_primitives [-regexp] [-nocase] [-filter <arg>] [-part <arg>] [-retarget] [-macro] [-hierarchy] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_primitives(patterns, regexp, nocase, filter, part, retarget, macro, hierarchy, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of projects<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_projects [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of open projects that match the specified search pattern. The default gets a list of all<br/>
		/// open projects.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets a list of all open projects.<br/>
		/// get_projects<br/>
		/// The following example sets a variable called project_found to the length of the list of projects<br/>
		/// returned by get_projects, then prints either that projects were found or were not found as<br/>
		/// appropriate:<br/>
		/// set project_found [llength [get_projects ISC*] ]<br/>
		/// if {$project_found &gt; 0} {puts "Project Found."} \<br/>
		/// else {puts "No Projects Found."}<br/>
		/// Note: If there are no projects matching the pattern you will get a warning.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 898<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match project names against patterns Default: *</param>
		/// <returns>list of project objects</returns>
		public VivadoTCL get_projects(bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_projects [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_projects(regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get properties of object<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_property [-min] [-max] [-quiet] [-verbose] &lt;name&gt; &lt;object&gt;
		/// <br/>
		/// <para>
		/// Gets the current value of the named property from the specified object or objects. If multiple<br/>
		/// objects are specified, a list of values is returned.<br/>
		/// If the property is not currently assigned to the object, or is assigned without a value, then the<br/>
		/// get_property command returns nothing, or the null string. If multiple objects are queried, the<br/>
		/// null string is added to the list of values returned.<br/>
		/// If multiple objects are passed to the get_property command, you can use the -min or -max<br/>
		/// options to return the smallest or greatest value of the property specified by name. This feature<br/>
		/// can be useful when setting timing constraints.<br/>
		/// RECOMMENDED: For numeric properties, the min/max determination is based on numeric values. For all<br/>
		/// other properties, the determination is based on string sorting.<br/>
		/// This command returns a value, or list of values, or returns an error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets the NAME property from the specified cell:<br/>
		/// get_property NAME [lindex [get_cells] 3]<br/>
		/// The following example returns the smallest PERIOD property from the specified clock objects:<br/>
		/// get_property -min PERIOD [get_clocks]<br/>
		/// This example demonstrates the string based sorting of the SITE property for the specified ports:<br/>
		/// get_property SITE [get_ports]<br/>
		/// IOB_X1Y75 IOB_X1Y76 IOB_X1Y98 IOB_X1Y125 IOB_X0Y94 IOB_X1Y95 IOB_X1Y96<br/>
		/// IOB_X1Y93 IOB_X1Y94<br/>
		/// get_property -min SITE [get_ports]<br/>
		/// IOB_X0Y94<br/>
		/// get_property -max SITE [get_ports]<br/>
		/// IOB_X1Y98<br/>
		/// Note: While IOB_X1Y125 is the largest site value on the port objects, the property value IOB_X1Y98 is<br/>
		/// returned because of the sorting of the property values as strings.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 901<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name of property whose value is to be retrieved</param>
		/// <param name="object">(Required) Object to query for properties</param>
		/// <param name="min">(Optional) Return only the minimum value</param>
		/// <param name="max">(Optional) Return only the maximum value</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>property value</returns>
		public VivadoTCL get_property(String name, String @object, bool? min = null, bool? max = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_property [-min] [-max] [-quiet] [-verbose] <name> <object>
			this.Entry(_builder.get_property(name, @object, min, max, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of available QoR suggestions<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_qor_suggestions [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;IDs&gt;]
		/// <br/>
		/// <para>
		/// Get existing QoR suggestion objects created by the report_qor_suggestions command, or<br/>
		/// read into the design using read_qor_suggestions. The selected QoR objects can be written<br/>
		/// to a file using the write_qor_suggestions command. The suggestions created by the report<br/>
		/// command remain in memory until delete_qor_suggestions is run, or until it is overwritten<br/>
		/// by another report.<br/>
		/// This command returns a list of existing QoR suggestion objects from the open design, or returns<br/>
		/// an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// To return an individual suggestion, you can supply the full ID:<br/>
		/// get_qor_suggestions RQS_CLOCK-5_1-1<br/>
		/// Due to the naming style of suggestions, wildcard searches do NOT work directly. However you<br/>
		/// can use the filter command with -regexp to use wildcards as follows:<br/>
		/// filter -regexp [get_qor_suggestions] {NAME =~ RQS_CLOCK.*}<br/>
		/// You can also filter suggestions objects within a given category. Available categories include:<br/>
		/// Timing, Congestion, Utilization, XDC, Clocking, and Strategy. For example, the following returns<br/>
		/// suggestions related to the Timing category:<br/>
		/// get_qor_suggestions -filter {CATEGORY==Timing}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 904<br/>
		/// </para>
		/// </summary>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="IDs">(Optional) Match suggestion names against given names</param>
		/// <returns>list of qor suggestion objects</returns>
		public VivadoTCL get_qor_suggestions(String filter = null, bool? quiet = null, bool? verbose = null, String IDs = null)
		{
			// TCL Syntax: get_qor_suggestions [-filter <arg>] [-quiet] [-verbose] [<IDs>]
			this.Entry(_builder.get_qor_suggestions(filter, quiet, verbose, IDs));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of ReconfigModules<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_reconfig_modules [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Get a list of reconfigurable modules (RMs) in the current design that match a specified search<br/>
		/// pattern. The default command returns a list of all RMs in the current project.<br/>
		/// This command returns a list of RM objects, or returns an error if the command fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 906<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get 'reconfig_module' objects of these types: 'partition_def'.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match reconfigurable module names against patterns Default: *</param>
		/// <returns>list of ReconfigModule objects</returns>
		public VivadoTCL get_reconfig_modules(bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_reconfig_modules [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_reconfig_modules(regexp, nocase, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of Configurable Report objects<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_report_configs [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Returns a list of report objects created by the create_report_config command.<br/>
		/// This command returns the list of report objects matching the search pattern and filters, or returns<br/>
		/// an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets all of the report objects in the current project:<br/>
		/// get_report_configs<br/>
		/// The following example gets all of the report objects in the current project that are associated<br/>
		/// with the opt_design step:<br/>
		/// get_report_configs -filter {RUN_STEP == opt_design}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 909<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get 'report' objects of these types: 'run'.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match report names against patterns Default: *</param>
		/// <returns>list of Configurable Report objects</returns>
		public VivadoTCL get_report_configs(bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_report_configs [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_report_configs(regexp, nocase, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of runs<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_runs [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of synthesis and implementation runs in the current project that match a specified<br/>
		/// search pattern. The default command gets a list of all runs defined in the project.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets a list of all incomplete runs in the current project:<br/>
		/// get_runs -filter {PROGRESS &lt; 100}<br/>
		/// The following example gets a list of runs matching the specified pattern:<br/>
		/// get_runs imp*<br/>
		/// Note: If there are no runs matching the pattern you will get a warning.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 912<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get 'run' objects of these types: 'reconfig_module'.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match run names against patterns Default: *</param>
		/// <returns>list of run objects</returns>
		public VivadoTCL get_runs(bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_runs [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_runs(regexp, nocase, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of children HDL scopes of a scope<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_scopes [-filter &lt;arg&gt;] [-regexp] [-nocase] [-r] [-quiet] [-verbose] [&lt;patterns&gt;...]
		/// <br/>
		/// <para>
		/// Get a list of children HDL scopes of the current or specified scope<br/>
		/// This command returns a list of scope objects, or returns an error.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example recursively returns all of the children scopes of the specified scope:<br/>
		/// get_scopes -r /testbench/dut<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 915<br/>
		/// </para>
		/// </summary>
		/// <param name="filter">
		/// <para>
		/// (Optional)<br/>
		/// filters &lt;patterns&gt; according to the specified property-matching expressions<br/>
		/// </para>
		/// </param>
		/// <param name="regexp">(Optional) interprets &lt;patterns&gt; using regular expressions</param>
		/// <param name="nocase">(Optional) only when regexp is used, performs a case insensitive match</param>
		/// <param name="r">
		/// <para>
		/// (Optional)<br/>
		/// only when a glob or regular expression pattern is used,<br/>
		/// descends recursively into children scopes to search for<br/>
		/// &lt;patterns&gt;<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// <para>
		/// (Optional)<br/>
		/// the pattern strings to search for scopes. Default: * (all<br/>
		/// children scopes)<br/>
		/// </para>
		/// </param>
		/// <returns>Returns HDL scope objects from the given arguments</returns>
		public VivadoTCL get_scopes(String filter = null, bool? regexp = null, bool? nocase = null, bool? r = null, bool? quiet = null, bool? verbose = null, TCLParameterList patterns = null)
		{
			// TCL Syntax: get_scopes [-filter <arg>] [-regexp] [-nocase] [-r] [-quiet] [-verbose] [<patterns>...]
			this.Entry(_builder.get_scopes(filter, regexp, nocase, r, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get selected objects<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_selected_objects [-primary] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Gets the objects currently selected in the Vivado IDE by the select_objects command. Can<br/>
		/// get the primary selected object and any secondary selected objects as well.<br/>
		/// Note: This Tcl command works only when Vivado is run in GUI mode.<br/>
		/// Primary objects are directly selected, while secondary objects are selected based on the selection<br/>
		/// rules currently defined by the Tools → Settings command. Refer to the Vivado Design Suite User<br/>
		/// Guide: Using the IDE (UG893) for more information on setting selection rules.<br/>
		/// This command returns a Tcl list of selected objects, even a list with just one object. This can be an<br/>
		/// issue for some of the Vivado tool commands that do not accept a list of objects, such as the<br/>
		/// current_instance command. In this case you can use lindex to pass a specific object from<br/>
		/// the get_selected_objects list to the current_instance command:<br/>
		/// current_instance [lindex [get_selected_objects] 0]<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports the properties of all currently selected objects, both primary and<br/>
		/// secondary:<br/>
		/// report_property [get_selected_objects]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 918<br/>
		/// </para>
		/// </summary>
		/// <param name="primary">(Optional) Do not include objects that were selected due to selection rules</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of selected objects</returns>
		public VivadoTCL get_selected_objects(bool? primary = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_selected_objects [-primary] [-quiet] [-verbose]
			this.Entry(_builder.get_selected_objects(primary, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get registered simulators<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_simulators [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Get the list of simulators registered for use with the Vivado Design Suite unified simulation<br/>
		/// environment.<br/>
		/// The Vivado Design Suite comes with some simulators pre-registered for use with the unified<br/>
		/// simulation environment. You can also register your own third-party simulators using the<br/>
		/// register_simulator command.<br/>
		/// This command returns the names of registered simulators, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 920<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match simulator names against patterns Default: *</param>
		public VivadoTCL get_simulators(bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_simulators [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_simulators(regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of site_pins.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_site_pins [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Returns a list of site pins of the specified site, node, logical cell pin, or net objects in an open<br/>
		/// design.<br/>
		/// This command recommends the use of the -of_objects argument to prevent high run times<br/>
		/// and compute resources.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the site_pins of the specified Nets:<br/>
		/// get_site_pins -of_objects [get_nets *Clk]<br/>
		/// IOB_X1Y24/I<br/>
		/// The following example returns the output site_pins associated with the site SLICE_X21Y92:<br/>
		/// get_site_pins -of_objects [get_sites SLICE_X21Y92] -filter<br/>
		/// {DIRECTION==OUT}<br/>
		/// SLICE_X21Y92/A SLICE_X21Y92/AMUX SLICE_X21Y92/AQ<br/>
		/// SLICE_X21Y92/B SLICE_X21Y92/BMUX SLICE_X21Y92/BQ<br/>
		/// SLICE_X21Y92/C SLICE_X21Y92/CMUX SLICE_X21Y92/COUT<br/>
		/// SLICE_X21Y92/CQ SLICE_X21Y92/D SLICE_X21Y92/DMUX<br/>
		/// SLICE_X21Y92/DQ<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 923<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get 'site_pin' objects of these types: 'site xdef_site node pin<br/>
		/// net bel_pin'.<br/>
		/// </para>
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'site_pin' objects against patterns. Default: *</param>
		/// <returns>site_pins</returns>
		public VivadoTCL get_site_pins(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_site_pins [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_site_pins(of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of site_pips from the given object.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_site_pips [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Programmable interconnect points, or PIPs, provide the physical routing paths on the device used<br/>
		/// to connect logic networks. This command returns a list of PIPs on specified sites that match a<br/>
		/// specified search pattern. The command requires a design to be open.<br/>
		/// This command requires the use of the -of_objects option to specify the sites to return PIPs<br/>
		/// from.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the pins of the specified BELs associated with the specified range<br/>
		/// of sites on the device:<br/>
		/// get_site_pips -of_objects [get_sites SLICE_X21Y92]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 926<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get the site_pips of these sites.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match site_pips against patterns Default: *</param>
		/// <returns>site_pips</returns>
		public VivadoTCL get_site_pips(bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_site_pips [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_site_pips(regexp, nocase, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of Sites<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_sites [-regexp] [-filter &lt;arg&gt;] [-nocase] [-range &lt;args&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of sites on the target device that match a specified search pattern. The default<br/>
		/// command gets a list of all sites on the target device.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets a list of all sites available on the target device:<br/>
		/// get_sites<br/>
		/// The following example returns the number of sites that are not currently used on the device.<br/>
		/// Both command forms in the example return the same results. The second command directly<br/>
		/// evaluates the IS_USED boolean property:<br/>
		/// llength [get_sites -filter {IS_USED==0}]<br/>
		/// -or-<br/>
		/// llength [get_sites -filter !IS_USED]<br/>
		/// Note: If no sites match the pattern you will get a warning.<br/>
		/// The following example gets all of the sites on the device, and returns the unique SITE_TYPEs:<br/>
		/// set sites [get_sites]<br/>
		/// set type {}<br/>
		/// foreach x $sites {<br/>
		/// set prop [get_property SITE_TYPE $x]<br/>
		/// if { [lsearch -exact $type $prop] == -1 } {<br/>
		/// lappend type $prop<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// }<br/>
		/// }<br/>
		/// foreach y $type {<br/>
		/// puts "SITE_TYPE: $y"<br/>
		/// }<br/>
		/// The following example shows three different forms for specifying the range of sites to return:<br/>
		/// get_sites -range {SLICE_X0Y0 SLICE_X1Y1}<br/>
		/// SLICE_X0Y0 SLICE_X0Y1 SLICE_X1Y0 SLICE_X1Y1<br/>
		/// get_sites -range SLICE_X0Y0 -range SLICE_X1Y1<br/>
		/// SLICE_X0Y0 SLICE_X0Y1 SLICE_X1Y0 SLICE_X1Y1<br/>
		/// get_sites -range {SLICE_X0Y0:SLICE_X1Y1}<br/>
		/// SLICE_X0Y0 SLICE_X0Y1 SLICE_X1Y0 SLICE_X1Y1<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 929<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="range">
		/// <para>
		/// (Optional)<br/>
		/// Match site names which fall into the range. Range is defined<br/>
		/// by exactly two site names.<br/>
		/// </para>
		/// </param>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get the sites of slrs, tiles, bels, pins, package_pins, ports,<br/>
		/// pblocks, nets, site_types, io_banks, cells, clock_regions or<br/>
		/// drc_violation<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// <para>
		/// (Optional)<br/>
		/// Match site names against patterns. Bonded sites will also<br/>
		/// match on package pin names. Default: *<br/>
		/// </para>
		/// </param>
		/// <returns>list of site objects</returns>
		public VivadoTCL get_sites(bool? regexp = null, String filter = null, bool? nocase = null, TCLParameterList range = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_sites [-regexp] [-filter <arg>] [-nocase] [-range <args>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_sites(regexp, filter, nocase, range, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of slrs.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_slrs [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Get a list of the super logic regions (SLRs) on the target device. On Devices that do not contain<br/>
		/// multiple SLRs, the SLR0 is returned.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example highlights each of the SLRs on the target device in a different color:<br/>
		/// foreach x [get_slrs] {<br/>
		/// incr i<br/>
		/// highlight_objects -color_index $i $x<br/>
		/// }<br/>
		/// Note: If there are no cells matching the pattern you will get a warning.<br/>
		/// The following example returns the number of super long lines (SLLs) between super logic regions<br/>
		/// on the current device:<br/>
		/// get_property NUM_SLLS [get_slrs SLR0]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 933<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get the slr of these device, tiles, sites, bels, sitepins, belpins,<br/>
		/// clock region, node, pip, pin, package pin, iobank, cell.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match slr against patterns Default: *</param>
		/// <returns>slr</returns>
		public VivadoTCL get_slrs(bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_slrs [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_slrs(regexp, nocase, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of speed_models in the device.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_speed_models [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-patterns &lt;arg&gt;] [-filter &lt;arg&gt;] [-speed_pattern &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Get speed models for UltraScale architecture device resources in the current design.<br/>
		/// Speed files are provided by Xilinx for each device and speed grade. Speed files contain speed<br/>
		/// models. There are speed models for the various elements of a device: nodes, pips, bels. There are<br/>
		/// speed models for setup and hold, propagation delays, jitter, etc.<br/>
		/// The speed models include information on the delays in nanoseconds (ns) associated with device<br/>
		/// resources like BELs and SITEs and routing resources. Speed models are used by the Vivado<br/>
		/// timing engine to perform analysis of the current design in the context of the target part.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The objects returned are the speed models associated with specific physical resources like pips<br/>
		/// and wires, drawn directly from the speed files. These can include capacitance and resistance<br/>
		/// values and buffer models.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// This command returns the specified speed model objects, or returns an error if the command<br/>
		/// fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports the properties on the speed model for an A6LUT:<br/>
		/// report_property -all [lindex [get_speed_models -of \<br/>
		/// [get_bels SLICE_X0Y0/A6LUT]] 0]<br/>
		/// Property Type Read-only Value<br/>
		/// CLASS string true speed_model<br/>
		/// DELAY double true 0.043<br/>
		/// FAST_MAX double true 0.035<br/>
		/// FAST_MIN double true 0.028<br/>
		/// IS_INSTANCE_SPECIFIC bool true 1<br/>
		/// NAME string true bel_d_lut6_a1_o6<br/>
		/// NAME_LOGICAL string true bel_d_lut6_a1_o6<br/>
		/// SLOW_MAX double true 0.043<br/>
		/// SLOW_MIN double true 0.036<br/>
		/// SPEED_INDEX int true 65535<br/>
		/// TYPE string true bel_delay<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example returns the delays, in nanoseconds, for a specific A6LUT on the device,<br/>
		/// followed by the delay name for the specified object:<br/>
		/// set x [get_speed_models -of [get_bels SLICE_X0Y0/A6LUT]]<br/>
		/// puts [format "%6.3f : %s" [get_property DELAY [lindex $x 0 ]] \<br/>
		/// [get_property NAME [lindex $x 0 ]]]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 936<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">(Optional) Get 'speed_model' objects of these types: 'node bel pip cell'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="patterns">(Optional) Match the 'speed_model' objects against patterns. Default: *</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="speed_pattern">(Optional) Returns a single model that exactly matches the pattern.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>speed_models</returns>
		public VivadoTCL get_speed_models(TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String patterns = null, String filter = null, String speed_pattern = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_speed_models [-of_objects <args>] [-regexp] [-nocase] [-patterns <arg>] [-filter <arg>] [-speed_pattern <arg>] [-quiet] [-verbose]
			this.Entry(_builder.get_speed_models(of_objects, regexp, nocase, patterns, filter, speed_pattern, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get list of processes in a design, which are waiting inside a subprogram<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_stacks [-of_instance &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Returns list of HDL scopes for all the processes in a design which are waiting inside a<br/>
		/// subprogram. With -of_instance switch, the output can be limited to such processes of the<br/>
		/// given instance only.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets a list of all sites available on the target device:<br/>
		/// module top;<br/>
		/// int i;<br/>
		/// function void f(input int in1);<br/>
		/// automatic int a;<br/>
		/// a = in1 + 7;<br/>
		/// $display($time, " in f :: a %d in1 %d ", a, in1);<br/>
		/// endfunction<br/>
		/// task automatic t(input int in2);<br/>
		/// int b;<br/>
		/// b = in2 + 10;<br/>
		/// $display($time, " in t :: in2 %d b %d ", in2, b);<br/>
		/// #5;<br/>
		/// f(b); // Case C<br/>
		/// $display($time, " Back in t : after wait and f(%d) ", b);<br/>
		/// endtask<br/>
		/// initial begin // "/top/Initial18_0"<br/>
		/// $display($time, " in initial 1 ");<br/>
		/// i = 200;<br/>
		/// t(i); // Case B<br/>
		/// $display($time, " Back in initial 1 after t(%d) ", i);<br/>
		/// end<br/>
		/// initial begin // "/top/Initial25_1"<br/>
		/// $display($time, " in initial 2 ");<br/>
		/// #2;<br/>
		/// f(50); // Case A<br/>
		/// $display($time, " Back in initial 2 after f(50) ");<br/>
		/// end<br/>
		/// endmodule<br/>
		/// When simulation is stopped inside function "f" for its call at 'Case A' , the two processes /top/<br/>
		/// Initial18_0, and /top/Initial25_1, are waiting inside task "t" (call at 'CaseB') and<br/>
		/// function "f" (call at 'CaseA') respectively.<br/>
		/// 1. &gt; get_stacks<br/>
		/// /top/Initial18_0 /top/Initial25_1<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 940<br/>
		/// </para>
		/// </summary>
		/// <param name="of_instance">(Optional) Default: NULL</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>
		/// </returns>
		public VivadoTCL get_stacks(String of_instance = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_stacks [-of_instance <arg>] [-quiet] [-verbose]
			this.Entry(_builder.get_stacks(of_instance, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of IPI example designs<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_template_bd_designs [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// The command returns the list of template block designs available in the current release of the<br/>
		/// Vivado Design Suite, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the list of available block design templates in the current release:<br/>
		/// get_template_bd_designs<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 942<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of IPI design objects</returns>
		public VivadoTCL get_template_bd_designs(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_template_bd_designs [-quiet] [-verbose]
			this.Entry(_builder.get_template_bd_designs(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of tiles.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_tiles [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// This command returns a list of tiles on the device in an open design. The default command gets a<br/>
		/// list of all tiles on the device.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the total number of tiles where the number of timing arcs is<br/>
		/// greater than 100 and 150 respectively:<br/>
		/// llength [get_tiles -filter {NUM_ARCS&gt;100} ]<br/>
		/// 13468<br/>
		/// llength [get_tiles -filter {NUM_ARCS&gt;150} ]<br/>
		/// 11691<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 943<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Get the tiles of these slr, sites, bels, site_pins, bel_pins,<br/>
		/// nodes, wires, pips, nets, clock_regions.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match tiles against patterns Default: *</param>
		/// <returns>tiles</returns>
		public VivadoTCL get_tiles(bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_tiles [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_tiles(regexp, nocase, filter, of_objects, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of timing arcs<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_timing_arcs [-from &lt;args&gt;] [-to &lt;args&gt;] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Gets a list of timing arcs for the specified objects. You can filter the timing arcs according to<br/>
		/// specified properties.<br/>
		/// Timing arcs are a part of a timing path. A timing arc can be a wire between two pins, or can be<br/>
		/// the internal path of a logic instance between an input pin and output pin, or clock input and data<br/>
		/// output pins.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the timing arc from the output pin of the specified buffer:<br/>
		/// report_property -all [get_timing_arcs -of_objects [get_cells go_IBUF_inst]]<br/>
		/// The following example returns the timing arcs of the specified cell:<br/>
		/// get_timing_arcs -of_objects [get_cells count_reg[6]]<br/>
		/// {count_reg[6]/C --&gt; count_reg[6]/Q [Reg Clk to Q] }<br/>
		/// {count_reg[6]/C --&gt; count_reg[6]/D [setup] }<br/>
		/// {count_reg[6]/C --&gt; count_reg[6]/D [hold] }<br/>
		/// {count_reg[6]/C --&gt; count_reg[6]/CLR [recovery] }<br/>
		/// {count_reg[6]/C --&gt; count_reg[6]/CE [hold] }<br/>
		/// {count_reg[6]/C --&gt; count_reg[6]/CLR [removal] }<br/>
		/// {count_reg[6]/C --&gt; count_reg[6]/CE [setup] }<br/>
		/// {count_reg[6]/CLR --&gt; count_reg[6]/Q [Reg Set/Clr] }<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 946<br/>
		/// </para>
		/// </summary>
		/// <param name="from">(Optional) List of pin or ports</param>
		/// <param name="to">(Optional) List of pin or ports</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get timing arcs for these cells</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of timing arc objects</returns>
		public VivadoTCL get_timing_arcs(TCLParameterList from = null, TCLParameterList to = null, String filter = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_timing_arcs [-from <args>] [-to <args>] [-filter <arg>] [-of_objects <args>] [-quiet] [-verbose]
			this.Entry(_builder.get_timing_arcs(from, to, filter, of_objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get timing paths<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_timing_paths [-from &lt;args&gt;] [-rise_from &lt;args&gt;] [-fall_from &lt;args&gt;] [-to &lt;args&gt;] [-rise_to &lt;args&gt;] [-fall_to &lt;args&gt;] [-through &lt;args&gt;] [-rise_through &lt;args&gt;] [-fall_through &lt;args&gt;] [-delay_type &lt;arg&gt;] [-setup] [-hold] [-max_paths &lt;arg&gt;] [-nworst &lt;arg&gt;] [-unique_pins] [-slack_lesser_than &lt;arg&gt;] [-slack_greater_than &lt;arg&gt;] [-group &lt;args&gt;] [-no_report_unconstrained] [-user_ignored] [-routable_nets] [-sort_by &lt;arg&gt;] [-filter &lt;arg&gt;] [-regexp] [-nocase] [-cell &lt;args&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Gets timing path objects that meet the specified criteria. This command can be used to predefine<br/>
		/// timing paths to pass to the report_timing command for instance. Another usage of this<br/>
		/// command is to create custom reporting and analysis.<br/>
		/// The get_timing_paths command is very similar to the report_timing command.<br/>
		/// However, get_timing_paths returns timing path objects which can be queried for properties,<br/>
		/// or passed to other Tcl commands for processing, where report_timing returns a file or a<br/>
		/// string.<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example gets the five worst timing paths from the specified endpoint, and reports<br/>
		/// all the properties of the fourth timing path in the list:<br/>
		/// report_property -all [lindex [get_timing_paths -to [get_ports led_pins[*]]<br/>
		/// \<br/>
		/// -nworst 5] 3]<br/>
		/// The following example defines a procedure called custom_report, then reports the 100 worst<br/>
		/// paths from the clk_tx_clk_core_1 path group using that proc:<br/>
		/// proc custom_report { listOfPaths } {<br/>
		/// puts [format {%-40s %-40s %-20s %-20s %7s} "Startpoint" "Endpoint" \<br/>
		/// "Launch Clock" "Capture Clock" "Slack"]<br/>
		/// puts [string repeat "-" 140]<br/>
		/// foreach path $listOfPaths {<br/>
		/// set startpoint [get_property STARTPOINT_PIN $path]<br/>
		/// set startclock [get_property STARTPOINT_CLOCK $path]<br/>
		/// set endpoint [get_property ENDPOINT_PIN $path]<br/>
		/// set endclock [get_property ENDPOINT_CLOCK $path]<br/>
		/// set slack [get_property SLACK $path]<br/>
		/// puts [format {%-40s %-40s %-20s %-20s %7s} $startpoint $endpoint \<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// $startclock $endclock $slack]<br/>
		/// }<br/>
		/// }<br/>
		/// set paths [get_timing_paths -group clk_tx_clk_core_1 -max_paths 100]\<br/>
		/// custom_report $path<br/>
		/// The following example illustrates how timing path objects can be used with the<br/>
		/// report_timing command:<br/>
		/// set paths [get_timing_paths -group clk_tx_clk_core_1 -max_paths 100]<br/>
		/// report_timing -of_objects $paths<br/>
		/// Which is the equivalent of:<br/>
		/// report_timing -group clk_tx_clk_core_1 -max_paths 100<br/>
		/// The following example returns timing paths where the logic levels are greater than the specified<br/>
		/// number of logic levels:<br/>
		/// get_timing_paths -max_paths 1000 -filter {LOGIC_LEVELS &gt; 1}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 949<br/>
		/// </para>
		/// </summary>
		/// <param name="from">(Optional) From pins, ports, cells or clocks</param>
		/// <param name="rise_from">(Optional) Rising from pins, ports, cells or clocks</param>
		/// <param name="fall_from">(Optional) Falling from pins, ports, cells or clocks</param>
		/// <param name="to">(Optional) To pins, ports, cells or clocks</param>
		/// <param name="rise_to">(Optional) Rising to pins, ports, cells or clocks</param>
		/// <param name="fall_to">(Optional) Falling to pins, ports, cells or clocks</param>
		/// <param name="through">(Optional) Through pins, ports, cells or nets</param>
		/// <param name="rise_through">(Optional) Rising through pins, ports, cells or nets</param>
		/// <param name="fall_through">(Optional) Falling through pins, ports, cells or nets</param>
		/// <param name="delay_type">
		/// <para>
		/// (Optional)<br/>
		/// Type of path delay: Values: max, min, min_max, max_rise,<br/>
		/// max_fall, min_rise, min_fall Default: max<br/>
		/// </para>
		/// </param>
		/// <param name="setup">(Optional) Get max delay timing paths (equivalent to -delay_type max)</param>
		/// <param name="hold">(Optional) Get min delay timing paths (equivalent to -delay_type min)</param>
		/// <param name="max_paths">(Optional) Maximum number of paths to return: Value &gt;=1 Default: 1</param>
		/// <param name="nworst">(Optional) List N worst paths to endpoint: Value &gt;=1 Default: 1</param>
		/// <param name="unique_pins">(Optional) for each unique set of pins, show at most 1 path per path group</param>
		/// <param name="slack_lesser_than">(Optional) Include paths with slack less than this Default: 1e+30</param>
		/// <param name="slack_greater_than">(Optional) Include paths with slack greater than this Default: -1e+30</param>
		/// <param name="group">(Optional) Limit paths in this group(s)</param>
		/// <param name="no_report_unconstrained">(Optional) Do not get unconstrained paths</param>
		/// <param name="user_ignored">
		/// <para>
		/// (Optional)<br/>
		/// only report paths which have infinite slack because of<br/>
		/// set_false_path or set_clock_groups timing constraints<br/>
		/// </para>
		/// </param>
		/// <param name="routable_nets">
		/// <para>
		/// (Optional)<br/>
		/// store the number of routable nets traversed as a property<br/>
		/// on timing paths.<br/>
		/// </para>
		/// </param>
		/// <param name="sort_by">(Optional) Sorting order of paths: Values: group, slack Default: slack</param>
		/// <param name="filter">
		/// <para>
		/// (Optional)<br/>
		/// Filter list with expression<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Name Description<br/>
		/// </para>
		/// </param>
		/// <param name="regexp">(Optional) Patterns specified in filter are full regular expressions</param>
		/// <param name="nocase">
		/// <para>
		/// (Optional)<br/>
		/// Perform case-insensitive matching for patterns specified in<br/>
		/// filter (valid only when -regexp specified)<br/>
		/// </para>
		/// </param>
		/// <param name="cell">(Optional) run get_timing_paths on the cell</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL get_timing_paths(TCLParameterList from = null, TCLParameterList rise_from = null, TCLParameterList fall_from = null, TCLParameterList to = null, TCLParameterList rise_to = null, TCLParameterList fall_to = null, TCLParameterList through = null, TCLParameterList rise_through = null, TCLParameterList fall_through = null, get_timing_paths_delay_type? delay_type = null, bool? setup = null, bool? hold = null, Int32? max_paths = null, String nworst = null, bool? unique_pins = null, String slack_lesser_than = null, String slack_greater_than = null, TCLParameterList group = null, bool? no_report_unconstrained = null, bool? user_ignored = null, bool? routable_nets = null, get_timing_paths_sort_by? sort_by = null, String filter = null, bool? regexp = null, bool? nocase = null, TCLParameterList cell = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_timing_paths [-from <args>] [-rise_from <args>] [-fall_from <args>] [-to <args>] [-rise_to <args>] [-fall_to <args>] [-through <args>] [-rise_through <args>] [-fall_through <args>] [-delay_type <arg>] [-setup] [-hold] [-max_paths <arg>] [-nworst <arg>] [-unique_pins] [-slack_lesser_than <arg>] [-slack_greater_than <arg>] [-group <args>] [-no_report_unconstrained] [-user_ignored] [-routable_nets] [-sort_by <arg>] [-filter <arg>] [-regexp] [-nocase] [-cell <args>] [-quiet] [-verbose]
			this.Entry(_builder.get_timing_paths(from, rise_from, fall_from, to, rise_to, fall_to, through, rise_through, fall_through, delay_type, setup, hold, max_paths, nworst, unique_pins, slack_lesser_than, slack_greater_than, group, no_report_unconstrained, user_ignored, routable_nets, sort_by, filter, regexp, nocase, cell, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get current value of the selected HDL object (variable, signal, wire, reg)<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_value [-radix &lt;arg&gt;] [-quiet] [-verbose] &lt;hdl_object&gt;
		/// <br/>
		/// <para>
		/// Get the value of a single HDL object at the current simulation run time.<br/>
		/// TIP: Use the report_values command to return the values of more than one HDL objects.<br/>
		/// HDL objects include HDL signals, variables, or constants as defined in the Verilog or VHDL test<br/>
		/// bench and source files. An HDL signal includes Verilog wire or reg entities, and VHDL signals.<br/>
		/// Examples of HDL variables include Verilog real, realtime, time, and event.<br/>
		/// HDL constants include Verilog parameters and localparams, and VHDL generic and constants.<br/>
		/// The HDL scope, or scope, is defined by a declarative region in the HDL code such as a module,<br/>
		/// function, task, process, or begin-end blocks in Verilog. VHDL scopes include entity/architecture<br/>
		/// definitions, block, function, procedure, and process blocks.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// HDL constants include Verilog parameters and localparams, and VHDL generic and constants.<br/>
		/// The HDL scope, or scope, is defined by a declarative region in the HDL code such as a module,<br/>
		/// function, task, process, or begin-end blocks in Verilog. VHDL scopes include entity/architecture<br/>
		/// definitions, block, function, procedure, and process blocks.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Arguments<br/>
		/// -radix &lt;arg&gt; - (Optional) Specifies the radix to use when returning the value of the specified<br/>
		/// object. Allowed values are: default, dec, bin, oct, hex, unsigned, ascii, or smag.<br/>
		/// Note: The radix dec indicates a signed decimal. Specify the radix unsigned when dealing with unsigned<br/>
		/// data.<br/>
		/// -quiet - (Optional) Execute the command quietly, returning no messages from the command.<br/>
		/// The command also returns TCL_OK regardless of any errors encountered during execution.<br/>
		/// Note: Any errors encountered on the command-line, while launching the command, will be returned. Only<br/>
		/// errors occurring inside the command will be trapped.<br/>
		/// -verbose - (Optional) Temporarily override any message limits and return all messages from this<br/>
		/// command.<br/>
		/// Note: Message limits can be defined with the set_msg_config command.<br/>
		/// &lt;hdl_object&gt; - (Required) Specifies a single HDL object to get the value of. The object can be<br/>
		/// specified by name, or can be returned as an object from the get_objects command.<br/>
		/// Examples<br/>
		/// The following example gets the value of the sysClk signal:<br/>
		/// get_value sysClk<br/>
		/// Z<br/>
		/// This example shows the difference between the bin, dec, and unsigned radix on the value<br/>
		/// returned from the specified bus:<br/>
		/// get_value -radix bin /test/bench_VStatus_pad_0_i[7:0]<br/>
		/// 10100101<br/>
		/// get_value -radix unsigned /test/bench_VStatus_pad_0_i[7:0]<br/>
		/// 165<br/>
		/// get_value -radix dec /test/bench_VStatus_pad_0_i[7:0]<br/>
		/// -91<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 955<br/>
		/// </para>
		/// </summary>
		/// <param name="hdl_object">(Required) The hdl_object to retrieve the current value</param>
		/// <param name="radix">
		/// <para>
		/// (Optional)<br/>
		/// radix specifies the radix to use for printing the values of the<br/>
		/// hdl_objects. Allowed values are: default, dec, bin, oct,hex,<br/>
		/// unsigned, ascii, smag<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Returns a string representation of value of a hdl_object</returns>
		public VivadoTCL get_value(String hdl_object, String radix = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_value [-radix <arg>] [-quiet] [-verbose] <hdl_object>
			this.Entry(_builder.get_value(hdl_object, radix, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get one or more DRC/METHODOLOGY/CDC message waivers<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_waivers [-type &lt;arg&gt;] [-id &lt;arg&gt;] [-of_objects &lt;args&gt;] [-regexp] [-filter &lt;arg&gt;] [-nocase] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// The create_waiver command lets you select individual DRC, methodology, or CDC violations<br/>
		/// or rule checks that can be waived for a design, letting you move forward in the design flow. The<br/>
		/// get_waivers command lets you query the defined waiver objects in the current design.<br/>
		/// A waiver must be specified for an individual DRC or methodology violation, or for a specific DRC<br/>
		/// or methodology check, or for a CDC path. The waiver must be assigned to a specific object, or<br/>
		/// specific violation ID, or for paths using -from/-to arguments. You can format the<br/>
		/// get_waivers command to return the specific types of waivers you are looking for, or waivers<br/>
		/// associated with specific objects.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// You can report the waivers defined in the current design with report_waivers, and remove<br/>
		/// waivers from the design using delete_waivers.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// This example gets any waivers in the current design:<br/>
		/// get_waivers<br/>
		/// The following example gets all DRC check waivers:<br/>
		/// get_waivers -type DRC *<br/>
		/// The following example gets all waivers associated with the specified objects:<br/>
		/// get_waivers -of_objects [get_ports {src_in* dest_out*}]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 957<br/>
		/// </para>
		/// </summary>
		/// <param name="type">(Optional) Type of waiver - DRC, METHODOLOGY, CDC, ALL</param>
		/// <param name="id">(Optional) ID of the DRC/METHODOLOGY/CDC message being waived</param>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// List of objects (cells, nets, pins, sites, etc.) for which DRC/<br/>
		/// METHODLOGY/CDC waiver(s) were set<br/>
		/// </para>
		/// </param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching (valid only when -regexp specified)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">
		/// <para>
		/// (Optional)<br/>
		/// Match waiver names against patterns Default: * Values: The<br/>
		/// default search pattern is the wildcard *, or .* when -regexp<br/>
		/// is specified.<br/>
		/// </para>
		/// </param>
		/// <returns>waivers</returns>
		public VivadoTCL get_waivers(String type = null, String id = null, TCLParameterList of_objects = null, bool? regexp = null, String filter = null, bool? nocase = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_waivers [-type <arg>] [-id <arg>] [-of_objects <args>] [-regexp] [-filter <arg>] [-nocase] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_waivers(type, id, of_objects, regexp, filter, nocase, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Gets the wave configs that match the given options<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_wave_configs [-regexp] [-nocase] [-filter &lt;arg&gt;] [-quiet] [-verbose] [&lt;patterns&gt;...]
		/// <br/>
		/// <para>
		/// Get the wave configuration objects that match the specified search options in the current<br/>
		/// simulation.<br/>
		/// In the Vivado® simulator GUI, you can work with a waveform to analyze your design and debug<br/>
		/// your code. The Wave Config file contains the list of wave objects (signals, dividers, groups, virtual<br/>
		/// buses) to display, and their display properties, plus markers. A wave configuration displays with<br/>
		/// top-level HDL objects, and can be further populated using commands like add_wave and<br/>
		/// add_wave_divider.<br/>
		/// This command returns the matching wave configuration objects, or returns nothing if no objects<br/>
		/// matched the search pattern.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns all wave configuration objects, in the current simulation, that have<br/>
		/// unsaved changes:<br/>
		/// get_wave_config -filter {NEEDS_SAVE}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 960<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) interprets &lt;patterns&gt; using regular expressions</param>
		/// <param name="nocase">(Optional) only when regexp is used, performs a case insensitive match</param>
		/// <param name="filter">
		/// <para>
		/// (Optional)<br/>
		/// filters &lt;patterns&gt; according to the specified property-matching expressions<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) the pattern strings to search for wave configuration names</param>
		/// <returns>Wave configs that match the given options</returns>
		public VivadoTCL get_wave_configs(bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, TCLParameterList patterns = null)
		{
			// TCL Syntax: get_wave_configs [-regexp] [-nocase] [-filter <arg>] [-quiet] [-verbose] [<patterns>...]
			this.Entry(_builder.get_wave_configs(regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Gets wave objects from a wave configuration<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_waves [-of &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] [-recursive] [-r] [-long_name] [-short_name] [-quiet] [-verbose] &lt;patterns&gt;...
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 963<br/>
		/// </para>
		/// </summary>
		/// <param name="patterns">(Required) the design objects from which to create wave objects</param>
		/// <param name="of">(Optional) the wave configuration, group, or virtual bus to search</param>
		/// <param name="regexp">(Optional) interprets &lt;patterns&gt; using regular expressions</param>
		/// <param name="nocase">(Optional) only when regexp is used, performs a case insensitive match</param>
		/// <param name="filter">
		/// <para>
		/// (Optional)<br/>
		/// filters &lt;patterns&gt; according to the specified property-matching expressions<br/>
		/// </para>
		/// </param>
		/// <param name="recursive">
		/// <para>
		/// (Optional)<br/>
		/// if the design object is a scope, this option specifies that<br/>
		/// wave objects for all design objects under that scope should<br/>
		/// be created<br/>
		/// </para>
		/// </param>
		/// <param name="r">
		/// <para>
		/// (Optional)<br/>
		/// if the design object is a scope, this option specifies that<br/>
		/// wave objects for all design objects under that scope should<br/>
		/// be created<br/>
		/// </para>
		/// </param>
		/// <param name="long_name">(Optional) search wave objects using the long form of their names</param>
		/// <param name="short_name">(Optional) search wave objects using the short form of their names</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>a collection of found wave objects</returns>
		public VivadoTCL get_waves(TCLParameterList patterns, TCLParameterList of = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? recursive = null, bool? r = null, bool? long_name = null, bool? short_name = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: get_waves [-of <args>] [-regexp] [-nocase] [-filter <arg>] [-recursive] [-r] [-long_name] [-short_name] [-quiet] [-verbose] <patterns>...
			this.Entry(_builder.get_waves(patterns, of, regexp, nocase, filter, recursive, r, long_name, short_name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get a list of wires.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: get_wires [-regexp] [-nocase] [-filter &lt;arg&gt;] [-of_objects &lt;args&gt;] [-uphill] [-downhill] [-from &lt;args&gt;] [-to &lt;args&gt;] [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Returns a list of wires in the design that match a specified search pattern in an open design.<br/>
		/// The default command gets a list of all wires in the design.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Note: To improve memory and performance, the get_* commands return a container list of a single type<br/>
		/// of objects (e.g. cells, nets, pins, or ports). You can add new objects to the list (using lappend for instance),<br/>
		/// but you can only add the same type of object that is currently in the list. Adding a different type of object,<br/>
		/// or string, to the list is not permitted and will result in a Tcl error.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the wires associated with the specified tile:<br/>
		/// get_wires -of_objects [get_tiles IO_INT_INTERFACE_L_X0Y198]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 964<br/>
		/// </para>
		/// </summary>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="of_objects">(Optional) Get the wires of these tiles, nodes, pips, or nets.</param>
		/// <param name="uphill">(Optional) Get the wires uphill from the provided pip.</param>
		/// <param name="downhill">(Optional) Get the wires downhill from the provided pip.</param>
		/// <param name="from">
		/// <para>
		/// (Optional)<br/>
		/// -from &lt;pip/site pin&gt; Return the ordered list of wires<br/>
		/// beginning at this pip or site pin. May be used in<br/>
		/// combination with uphill. Default is downhill. -all is implied.<br/>
		/// </para>
		/// </param>
		/// <param name="to">
		/// <para>
		/// (Optional)<br/>
		/// -to &lt;pip/site pin&gt; Return the ordered list of wires ending at<br/>
		/// this wire or site pin. May be used in combination with uphill.<br/>
		/// Default is downhill. -all is implied.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match wires against patterns Default: *</param>
		/// <returns>wires</returns>
		public VivadoTCL get_wires(bool? regexp = null, bool? nocase = null, String filter = null, TCLParameterList of_objects = null, bool? uphill = null, bool? downhill = null, TCLParameterList from = null, TCLParameterList to = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: get_wires [-regexp] [-nocase] [-filter <arg>] [-of_objects <args>] [-uphill] [-downhill] [-from <args>] [-to <args>] [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.get_wires(regexp, nocase, filter, of_objects, uphill, downhill, from, to, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create a hierarchical cell, and then move the group of cells into the hierarchy cell. The<br/>
		/// connections between these cells are maintained; the connections between these cells and other<br/>
		/// cells are maintained through crossing hierarchy cell.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: group_bd_cells [-prefix &lt;arg&gt;] [-quiet] [-verbose] [&lt;target_cell_name&gt;] [&lt;cells&gt;...]
		/// <br/>
		/// <para>
		/// Create a new hierarchical module in the current IP integrator subsystem design, and move the<br/>
		/// specified cells into that module.<br/>
		/// You can also optionally move a group of specified cells into the hierarchical module. The<br/>
		/// connections between the specified cells are maintained. The connections between the cells being<br/>
		/// moved are maintained; connections between these cells and other cells that are not being moved<br/>
		/// are maintained automatically by IP integrator adding pins and ports to cross the hierarchical<br/>
		/// boundary.<br/>
		/// You can also move cells into the hierarchical module by using the move_bd_cells command<br/>
		/// after the hierarchical module has been created using the create_bd_cells command.<br/>
		/// The command returns the name of the created hierarchical module if successful, or an error<br/>
		/// message if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 967<br/>
		/// </para>
		/// </summary>
		/// <param name="target_cell_name">(Required) Target cell</param>
		/// <param name="cells">(Required) Match engine names against cell names Default: *</param>
		/// <param name="prefix">(Optional) Prefix name to add to cells</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>0 if success.</returns>
		public VivadoTCL group_bd_cells(String target_cell_name, TCLParameterList cells, String prefix = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: group_bd_cells [-prefix <arg>] [-quiet] [-verbose] [<target_cell_name>] [<cells>...]
			this.Entry(_builder.group_bd_cells(target_cell_name, cells, prefix, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Groups paths for cost function calculations<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: group_path [-name &lt;args&gt;] [-weight &lt;arg&gt;] [-default] [-from &lt;args&gt;] [-to &lt;args&gt;] [-through &lt;args&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// This command lets you group a set of paths for cost function calculations, primarily for timing<br/>
		/// analysis. The Vivado tool automatically defines path groups of clock signals for special handling.<br/>
		/// User-defined path groups can be specified generally as from a startpoint, or to an endpoint, or as<br/>
		/// specific paths from-through-to specific points. Once a path group has been created, some timing<br/>
		/// analysis can be performed against it with the report_timing command.<br/>
		/// You can specify a weight for an existing path group of clocks, and let the placement, routing, and<br/>
		/// optimization engines prioritize those paths first.<br/>
		/// To remove a path from a path group, you must specify the -default option to remove the path<br/>
		/// from a named path group and restore the path to the standard "default" path group.<br/>
		/// This option has the following limitations:<br/>
		/// • For paths originally assigned by the tool to a clock path group, the -default option will<br/>
		/// revert those paths to the clock path group instead of reverting them to the "default" path<br/>
		/// group.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// • group_path -default and reset_path are completely independent commands. The<br/>
		/// reset_path command doesn't affect path groups, and the group_path command doesn't<br/>
		/// affect other timing exceptions .<br/>
		/// The path groups currently defined in a design can be found by using the get_path_groups<br/>
		/// command.<br/>
		/// Note: This command operates silently and does not return direct feedback of its operation.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates a group named signal_grp to the specified registers' endpoints<br/>
		/// matching *signal*reg/D, and then reports timing on the specified group:<br/>
		/// group_path -to [get_pins *signal*reg/D -hierarchical] -name signal_grp<br/>
		/// report_timing -group signal_grp<br/>
		/// The path group signal_grp is also returned by the get_path_groups command:<br/>
		/// get_path_groups signal_grp<br/>
		/// The following example removes the path from the signal_grp, restoring it to the default path<br/>
		/// group:<br/>
		/// group_path -to [get_pins *signal*reg/D -hierarchical] -default<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 969<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Optional) The name of group, can be multiple names</param>
		/// <param name="weight">(Optional) Cost function Weight, Valid values are 1, 2 Default: 1.0</param>
		/// <param name="default">(Optional) Restore path to its default group</param>
		/// <param name="from">(Optional) Filter by paths starting at these path startpoints</param>
		/// <param name="to">(Optional) Filter by paths terminating at these path endpoints</param>
		/// <param name="through">(Optional) Consider paths through pins, cells or nets</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL group_path(TCLParameterList name = null, String weight = null, bool? @default = null, TCLParameterList from = null, TCLParameterList to = null, TCLParameterList through = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: group_path [-name <args>] [-weight <arg>] [-default] [-from <args>] [-to <args>] [-through <args>] [-quiet] [-verbose]
			this.Entry(_builder.group_path(name, weight, @default, from, to, through, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Display help for one or more topics<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: help [-category &lt;arg&gt;] [-args] [-syntax] [-long] [-prop &lt;arg&gt;] [-class &lt;arg&gt;] [-message &lt;arg&gt;] [-quiet] [-verbose] [&lt;pattern_or_object&gt;]
		/// <br/>
		/// <para>
		/// Returns a long description of the specified Tcl command; or a list of available Xilinx Tcl command<br/>
		/// categories; or a list of commands matching a specific pattern.<br/>
		/// The default help command without any arguments returns a list of Tcl command categories that<br/>
		/// can be further explored. Command categories are groups of commands performing a specific<br/>
		/// function, like File I/O commands for instance.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Available options for the help command can return just the command syntax for a quick<br/>
		/// reminder of how the command should be structured; the command syntax and a brief description<br/>
		/// of each argument; or the long form of the command with more detailed descriptions and<br/>
		/// examples of the command.<br/>
		/// To limit the memory usage of the Vivado Design Suite, some features of the tool are only loaded<br/>
		/// into memory when that feature set is used. To access the complete list of Tcl commands and help<br/>
		/// text associated with a given feature, you must load the feature into memory using the<br/>
		/// load_features command.<br/>
		/// The help command can also return any available information related to various properties<br/>
		/// assignable to design objects. Use the -prop and -class options to return help information for<br/>
		/// properties.<br/>
		/// This command returns the specified help text, or an error.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns a list of Xilinx Tcl command categories:<br/>
		/// help<br/>
		/// This example loads the simulator feature of the Vivado Design Suite, and then returns a list of Tcl<br/>
		/// commands in the simulation and waveform categories:<br/>
		/// load_features simulator<br/>
		/// help -category simulation<br/>
		/// help -category waveform<br/>
		/// Returns a list of all commands matching the specified search pattern:<br/>
		/// help *file*<br/>
		/// This list can be used to quickly locate a command for a specific purpose, such as remove_files<br/>
		/// or delete_files.<br/>
		/// The following help command returns a long description of the remove_files command and its<br/>
		/// arguments:<br/>
		/// help remove_files<br/>
		/// Note: You can also use the -args option to get a brief description of the command.<br/>
		/// This example defines a procedure called short, and returns the -args form of help for the<br/>
		/// specified command:<br/>
		/// proc short cmdName {help -args $cmdName}<br/>
		/// Note: You can add this procedure to your init.tcl file to load this command every time the tool is<br/>
		/// launched. Refer to Chapter 1, Introduction of the Vivado Design Suite Tcl Command Reference (UG835) for<br/>
		/// more information on the init.tcl file.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following examples show how to obtain help for properties of design objects, or a class of<br/>
		/// design objects:<br/>
		/// help -class cell -prop NAME<br/>
		/// help -prop NAME [get_cells cpuEngine]<br/>
		/// Note: In the preceding example, the first command returns general information related to the NAME<br/>
		/// property, while the second command also returns the value of the NAME property on the specified design<br/>
		/// object.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 972<br/>
		/// </para>
		/// </summary>
		/// <param name="category">(Optional) Search for topics in the specified category</param>
		/// <param name="args">(Optional) Display arguments description</param>
		/// <param name="syntax">(Optional) Display syntax description</param>
		/// <param name="long">(Optional) Display long help description</param>
		/// <param name="prop">(Optional) Display property help for matching property names Default: *</param>
		/// <param name="class">(Optional) Display object type help</param>
		/// <param name="message">
		/// <para>
		/// (Optional)<br/>
		/// Display information about the message with the given<br/>
		/// message. Every message delivered by the tool has a unique<br/>
		/// global message ID that consists of an application sub-system code and a message identifier. Example: -message<br/>
		/// {Common 17-8}.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="pattern_or_object">(Optional) Display help for topics that match the specified pattern Default: *</param>
		public VivadoTCL help(String category = null, bool? args = null, bool? syntax = null, bool? @long = null, String prop = null, String @class = null, String message = null, bool? quiet = null, bool? verbose = null, String pattern_or_object = null)
		{
			// TCL Syntax: help [-category <arg>] [-args] [-syntax] [-long] [-prop <arg>] [-class <arg>] [-message <arg>] [-quiet] [-verbose] [<pattern_or_object>]
			this.Entry(_builder.help(category, args, syntax, @long, prop, @class, message, quiet, verbose, pattern_or_object));
			return this;
		}
		/// <summary>
		/// <para>
		/// Highlight objects in different colors<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: highlight_objects [-color_index &lt;arg&gt;] [-rgb &lt;args&gt;] [-color &lt;arg&gt;] [-leaf_cells] [-quiet] [-verbose] &lt;objects&gt;
		/// <br/>
		/// <para>
		/// Highlights the specified or selected object or objects in a color as determined by one of the<br/>
		/// available color options.<br/>
		/// TIP: Only one of the available color option should be used to specify the highlight color. However, if more<br/>
		/// than one color option is used, the order of precedence to define the color is -rgb, -color_index, and -<br/>
		/// color.<br/>
		/// Selected objects are automatically unselected in order to display the objects in the specified<br/>
		/// highlight color. Objects can be unhighlighted with the unhighlight_objects command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example highlights the currently selected objects in the color red:<br/>
		/// highlight_objects -color red [get_selected_objects]<br/>
		/// This example highlights the specified cells in green:<br/>
		/// highlight_objects -color green -leaf_cells [get_cells cpuEngine/*]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 976<br/>
		/// </para>
		/// </summary>
		/// <param name="objects">(Required) Objects to highlight</param>
		/// <param name="color_index">(Optional) Color index</param>
		/// <param name="rgb">(Optional) RGB color index list</param>
		/// <param name="color">(Optional) Valid values are red green blue magenta yellow cyan and orange</param>
		/// <param name="leaf_cells">(Optional) Leaf cells</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL highlight_objects(String objects, String color_index = null, TCLParameterList rgb = null, String color = null, bool? leaf_cells = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: highlight_objects [-color_index <arg>] [-rgb <args>] [-color <arg>] [-leaf_cells] [-quiet] [-verbose] <objects>
			this.Entry(_builder.highlight_objects(objects, color_index, rgb, color, leaf_cells, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Implement debug core<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: implement_debug_core [-quiet] [-verbose] [&lt;cores&gt;...]
		/// <br/>
		/// <para>
		/// Implements the Vivado logic analyzer debug cores in the current project. The tools will be run<br/>
		/// once for any ILA debug cores specified, and run one more time for the Debug Hub core if all<br/>
		/// cores are specified. The ILA core (labtools_ila_v3) is the only core type currently supported by the<br/>
		/// create_debug_core command. The tool automatically adds a Debug Hub core<br/>
		/// (labtools_xsdbmasterlib_v2) to contain and configure the ILA cores in the project.<br/>
		/// The Vivado tool creates Debug Hub core and ILA cores initially as black boxes. These cores must<br/>
		/// be implemented prior to running through place and route. After the core is created with<br/>
		/// create_debug_core, and while ports are being added and connected with<br/>
		/// create_debug_port and connect_debug_port, the content of the debug core is not<br/>
		/// defined or visible within the design.<br/>
		/// Debug core implementation is automatic when you launch an implementation run using the<br/>
		/// launch_runs command, or during design optimization using opt_design. However, you can<br/>
		/// also use the implement_debug_core command to implement one or more of the cores in the<br/>
		/// design without having to implement the whole design.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example implements all debug cores in the current project:<br/>
		/// implement_debug_core [get_debug_cores]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 978<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="cores">(Optional) Debug core</param>
		public VivadoTCL implement_debug_core(bool? quiet = null, bool? verbose = null, TCLParameterList cores = null)
		{
			// TCL Syntax: implement_debug_core [-quiet] [-verbose] [<cores>...]
			this.Entry(_builder.implement_debug_core(quiet, verbose, cores));
			return this;
		}
		/// <summary>
		/// <para>
		/// Call IP Services to regenerate an IP, then stitch it into the current netlist<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: implement_mig_cores [-outputdir &lt;arg&gt;] [-rtlonly] [-force] [-debug_output] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Implements the memory IP cores in the current project.<br/>
		/// Memory IP included in the Xilinx® IP catalog are used to generate memory controllers and<br/>
		/// interfaces for Xilinx devices. Memory IP includes different IP cores from the Xilinx IP catalog<br/>
		/// depending on the device architecture and memory interface specified. Refer to Zynq-7000 SoC<br/>
		/// and 7 Series Devices Memory Interface Solutions (UG586), or UltraScale Architecture-Based FPGAs<br/>
		/// Memory Interface Solutions (PG150), for details of the available memory IP.<br/>
		/// The implement_mig_cores command generates the RTL information for the physical<br/>
		/// interface (PHY) of the memory controller, and integrates the synthesized netlist of the memory<br/>
		/// controller into the top-level design.<br/>
		/// A memory controller can be debug enabled when added into the design from the Xilinx IP<br/>
		/// catalog. In the Vivado logic analyzer, or the Vivado Lab Edition, memory controllers implemented<br/>
		/// into a design are associated with hw_mig objects, one hw_mig object per debug-enabled memory<br/>
		/// controller. The hw_mig object will have all the properties needed to get the calibration status and<br/>
		/// draw the per-bit eye margin views.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Implementation of the memory IP, and debug core, is automatic when you launch an<br/>
		/// implementation run using the launch_runs command, or when you run opt_design.<br/>
		/// However, you can also use the implement_mig_cores command to integrate the memory IP<br/>
		/// without having to implement the whole design.<br/>
		/// TIP: All pins of the memory controller must be assigned prior to running the implement_mig_cores<br/>
		/// command, or an error will be returned. You can use report_drc to check the status of the memory<br/>
		/// controller.<br/>
		/// This command returns a transcript of its process, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example implements the memory IP cores in the current design:<br/>
		/// implement_mig_cores<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 980<br/>
		/// </para>
		/// </summary>
		/// <param name="outputdir">(Optional) Target Output Directory for PHY IP Generated Files Default: empty</param>
		/// <param name="rtlonly">
		/// <para>
		/// (Optional)<br/>
		/// Run the complete process to generate the PHY RTL code but<br/>
		/// do not replace the PHY core netlist<br/>
		/// </para>
		/// </param>
		/// <param name="force">
		/// <para>
		/// (Optional)<br/>
		/// Implement all non-optimized memory cores. When use with<br/>
		/// -rtlonly, optimized cores will be included, as well.<br/>
		/// </para>
		/// </param>
		/// <param name="debug_output">(Optional) Enable debugging output.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL implement_mig_cores(String outputdir = null, bool? rtlonly = null, bool? force = null, bool? debug_output = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: implement_mig_cores [-outputdir <arg>] [-rtlonly] [-force] [-debug_output] [-quiet] [-verbose]
			this.Entry(_builder.implement_mig_cores(outputdir, rtlonly, force, debug_output, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Call IP Services to regenerate an IP, then stitch it into the current netlist<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: implement_xphy_cores [-outputdir &lt;arg&gt;] [-rtlonly] [-force] [-debug_output] [-update_delay_value_only] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 983<br/>
		/// </para>
		/// </summary>
		/// <param name="outputdir">(Optional) Target Output Directory for PHY IP Generated Files Default: empty</param>
		/// <param name="rtlonly">
		/// <para>
		/// (Optional)<br/>
		/// Run the complete process to generate the PHY RTL code but<br/>
		/// do not replace the PHY core netlist<br/>
		/// </para>
		/// </param>
		/// <param name="force">
		/// <para>
		/// (Optional)<br/>
		/// Implement all non-optimized memory cores. When use with<br/>
		/// -rtlonly, optimized cores will be included, as well.<br/>
		/// </para>
		/// </param>
		/// <param name="debug_output">(Optional) Enable debugging output.</param>
		/// <param name="update_delay_value_only">(Optional) Update latest Delay value.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL implement_xphy_cores(String outputdir = null, bool? rtlonly = null, bool? force = null, bool? debug_output = null, bool? update_delay_value_only = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: implement_xphy_cores [-outputdir <arg>] [-rtlonly] [-force] [-debug_output] [-update_delay_value_only] [-quiet] [-verbose]
			this.Entry(_builder.implement_xphy_cores(outputdir, rtlonly, force, debug_output, update_delay_value_only, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Import files and/or directories into the active fileset<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: import_files [-fileset &lt;arg&gt;] [-force] [-of_objects &lt;args&gt;] [-norecurse] [-flat] [-relative_to &lt;arg&gt;] [-quiet] [-verbose] [&lt;files&gt;...]
		/// <br/>
		/// <para>
		/// Imports one or more files or the source file contents of one or more directories to the specified<br/>
		/// fileset.<br/>
		/// For every file added to a project the Vivado Design Suite attempts to store and maintain both a<br/>
		/// relative path and an absolute path to the file or directory. When a project is opened, these paths<br/>
		/// are used to locate the files and directories. By default the Vivado Design Suite applies a Relative<br/>
		/// First approach to resolving paths, searching the relative path first, then the absolute path. You<br/>
		/// can use the PATH_MODE property to change how the Vivado tool resolves file paths or<br/>
		/// properties for specific objects. For more information, see the Vivado Design Suite Properties<br/>
		/// Reference Guide (UG912).<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// IMPORTANT! Importing multiple files one at a time can cause noticeable performance degradation. It is<br/>
		/// more efficient to use a single import_files command to import a list of files:<br/>
		/// import_files {file1 file2 file3 ... fileN}<br/>
		/// This command is different from the add_files command, which adds files by reference into the<br/>
		/// specified fileset. This command imports the files into the local project folders under<br/>
		/// project.srcs\&lt;fileset&gt;\imports and then adds the file to the specified fileset.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example imports the top.ucf file into the constrs_1 constraint fileset.<br/>
		/// import_files -fileset constrs_1 top.ucf<br/>
		/// The following example imports the valid source files into the source fileset (sources_1) as a<br/>
		/// default since the -fileset argument is not specified. In addition, the -norecurse argument<br/>
		/// restricts the tool to looking only in the specified \level1 directory and not searching any<br/>
		/// subdirectories. All valid source files will be imported into the \imports folder of the project<br/>
		/// because the -flat argument has been specified.<br/>
		/// import_files C:/Data/FPGA_Design/level1 -norecurse -flat<br/>
		/// Note: Without the -flat option a \level1 directory would be created inside of the \imports folder of<br/>
		/// the project.<br/>
		/// The following example imports files into the source fileset (sources_1) because the -fileset<br/>
		/// argument is not specified. Valid source files are imported from the \level1 directory, and all<br/>
		/// subdirectories, and the files will be written into the \imports folder of the project starting at<br/>
		/// the \Data directory due to the use of the -relative_to argument.<br/>
		/// import_files C:/Data/FPGA_Design/level1 -relative_to C:/Data<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 984<br/>
		/// </para>
		/// </summary>
		/// <param name="fileset">(Optional) Fileset name</param>
		/// <param name="force">(Optional) Overwrite files of the same name in project directory</param>
		/// <param name="of_objects">(Optional) RMs to import the files to</param>
		/// <param name="norecurse">(Optional) Disables the default behavior of recursive directory searches</param>
		/// <param name="flat">(Optional) Import the files into a flat directory structure</param>
		/// <param name="relative_to">(Optional) Import the files with respect to the given relative directory</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="files">(Optional) Name of the files to import into fileset</param>
		/// <returns>A list of file objects that were imported</returns>
		public VivadoTCL import_files(String fileset = null, bool? force = null, TCLParameterList of_objects = null, bool? norecurse = null, bool? flat = null, String relative_to = null, bool? quiet = null, bool? verbose = null, TCLParameterList files = null)
		{
			// TCL Syntax: import_files [-fileset <arg>] [-force] [-of_objects <args>] [-norecurse] [-flat] [-relative_to <arg>] [-quiet] [-verbose] [<files>...]
			this.Entry(_builder.import_files(fileset, force, of_objects, norecurse, flat, relative_to, quiet, verbose, files));
			return this;
		}
		/// <summary>
		/// <para>
		/// Import an IP file and add it to the fileset<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: import_ip [-srcset &lt;arg&gt;] [-name &lt;arg&gt;] [-quiet] [-verbose] [&lt;files&gt;]
		/// <br/>
		/// <para>
		/// Adds an existing XCI or XCO file as an IP source into the current project, and copies it into the<br/>
		/// local project directory structure.<br/>
		/// The import_ip command allows you to read existing IP files directly, and copy them into the<br/>
		/// local project folders. Use the read_ip or add_files command to add IP files by reference into<br/>
		/// the current project.<br/>
		/// Use the create_ip command to create new IP files from the current IP catalog.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example copies the 10gig ethernet core into the current project, and assigns it a<br/>
		/// name of IP_block1:<br/>
		/// import_ip C:/Data/FPGA_Design/10gig_eth.xci -name IP_block1<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 987<br/>
		/// </para>
		/// </summary>
		/// <param name="srcset">
		/// <para>
		/// (Optional)<br/>
		/// (Optional) Specifies the source file set containing the objects<br/>
		/// to be upgraded Default: The current source fileset Values:<br/>
		/// Source set name<br/>
		/// </para>
		/// </param>
		/// <param name="name">
		/// <para>
		/// (Optional)<br/>
		/// (Optional) Specifies a replacement name for the imported<br/>
		/// IP; may not be used with multiple files. Default: The current<br/>
		/// name for the imported IP Values: The new name for the<br/>
		/// imported IP<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="files">
		/// <para>
		/// (Optional)<br/>
		/// Names of the IP files to be imported Values: A list of XCI<br/>
		/// (and/or XCO) file name(s)<br/>
		/// </para>
		/// </param>
		/// <returns>list of file objects that were added</returns>
		public VivadoTCL import_ip(String srcset = null, String name = null, bool? quiet = null, bool? verbose = null, String files = null)
		{
			// TCL Syntax: import_ip [-srcset <arg>] [-name <arg>] [-quiet] [-verbose] [<files>]
			this.Entry(_builder.import_ip(srcset, name, quiet, verbose, files));
			return this;
		}
		/// <summary>
		/// <para>
		/// Imports the given Synplify project file<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: import_synplify [-copy_sources] [-quiet] [-verbose] &lt;file&gt;
		/// <br/>
		/// <para>
		/// Imports Synplify synthesis project files (.prj) into the current project, including the various<br/>
		/// source files used in the synthesis run.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates a new project and imports the specified Synplify project file,<br/>
		/// copying the various source files from the Synplify project into the local project directories:<br/>
		/// create_project syn_test C:/Data/FPGA_Design/syn_test<br/>
		/// import_synplify -copy_sources C:/Data/syn_data.prj<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 989<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) Name of the Synplify project file to be imported</param>
		/// <param name="copy_sources">
		/// <para>
		/// (Optional)<br/>
		/// Copy all the sources from synplify project file into the<br/>
		/// created project<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of files object that were imported from the Synplify file</returns>
		public VivadoTCL import_synplify(String file, bool? copy_sources = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: import_synplify [-copy_sources] [-quiet] [-verbose] <file>
			this.Entry(_builder.import_synplify(file, copy_sources, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Import XISE project file settings into the created project<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: import_xise [-copy_sources] [-quiet] [-verbose] &lt;file&gt;
		/// <br/>
		/// <para>
		/// Imports an ISE project file (XISE) into the current project. This allows ISE projects to be quickly<br/>
		/// migrated into the Vivado Design Suite for synthesis, simulation, and implementation. All project<br/>
		/// source files, constraint files, simulation files, and run settings are imported from the ISE project<br/>
		/// and recreated in the current project.<br/>
		/// This command should be run on a new empty project. Since source files, constraints, and run<br/>
		/// settings are imported from the ISE project, any existing source files or constraints may be<br/>
		/// overwritten.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates a new project called importISE, and then imports the ISE project<br/>
		/// file (first_use.xise) into the new project.<br/>
		/// create_project importISE C:/Data/importISE import_xise \<br/>
		/// C:/Data/FPGA_design/ise_designs/drp_des/first_use.xise<br/>
		/// Note: This example does not specify the -copy_sources argument, so all source files in the ISE project<br/>
		/// will be added to the current project by reference.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 991<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) Name of the XISE project file to be imported</param>
		/// <param name="copy_sources">(Optional) Copy all ISE sources into the created project</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>true</returns>
		public VivadoTCL import_xise(String file, bool? copy_sources = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: import_xise [-copy_sources] [-quiet] [-verbose] <file>
			this.Entry(_builder.import_xise(file, copy_sources, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Imports the given XST project file<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: import_xst [-copy_sources] [-quiet] [-verbose] &lt;file&gt;
		/// <br/>
		/// <para>
		/// Imports XST synthesis project files into the current project, including the various source files<br/>
		/// used in the XST run.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates a new project called xst_test, and imports the drp_des.xst<br/>
		/// file:<br/>
		/// create_project xst_test C:/Data/FPGA_Design/xst_test<br/>
		/// import_xst C:/Data/ise_designs/drp_des.xst<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 993<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) Name of the XST project file to be imported</param>
		/// <param name="copy_sources">(Optional) Copy all the sources from xst project file into the created project</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of files object that were imported from the XST file</returns>
		public VivadoTCL import_xst(String file, bool? copy_sources = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: import_xst [-copy_sources] [-quiet] [-verbose] <file>
			this.Entry(_builder.import_xst(file, copy_sources, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// include segment from an address space.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: include_bd_addr_seg [-quiet] [-verbose] [&lt;segment_to_include&gt;]
		/// <br/>
		/// <para>
		/// Reverses the exclusion of an AXI peripheral address segment from access by the AXI master, and<br/>
		/// restores the address segment to a mapped state.<br/>
		/// In the block design, address segments of AXI peripherals can have one of three states:<br/>
		/// • Unmapped - An AXI peripheral, or slave interface, is connected to an AXI master, but the<br/>
		/// peripheral has not been assigned an address segment in the master's address space and is not<br/>
		/// visible to the master.<br/>
		/// • Mapped - The AXI peripheral is mapped into the AXI master's address space, assigned an<br/>
		/// address segment or range, and is accessible through the master.<br/>
		/// • Excluded - The AXI peripheral is mapped to the AXI master, and has been assigned an address<br/>
		/// segment, but is not accessible to the master. The address segment that the AXI slave occupies<br/>
		/// within the master address space is also considered filled.<br/>
		/// The exclude_bd_addr_seg command lets you exclude specific address segments from access<br/>
		/// by the AXI master they are mapped to. The include_bd_addr_seg restores access to the<br/>
		/// mapped address segment.<br/>
		/// This command returns nothing if successful, or returns an error if it failed.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 995<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="segment_to_include">(Optional) Segment to include</param>
		/// <returns>The newly included segment object, "" if failed.</returns>
		public VivadoTCL include_bd_addr_seg(bool? quiet = null, bool? verbose = null, String segment_to_include = null)
		{
			// TCL Syntax: include_bd_addr_seg [-quiet] [-verbose] [<segment_to_include>]
			this.Entry(_builder.include_bd_addr_seg(quiet, verbose, segment_to_include));
			return this;
		}
		/// <summary>
		/// <para>
		/// Infer differential pairs, typically for ports just imported from a CSV or XDC file<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: infer_diff_pairs [-file_type &lt;arg&gt;] [-quiet] [-verbose] [&lt;file&gt;...]
		/// <br/>
		/// <para>
		/// The infer_diff_pairs command can be used in an I/O Pin Planning project, after importing<br/>
		/// the I/O pin information using the read_csv or read_xdc command.<br/>
		/// There are several attributes that identify differential pairs in the file: Signal Name, DiffPair Signal,<br/>
		/// DiffPair Type, and I/O Standard.<br/>
		/// The tool will identify differential pairs using the following methods:<br/>
		/// • Matching Diff Pair - This is a direct definition of the two signals which make up a differential<br/>
		/// pair. Two port entries, each have DiffPair Signal values linking to the Signal Name of the other,<br/>
		/// and have complementary DiffPair Type values, one N and one P. The tool checks to ensure<br/>
		/// that the other attributes such as I/O Standard are compatible when forming the diff pair.<br/>
		/// • Unmatched Diff Pair - Two port entries, with complementary DiffPair Type values (one N, one<br/>
		/// P), but only one port has a DiffPair Signal linking to the other Signal Name. The tool will create<br/>
		/// the differential pair if all other attributes are compatible.<br/>
		/// • Single Port Diff Pair - A single port entry with a differential I/O Standard, a DiffPair Type value,<br/>
		/// and a DiffPair Signal that does not otherwise appear in the CSV. The tool will create the<br/>
		/// opposite side of the differential pair (the N or P side), with all properties matching those on<br/>
		/// the original port.<br/>
		/// • Inferred Diff Pair - Two ports entries, with Signal Names that imply the N and P side. The tool<br/>
		/// will infer a differential pair if all other attributes are compatible.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// After reading the port definitions from a CSV or XDC file, the tool will report that some<br/>
		/// differential pairs can be inferred from the data. You can run the infer_diff_pairs command<br/>
		/// to infer these differential pairs if you choose.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example imports the specified XDC file, and then infers differential pairs from the<br/>
		/// file:<br/>
		/// read_xdc C:/Vivado_Install/io_1.xdc<br/>
		/// infer_diff_pairs C:/Vivado_Install/io_1.xdc -file_type xdc<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 997<br/>
		/// </para>
		/// </summary>
		/// <param name="file_type">(Optional) Input file type: 'csv' or 'xdc' Default: file type</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="file">(Optional) Pin Planning CSV or XDC file Default: file</param>
		public VivadoTCL infer_diff_pairs(String file_type = null, bool? quiet = null, bool? verbose = null, TCLParameterList file = null)
		{
			// TCL Syntax: infer_diff_pairs [-file_type <arg>] [-quiet] [-verbose] [<file>...]
			this.Entry(_builder.infer_diff_pairs(file_type, quiet, verbose, file));
			return this;
		}
		/// <summary>
		/// <para>
		/// Creates an example design from a predefined template in an open project.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: instantiate_example_design [-design &lt;arg&gt;] [-hier &lt;arg&gt;] [-project &lt;arg&gt;] [-project_location &lt;arg&gt;] [-options &lt;args&gt;] [-quiet] [-verbose] &lt;template&gt;
		/// <br/>
		/// <para>
		/// This command creates an example design from a predefined template in an open project. The<br/>
		/// target part specified by the open project must be compatible with the example design, as defined<br/>
		/// in the SUPPORTED_PARTS property of the example, or an error is returned.<br/>
		/// For the embedded processor example designs, base_microblaze and base_zynq, the example<br/>
		/// design must be created in an open block design in the Vivado IP integrator. Embedded processor<br/>
		/// example designs require the use of a board as defined by the BOARD_PART property, rather than<br/>
		/// a target part. Refer to the current_board_part command for more information.<br/>
		/// The command returns the name of the example design used and a transcript of commands; or it<br/>
		/// returns an error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates a new project as specified, overwriting an existing project of the<br/>
		/// same name if one is found, specifies the BOARD_PART property for the project, creates a new<br/>
		/// empty block design in the Vivado IP integrator, and then instantiates the Zynq embedded<br/>
		/// processor example design:<br/>
		/// create_project zynq1 -force<br/>
		/// set_property BOARD_PART em.avnet.com:zed:1.3 [current_project]<br/>
		/// create_bd_design myFirstZynq<br/>
		/// instantiate_example_design -design myFirstZynq \<br/>
		/// [lindex [get_example_designs] 1]<br/>
		/// This example reports the configurable properties of the specified example design:<br/>
		/// report_property [lindex [get_example_designs] 3] CONFIG.*<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This example creates a new empty project as specified, sets a target BOARD for the project,<br/>
		/// creates and opens a new empty block design, and then instantiates the configurable example<br/>
		/// design:<br/>
		/// create_project mb1 C:/Data/Vivado_Tutorial/Tutorial_Created_Data/mb1<br/>
		/// set_property board_part xilinx.com:kcu105:part0:1.1 [current_project]<br/>
		/// create_bd_design design_1<br/>
		/// instantiate_example_design -design design_1 \<br/>
		/// -options { Data_Cache.VALUE 8K Include_DDR4.VALUE true \<br/>
		/// Local_memory.VALUE 128K }\<br/>
		/// xilinx.com:design:config_mb:1.0<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 999<br/>
		/// </para>
		/// </summary>
		/// <param name="template">(Required) Configurable Design Name</param>
		/// <param name="design">(Optional) Block Design Name</param>
		/// <param name="hier">(Optional) Hierarchy Block</param>
		/// <param name="project">(Optional) Project Name</param>
		/// <param name="project_location">(Optional) Project location Default: .</param>
		/// <param name="options">(Optional) Configurable options</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Returns the name of the template applied.</returns>
		public VivadoTCL instantiate_example_design(String template, String design = null, String hier = null, String project = null, String project_location = null, TCLParameterList options = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: instantiate_example_design [-design <arg>] [-hier <arg>] [-project <arg>] [-project_location <arg>] [-options <args>] [-quiet] [-verbose] <template>
			this.Entry(_builder.instantiate_example_design(template, design, hier, project, project_location, options, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Creates a block design in IP integrator from a predefined template.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: instantiate_template_bd_design -design &lt;arg&gt; [-hier &lt;arg&gt;] [-options &lt;args&gt;] [-quiet] [-verbose] &lt;template&gt;
		/// <br/>
		/// <para>
		/// This command creates an example design from a template Block Design in the IP integrator of<br/>
		/// the Vivado Design Suite.<br/>
		/// The template diagram is created in an existing and open block design. In addition, the target part<br/>
		/// specified by the current project or in-memory project must be compatible with the template<br/>
		/// design or an error is returned.<br/>
		/// The command returns a transcript of its process, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example builds the specified template block design in the specified design:<br/>
		/// instantiate_template_bd_design -design myFirstZynq \<br/>
		/// [lindex [get_template_bd_designs] 1]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1002<br/>
		/// </para>
		/// </summary>
		/// <param name="design">(Required) Block Design Name</param>
		/// <param name="template">(Required) Configurable Design Name</param>
		/// <param name="hier">(Optional) Hierarchy Block</param>
		/// <param name="options">(Optional) Configurable options</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Returns the name of the template applied.</returns>
		public VivadoTCL instantiate_template_bd_design(String design, String template, String hier = null, TCLParameterList options = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: instantiate_template_bd_design -design <arg> [-hier <arg>] [-options <args>] [-quiet] [-verbose] <template>
			this.Entry(_builder.instantiate_template_bd_design(design, template, hier, options, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Interactive phys_opt_design.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: iphys_opt_design [-fanout_opt] [-critical_cell_opt] [-placement_opt] [-rewire] [-net &lt;arg&gt;] -cluster &lt;args&gt; -place_cell &lt;args&gt; [-dsp_register_opt] [-bram_register_opt] [-uram_register_opt] [-shift_register_opt] [-cell &lt;arg&gt;] [-packing] [-unpacking] [-port &lt;arg&gt;] [-critical_pin_opt] [-equ_drivers_opt] [-skipped_optimization] [-insert_negative_edge_ffs] [-hold_fix] [-slr_crossing_opt] [-auto_pipeline] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// The iphys_opt_design command describes a specific optimization that was performed by the<br/>
		/// phys_opt_design command, such as replicating a critical cell or pulling registers from a block<br/>
		/// RAM to improve critical path delay. The iphys_opt_design command includes all the<br/>
		/// information necessary to recreate both the post-optimization logical netlist and the placement<br/>
		/// changes required for the optimized netlist.<br/>
		/// Interactive physical optimization can be used in two ways:<br/>
		/// • Applying post-placement physical optimizations to the pre-placement netlist to improve the<br/>
		/// overall placement result and improve design performance.<br/>
		/// • Saving the physical optimizations in a Tcl script to be repeated as needed.<br/>
		/// The various optimizations performed by phys_opt_design can be written to an iphys_opt Tcl<br/>
		/// script by write_iphys_opt_tcl, and read into the design by the read_iphys_opt_tcl<br/>
		/// command.<br/>
		/// TIP: The iphys_opt_design command is intended for use inside the iphys_opt Tcl script file. These<br/>
		/// commands can be edited in the context of the iphys_opt Tcl script, but they are not intended to be<br/>
		/// specified at the command line.<br/>
		/// This command returns a transcript of its processes, or an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example performs a critical cell optimization on the specified net and cluster of<br/>
		/// ports:<br/>
		/// iphys_opt_design -critical_cell_opt -net \<br/>
		/// {ADUR_CORE_INST/CPE_INST/CPE_ANT_RESOURCE_TDM_INST0 \<br/>
		/// /CPE_ANT_LINE_IQ_TDM_ANT0_INST/CPE_PN_MULT_INST/CPE_PN_MUL_INST3 \<br/>
		/// /Q_PNI_MULT_INST/pn_mult_reg[3][0]} \<br/>
		/// -cluster {pn_mult[3]_i_14_replica {\<br/>
		/// {ADUR_CORE_INST/CPE_INST/CPE_ANT_RESOURCE_TDM_INST0 \<br/>
		/// /CPE_ANT_LINE_IQ_TDM_ANT0_INST/CPE_PN_MULT_INST/CPE_PN_MUL_INST2 \<br/>
		/// /Q_ADD_INST/pn_mult_reg[3]_i_6_CARRY8/S[0]}}}\<br/>
		/// -cluster {pn_mult[3]_i_14_replica_1 {\<br/>
		/// {ADUR_CORE_INST/CPE_INST/CPE_ANT_RESOURCE_TDM_INST0 \<br/>
		/// /CPE_ANT_LINE_IQ_TDM_ANT0_INST/CPE_PN_MULT_INST/CPE_PN_MUL_INST0 \<br/>
		/// /Q_ADD_INST/pn_mult_reg[3]_i_10_CARRY8/S[0]}}}\<br/>
		/// The following example performs a shift register optimization on the specified cell:<br/>
		/// iphys_opt_design -shift_register_opt -cell \<br/>
		/// {ADUR_CORE_INST/EMIF_INTERFACE_INST/EMIF_HOST_IF_INST/DLY_INST1 \<br/>
		/// /PD_INST_FPGA/delay_chain_reg[9][16]_srl9} -port D<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1004<br/>
		/// </para>
		/// </summary>
		/// <param name="cluster">(Required) Clusters of load pins</param>
		/// <param name="place_cell">(Required) Place cell or cell connecting to pin to loc</param>
		/// <param name="fanout_opt">(Optional) Fanout optimization including very high fanout optimizations</param>
		/// <param name="critical_cell_opt">(Optional) Do cell-duplication based optimization on timing critical nets</param>
		/// <param name="placement_opt">(Optional) Move cells to reduce delay on timing-critical nets</param>
		/// <param name="rewire">(Optional) Do rewiring optimization</param>
		/// <param name="net">(Optional) net to be optimized</param>
		/// <param name="dsp_register_opt">(Optional) DSP register optimization</param>
		/// <param name="bram_register_opt">(Optional) BRAM register optimization</param>
		/// <param name="uram_register_opt">(Optional) UltraRAM register optimization</param>
		/// <param name="shift_register_opt">(Optional) Shift register optimization</param>
		/// <param name="cell">(Optional) cell to be optimized</param>
		/// <param name="packing">(Optional) Packing in DSP/BRAM</param>
		/// <param name="unpacking">(Optional) Unpacking in DSP/BRAM</param>
		/// <param name="port">(Optional) Port in DSP/BRAM that is optimized</param>
		/// <param name="critical_pin_opt">(Optional) Pin Swap optimization</param>
		/// <param name="equ_drivers_opt">(Optional) Equivalent driver rewiring</param>
		/// <param name="skipped_optimization">(Optional) The change is not committed</param>
		/// <param name="insert_negative_edge_ffs">(Optional) Inserting negative edge triggered FFs for high hold mitigation</param>
		/// <param name="hold_fix">(Optional) Inserting buffers for hold fix optimization</param>
		/// <param name="slr_crossing_opt">(Optional) Optimize slr crossing nets</param>
		/// <param name="auto_pipeline">(Optional) Auto pipeline</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">
		/// <para>
		/// (Optional)<br/>
		/// Suspend message limits during command execution<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// </param>
		public VivadoTCL iphys_opt_design(TCLParameterList cluster, TCLParameterList place_cell, bool? fanout_opt = null, bool? critical_cell_opt = null, bool? placement_opt = null, bool? rewire = null, String net = null, bool? dsp_register_opt = null, bool? bram_register_opt = null, bool? uram_register_opt = null, bool? shift_register_opt = null, String cell = null, bool? packing = null, bool? unpacking = null, String port = null, bool? critical_pin_opt = null, bool? equ_drivers_opt = null, bool? skipped_optimization = null, bool? insert_negative_edge_ffs = null, bool? hold_fix = null, bool? slr_crossing_opt = null, bool? auto_pipeline = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: iphys_opt_design [-fanout_opt] [-critical_cell_opt] [-placement_opt] [-rewire] [-net <arg>] -cluster <args> -place_cell <args> [-dsp_register_opt] [-bram_register_opt] [-uram_register_opt] [-shift_register_opt] [-cell <arg>] [-packing] [-unpacking] [-port <arg>] [-critical_pin_opt] [-equ_drivers_opt] [-skipped_optimization] [-insert_negative_edge_ffs] [-hold_fix] [-slr_crossing_opt] [-auto_pipeline] [-quiet] [-verbose]
			this.Entry(_builder.iphys_opt_design(cluster, place_cell, fanout_opt, critical_cell_opt, placement_opt, rewire, net, dsp_register_opt, bram_register_opt, uram_register_opt, shift_register_opt, cell, packing, unpacking, port, critical_pin_opt, equ_drivers_opt, skipped_optimization, insert_negative_edge_ffs, hold_fix, slr_crossing_opt, auto_pipeline, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Issues an error that you can not run this command<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: launch_chipscope_analyzer [-run &lt;arg&gt;] [-csproject &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Launches the ChipScope™ Pro Analyzer tool for the active run, or a specified Implemented<br/>
		/// Design run. You can setup a Netlist Design for use with ChipScope prior to implementation, using<br/>
		/// the create_debug_core, create_debug_port, and connect_debug_port commands.<br/>
		/// The Implemented Design must also have a bitstream file generated by BitGen for<br/>
		/// launch_chipscope_analyzer to run. If BitGen has not been run, an error will be returned.<br/>
		/// Note: It is not enough to use the write_bitstream command to create a bitstream file. You must follow<br/>
		/// the steps outlined below in the second example.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example launches ChipScope Pro Analyzer, specifying the implementation run to<br/>
		/// use and the name of the ChipScope project to create:<br/>
		/// launch_chipscope_analyzer -run impl_3 -csproject impl_3_cs_project<br/>
		/// The following example sets the add_step Bitgen property for the impl_4 run, launches the<br/>
		/// impl_4 run, and then launches the ChipScope Pro Analyzer on the specified run:<br/>
		/// set_property add_step Bitgen [get_runs impl_4]<br/>
		/// launch_runs impl_4 -jobs 2<br/>
		/// launch_chipscope_analyzer -run impl_4<br/>
		/// Note: In this example the ChipScope project will be called csdefaultproj.cpj.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1008<br/>
		/// </para>
		/// </summary>
		/// <param name="run">(Optional) Implemented run to launch ChipScope Analyzer with</param>
		/// <param name="csproject">(Optional) ChipScope project</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL launch_chipscope_analyzer(String run = null, String csproject = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: launch_chipscope_analyzer [-run <arg>] [-csproject <arg>] [-quiet] [-verbose]
			this.Entry(_builder.launch_chipscope_analyzer(run, csproject, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Issues an error that you can not run this command<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: launch_impact [-run &lt;arg&gt;] [-ipf &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Launch iMPACT to configure your device and generate programming files. You can also read back<br/>
		/// and verify design configuration data, debug configuration problems, or execute XSVF files.<br/>
		/// You must generate the bitstream file using write_bitstream prior to using iMPACT.<br/>
		/// The command returns the list of files read.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example launches iMPACT using the specified implementation run:<br/>
		/// launch_impact -run impl_3<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1010<br/>
		/// </para>
		/// </summary>
		/// <param name="run">(Optional) Implemented run to launch iMPACT with</param>
		/// <param name="ipf">(Optional) Project for iMPACT</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL launch_impact(String run = null, String ipf = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: launch_impact [-run <arg>] [-ipf <arg>] [-quiet] [-verbose]
			this.Entry(_builder.launch_impact(run, ipf, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Launch a set of runs<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: launch_runs [-jobs &lt;arg&gt;] [-scripts_only] [-lsf &lt;arg&gt;] [-sge &lt;arg&gt;] [-cluster_configuration &lt;arg&gt;] [-dir &lt;arg&gt;] [-to_step &lt;arg&gt;] [-next_step] [-host &lt;args&gt;] [-remote_cmd &lt;arg&gt;] [-email_to &lt;args&gt;] [-email_all] [-pre_launch_script &lt;arg&gt;] [-post_launch_script &lt;arg&gt;] [-custom_script &lt;arg&gt;] [-force] [-quiet] [-verbose] &lt;runs&gt;...
		/// <br/>
		/// <para>
		/// Launches synthesis and implementation runs when running the Vivado tools in Project Mode.<br/>
		/// Refer to the Vivado Design Suite User Guide: Design Flows Overview (UG892) for a complete<br/>
		/// description of Project Mode and Non-Project Mode.<br/>
		/// A run must be previously defined using the create_run command, and the properties of the<br/>
		/// run must be previously configured using the set_property command. Both synthesis and<br/>
		/// implementation runs can be specified in the same launch_runs command. However, to launch<br/>
		/// an implementation run, the parent synthesis run must already be complete.<br/>
		/// In Non-Project Mode, Vivado synthesis can be launched directly using the synth_design<br/>
		/// command, and does not require the use of a defined run.<br/>
		/// In Non-Project Mode, Vivado implementation steps can be launched individually with the<br/>
		/// opt_design, power_opt_design, place_design, route_design, phys_opt_design,<br/>
		/// and write_bitstream commands.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following command launches three different synthesis runs with two parallel jobs:<br/>
		/// launch_runs synth_1 synth_2 synth_4 -jobs 2<br/>
		/// Note: The results for each run will be written to a separate folder synth_1, synth_2, and synth_4<br/>
		/// inside of the &lt;project&gt;.runs directory.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example creates a results directory to write run results. In this case a separate<br/>
		/// folder named impl_3, impl_4, and synth_3 will be written to the specified directory. In<br/>
		/// addition, the -scripts_only argument tells the tool to write runme.bat scripts to each of<br/>
		/// these folders but not to launch the runs at this time.<br/>
		/// launch_runs impl_3 impl_4 synth_3 -dir C:/Data/FPGA_Design/results -<br/>
		/// scripts_only<br/>
		/// The following example configures the impl_1 run, setting options for Vivado Implementation<br/>
		/// 2013, enabling some of the optional optimizations, and then launches the run to the<br/>
		/// place_design step:<br/>
		/// set_property flow {Vivado Implementation 2013} [get_runs impl_1]<br/>
		/// set_property STEPS.POWER_OPT_DESIGN.IS_ENABLED true [get_runs impl_1]<br/>
		/// set_property STEPS.POST_PLACE_POWER_OPT_DESIGN.IS_ENABLED true \<br/>
		/// [get_runs impl_1]<br/>
		/// set_property STEPS.PHYS_OPT_DESIGN.IS_ENABLED true [get_runs impl_1]<br/>
		/// launch_runs -to_step place_design impl_1<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1012<br/>
		/// </para>
		/// </summary>
		/// <param name="runs">(Required) Runs to launch UG835 (v2020.2) November 18, 2020 www.xilinx.com</param>
		/// <param name="jobs">(Optional) Number of jobs Default: 1</param>
		/// <param name="scripts_only">(Optional) Only generate scripts</param>
		/// <param name="lsf">
		/// <para>
		/// (Optional)<br/>
		/// Use LSF to launch jobs. Required argument is the bsub<br/>
		/// command line to pass to LSF Default: empty<br/>
		/// </para>
		/// </param>
		/// <param name="sge">
		/// <para>
		/// (Optional)<br/>
		/// Use SGE to launch jobs. Required argument is the qsub<br/>
		/// command line to pass to SGE Default: empty<br/>
		/// </para>
		/// </param>
		/// <param name="cluster_configuration">
		/// <para>
		/// (Optional)<br/>
		/// Run jobs on a particular cluster configuration (picks cluster<br/>
		/// configuration from GUI settings). Default: empty<br/>
		/// </para>
		/// </param>
		/// <param name="dir">(Optional) Launch directory</param>
		/// <param name="to_step">
		/// <para>
		/// (Optional)<br/>
		/// Last Step to run. Ignored when launching multiple runs. Not<br/>
		/// valid with -next_step<br/>
		/// </para>
		/// </param>
		/// <param name="next_step">
		/// <para>
		/// (Optional)<br/>
		/// Run next step. Ignored when launching multiple runs. Not<br/>
		/// valid with -to_step.<br/>
		/// </para>
		/// </param>
		/// <param name="host">
		/// <para>
		/// (Optional)<br/>
		/// Launch on specified remote host with a specified number of<br/>
		/// jobs. Example: -host {machine1 2} -host {machine2 4}<br/>
		/// </para>
		/// </param>
		/// <param name="remote_cmd">(Optional) Command to log in to remote hosts Default: ssh -q -o BatchMode=yes</param>
		/// <param name="email_to">
		/// <para>
		/// (Optional)<br/>
		/// List of email addresses to notify when jobs complete (only<br/>
		/// applicable with -host)<br/>
		/// </para>
		/// </param>
		/// <param name="email_all">(Optional) Send email after each job completes (only applicable with - host)</param>
		/// <param name="pre_launch_script">(Optional) Script to run before launching each job (only applicable with -host)</param>
		/// <param name="post_launch_script">(Optional) Script to run after each job completes (only applicable with - host)</param>
		/// <param name="custom_script">
		/// <para>
		/// (Optional)<br/>
		/// User run script map file which contains run name to user<br/>
		/// run script mapping<br/>
		/// </para>
		/// </param>
		/// <param name="force">
		/// <para>
		/// (Optional)<br/>
		/// Run the command, even if there are pending constraint<br/>
		/// changes, which will be lost (in a Dynamic Function eXchange<br/>
		/// design)<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL launch_runs(TCLParameterList runs, Int32? jobs = null, bool? scripts_only = null, String lsf = null, String sge = null, String cluster_configuration = null, String dir = null, String to_step = null, bool? next_step = null, TCLParameterList host = null, String remote_cmd = null, TCLParameterList email_to = null, bool? email_all = null, String pre_launch_script = null, String post_launch_script = null, String custom_script = null, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: launch_runs [-jobs <arg>] [-scripts_only] [-lsf <arg>] [-sge <arg>] [-cluster_configuration <arg>] [-dir <arg>] [-to_step <arg>] [-next_step] [-host <args>] [-remote_cmd <arg>] [-email_to <args>] [-email_all] [-pre_launch_script <arg>] [-post_launch_script <arg>] [-custom_script <arg>] [-force] [-quiet] [-verbose] <runs>...
			this.Entry(_builder.launch_runs(runs, jobs, scripts_only, lsf, sge, cluster_configuration, dir, to_step, next_step, host, remote_cmd, email_to, email_all, pre_launch_script, post_launch_script, custom_script, force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Generate simulation scripts of the design and launch steps for the target simulator.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: launch_simulation [-step &lt;arg&gt;] [-simset &lt;arg&gt;] [-mode &lt;arg&gt;] [-type &lt;arg&gt;] [-scripts_only] [-of_objects &lt;args&gt;] [-absolute_path] [-install_path &lt;arg&gt;] [-gcc_install_path &lt;arg&gt;] [-noclean_dir] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Launch a simulator to perform analysis and verification of a design.<br/>
		/// The launch_simulation command creates a script file for the target simulator and then<br/>
		/// executes this file in the simulation run directory. The simulation results are saved in the log files<br/>
		/// created in the run directory.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// To run simulation for a specific simulator, you must first define the target simulator by setting the<br/>
		/// TARGET_SIMULATOR property on the design project:<br/>
		/// set_property TARGET_SIMULATOR &lt;name&gt; [current_project]<br/>
		/// The TARGET_SIMULATOR property can have a value of XSim, ModelSim, IES, Xcelium, VCS,<br/>
		/// Riviera, or ActiveHDL. The default value is XSim, the Vivado simulator.<br/>
		/// The target simulator can also be defined from the Vivado IDE. Create or open a project, select<br/>
		/// Tools → Settings → Simulation menu item, and select the Target simulator from the drop-down<br/>
		/// menu. The available choices are: Vivado simulator, ModelSim Simulator, Questa Advanced<br/>
		/// Simulator, Incisive Enterprise Simulator (IES), Xcelium Parallel Simulator, Verilog Compiler<br/>
		/// Simulator (VCS), Riviera-PRO Simulator, and Active-HDL Simulator.<br/>
		/// TIP: Some of these simulators are only available on Linux and some are only available on Windows.<br/>
		/// The launch_simulation command uses a three-step process comprised of compile,<br/>
		/// elaborate, and simulate steps. A script file for the target simulator is created for each step in the<br/>
		/// process, (compile.bat, elaborate.bat, simulate.bat), and written to the simulation run<br/>
		/// directory.<br/>
		/// TIP: On Linux the script files are named with the .sh suffix instead of .bat.<br/>
		/// By default, launch_simulation will run these script files in sequence to run the simulation.<br/>
		/// You can create the scripts without running them by using the -scripts_only option.<br/>
		/// This command returns a transcript of its process, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following commands run behavioral simulation of the design using the Vivado simulator:<br/>
		/// set_property target_simulator "XSim" [current_project]<br/>
		/// launch_simulation<br/>
		/// The following commands run post-synthesis functional simulation of the design using the<br/>
		/// ModelSim Simulator:<br/>
		/// set_property target_simulator "ModelSim" [current_project]<br/>
		/// launch_simulation -mode "post-synthesis" -type "functional"<br/>
		/// The following commands run post-implementation functional simulation of the design using the<br/>
		/// Cadence IES Simulator:<br/>
		/// set_property target_simulator "IES" [current_project]<br/>
		/// launch_simulation -mode "post-implementation" -type "functional"<br/>
		/// The following commands run post-implementation timing simulation of the design using the<br/>
		/// Synopsys VCS Simulator:<br/>
		/// set_property target_simulator "VCS" [current_project]<br/>
		/// launch_simulation -mode "post-implementation" -type "timing"<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following command generates behavioral simulation scripts for the target simulator in the<br/>
		/// simulation run directory:<br/>
		/// launch_simulation -scripts_only<br/>
		/// The following commands run behavioral simulation flow of the design for the "my_simset"<br/>
		/// simulation fileset for the target simulator in the simulation run directory:<br/>
		/// launch_simulation -simset [get_filesets my_simset]<br/>
		/// The following command runs behavioral simulation flow for the char_fifo.xci IP for the<br/>
		/// target simulator in the simulation run directory, and does not clean up prior simulation files:<br/>
		/// launch_simulation -noclean_dir -of_objects [get_files char_fifo.xci]<br/>
		/// The following command generates absolute paths for the source files in the generated script files:<br/>
		/// launch_simulation -absolute_path<br/>
		/// The following command will pick the simulator tools from the specified installation path instead<br/>
		/// of from the PATH variable:<br/>
		/// launch_simulation -install_path /tools/ius/13.20.005/tools/bin<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1017<br/>
		/// </para>
		/// </summary>
		/// <param name="step">
		/// <para>
		/// (Optional)<br/>
		/// Launch a simulation step. Values: all, compile, elaborate,<br/>
		/// simulate. Default:all (launch all steps). Default: all<br/>
		/// </para>
		/// </param>
		/// <param name="simset">(Optional) Name of the simulation fileset</param>
		/// <param name="mode">
		/// <para>
		/// (Optional)<br/>
		/// Simulation mode. Values: behavioral, post-synthesis, post-implementation Default: behavioral<br/>
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// (Optional)<br/>
		/// Netlist type. Values: functional, timing. This is only<br/>
		/// applicable when mode is set to post-synthesis or post-implementation<br/>
		/// </para>
		/// </param>
		/// <param name="scripts_only">(Optional) Only generate scripts</param>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// Generate compile order file for this object (applicable with -<br/>
		/// scripts_only option only)<br/>
		/// </para>
		/// </param>
		/// <param name="absolute_path">(Optional) Make design source file paths in 'absolute' format</param>
		/// <param name="install_path">(Optional) Custom installation directory path</param>
		/// <param name="gcc_install_path">
		/// <para>
		/// (Optional)<br/>
		/// Specify GNU compiler installation directory path for the g+<br/>
		/// +/gcc executables<br/>
		/// </para>
		/// </param>
		/// <param name="noclean_dir">(Optional) Do not remove simulation run directory files</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL launch_simulation(launch_simulation_step? step = null, String simset = null, launch_simulation_mode? mode = null, launch_simulation_type? type = null, bool? scripts_only = null, TCLParameterList of_objects = null, bool? absolute_path = null, String install_path = null, String gcc_install_path = null, bool? noclean_dir = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: launch_simulation [-step <arg>] [-simset <arg>] [-mode <arg>] [-type <arg>] [-scripts_only] [-of_objects <args>] [-absolute_path] [-install_path <arg>] [-gcc_install_path <arg>] [-noclean_dir] [-quiet] [-verbose]
			this.Entry(_builder.launch_simulation(step, simset, mode, type, scripts_only, of_objects, absolute_path, install_path, gcc_install_path, noclean_dir, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Limit the maximum size of the VCD file on disk (equivalent of $dumplimit verilog task)<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: limit_vcd [-quiet] [-verbose] &lt;filesize&gt;
		/// <br/>
		/// <para>
		/// Specify the size limit, in bytes, of the Value Change Dump (VCD) file. This command operates like<br/>
		/// the Verilog $dumplimit simulator directive.<br/>
		/// When the specified file size limit has been reached, the dump process stops, and a comment is<br/>
		/// inserted into the VCD file to indicate that the file size limit has been reached.<br/>
		/// Note: You must run the open_vcd command before using the limit_vcd command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example limits the current VCD file:<br/>
		/// limit_vcd 1000<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1022<br/>
		/// </para>
		/// </summary>
		/// <param name="filesize">(Required) Specify the maximum size of the VCD file in bytes.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL limit_vcd(String filesize, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: limit_vcd [-quiet] [-verbose] <filesize>
			this.Entry(_builder.limit_vcd(filesize, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Open a netlist design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: link_design [-name &lt;arg&gt;] [-part &lt;arg&gt;] [-constrset &lt;arg&gt;] [-top &lt;arg&gt;] [-mode &lt;arg&gt;] [-pr_config &lt;arg&gt;] [-reconfig_partitions &lt;args&gt;] [-partitions &lt;args&gt;] [-ignore_timing] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Opens a new or existing netlist design, linking the netlist files and constraints with the target part<br/>
		/// to create the design. This command is intended for use with netlist source files, such as files<br/>
		/// generated by third party synthesis tools, or Vivado synthesis through the synth_design<br/>
		/// command.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The DESIGN_MODE property for the current source fileset must be defined as GateLvl in order<br/>
		/// to open a netlist design. If not, you will get the following error:<br/>
		/// ERROR: The design mode of 'sources_1' must be GateLvl.<br/>
		/// The -top switch is required for third-party synthesis designs. The netlist for the design must be<br/>
		/// rooted in a specific module. For project-based designs you can specify the TOP property on the<br/>
		/// project. However, in non-project mode, you must use the -top option for the link_design<br/>
		/// command.<br/>
		/// For project based designs with RTL source files, use launch_runs to launch synthesis or<br/>
		/// implementation, and then use the open_run command to open the design.<br/>
		/// For non-project based designs, use the open_checkpoint command to open a checkpoint into<br/>
		/// memory, opening the design in Non-Project Mode. Refer to the Vivado Design Suite User Guide:<br/>
		/// Design Flows Overview (UG892) for more information on Project Mode and Non-Project Mode.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following creates a new netlist design called Net1:<br/>
		/// link_design -name Net1<br/>
		/// Note: The default source set, constraint set, and part will be used in this example.<br/>
		/// The following example opens a netlist design called Net1, and specifies the constraint set to be<br/>
		/// used:<br/>
		/// link_design -name Net1 -constrset con1<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1024<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Optional) Design name</param>
		/// <param name="part">(Optional) Target part</param>
		/// <param name="constrset">(Optional) Constraint fileset to use</param>
		/// <param name="top">(Optional) Specify the top module name when the structural netlist is Verilog</param>
		/// <param name="mode">(Optional) The design mode. Values: default, out_of_context Default: default</param>
		/// <param name="pr_config">(Optional) PR Configuration to apply while opening the design</param>
		/// <param name="reconfig_partitions">(Optional) List of reconfigurable partitions to load while opening the design</param>
		/// <param name="partitions">(Optional) List of partitions to load while opening the design</param>
		/// <param name="ignore_timing">(Optional) open a netlist design without the timing constraints.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>design object</returns>
		public VivadoTCL link_design(String name = null, String part = null, String constrset = null, String top = null, link_design_mode? mode = null, String pr_config = null, TCLParameterList reconfig_partitions = null, TCLParameterList partitions = null, bool? ignore_timing = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: link_design [-name <arg>] [-part <arg>] [-constrset <arg>] [-top <arg>] [-mode <arg>] [-pr_config <arg>] [-reconfig_partitions <args>] [-partitions <args>] [-ignore_timing] [-quiet] [-verbose]
			this.Entry(_builder.link_design(name, part, constrset, top, mode, pr_config, reconfig_partitions, partitions, ignore_timing, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// List available features.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: list_features [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// In order to reduce the memory footprint of the Vivado Design Suite, there are groups of Tcl<br/>
		/// commands called "features" which are unavailable for use until you run a command from that<br/>
		/// feature set, or unless you explicitly load the feature using the load_features command.<br/>
		/// This command lists the available features sets of the Vivado Design Suite that can be loaded with<br/>
		/// the load_features command.<br/>
		/// Note: If a feature has been previously loaded, it will not be listed as a feature available to load.<br/>
		/// This command returns a list of features, or an error message.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the list of features available to load into the Vivado Design Suite:<br/>
		/// list_features<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1028<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL list_features(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: list_features [-quiet] [-verbose]
			this.Entry(_builder.list_features(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Return probe sample values<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: list_hw_samples [-quiet] [-verbose] [&lt;hw_probe&gt;]
		/// <br/>
		/// <para>
		/// Writes data samples from the specified hw_probe object on the current hw_ila.<br/>
		/// The number of captured samples returned from the specified probe is equal to the DATA_DEPTH<br/>
		/// property of the ILA core. The default data depth is 1024 samples. Data values are returned in the<br/>
		/// radix specified for the hw_probe, as determined by the DISPLAY_RADIX property.<br/>
		/// TIP: For any samples to be returned, data must have been captured by the specified port.<br/>
		/// The values are listed to the standard output, or can be captured to a Tcl variable for post-processing, or output to a file.<br/>
		/// The following is an example Tcl script that lists the data samples from hw_probes of interest:<br/>
		/// # Define a list of probes to get the data samples from<br/>
		/// set probeList [get_hw_probes *AR*]<br/>
		/// #Specify the radix for the return values<br/>
		/// set_property DISPLAY_RADIX BINARY [get_hw_probes *AR*]<br/>
		/// # Define a filename to write data to<br/>
		/// set fileName C:/Data/probeData1.txt<br/>
		/// # Open the specified file in write mode<br/>
		/// set FH [open $fileName w]<br/>
		/// # Write probe data for each probe<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// foreach x $probeList {<br/>
		/// puts $FH "$x:"<br/>
		/// puts $FH [list_hw_samples $x]<br/>
		/// }<br/>
		/// # Close the output file<br/>
		/// close $FH<br/>
		/// puts "Probe data written to $fileName\n"<br/>
		/// This command returns the requested output, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the data samples for the specified probe:<br/>
		/// list_hw_samples [get_hw_probes *probe18]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1030<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_probe">(Optional) hw_probe object</param>
		/// <returns>samples</returns>
		public VivadoTCL list_hw_samples(bool? quiet = null, bool? verbose = null, String hw_probe = null)
		{
			// TCL Syntax: list_hw_samples [-quiet] [-verbose] [<hw_probe>]
			this.Entry(_builder.list_hw_samples(quiet, verbose, hw_probe));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get all parameter names<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: list_param [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Gets a list of user-definable configuration parameters. These parameters configure a variety of<br/>
		/// settings and behaviors of the tool. For more information on a specific parameter use the<br/>
		/// report_param command, which returns a description of the parameter as well as its current<br/>
		/// value.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns a list of all user-definable parameters:<br/>
		/// list_param<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1032<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list</returns>
		public VivadoTCL list_param(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: list_param [-quiet] [-verbose]
			this.Entry(_builder.list_param(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// List properties of object<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: list_property [-class &lt;arg&gt;] [-regexp] [-quiet] [-verbose] [&lt;object&gt;] [&lt;pattern&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of all properties on a specified object or class.<br/>
		/// Note: report_property also returns a list of properties on an object or class of objects, but also reports<br/>
		/// the property type and property value.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns all properties of the specified CELL object:<br/>
		/// list_property [get_cells cpuEngine]<br/>
		/// The following example returns the properties matching the specified search pattern from the BEL<br/>
		/// class of objects:<br/>
		/// list_property -class bel *NUM*<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1034<br/>
		/// </para>
		/// </summary>
		/// <param name="class">(Optional) Object type to query for properties. Ignored if object is specified.</param>
		/// <param name="regexp">(Optional) Pattern is treated as a regular expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="object">(Optional) Object to query for properties</param>
		/// <param name="pattern">(Optional) Pattern to match properties against Default: *</param>
		/// <returns>list of property names</returns>
		public VivadoTCL list_property(String @class = null, bool? regexp = null, bool? quiet = null, bool? verbose = null, String @object = null, String pattern = null)
		{
			// TCL Syntax: list_property [-class <arg>] [-regexp] [-quiet] [-verbose] [<object>] [<pattern>]
			this.Entry(_builder.list_property(@class, regexp, quiet, verbose, @object, pattern));
			return this;
		}
		/// <summary>
		/// <para>
		/// List legal property values of object<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: list_property_value [-default] [-class &lt;arg&gt;] [-quiet] [-verbose] &lt;name&gt; [&lt;object&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of valid values for an enumerated type property of either a class of objects or a<br/>
		/// specific object.<br/>
		/// Note: The command cannot be used to return valid values for properties other than Enum properties. The<br/>
		/// report_property command will return the type of property to help you identify Enum properties.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the list of valid values for the KEEP_HIERARCHY property from<br/>
		/// cell objects:<br/>
		/// list_property_value KEEP_HIERARCHY -class cell<br/>
		/// The following example returns the same result, but uses an actual cell object in place of the<br/>
		/// general cell class:<br/>
		/// list_property_value KEEP_HIERARCHY [get_cells cpuEngine]<br/>
		/// The following example returns the default value for the specified property by using the current<br/>
		/// design as a representative of the design class:<br/>
		/// list_property_value -default BITSTREAM.GENERAL.COMPRESS [current_design]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1036<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name of property whose legal values is to be retrieved</param>
		/// <param name="default">(Optional) Show only the default value.</param>
		/// <param name="class">
		/// <para>
		/// (Optional)<br/>
		/// Object type to query for legal property values. Ignored if<br/>
		/// object is specified.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="object">(Optional) Object to query for legal properties values</param>
		/// <returns>list of property values</returns>
		public VivadoTCL list_property_value(String name, bool? @default = null, String @class = null, bool? quiet = null, bool? verbose = null, String @object = null)
		{
			// TCL Syntax: list_property_value [-default] [-class <arg>] [-quiet] [-verbose] <name> [<object>]
			this.Entry(_builder.list_property_value(name, @default, @class, quiet, verbose, @object));
			return this;
		}
		/// <summary>
		/// <para>
		/// List applicable targets for the specified source<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: list_targets [-quiet] [-verbose] &lt;files&gt;
		/// <br/>
		/// <para>
		/// List the targets that are available for a specified IP core, DSP module, or IP Subsystem. The<br/>
		/// following file types are accepted: .xci, .xco, .mdl, .bd, .bxml.<br/>
		/// Use the generate_targets command to generate the listed targets.<br/>
		/// The command returns the list of available targets. If no targets are available for the specified file<br/>
		/// objects, nothing is returned.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example lists the available targets for any DSP modules in the design:<br/>
		/// list_targets [get_files *.mdl]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1038<br/>
		/// </para>
		/// </summary>
		/// <param name="files">(Required) Source file for which the targets needs to be listed</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of targets</returns>
		public VivadoTCL list_targets(String files, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: list_targets [-quiet] [-verbose] <files>
			this.Entry(_builder.list_targets(files, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Load Tcl commands for a specified feature.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: load_features [-quiet] [-verbose] [&lt;features&gt;...]
		/// <br/>
		/// <para>
		/// Load the specified features of the Vivado Design Suite into memory.<br/>
		/// In order to reduce the memory footprint of the Vivado Design Suite, there are groups of Tcl<br/>
		/// commands called "features" which are unavailable for use until you run a command from that<br/>
		/// feature set, or unless you explicitly load the feature using the load_features command.<br/>
		/// For example, the load_features simulator command loads the commands for the Vivado<br/>
		/// simulator, as does directly launching the Vivado simulator using the launch_xsim command.<br/>
		/// To access the complete list of Tcl commands associated with a feature of the Vivado Design<br/>
		/// Suite, and the help text for these commands, you can load the feature into the application<br/>
		/// memory using the load_features command without actually running the feature of the tool.<br/>
		/// You can list the features that are available to be loaded using the list_features command.<br/>
		/// The list of features is dynamic, and changes from release to release.<br/>
		/// The command returns nothing if successful, or an error message if failed.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example loads the Vivado simulator feature:<br/>
		/// load_features simulator<br/>
		/// The following example loads all of the loadable feature sets of the Vivado Design Suite:<br/>
		/// load_features [list_features]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1040<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="features">
		/// <para>
		/// (Optional)<br/>
		/// Feature(s) to load, use list_features for a list of available<br/>
		/// features.<br/>
		/// </para>
		/// </param>
		public VivadoTCL load_features(bool? quiet = null, bool? verbose = null, TCLParameterList features = null)
		{
			// TCL Syntax: load_features [-quiet] [-verbose] [<features>...]
			this.Entry(_builder.load_features(quiet, verbose, features));
			return this;
		}
		/// <summary>
		/// <para>
		/// Locks or unlocks netlist, placement or routing of a design. The 'lock/unlock' will only applied on<br/>
		/// physically placed cells and routed nets<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: lock_design [-level &lt;arg&gt;] [-unlock] [-export] [-quiet] [-verbose] [&lt;cell&gt;]
		/// <br/>
		/// <para>
		/// This command is used in the Hierarchical Design Flows for Design Preservation and Partial<br/>
		/// Reconfiguration. Refer to the Vivado Design Suite User Guide: Hierarchical Design (UG905) for more<br/>
		/// information on these design flows, and the use of this command.<br/>
		/// The lock_design command is used to lock down the placement and/or routing of a design, or<br/>
		/// of the specified cell of a design. After reading in an Out-of-Context (OOC) design checkpoint<br/>
		/// using the read_checkpoint command, the preservation level for the module must be defined.<br/>
		/// This command sets the IS_LOC_FIXED, IS_BEL_FIXED, and IS_ROUTE_FIXED properties of the<br/>
		/// specified logic.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example locks the netlist, placement, and routing data for the specified cells of the<br/>
		/// current design:<br/>
		/// lock_design -level routing [get_cells usbEngine*]<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This example unlocks the routing data for the specified cells of the current design, while leaving<br/>
		/// the netlist and placement data locked from the prior example:<br/>
		/// lock_design -unlock -level routing [get_cells usbEngine*]<br/>
		/// The following example unlocks the routing, placement, and netlist data for the specified cells of<br/>
		/// the current design:<br/>
		/// lock_design -unlock -level logical [get_cells usbEngine*]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1042<br/>
		/// </para>
		/// </summary>
		/// <param name="level">
		/// <para>
		/// (Optional)<br/>
		/// specify the locking and unlocking level; Valid values are<br/>
		/// logical, placement, and routing. Default: placement<br/>
		/// </para>
		/// </param>
		/// <param name="unlock">
		/// <para>
		/// (Optional)<br/>
		/// Unlock cells, if cells are not specified, whole design is<br/>
		/// unlocked; '-level' parameter must be specified for<br/>
		/// unlocking.<br/>
		/// </para>
		/// </param>
		/// <param name="export">(Optional) mark that the constraints can be exported.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="cell">
		/// <para>
		/// (Optional)<br/>
		/// Lock cells, if cells are not specified, whole design is locked.<br/>
		/// Notice only placed cells and routed nets will be locked.<br/>
		/// Default: *<br/>
		/// </para>
		/// </param>
		public VivadoTCL lock_design(String level = null, bool? unlock = null, bool? export = null, bool? quiet = null, bool? verbose = null, String cell = null)
		{
			// TCL Syntax: lock_design [-level <arg>] [-unlock] [-export] [-quiet] [-verbose] [<cell>]
			this.Entry(_builder.lock_design(level, unlock, export, quiet, verbose, cell));
			return this;
		}
		/// <summary>
		/// <para>
		/// Log Switching Activity Interchange Format (SAIF) toggle for specified wire, signal, or reg<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: log_saif [-quiet] [-verbose] &lt;hdl_objects&gt;...
		/// <br/>
		/// <para>
		/// Writes the switching activity rates for the specified HDL signals during the current simulation.<br/>
		/// The Switching Activity Interchange format (SAIF) file is an ASCII file containing header<br/>
		/// information, and toggle counts for the specified signals of the design. It also contains the timing<br/>
		/// attributes which specify time durations for signals at level 0, 1, X, or Z.<br/>
		/// The log_saif command can only be used after the open_saif command has opened an SAIF<br/>
		/// file in the current simulation to capture switching activity rates.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example logs switching activity for all signals in the current_scope:<br/>
		/// log_saif [ get_objects ]<br/>
		/// Log SAIF for only the internal signals starting with name c of the scope /tb/UUT:<br/>
		/// log_saif [get_objects -filter { type == internal_signal }/tb/UUT/c*]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1045<br/>
		/// </para>
		/// </summary>
		/// <param name="hdl_objects">(Required) The hdl_objects to log</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Does not return any object</returns>
		public VivadoTCL log_saif(TCLParameterList hdl_objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: log_saif [-quiet] [-verbose] <hdl_objects>...
			this.Entry(_builder.log_saif(hdl_objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Log Value Change Dump (VCD) simulation output for specified wire, signal, or reg<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: log_vcd [-level &lt;arg&gt;] [-quiet] [-verbose] [&lt;hdl_objects&gt;...]
		/// <br/>
		/// <para>
		/// Indicates which HDL objects to write into the Value Change Dump (VCD) file. In some designs<br/>
		/// the simulation results can become quite large; the log_vcd command lets you define the<br/>
		/// specific content of interest. This command models the behavior of the Verilog $dumpvars<br/>
		/// system task.<br/>
		/// HDL objects include HDL signals, variables, or constants as defined in the Verilog or VHDL test<br/>
		/// bench and source files. An HDL signal includes Verilog wire or reg entities, and VHDL signals.<br/>
		/// Examples of HDL variables include Verilog real, realtime, time, and event.<br/>
		/// This command specifies which HDL objects and how many levels of design hierarchy to write<br/>
		/// into the VCD file. The actual values of the objects are written to the VCD file when you run the<br/>
		/// checkpoint_vcd or flush_vcd commands at a specific time during simulation.<br/>
		/// IMPORTANT! You must use the open_vcd command before using any other *_vcd commands.<br/>
		/// Nothing is returned by this command.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// This command specifies which HDL objects and how many levels of design hierarchy to write<br/>
		/// into the VCD file. The actual values of the objects are written to the VCD file when you run the<br/>
		/// checkpoint_vcd or flush_vcd commands at a specific time during simulation.<br/>
		/// IMPORTANT! You must use the open_vcd command before using any other *_vcd commands.<br/>
		/// Nothing is returned by this command.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Arguments<br/>
		/// -level &lt;arg&gt; - (Optional) Specifies the number of levels of design hierarchy to traverse when<br/>
		/// locating HDL objects to write to the VCD file. The default value of 0 causes the tool to dump all<br/>
		/// values for the specified HDL objects at the level of hierarchy defined by &lt;hdl_objects&gt;, and all<br/>
		/// levels below that. A value of 1 indicates that only the level of hierarchy specified by<br/>
		/// &lt;hdl_objects&gt; should be written to the VCD file.<br/>
		/// -quiet - (Optional) Execute the command quietly, returning no messages from the command.<br/>
		/// The command also returns TCL_OK regardless of any errors encountered during execution.<br/>
		/// Note: Any errors encountered on the command-line, while launching the command, will be returned. Only<br/>
		/// errors occurring inside the command will be trapped.<br/>
		/// -verbose - (Optional) Temporarily override any message limits and return all messages from this<br/>
		/// command.<br/>
		/// Note: Message limits can be defined with the set_msg_config command.<br/>
		/// &lt;hdl_objects&gt; - (Optional) Specifies the HDL objects to identify and write changing values into<br/>
		/// the VCD file. The level of hierarchy is also represented in the hdl_objects pattern. For<br/>
		/// instance /tb/UUT/* indicates all HDL objects within the /tb/UUT level of the design.<br/>
		/// Examples<br/>
		/// Log value changes for all the ports from the scope /tb/UUT:<br/>
		/// log_vcd [get_objects -filter { type == port } /tb/UUT/* ]<br/>
		/// Note: Since -levels is not specified, all levels below the specified scope will be searched for ports<br/>
		/// matching the specified pattern as well.<br/>
		/// Log VCD for all the objects in the current_scope:<br/>
		/// log_vcd *<br/>
		/// log_vcd [ get_objects *]<br/>
		/// Log value changes for only internal signals with names starting with C, of the root scope /tb/<br/>
		/// UUT:<br/>
		/// log_vcd [get_objects -filter { type == internal_signal }./C*]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1047<br/>
		/// </para>
		/// </summary>
		/// <param name="level">(Optional) Number of levels to log (for HDL scopes) Default: 0</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hdl_objects">(Optional) Which HDL objects to log</param>
		/// <returns>Does not return any object</returns>
		public VivadoTCL log_vcd(Int32? level = null, bool? quiet = null, bool? verbose = null, TCLParameterList hdl_objects = null)
		{
			// TCL Syntax: log_vcd [-level <arg>] [-quiet] [-verbose] [<hdl_objects>...]
			this.Entry(_builder.log_vcd(level, quiet, verbose, hdl_objects));
			return this;
		}
		/// <summary>
		/// <para>
		/// Log simulation output for specified wire, signal, or reg for viewing using Vivado Simulators<br/>
		/// waveform viewer. Unlike add_wave, this command does not add the waveform object to<br/>
		/// waveform viewer (i.e. Waveform Configuration). It simply enables logging of output to the Vivado<br/>
		/// Simulators Waveform Database (WDB).<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: log_wave [-recursive] [-r] [-verbose] [-v] [-quiet] &lt;hdl_objects&gt;...
		/// <br/>
		/// <para>
		/// Log simulation activity for the specified HDL objects into the waveform database file (.wdb) for<br/>
		/// viewing using Vivado simulator waveform viewer.<br/>
		/// In the Vivado simulator, an HDL object is an entity that can hold a value, such as a wire, signal, or<br/>
		/// register.<br/>
		/// Unlike add_wave, this command does not add the waveform object to waveform configuration.<br/>
		/// It simply enables logging of waveform activity to the Vivado simulator waveform database<br/>
		/// (WDB). See the Vivado Design Suite User Guide: Logic Simulation (UG900) for more information.<br/>
		/// This command returns nothing.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example logs the waveform activities for the specified HDL objects.<br/>
		/// log_wave -r [get_objects /testbench/dut/*]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1049<br/>
		/// </para>
		/// </summary>
		/// <param name="hdl_objects">(Required) Which hdl_objects to trace</param>
		/// <param name="recursive">(Optional) Searches recursively for objects</param>
		/// <param name="r">(Optional) Searches recursively for objects</param>
		/// <param name="verbose">(Optional) Displays all warnings</param>
		/// <param name="v">(Optional) Displays all warnings</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		public VivadoTCL log_wave(TCLParameterList hdl_objects, bool? recursive = null, bool? r = null, bool? verbose = null, bool? v = null, bool? quiet = null)
		{
			// TCL Syntax: log_wave [-recursive] [-r] [-verbose] [-v] [-quiet] <hdl_objects>...
			this.Entry(_builder.log_wave(hdl_objects, recursive, r, verbose, v, quiet));
			return this;
		}
		/// <summary>
		/// <para>
		/// Turns on or off printing of file name and line number of the hdl statement being simulated<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: ltrace [-quiet] [-verbose] &lt;value&gt;
		/// <br/>
		/// <para>
		/// Enables line-level tracing for simulation debugging purposes.<br/>
		/// During simulation the simulation source file and line number being evaluated is returned to the<br/>
		/// Tcl console.<br/>
		/// TIP: Process tracing with the ptrace command provides more detailed information than is available with<br/>
		/// line tracing.<br/>
		/// This feature can also be enabled using the LINE_TRACING property on the current simulation<br/>
		/// object:<br/>
		/// set_property LINE_TRACING on [current_sim]<br/>
		/// The command returns the state of line tracing, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1051<br/>
		/// </para>
		/// </summary>
		/// <param name="value">(Required) value: on, true, yes. Otherwise set to off, false, no</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL ltrace(String value, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: ltrace [-quiet] [-verbose] <value>
			this.Entry(_builder.ltrace(value, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create external port for the corresponding interface pins. If a cell is specified, create external<br/>
		/// interface ports for all unconnected interface pins.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: make_bd_intf_pins_external [-quiet] [-verbose] &lt;objects&gt;...
		/// <br/>
		/// <para>
		/// Create an external interface port in the current block design and connect that to the selected<br/>
		/// block interface pin. If a bd_cell is specified as the argument, all unconnected block interface pins<br/>
		/// of that cell will be made external. The created external interface port will have the same<br/>
		/// properties as the selected block interface pin.<br/>
		/// IMPORTANT! For a group of block interface pins, one external port will be created per block interface pin.<br/>
		/// The selected block interface pin, if unconnected, will be connected to a new interface port at the<br/>
		/// top-most level of the block design.<br/>
		/// This command returns TCL_OK if it is successful, or TCL_ERROR if it fails, unless -quiet is<br/>
		/// specified.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example will select the specified block interface pin on the bd_cell axi_gpio_0,<br/>
		/// and connect it to an external interface port:<br/>
		/// make_bd_intf_pins_external [get_bd_intf_pins axi_gpio_0/S_AXI]<br/>
		/// The following example will look at all unconnected block interface pins of the bd_cell<br/>
		/// axi_gpio_0 and individually connect them to external interface ports:<br/>
		/// make_bd_intf_pins_external [get_bd_cells axi_gpio_0]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1053<br/>
		/// </para>
		/// </summary>
		/// <param name="objects">(Required) The interface pins/cells to be made external</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Pass if successful in creating at least one interface port</returns>
		public VivadoTCL make_bd_intf_pins_external(TCLParameterList objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: make_bd_intf_pins_external [-quiet] [-verbose] <objects>...
			this.Entry(_builder.make_bd_intf_pins_external(objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create external port for the corresponding pin. If a cell is specified, create external ports for all<br/>
		/// unconnected pins.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: make_bd_pins_external [-quiet] [-verbose] &lt;objects&gt;...
		/// <br/>
		/// <para>
		/// Create an external port in the current block design and connect that to the selected block pin. If<br/>
		/// a bd_cell is specified as the argument, all unconnected block pins of that cell will be made<br/>
		/// external. The created external port will have the same properties as the selected block pin.<br/>
		/// IMPORTANT! For a group of block pins, one external port will be created per block pin.<br/>
		/// The selected block pin, if unconnected, will be connected to a new port at the topmost level of<br/>
		/// the block design.<br/>
		/// This command returns TCL_OK if it is successful, or TCL_ERROR if it fails, unless -quiet is<br/>
		/// specified.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example will select a block pin on the bd_cell axi_gpio_0 and connect it to an<br/>
		/// external port:<br/>
		/// make_bd_pins_external [get_bd_pins axi_gpio_0/s_axi_aclk]<br/>
		/// The following example will look at all unconnected block pins of the bd_cell axi_gpio_0 and<br/>
		/// individually connect them to external ports:<br/>
		/// make_bd_pins_external [get_bd_cells axi_gpio_0]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1055<br/>
		/// </para>
		/// </summary>
		/// <param name="objects">(Required) The pins/cells to be made external</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Pass if successful in creating at least one port</returns>
		public VivadoTCL make_bd_pins_external(TCLParameterList objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: make_bd_pins_external [-quiet] [-verbose] <objects>...
			this.Entry(_builder.make_bd_pins_external(objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Make differential pair for 2 ports<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: make_diff_pair_ports [-quiet] [-verbose] &lt;ports&gt;...
		/// <br/>
		/// <para>
		/// Joins two existing ports to create a differential pair. The port directions, interfaces, and other<br/>
		/// properties must match in order for the specified ports to be joined as a differential pair.<br/>
		/// Otherwise an error will be returned.<br/>
		/// IMPORTANT! The two ports must first be created, either by using the create_port command or by<br/>
		/// reading in an XDC file, prior to making them into a differential pair.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example joins the two specified ports to create a differential pair:<br/>
		/// make_diff_pair_ports port_Pos1 port_Neg1<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1057<br/>
		/// </para>
		/// </summary>
		/// <param name="ports">(Required) Ports to join</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL make_diff_pair_ports(TCLParameterList ports, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: make_diff_pair_ports [-quiet] [-verbose] <ports>...
			this.Entry(_builder.make_diff_pair_ports(ports, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Generate HDL wrapper for the specified source<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: make_wrapper [-top] [-testbench] [-inst_template] [-fileset &lt;arg&gt;] [-import] [-force] [-quiet] [-verbose] &lt;files&gt;
		/// <br/>
		/// <para>
		/// Create a Verilog or VHDL wrapper for instantiating a sub-design into the project.<br/>
		/// The make_wrapper command will create a wrapper for Embedded Processor Designs from the<br/>
		/// IP integrator of the Vivado Design Suite, or any IP integrator block design, as well as DSP<br/>
		/// modules created in System Generator or MathWorks MatLab.<br/>
		/// You can generate a wrapper to make the sub-design the top-level of a stand-alone design, or for<br/>
		/// instantiating a sub-design into an existing design. You can also generate a wrapper for a<br/>
		/// simulation test bench of System Generator sub-designs.<br/>
		/// Note: The wrapper is generated in Verilog or VHDL according to the TARGET_LANGUAGE property on the<br/>
		/// project.<br/>
		/// The command returns information related to the creation of the wrappers, or returns an error if it<br/>
		/// fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates the instantiation template to integrate the specified IP integrator<br/>
		/// block design into the design hierarchy of the current project:<br/>
		/// make_wrapper -inst_template -fileset [get_filesets sources_1] \<br/>
		/// -files [get_files C:/Data/design_1/design_1.bd]<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1059<br/>
		/// </para>
		/// </summary>
		/// <param name="files">(Required) Source file for which the wrapper needs to be generated</param>
		/// <param name="top">(Optional) Create a top-level wrapper for the specified source</param>
		/// <param name="testbench">(Optional) Create a testbench for the specified source</param>
		/// <param name="inst_template">
		/// <para>
		/// (Optional)<br/>
		/// Create an instantiation template for the specified source.<br/>
		/// The template will not be added to the project and will be<br/>
		/// generated for reference purposes only.<br/>
		/// </para>
		/// </param>
		/// <param name="fileset">(Optional) Fileset name</param>
		/// <param name="import">(Optional) Import generated wrapper to the project</param>
		/// <param name="force">(Optional) Overwrite existing source(s)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL make_wrapper(String files, bool? top = null, bool? testbench = null, bool? inst_template = null, String fileset = null, bool? import = null, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: make_wrapper [-top] [-testbench] [-inst_template] [-fileset <arg>] [-import] [-force] [-quiet] [-verbose] <files>
			this.Entry(_builder.make_wrapper(files, top, testbench, inst_template, fileset, import, force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Mark objects in GUI<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: mark_objects [-rgb &lt;args&gt;] [-color &lt;arg&gt;] [-quiet] [-verbose] &lt;objects&gt;
		/// <br/>
		/// <para>
		/// Marks specified objects in GUI mode. This command places an iconic mark to aid in the location<br/>
		/// of the specified object or objects. The mark is displayed in a color as determined by one of the<br/>
		/// color options.<br/>
		/// Objects can be unmarked with the unmark_objects command.<br/>
		/// Note: Use only one color option. If both color options are specified, -rgb takes precedence over -color.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example adds a red icon to mark the currently selected objects:<br/>
		/// mark_objects -color red [get_selected_objects]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1062<br/>
		/// </para>
		/// </summary>
		/// <param name="objects">(Required) Objects to mark</param>
		/// <param name="rgb">(Optional) RGB color index list</param>
		/// <param name="color">(Optional) Valid values are red green blue magenta yellow cyan and orange</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL mark_objects(String objects, TCLParameterList rgb = null, String color = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: mark_objects [-rgb <args>] [-color <arg>] [-quiet] [-verbose] <objects>
			this.Entry(_builder.mark_objects(objects, rgb, color, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Modify routed probe connections to debug cores.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: modify_debug_ports [-probes &lt;args&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Modifies a routed design to connect nets to specified ports of debug cores. This command takes<br/>
		/// a list of connections to be made to specified debug probes. Each connection is defined as a Tcl<br/>
		/// list, enclosed in braces {}, specifying the following three elements separated by spaces:<br/>
		/// 1. The logical pin of the debug core to be connected.<br/>
		/// 2. The channel index of the specified probe.<br/>
		/// 3. The logical net of the signal to be probed.<br/>
		/// Multiple probe connections are specified as a list of lists, with each connection itself being a Tcl<br/>
		/// list as shown in the example.<br/>
		/// The command performs all of the netlist modifications to disconnect existing net connections to<br/>
		/// the specified probe ports as needed, connecting each net to be probed to the specified probe<br/>
		/// port, and automatically routing the modified connections. Nets that become disconnected during<br/>
		/// the process are left unconnected.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example modifies 3 probe connections:<br/>
		/// modify_debug_ports -probes [list {top/x_ila/probe0 0 top/inst_A/net_0} \<br/>
		/// {top/x_ila/probe1 1 top/inst_A/net_a} {top/x_ila/probe1 2 top/inst_A/<br/>
		/// net_b}]<br/>
		/// TIP: The modify_debug_ports command moves a port probe from one signal to another.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1064<br/>
		/// </para>
		/// </summary>
		/// <param name="probes">
		/// <para>
		/// (Required)<br/>
		/// List of probes to be connected: debug core pin, channel<br/>
		/// index, and logical net for each probe connection.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL modify_debug_ports(TCLParameterList probes, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: modify_debug_ports [-probes <args>] [-quiet] [-verbose]
			this.Entry(_builder.modify_debug_ports(probes, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Move cells into a hierarchy cell. The connections between these cells are maintained; the<br/>
		/// connections between these cells and other cells are maintained through crossing hierarchy cell.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: move_bd_cells [-prefix &lt;arg&gt;] [-quiet] [-verbose] [&lt;parent_cell&gt;] [&lt;cells&gt;...]
		/// <br/>
		/// <para>
		/// Move IP integrator cells into the specified hierarchical module within the current subsystem<br/>
		/// design. The connections between the cells being moved are maintained; connections between<br/>
		/// these cells and other cells that are not being moved are maintained automatically by IP integrator<br/>
		/// adding pins and ports to cross the hierarchical boundary.<br/>
		/// Cells in the IP subsystem design can also be copied into a hierarchical module using<br/>
		/// copy_bd_objs, and can be grouped and added to a hierarchical module using<br/>
		/// group_bd_cells.<br/>
		/// This command returns the name of the &lt;parent_cell&gt; module when successful, or returns an<br/>
		/// error message if it failed.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1066<br/>
		/// </para>
		/// </summary>
		/// <param name="prefix">(Optional) Prefix name to add to cells</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="parent_cell">(Optional) Parent cell</param>
		/// <param name="cells">(Optional) Match engine names against cell names Default: *</param>
		/// <returns>0 if success.</returns>
		public VivadoTCL move_bd_cells(String prefix = null, bool? quiet = null, bool? verbose = null, String parent_cell = null, TCLParameterList cells = null)
		{
			// TCL Syntax: move_bd_cells [-prefix <arg>] [-quiet] [-verbose] [<parent_cell>] [<cells>...]
			this.Entry(_builder.move_bd_cells(prefix, quiet, verbose, parent_cell, cells));
			return this;
		}
		/// <summary>
		/// <para>
		/// Reposition the Gadget for Project summary dashboard<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: move_dashboard_gadget -name &lt;arg&gt; -row &lt;arg&gt; -col &lt;arg&gt; [-dashboard &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Specify the placement of a dashboard gadget into the dashboard.<br/>
		/// TIP: Currently the Project Summary is the only dashboard, so the gadget is placed into that dashboard.<br/>
		/// The arrangement of gadgets in a dashboard is by row and column. The Project Summary<br/>
		/// dashboard has two columns, 0 and 1, and has as many rows as needed to display all the gadgets.<br/>
		/// If you specify a column other than 0 or 1, or specify a row in excess of the current defined rows +<br/>
		/// 1, an error will be returned.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1068<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name of the gadget</param>
		/// <param name="row">(Required) Target row number to which the gadget has to be moved</param>
		/// <param name="col">(Required) Target column number to which the gadget has to be moved</param>
		/// <param name="dashboard">(Optional) Name of the dashboard to which the gadget is associated</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL move_dashboard_gadget(String name, String row, String col, String dashboard = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: move_dashboard_gadget -name <arg> -row <arg> -col <arg> [-dashboard <arg>] [-quiet] [-verbose]
			this.Entry(_builder.move_dashboard_gadget(name, row, col, dashboard, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Moves the files from one fileset to another while maintaining all of their original properties.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: move_files [-fileset &lt;arg&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose] [&lt;files&gt;...]
		/// <br/>
		/// <para>
		/// Moves files returned by the get_files command from one fileset to another while maintaining<br/>
		/// the properties on the files.<br/>
		/// This command returns the list of files that were moved, or an error if the command fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example moves the file, top_full.xdc, to the constrs_2 fileset.<br/>
		/// move_files -fileset constrs_2 [get_files top_full.xdc]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1070<br/>
		/// </para>
		/// </summary>
		/// <param name="fileset">(Optional) Destination fileset name</param>
		/// <param name="of_objects">(Optional) Reconfig Modules to move the files to</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="files">(Optional) Name of the files to be moved</param>
		/// <returns>list of files that were moved</returns>
		public VivadoTCL move_files(String fileset = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null, TCLParameterList files = null)
		{
			// TCL Syntax: move_files [-fileset <arg>] [-of_objects <args>] [-quiet] [-verbose] [<files>...]
			this.Entry(_builder.move_files(fileset, of_objects, quiet, verbose, files));
			return this;
		}
		/// <summary>
		/// <para>
		/// Moves wave objects from their current position to the specified position in the wave<br/>
		/// configuration<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: move_wave [-into &lt;args&gt;] [-at_wave &lt;args&gt;] [-after_wave &lt;args&gt;] [-before_wave &lt;args&gt;] [-quiet] [-verbose] &lt;items&gt;...
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1072<br/>
		/// </para>
		/// </summary>
		/// <param name="items">(Required) wave objects to move</param>
		/// <param name="into">
		/// <para>
		/// (Optional)<br/>
		/// the wave configuration, group, or virtual bus into which the<br/>
		/// wave object(s) will be moved.<br/>
		/// </para>
		/// </param>
		/// <param name="at_wave">
		/// <para>
		/// (Optional)<br/>
		/// inserts the new wave object(s) into the specified wave<br/>
		/// object, or after the specified wave object if not a group or<br/>
		/// virtual bus<br/>
		/// </para>
		/// </param>
		/// <param name="after_wave">(Optional) inserts the new wave objects(s) after the specified wave object</param>
		/// <param name="before_wave">(Optional) inserts the new wave objects(s) before the specified wave object</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL move_wave(TCLParameterList items, TCLParameterList into = null, TCLParameterList at_wave = null, TCLParameterList after_wave = null, TCLParameterList before_wave = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: move_wave [-into <args>] [-at_wave <args>] [-after_wave <args>] [-before_wave <args>] [-quiet] [-verbose] <items>...
			this.Entry(_builder.move_wave(items, into, at_wave, after_wave, before_wave, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Open an existing IP subsystem design from disk file.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: open_bd_design [-quiet] [-verbose] &lt;name&gt;
		/// <br/>
		/// <para>
		/// Open an IP subsystem design in the IP integrator of the Vivado IDE. The IP subsystem must<br/>
		/// previously have been created using the create_bd_design command.<br/>
		/// This command returns a message with the name of the opened IP subsystem design, or returns<br/>
		/// an error if the command fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following opens the specified IP subsystem design in the current project:<br/>
		/// open_bd_design C:/Data/project1/project1.src/sources_1/bd/design_1/<br/>
		/// design_1.bd<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1073<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name of IP subsystem design to open</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The design object. Returns nothing if the command fails.</returns>
		public VivadoTCL open_bd_design(String name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: open_bd_design [-quiet] [-verbose] <name>
			this.Entry(_builder.open_bd_design(name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Open a design checkpoint in a new project<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: open_checkpoint [-part &lt;arg&gt;] [-ignore_timing] [-quiet] [-verbose] &lt;file&gt;
		/// <br/>
		/// <para>
		/// Open a design checkpoint file (DCP), create a new in-memory project and initialize a design<br/>
		/// immediately in the new project with the contents of the checkpoint. This command can be used<br/>
		/// to open a top-level design checkpoint, or the checkpoint created for an out-of-context module.<br/>
		/// When opening a checkpoint, there is no need to create a project first. The open_checkpoint<br/>
		/// command reads the design data into memory, opening the design in Non-Project Mode. Refer to<br/>
		/// the Vivado Design Suite User Guide: Design Flows Overview (UG892) for more information on<br/>
		/// Project Mode and Non-Project Mode.<br/>
		/// Note: When multiple design checkpoints are open in the Vivado tool, you must use the<br/>
		/// current_project command to switch between the open designs. You can use current_design to<br/>
		/// check which checkpoint is the active design.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example opens the specified checkpoint file, and specifies the target part for the<br/>
		/// design:<br/>
		/// open_checkpoint C:/Data/state1/checkpoint.dcp -part xc7k325tffg900-2<br/>
		/// Note: If the specified part is not compatible with the device and package used by the specified checkpoint,<br/>
		/// the command will return an error.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1075<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) Design checkpoint file</param>
		/// <param name="part">
		/// <para>
		/// (Optional)<br/>
		/// Override the checkpoint part. Note that this may cause<br/>
		/// errors if the checkpoint contains xdef.<br/>
		/// </para>
		/// </param>
		/// <param name="ignore_timing">
		/// <para>
		/// (Optional)<br/>
		/// reload a checkpoint without the timing constraints. Will not<br/>
		/// work if '-time' option given.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL open_checkpoint(String file, String part = null, bool? ignore_timing = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: open_checkpoint [-part <arg>] [-ignore_timing] [-quiet] [-verbose] <file>
			this.Entry(_builder.open_checkpoint(file, part, ignore_timing, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Open the example project for the indicated IP<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: open_example_project [-dir &lt;arg&gt;] [-force] [-in_process] [-quiet] [-verbose] &lt;objects&gt;...
		/// <br/>
		/// <para>
		/// Open an example project for the specified IP cores. The example project can be used to explore<br/>
		/// the features of the IP core in a stand-alone project, instead of integrated into the current project.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following copies the IP customization and opens the example project for the specified IP<br/>
		/// core in a new location:<br/>
		/// open_example_project -dir C:/Data/examples -force [get_ips blk_mem*]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1077<br/>
		/// </para>
		/// </summary>
		/// <param name="objects">(Required) The objects whose example projects will be opened</param>
		/// <param name="dir">(Optional) Path to directory where example project will be created</param>
		/// <param name="force">(Optional) Overwrite an example project if it exists</param>
		/// <param name="in_process">(Optional) Open the example project in the same process</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The Project that was opened</returns>
		public VivadoTCL open_example_project(TCLParameterList objects, String dir = null, bool? force = null, bool? in_process = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: open_example_project [-dir <arg>] [-force] [-in_process] [-quiet] [-verbose] <objects>...
			this.Entry(_builder.open_example_project(objects, dir, force, in_process, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Open the hardware tool<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: open_hw_manager [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Open the Hardware Manager in the Vivado Design Suite in either the Vivado IDE or in Tcl or<br/>
		/// batch mode. Opening the Hardware Manager is the first step in programming and/or debugging<br/>
		/// your design in Xilinx FPGA hardware. For more information refer to the Vivado Design Suite User<br/>
		/// Guide: Programming and Debugging (UG908).<br/>
		/// Hardware Manager is a feature of the Vivado Design Suite which lets you interact with FPGA<br/>
		/// devices on a board. The features of the Hardware Manager include:<br/>
		/// • Logic Debug or Logic Analyzer- Debugging FPGA programmable logic designs.<br/>
		/// • Programming/Configuration - Program FPGA devices using JTAG and configuring flash<br/>
		/// memory devices connected to FPGAs.<br/>
		/// • In-system Serial I/O debug - Adjust SERDES receive/transmit settings and measure<br/>
		/// transmission bit error rates.<br/>
		/// • System Monitor - Control on chip system monitor and read system monitor temperature and<br/>
		/// voltage values.<br/>
		/// The Hardware Manager uses a number of first class objects, like hw_server, hw_target,<br/>
		/// hw_device, and hw_ila. Each of these objects is related to other objects, and has properties that<br/>
		/// can be set or read by the set_property and get_property commands to configure or<br/>
		/// control its function in the Hardware Manager. Refer to the Vivado Design Suite Properties<br/>
		/// Reference Guide (UG912) for more information on these objects.<br/>
		/// The steps to connect to hardware and program the target FPGA are:<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// 1. Open the hardware manager in the IDE (open_hw_manager).<br/>
		/// TIP: This step can be skipped if you are running in batch or Tcl mode.<br/>
		/// 2. Connect to a hardware server running either on the local machine, or on a remote network<br/>
		/// accessible host (connect_hw_server).<br/>
		/// 3. Open a hardware target on the connected hardware server (open_hw_target).<br/>
		/// 4. Identify the Xilinx FPGA on the open hardware target (current_hw_device,<br/>
		/// get_hw_devices).<br/>
		/// 5. Associate the bitstream data programming file (.bit), and probes file (.ltx) if one exists,<br/>
		/// with the appropriate FPGA (set_property).<br/>
		/// 6. Program or download the programming file into the hardware device<br/>
		/// (program_hw_device, refresh_hw_device).<br/>
		/// Note that you can run the Hardware Manager from within the Vivado tool without having a<br/>
		/// project or design open. You can open the Hardware Manager, connect to the hardware server,<br/>
		/// and program the device on the target by providing a bitstream file, and probes file for debugging.<br/>
		/// You can close the Hardware Manager using the close_hw_manager command.<br/>
		/// This command returns nothing if successful, and returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1079<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL open_hw_manager(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: open_hw_manager [-quiet] [-verbose]
			this.Entry(_builder.open_hw_manager(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Open the Xilinx Shell Archive<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: open_hw_platform [-no_auto_upgrade] [-quiet] [-verbose] [&lt;file&gt;]
		/// <br/>
		/// <para>
		/// Open a Xilinx support archive (XSA) file and extract the Vivado project, block design, and IP from<br/>
		/// the archive. This will create a project directory and project file (.xpr) from the XSA.<br/>
		/// Note: The project will be created in the current working directory, or the directory from which the Vivado<br/>
		/// tool was launched.<br/>
		/// This command returns a transcript of its actions, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example opens the specified XSA, automatically upgrading the IP as needed:<br/>
		/// open_hw_platform C:/Data/zc706.xsa<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1082<br/>
		/// </para>
		/// </summary>
		/// <param name="file">
		/// <para>
		/// (Required)<br/>
		/// Xilinx Shell Archive file Values: A filename with alphanumeric<br/>
		/// characters and .dsa/.xsa extension.<br/>
		/// </para>
		/// </param>
		/// <param name="no_auto_upgrade">(Optional) Disable BD auto upgrade</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The name of the shell file</returns>
		public VivadoTCL open_hw_platform(String file, bool? no_auto_upgrade = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: open_hw_platform [-no_auto_upgrade] [-quiet] [-verbose] [<file>]
			this.Entry(_builder.open_hw_platform(file, no_auto_upgrade, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Open a connection to a hardware target on the hardware server<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: open_hw_target [-jtag_mode &lt;arg&gt;] [-xvc_url &lt;arg&gt;] [-auto_calibrate] [-quiet] [-verbose] [&lt;hw_target&gt;]
		/// <br/>
		/// <para>
		/// Opens a connection to the specified hardware target of the connected hardware servers, or<br/>
		/// opens the current hardware target.<br/>
		/// The hardware target is a system board containing a JTAG chain of one or more Xilinx devices that<br/>
		/// you can program with a bitstream file, or use to debug your design. Connections between<br/>
		/// hardware targets on the system board and the Vivado Design Suite are managed by the Xilinx<br/>
		/// hardware server application, and the connect_hw_server command. Refer to Vivado Design<br/>
		/// Suite User Guide: Programming and Debugging (UG908) for a list of supported JTAG download<br/>
		/// cables and devices.<br/>
		/// Each hardware target can have one or more Xilinx devices to program, or to use for debugging<br/>
		/// purposes. The current device is specified or returned by the current_hw_device command.<br/>
		/// Use the open_hw_target command to open a connection to one of the available hardware<br/>
		/// targets. The open target is automatically defined as the current hardware target. Alternatively,<br/>
		/// you can define the current target with the current_hw_target command, and then open the<br/>
		/// current target. The Vivado Design Suite directs programming and debug commands to the open<br/>
		/// target through the hardware server connection.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// An open connection to the hardware target can be closed using the close_hw_target<br/>
		/// command.<br/>
		/// The open_hw_target command returns connection messages from the hardware server, or<br/>
		/// returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1084<br/>
		/// </para>
		/// </summary>
		/// <param name="jtag_mode">(Optional) Open target in JTAG mode</param>
		/// <param name="xvc_url">(Optional) Open target connection to XVC server</param>
		/// <param name="auto_calibrate">(Optional) Auto-calibrate target for optimal frequency (SmartLynq cable only)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_target">(Optional) hardware target Default: current hardware target</param>
		public VivadoTCL open_hw_target(String jtag_mode = null, String xvc_url = null, bool? auto_calibrate = null, bool? quiet = null, bool? verbose = null, String hw_target = null)
		{
			// TCL Syntax: open_hw_target [-jtag_mode <arg>] [-xvc_url <arg>] [-auto_calibrate] [-quiet] [-verbose] [<hw_target>]
			this.Entry(_builder.open_hw_target(jtag_mode, xvc_url, auto_calibrate, quiet, verbose, hw_target));
			return this;
		}
		/// <summary>
		/// <para>
		/// Open an IO design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: open_io_design [-name &lt;arg&gt;] [-part &lt;arg&gt;] [-constrset &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Opens a new or existing I/O Pin Planning design.<br/>
		/// Note: The design_mode property for the current source fileset must be defined as PinPlanning in order to<br/>
		/// open an I/O design. If not, you will get the following error:<br/>
		/// ERROR: The design mode of 'sources_1' must be PinPlanning<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following creates a new I/O design called myIO:<br/>
		/// open_io_design -name myIO<br/>
		/// Note: The default source set, constraint set, and part will be used in this case.<br/>
		/// The following example opens an existing I/O design called myIO, and specifies the constraint set<br/>
		/// to be used:<br/>
		/// open_io_design -name myIO -constrset topCon<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1087<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Optional) Design name</param>
		/// <param name="part">(Optional) Target part</param>
		/// <param name="constrset">(Optional) Constraint fileset to use</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>design object</returns>
		public VivadoTCL open_io_design(String name = null, String part = null, String constrset = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: open_io_design [-name <arg>] [-part <arg>] [-constrset <arg>] [-quiet] [-verbose]
			this.Entry(_builder.open_io_design(name, part, constrset, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Open a Vivado project file (.xpr)<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: open_project [-part &lt;arg&gt;] [-read_only] [-quiet] [-verbose] &lt;file&gt;
		/// <br/>
		/// <para>
		/// Opens the specified Vivado Design Suite project file (.xpr), or the project file for the Vivado Lab<br/>
		/// Edition (.lpr).<br/>
		/// IMPORTANT! The open_project command has a different command syntax in the Vivado Lab<br/>
		/// Edition. The -part option is not supported because the Vivado Lab Edition project (.lpr ) does not<br/>
		/// specify a target part. The current_hw_target and current_hw_device commands determine<br/>
		/// the target part.<br/>
		/// This command returns a transcript of its process and the name of the created project, or returns<br/>
		/// an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example opens the project named my_project1 located in the Designs directory.<br/>
		/// open_project C:/Designs/project1.xpr<br/>
		/// Note: The project must be specified with the .xpr extension for the tool to recognize it as a project file.<br/>
		/// The path to the file must be specified along with the project file name or the tool will return an error that it<br/>
		/// cannot find the specified file.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1089<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) Project file to be read</param>
		/// <param name="part">(Optional) Open the project using this part (overrides project's part)</param>
		/// <param name="read_only">(Optional) Open the project in read-only mode</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>opened project object</returns>
		public VivadoTCL open_project(String file, String part = null, bool? read_only = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: open_project [-part <arg>] [-read_only] [-quiet] [-verbose] <file>
			this.Entry(_builder.open_project(file, part, read_only, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Open report from .rpx file<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: open_report [-file &lt;arg&gt;] [-append] [-console] [-name &lt;arg&gt;] [-return_string] [-quiet] [-verbose] &lt;rpx&gt;
		/// <br/>
		/// <para>
		/// Read an RPX (protobuf) file into memory to reload report results into the Vivado Design Suite.<br/>
		/// This command requires an open implemented or synthesized design.<br/>
		/// The RPX file is written by report commands such as report_timing_summary, and<br/>
		/// report_pulse_width, that support the -rpx option, and is an interactive report file that can<br/>
		/// be reloaded into memory. Reloading the report into memory, reconnects the objects in the report<br/>
		/// to design objects so that cross-selection between the report in the Vivado IDE and the design is<br/>
		/// enabled.<br/>
		/// This command returns the report results to the Tcl console by default, or when -console is<br/>
		/// specified, or opens a report window in the Vivado IDE when -name is specified. This command<br/>
		/// returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reads the specified RPX file an opens a named report in the Vivado IDE:<br/>
		/// open_report -name RPX1 design1_summary.rpx<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1091<br/>
		/// </para>
		/// </summary>
		/// <param name="rpx">(Required) Report data file to be read</param>
		/// <param name="file">(Optional) Filename to output results to</param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="console">(Optional) Send output to console</param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="return_string">(Optional) Return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL open_report(String rpx, String file = null, bool? append = null, bool? console = null, String name = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: open_report [-file <arg>] [-append] [-console] [-name <arg>] [-return_string] [-quiet] [-verbose] <rpx>
			this.Entry(_builder.open_report(rpx, file, append, console, name, return_string, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Open a run into a netlist or implementation design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: open_run [-name &lt;arg&gt;] [-pr_config &lt;arg&gt;] [-quiet] [-verbose] &lt;run&gt;
		/// <br/>
		/// <para>
		/// Opens the specified synthesis run into a Netlist Design or implementation run into an<br/>
		/// Implemented Design. The run properties defining the target part and constraint set are combined<br/>
		/// with the synthesis or implementation results to create the design view in the tool.<br/>
		/// This command is intended to open a synthesized or implemented design that was created from<br/>
		/// design runs in Project Mode in the Vivado Design Suite.<br/>
		/// Use the open_checkpoint command to open a Non-Project based checkpoint into memory,<br/>
		/// opening the design in Non-Project Mode. Refer to the Vivado Design Suite User Guide: Design<br/>
		/// Flows Overview (UG892) for more information on Project Mode and Non-Project Mode.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following command opens the specified synthesis run into a Netlist Design named<br/>
		/// synthPass1:<br/>
		/// open_run -name synthPass1 synth_1<br/>
		/// The following opens an Implemented Design for impl_1:<br/>
		/// open_run impl_1<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1094<br/>
		/// </para>
		/// </summary>
		/// <param name="run">(Required) Run to open into the design</param>
		/// <param name="name">(Optional) Design name</param>
		/// <param name="pr_config">
		/// <para>
		/// (Optional)<br/>
		/// PR Configuration to apply while opening the design (only<br/>
		/// valid when opening a synthesis run)<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>design object</returns>
		public VivadoTCL open_run(String run, String name = null, String pr_config = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: open_run [-name <arg>] [-pr_config <arg>] [-quiet] [-verbose] <run>
			this.Entry(_builder.open_run(run, name, pr_config, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Open file for storing signal switching rate for power estimation. The switching rate is written out<br/>
		/// in Switching Activity Interchange Format (SAIF) Only one SAIF is allowed to be open per<br/>
		/// simulation run.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: open_saif [-quiet] [-verbose] &lt;file_name&gt;
		/// <br/>
		/// <para>
		/// Create or open a Switching Activity Interchange Format (SAIF) file for storing signal switching<br/>
		/// rates in the current simulation for later use by the report_power command.<br/>
		/// The Switching Activity Interchange format (SAIF) file is an ASCII file containing header<br/>
		/// information, and toggle counts for the specified signals of the design. It also contains the timing<br/>
		/// attributes which specify time durations for signals at level 0, 1, X, or Z.<br/>
		/// The SAIF file is recommended for power analysis since it is smaller than the VCD file.<br/>
		/// When an SAIF file has been opened, you can write the switching activity from the simulation into<br/>
		/// the SAIF file using log_saif.<br/>
		/// Only one SAIF can be open at one time during simulation. To close the SAIF file, use the<br/>
		/// close_saif command.<br/>
		/// This command returns the object ID of the opened SAIF file, or returns an error if the command<br/>
		/// failed.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example opens the specified simulation:<br/>
		/// open_saif myData.saif<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1096<br/>
		/// </para>
		/// </summary>
		/// <param name="file_name">(Required) The SAIF filename to store information</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The SAIF object that was opened</returns>
		public VivadoTCL open_saif(String file_name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: open_saif [-quiet] [-verbose] <file_name>
			this.Entry(_builder.open_saif(file_name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Open a Value Change Dump (VCD) file for capturing simulation output. This Tcl command models<br/>
		/// behavior of $dumpfile Verilog system task<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: open_vcd [-quiet] [-verbose] [&lt;file_name&gt;]
		/// <br/>
		/// <para>
		/// Create or open a Value Change Dump (VCD) file to capture simulation output. This command<br/>
		/// operates like the Verilog $dumpfile simulator directive.<br/>
		/// VCD is an ASCII file containing header information, variable definitions, and value change details<br/>
		/// of a set of HDL signals. The VCD file can be used to view simulation result in a VCD viewer or to<br/>
		/// estimate the power consumption of the design.<br/>
		/// When a VCD file has been opened, you can write the value changes from the simulation into the<br/>
		/// VCD file using checkpoint_vcd, flush_vcd, or log_vcd. In addition, you can pause and<br/>
		/// resume the collection of value change data with the stop_vcd and start_vcd commands.<br/>
		/// You can limit the size of the VCD file by using the limit_vcd command.<br/>
		/// To close the VCD file, use the close_vcd command.<br/>
		/// Note: You must use the open_vcd command before using any other *_vcd commands. Only one VCD file<br/>
		/// can be open at any time.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example opens the specified VCD file (design1.vcd) so that value changes can<br/>
		/// be written to it. The log_vcd command identifies all ports in the /tb/UUT scope, and only that<br/>
		/// level of the design hierarchy, to be written to the VCD file. The simulation is run for a specified<br/>
		/// period of time, and flush_vcd writes the current values of the HDL objects to the VCD file.<br/>
		/// Then close_vcd closes the open file.<br/>
		/// open_vcd design1.vcd<br/>
		/// log_vcd -level 1 [get_objects filter { type == port } /tb/UUT/* ]<br/>
		/// run 1000<br/>
		/// flush_vcd<br/>
		/// close_vcd<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1098<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="file_name">
		/// <para>
		/// (Optional)<br/>
		/// file name. Defaults to dump.vcd (This is LRM standard)<br/>
		/// Default: dump.vcd<br/>
		/// </para>
		/// </param>
		/// <returns>
		/// </returns>
		public VivadoTCL open_vcd(bool? quiet = null, bool? verbose = null, String file_name = null)
		{
			// TCL Syntax: open_vcd [-quiet] [-verbose] [<file_name>]
			this.Entry(_builder.open_vcd(quiet, verbose, file_name));
			return this;
		}
		/// <summary>
		/// <para>
		/// Open a wave config<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: open_wave_config [-quiet] [-verbose] [&lt;filename&gt;]
		/// <br/>
		/// <para>
		/// Open the specified Wave Config file (.wcfg) in the current simulation.<br/>
		/// Vivado simulator uses a simulation debug data model to allow users to debug HDL source files<br/>
		/// using source code stepping, breakpoints, conditions, and waveform viewing tools. The debug<br/>
		/// data model contains HDL object and scope names, and maps them to memory addresses to let<br/>
		/// you examine the changing values of signals, variables and constants during the simulation.<br/>
		/// The waveform database is separate from the Wave Config file that stores the waveform activity<br/>
		/// for the simulation. The Wave Config file contains just the list of wave objects (signals, dividers,<br/>
		/// groups, virtual buses) to display, and their display properties, plus markers. The waveform<br/>
		/// database (WDB) contains the event data, values changing over time, for all traced signals,<br/>
		/// whether displayed or not.<br/>
		/// A wave configuration object is created in the current simulation with the<br/>
		/// create_wave_config command. A Wave Config file is written to disk by the use of the<br/>
		/// save_wave_config command, and can be opened with the open_wave_config command.<br/>
		/// The open_wave_config command opens a Wave Config file and maps it to the data source in<br/>
		/// the current simulation.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// IMPORTANT! Any HDL objects that are specified in the Wave Config file that are not found in the current<br/>
		/// simulation will be ignored.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example opens the specified Wave Config file:<br/>
		/// open_wave_config testbench.wcfg<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1100<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="filename">
		/// <para>
		/// (Optional)<br/>
		/// the name of a WCFG file from which to create a new wave<br/>
		/// configuration and corresponding wave window<br/>
		/// </para>
		/// </param>
		/// <returns>The wave config opened</returns>
		public VivadoTCL open_wave_config(bool? quiet = null, bool? verbose = null, String filename = null)
		{
			// TCL Syntax: open_wave_config [-quiet] [-verbose] [<filename>]
			this.Entry(_builder.open_wave_config(quiet, verbose, filename));
			return this;
		}
		/// <summary>
		/// <para>
		/// Open Waveform Database (WDB) file produced by a prior simulation run and return a simulation<br/>
		/// object<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: open_wave_database [-noautoloadwcfg] [-protoinst &lt;args&gt;] [-quiet] [-verbose] &lt;wdb&gt;
		/// <br/>
		/// <para>
		/// The open_wave_database command opens an existing static simulator database file (WDB)<br/>
		/// and associated wave config file (WCFG). This simulation is a static simulation, not live, and can<br/>
		/// only be used to review prior results.<br/>
		/// Note: Many of the commands for running and resetting the simulation are not available in a static<br/>
		/// simulation.<br/>
		/// Vivado simulator uses a simulation debug data model to allow users to debug HDL source files<br/>
		/// using source code stepping, breakpoints, conditions, and waveform viewing tools. The debug<br/>
		/// data model contains HDL object and scope names, and maps them to memory addresses to let<br/>
		/// you examine the changing values of signals, variables and constants during the simulation. When<br/>
		/// the simulation completes, the simulation is written to a static simulator database file (WDB).<br/>
		/// HDL objects can be added to the simulation waveform database using the log_wave command<br/>
		/// which enables logging of waveform activity for the specified objects to the Vivado simulator<br/>
		/// waveform database.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The waveform database is associated with a Wave Config file that stores the waveform activity<br/>
		/// for the simulation. The Wave Config file contains just the list of wave objects (signals, dividers,<br/>
		/// groups, virtual buses) to display, and their display properties, plus markers. The waveform<br/>
		/// database (WDB) contains the event data, values changing over time, for all traced signals,<br/>
		/// whether displayed or not.<br/>
		/// A Wave Config file is written to disk by the use of the save_wave_config command, and can<br/>
		/// be opened with the open_wave_config command.<br/>
		/// Use the open_wave_database command with the open_wave_config command to open a<br/>
		/// previously completed simulation for review in the Vivado IDE.<br/>
		/// TIP: Objects that were logged in the simulation waveform database, with the log_wave command, can<br/>
		/// be added posthumously to the wave configuration in a static simulation using the add_wave command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example opens a WDB file with the specified name, then opens an associated<br/>
		/// Wave Config file, and finally uses the current_fileset command to open the simulation<br/>
		/// database in the Vivado IDE:<br/>
		/// open_wave_database {C:/Data/project_xsim/testbench_behav.wdb}<br/>
		/// open_wave_config {C:/Data/project_xsim/testbench_behav.wcfg}<br/>
		/// current_fileset<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1102<br/>
		/// </para>
		/// </summary>
		/// <param name="wdb">(Required) file name</param>
		/// <param name="noautoloadwcfg">(Optional) Do not automatically open associated WCFG files</param>
		/// <param name="protoinst">(Optional) Specify a .protoinst file for protocol analysis</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL open_wave_database(String wdb, bool? noautoloadwcfg = null, TCLParameterList protoinst = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: open_wave_database [-noautoloadwcfg] [-protoinst <args>] [-quiet] [-verbose] <wdb>
			this.Entry(_builder.open_wave_database(wdb, noautoloadwcfg, protoinst, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Optimize the current netlist. This will perform the retarget, propconst, sweep and<br/>
		/// bram_power_opt optimizations by default.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: opt_design [-retarget] [-propconst] [-sweep] [-bram_power_opt] [-remap] [-aggressive_remap] [-resynth_area] [-resynth_seq_area] [-directive &lt;arg&gt;] [-muxf_remap] [-hier_fanout_limit &lt;arg&gt;] [-bufg_opt] [-shift_register_opt] [-dsp_register_opt] [-srl_remap_modes &lt;arg&gt;] [-control_set_merge] [-merge_equivalent_drivers] [-carry_remap] [-debug_log] [-property_opt_only] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Optimizes a design netlist for the target part. Optimization can provide improvements to<br/>
		/// synthesized netlists from third-party tools, or for netlists that may not have been optimized<br/>
		/// during synthesis.<br/>
		/// Run this command after synthesis but prior to implementation to optimize the design and<br/>
		/// simplify the netlist before placing and routing the design. Assign the DONT_TOUCH property to<br/>
		/// prevent the optimization of individual cells.<br/>
		/// TIP: To see what actions opt_design is taking in optimizing your design, you can use the -verbose<br/>
		/// option to get a more detailed transcript of the process. This can help you in understanding and debugging<br/>
		/// some of the changes made to your design.<br/>
		/// The opt_design command performs the following optimizations by default:<br/>
		/// • Retarget<br/>
		/// • Constant Propagation<br/>
		/// • Sweep<br/>
		/// • Global Buffer (BUFG) optimizations<br/>
		/// • DSP Register optimizations<br/>
		/// • Shift-Register Logic optimizations<br/>
		/// • Block RAM Power optimizations<br/>
		/// • Implement MIG cores<br/>
		/// • Implement Debug cores<br/>
		/// IMPORTANT! Using command-line options for specific optimizations results in opt_design performing<br/>
		/// only the specified optimizations and disabling all others, even the ones that are usually performed by<br/>
		/// default.<br/>
		/// To perform LUT Remapping, you must specify -remap.<br/>
		/// To perform area-based re-synthesis, you must specify -resynth_area, or -directive<br/>
		/// ExploreArea.<br/>
		/// To perform sequential area-based re-synthesis, you must specify -resynth_seq_area, or -<br/>
		/// directive ExploreSequentialArea.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example performs all four default optimizations: retarget, constant propagation,<br/>
		/// sweep, and BRAM power optimization. The command returns detailed results with the -<br/>
		/// verbose switch:<br/>
		/// opt_design -verbose<br/>
		/// This example excludes specific BRAM cells from power optimization using the set_power_opt<br/>
		/// command, and then runs opt_design with the four default optimizations:<br/>
		/// set_power_opt -exclude_cells [get_cells \<br/>
		/// -filter {PRIMITIVE_TYPE =~ BMEM.*.*} \<br/>
		/// -of_objects [get_pins -leaf -filter {DIRECTION == IN} \<br/>
		/// -of_objects [get_nets -of_objects [get_pins clock/bufgctrl_clk_mld/<br/>
		/// O]]]]<br/>
		/// opt_design<br/>
		/// The following example performs the sweep and retarget optimizations:<br/>
		/// opt_design -sweep -retarget<br/>
		/// Note: Because -sweep and -retarget are expressly enabled in the prior example, -propconst<br/>
		/// optimization and -bram_power_opt are implicitly disabled.<br/>
		/// The following example directs the opt_design command to use various algorithms to achieve<br/>
		/// potentially better results:<br/>
		/// opt_design -directive Explore<br/>
		/// The following example directs the opt_design command to use various algorithms to achieve<br/>
		/// potentially better results, while focusing on area reduction:<br/>
		/// opt_design -directive ExploreArea<br/>
		/// This example uses the -srl_remap_modes argument with the automatic option to convert FF<br/>
		/// chains into SRLs when FF utilization is greater than 20%, or SRLs into FF chains when SRL<br/>
		/// utilization is over 50%:<br/>
		/// -srl_remap_modes {{target_ff_util 20 target_lutram_util 50}}<br/>
		/// TIP: In this case, the srl_remap is only performed if either specified utilization rate is exceeded, but NOT if<br/>
		/// both are exceeded.<br/>
		/// The following example uses the -srl_remap_modes argument with the manual option to<br/>
		/// convert FF chains with length greater than 5 to SRLs, and SRLs with depth less than or equal to 8<br/>
		/// to FF chains:<br/>
		/// -srl_remap_modes {{min_depth_ffs_to_srl 5}{max_depth_srl_to_ffs 8}}<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1105<br/>
		/// </para>
		/// </summary>
		/// <param name="retarget">(Optional) Retarget</param>
		/// <param name="propconst">(Optional) Propagate constants across leaf-level instances</param>
		/// <param name="sweep">(Optional) Remove unconnected leaf-level instances</param>
		/// <param name="bram_power_opt">(Optional) Perform Block RAM power optimizations</param>
		/// <param name="remap">(Optional) Remap logic optimally in LUTs</param>
		/// <param name="aggressive_remap">(Optional) High effort remap optimization</param>
		/// <param name="resynth_area">(Optional) Resynthesis</param>
		/// <param name="resynth_seq_area">(Optional) Resynthesis (with Sequential optimizations)</param>
		/// <param name="directive">
		/// <para>
		/// (Optional)<br/>
		/// Mode of behavior (directive) for this command. Please refer<br/>
		/// to Arguments section of this help for values for this option<br/>
		/// Default: Default<br/>
		/// </para>
		/// </param>
		/// <param name="muxf_remap">(Optional) Optimize all MuxFx cells to LUT3</param>
		/// <param name="hier_fanout_limit">(Optional) Replicate by module with threshold N</param>
		/// <param name="bufg_opt">(Optional) Insert, Merge and Split BUFGs</param>
		/// <param name="shift_register_opt">(Optional) Pull register stage from shift register</param>
		/// <param name="dsp_register_opt">(Optional) Push/Pull Registers out of a DSP</param>
		/// <param name="srl_remap_modes">(Optional) remap shift registers to flops or flops to shift registers</param>
		/// <param name="control_set_merge">(Optional) Merge all equivalent control set drivers to a single driver</param>
		/// <param name="merge_equivalent_drivers">(Optional) Merge all LUT,Flop equivalent driver replications</param>
		/// <param name="carry_remap">(Optional) reamp carries into luts</param>
		/// <param name="debug_log">(Optional) show debug message</param>
		/// <param name="property_opt_only">(Optional) Do targeted optimizations on tagged cells</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">
		/// <para>
		/// (Optional)<br/>
		/// Suspend message limits during command execution<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// </param>
		public VivadoTCL opt_design(bool? retarget = null, bool? propconst = null, bool? sweep = null, bool? bram_power_opt = null, bool? remap = null, bool? aggressive_remap = null, bool? resynth_area = null, bool? resynth_seq_area = null, String directive = null, bool? muxf_remap = null, String hier_fanout_limit = null, bool? bufg_opt = null, bool? shift_register_opt = null, bool? dsp_register_opt = null, String srl_remap_modes = null, bool? control_set_merge = null, bool? merge_equivalent_drivers = null, bool? carry_remap = null, bool? debug_log = null, bool? property_opt_only = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: opt_design [-retarget] [-propconst] [-sweep] [-bram_power_opt] [-remap] [-aggressive_remap] [-resynth_area] [-resynth_seq_area] [-directive <arg>] [-muxf_remap] [-hier_fanout_limit <arg>] [-bufg_opt] [-shift_register_opt] [-dsp_register_opt] [-srl_remap_modes <arg>] [-control_set_merge] [-merge_equivalent_drivers] [-carry_remap] [-debug_log] [-property_opt_only] [-quiet] [-verbose]
			this.Entry(_builder.opt_design(retarget, propconst, sweep, bram_power_opt, remap, aggressive_remap, resynth_area, resynth_seq_area, directive, muxf_remap, hier_fanout_limit, bufg_opt, shift_register_opt, dsp_register_opt, srl_remap_modes, control_set_merge, merge_equivalent_drivers, carry_remap, debug_log, property_opt_only, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Pause Activity Monitor runs for the specified hardware HBM(s)<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: pause_hw_hbm_amon [-quiet] [-verbose] &lt;hw_objects&gt;
		/// <br/>
		/// <para>
		/// The pause_hw_hbm_amon command pauses a running HBM activity monitor in the Vivado<br/>
		/// hardware manager that has been previously started using the run_hw_hbm_amon command.<br/>
		/// This command returns nothing when successful, or returns an error when it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example pauses the HBM activity monitor for the associated HBM core:<br/>
		/// pause_hw_hbm_amon [get_hw_hbms *HBM_2]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1112<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_objects">(Required) hardware objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL pause_hw_hbm_amon(String hw_objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: pause_hw_hbm_amon [-quiet] [-verbose] <hw_objects>
			this.Entry(_builder.pause_hw_hbm_amon(hw_objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Optimize the current placed netlist.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: phys_opt_design [-fanout_opt] [-placement_opt] [-routing_opt] [-slr_crossing_opt] [-rewire] [-insert_negative_edge_ffs] [-critical_cell_opt] [-dsp_register_opt] [-bram_register_opt] [-uram_register_opt] [-bram_enable_opt] [-shift_register_opt] [-hold_fix] [-aggressive_hold_fix] [-retime] [-force_replication_on_nets &lt;args&gt;] [-directive &lt;arg&gt;] [-critical_pin_opt] [-clock_opt] [-path_groups &lt;args&gt;] [-tns_cleanup] [-sll_reg_hold_fix] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Performs timing-driven optimization on the negative-slack paths of a design. A path should have<br/>
		/// negative slack near the worst negative slack (WNS) to be considered for optimization.<br/>
		/// Optimization will not be performed on designs without negative slack.<br/>
		/// This optional command can be run for post-place or post-route optimizations.<br/>
		/// RECOMMENDED: Because physical optimization requires timing data that is only available after<br/>
		/// placement, the command cannot be run prior to placement. However, the write_iphys_opt_tcl and<br/>
		/// read_iphys_opt_tcl commands let you write out the physical optimizations performed on the post-placed design, and then apply those optimizations to the design netlist prior to placement. Refer to the<br/>
		/// Vivado Design Suite User Guide: Implementation (UG904) for more information on interactive physical<br/>
		/// optimization.<br/>
		/// Post-place phys_opt_design performs the following optimizations by default:<br/>
		/// • high-fanout optimization<br/>
		/// • placement-based optimization of critical paths<br/>
		/// • rewire<br/>
		/// • critical-cell optimization<br/>
		/// • DSP register optimization<br/>
		/// • BRAM register optimization<br/>
		/// • URAM register optimization<br/>
		/// • a final fanout optimization<br/>
		/// TIP: Using command-line options for specific optimizations results in phys_opt_design performing<br/>
		/// only the specified optimizations and disabling all others, even the ones that are usually performed by<br/>
		/// default.<br/>
		/// Post-route phys_opt_design performs the following optimizations by default:<br/>
		/// • placement-based optimization of critical paths<br/>
		/// • routing optimization<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// • rewire<br/>
		/// • critical-cell optimization<br/>
		/// Physical optimizations involve replication, re-timing, hold fixing, and placement improvement.<br/>
		/// The phys_opt_design command automatically performs all necessary netlist and placement<br/>
		/// changes.<br/>
		/// To perform re-timing you must specify the -retime option, or the -directive AddRetime<br/>
		/// option.<br/>
		/// To perform hold fixing you must specify the -hold_fix option, or the -directive<br/>
		/// ExploreWithHoldFix option.<br/>
		/// If the phys_opt_design command is used iteratively, the subsequent run optimizes the results<br/>
		/// of the prior run.<br/>
		/// TIP: The phys_opt_design can be multi-threaded to speed the process. Refer to the set_param<br/>
		/// command for more information on setting the general.maxThreads parameter.<br/>
		/// The command reports each net processed, a summary of any optimizations performed, and the<br/>
		/// WNS before and after optimization. Replicated objects are named by appending _replica to<br/>
		/// the original object name, followed by the replicated object count.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example performs a physical optimization of the current post-placement design,<br/>
		/// and then writes the iphys_opt Tcl script for use before placement:<br/>
		/// phys_opt_design<br/>
		/// write_iphys_opt_tcl C:/Data/my_iphys_opt.tcl<br/>
		/// This example sets the LOCK_PINS property on the specified cell, then performs physical<br/>
		/// optimizations including register re-timing, optimization of registers across DSP blocks and block<br/>
		/// RAMs, and pin swapping (excluding the locked pins) to improve timing:<br/>
		/// set_property LOCK_PINS {I3:A1 I2:A4} [get_cell cpuEngine/<br/>
		/// qmem_dack_reg_i_1]<br/>
		/// phys_opt_design -retime -dsp_register_opt -bram_register_opt \<br/>
		/// -critical_pin_opt<br/>
		/// This example directs phys_opt_design to run more iterations, with hold violation fixing, to<br/>
		/// achieve potentially better results:<br/>
		/// phys_opt_design -directive ExploreWithHoldFix<br/>
		/// This example directs phys_opt_design to consider more nets for replication:<br/>
		/// phys_opt_design -directive AggressiveFanoutOpt<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1114<br/>
		/// </para>
		/// </summary>
		/// <param name="fanout_opt">
		/// <para>
		/// (Optional)<br/>
		/// Do cell-duplication based optimization on high-fanout<br/>
		/// timing critical nets<br/>
		/// </para>
		/// </param>
		/// <param name="placement_opt">(Optional) Do placement based optimization on timing critical nets</param>
		/// <param name="routing_opt">(Optional) Do routing based optimization on timing critical nets</param>
		/// <param name="slr_crossing_opt">(Optional) Do placement optimization of SLR-crossing timing critical nets</param>
		/// <param name="rewire">(Optional) Do rewiring optimization</param>
		/// <param name="insert_negative_edge_ffs">(Optional) Insert negative edge triggered FFs for hold optimization</param>
		/// <param name="critical_cell_opt">(Optional) Do cell-duplication based optimization on timing critical nets</param>
		/// <param name="dsp_register_opt">(Optional) Do DSP register optimization</param>
		/// <param name="bram_register_opt">(Optional) Do BRAM register optimization</param>
		/// <param name="uram_register_opt">(Optional) Do UltraRAM register optimization</param>
		/// <param name="bram_enable_opt">(Optional) Do BRAM enable optimization</param>
		/// <param name="shift_register_opt">(Optional) Do Shift register optimization</param>
		/// <param name="hold_fix">(Optional) Attempt to improve slack of high hold violators</param>
		/// <param name="aggressive_hold_fix">(Optional) Attempt to aggressively improve slack of high hold violators</param>
		/// <param name="retime">(Optional) Do retiming optimization</param>
		/// <param name="force_replication_on_nets">(Optional) Force replication optimization on nets</param>
		/// <param name="directive">
		/// <para>
		/// (Optional)<br/>
		/// Mode of behavior (directive) for this command. Please refer<br/>
		/// to Arguments section of this help for values for this option<br/>
		/// Default: Default<br/>
		/// </para>
		/// </param>
		/// <param name="critical_pin_opt">(Optional) Do pin-swapping based optimization on timing critical nets</param>
		/// <param name="clock_opt">(Optional) Do clock skew optimization in post-route optimization</param>
		/// <param name="path_groups">(Optional) Work only on specified path groups</param>
		/// <param name="tns_cleanup">
		/// <para>
		/// (Optional)<br/>
		/// Work on all nets in the design that meet criteria for the<br/>
		/// specified optimizations to improve design tns<br/>
		/// </para>
		/// </param>
		/// <param name="sll_reg_hold_fix">
		/// <para>
		/// (Optional)<br/>
		/// Do hold fixing on SLL Tx-Rx paths<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Name Description<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL phys_opt_design(bool? fanout_opt = null, bool? placement_opt = null, bool? routing_opt = null, bool? slr_crossing_opt = null, bool? rewire = null, bool? insert_negative_edge_ffs = null, bool? critical_cell_opt = null, bool? dsp_register_opt = null, bool? bram_register_opt = null, bool? uram_register_opt = null, bool? bram_enable_opt = null, bool? shift_register_opt = null, bool? hold_fix = null, bool? aggressive_hold_fix = null, bool? retime = null, TCLParameterList force_replication_on_nets = null, String directive = null, bool? critical_pin_opt = null, bool? clock_opt = null, TCLParameterList path_groups = null, bool? tns_cleanup = null, bool? sll_reg_hold_fix = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: phys_opt_design [-fanout_opt] [-placement_opt] [-routing_opt] [-slr_crossing_opt] [-rewire] [-insert_negative_edge_ffs] [-critical_cell_opt] [-dsp_register_opt] [-bram_register_opt] [-uram_register_opt] [-bram_enable_opt] [-shift_register_opt] [-hold_fix] [-aggressive_hold_fix] [-retime] [-force_replication_on_nets <args>] [-directive <arg>] [-critical_pin_opt] [-clock_opt] [-path_groups <args>] [-tns_cleanup] [-sll_reg_hold_fix] [-quiet] [-verbose]
			this.Entry(_builder.phys_opt_design(fanout_opt, placement_opt, routing_opt, slr_crossing_opt, rewire, insert_negative_edge_ffs, critical_cell_opt, dsp_register_opt, bram_register_opt, uram_register_opt, bram_enable_opt, shift_register_opt, hold_fix, aggressive_hold_fix, retime, force_replication_on_nets, directive, critical_pin_opt, clock_opt, path_groups, tns_cleanup, sll_reg_hold_fix, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Move or place one or more instances to new locations. Sites and cells are required to be listed in<br/>
		/// the right order and there should be same number of sites as number of cells.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: place_cell [-quiet] [-verbose] &lt;cell_site_list&gt;...
		/// <br/>
		/// <para>
		/// Places cells onto device resources of the target part. Cells can be placed onto specific BEL sites<br/>
		/// (e.g. SLICE_X49Y60/A6LUT), or into available SLICE resources (e.g. SLICE_X49Y60). If you<br/>
		/// specify the SLICE but not the BEL the tool will determine an appropriate BEL within the specified<br/>
		/// SLICE if one is available.<br/>
		/// When placing a cell onto a specified site, the site must not be currently occupied, or an error will<br/>
		/// be returned: Cannot set site and bel property of instances. Site<br/>
		/// SLICE_X49Y61 is already occupied.<br/>
		/// You can test if a site is occupied by querying the IS_OCCUPIED property of a BEL site:<br/>
		/// get_property IS_OCCUPIED [get_bels SLICE_X48Y60/D6LUT]<br/>
		/// Note: The IS_OCCUPIED property of a SLICE only tells you if some of the BELs within the SLICE are<br/>
		/// occupied; not whether or not the SLICE is fully occupied.<br/>
		/// This command can be used to place cells, or to move placed cells from one site on the device to<br/>
		/// another site. The command syntax is the same for placing an unplaced cell, or moving a placed<br/>
		/// cell.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// When moving a placed cell, if you specify only the SLICE for the site, the tool will attempt to<br/>
		/// place the cell onto the same BEL site in the new SLICE as it currently is placed. For instance<br/>
		/// moving a cell from the B6LUT, by specifying a new SLICE, will cause the tool to attempt to place<br/>
		/// the cell onto the B6LUT in the new SLICE. If this BEL site is currently occupied, an error is<br/>
		/// returned.<br/>
		/// Note: This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example places the specified cell onto the specified BEL site:<br/>
		/// place_cell div_cntr_reg_inferredi_4810_15889 SLICE_X49Y60/D6LUT<br/>
		/// The following example places the specified cell into the specified SLICE:<br/>
		/// place_cell div_cntr_reg_inferredi_4810_15889 SLICE_X49Y61<br/>
		/// Note: The tool will select an appropriate BEL site if one is available. If no BEL is available, and error will be<br/>
		/// returned.<br/>
		/// The following example places multiple cells onto multiple sites:<br/>
		/// place_cell { \<br/>
		/// cpuEngine/cpu_iwb_adr_o/buffer_fifo/i_4810_17734 SLICE_X49Y60/A6LUT \<br/>
		/// cpuEngine/or1200_cpu/or1200_mult_mac/i_4775_15857 SLICE_X49Y60/B6LUT \<br/>
		/// cpuEngine/cpu_iwb_adr_o/buffer_fifo/xlnx_opt_LUT_i_4810_18807_2 \<br/>
		/// SLICE_X49Y60/C6LUT }<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1121<br/>
		/// </para>
		/// </summary>
		/// <param name="cell_site_list">(Required) a list of cells and sites in the interleaved order</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL place_cell(TCLParameterList cell_site_list, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: place_cell [-quiet] [-verbose] <cell_site_list>...
			this.Entry(_builder.place_cell(cell_site_list, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Automatically place ports and leaf-level instances<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: place_design [-directive &lt;arg&gt;] [-no_timing_driven] [-timing_summary] [-unplace] [-post_place_opt] [-no_psip] [-no_bufg_opt] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Place the specified ports and logic cells in the current design, or all ports and logic cells, onto<br/>
		/// device resources on the target part. The tool optimizes placement to minimize negative timing<br/>
		/// slack and reduce overall wire length, while also attempting to spread out placement to reduce<br/>
		/// routing congestion.<br/>
		/// Placement is one step of the complete design implementation process, which can be run<br/>
		/// automatically through the use of the launch_runs command when running the Vivado tools in<br/>
		/// Project Mode.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// In Non-Project Mode, the implementation process must be run manually with the individual<br/>
		/// commands: opt_design, place_design, phys_opt_design, power_opt_design, and<br/>
		/// route_design. Refer to the Vivado Design Suite User Guide: Design Flows Overview (UG892) for<br/>
		/// a complete description of Project Mode and Non-Project Mode.<br/>
		/// Both placement and routing can be completed incrementally, based on prior results stored in a<br/>
		/// Design Checkpoint file (DCP), using the incremental implementation flow. Refer to the<br/>
		/// read_checkpoint command, or to Vivado Design Suite User Guide: Implementation (UG904) for<br/>
		/// more information on incremental place and route.<br/>
		/// TIP: The place_design can be multi-threaded to speed the process. Refer to the set_param<br/>
		/// command for more information on setting the general.maxThreads parameter.<br/>
		/// You can also manually place some elements of the design using place_ports, or by setting<br/>
		/// LOC properties on the cell, and then automatically place the remainder of the design using<br/>
		/// place_design.<br/>
		/// This command requires an open synthesized design, and it is recommended that you run the<br/>
		/// opt_design command prior to running place_design to avoid placing a suboptimal netlist.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example places the current design, runs optimization, routes the design, runs post<br/>
		/// placement optimization, and then reroutes the design to cleanup any unconnected nets as a<br/>
		/// result of post placement optimization:<br/>
		/// place_design<br/>
		/// phys_opt_design<br/>
		/// route_design<br/>
		/// place_design -post_place_opt<br/>
		/// phys_opt_design<br/>
		/// route_design<br/>
		/// The following example directs the Vivado placer to try different placement algorithms to achieve<br/>
		/// a better placement result:<br/>
		/// place_design -directive Explore<br/>
		/// This example unplaces the current design:<br/>
		/// place_design -unplace<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1124<br/>
		/// </para>
		/// </summary>
		/// <param name="directive">
		/// <para>
		/// (Optional)<br/>
		/// Mode of behavior (directive) for this command. Please refer<br/>
		/// to Arguments section of this help for values for this option.<br/>
		/// Default: Default<br/>
		/// </para>
		/// </param>
		/// <param name="no_timing_driven">(Optional) Do not run in timing driven mode</param>
		/// <param name="timing_summary">(Optional) Enable accurate post-placement timing summary.</param>
		/// <param name="unplace">(Optional) Unplace all the instances which are not locked by Constraints.</param>
		/// <param name="post_place_opt">(Optional) Run only the post commit optimizer</param>
		/// <param name="no_psip">
		/// <para>
		/// (Optional)<br/>
		/// Disable PSIP (Physical Synthesis In Placer) optimization<br/>
		/// during placement.<br/>
		/// </para>
		/// </param>
		/// <param name="no_bufg_opt">(Optional) Disable global buffer insertion during placement</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL place_design(String directive = null, bool? no_timing_driven = null, bool? timing_summary = null, bool? unplace = null, bool? post_place_opt = null, bool? no_psip = null, bool? no_bufg_opt = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: place_design [-directive <arg>] [-no_timing_driven] [-timing_summary] [-unplace] [-post_place_opt] [-no_psip] [-no_bufg_opt] [-quiet] [-verbose]
			this.Entry(_builder.place_design(directive, no_timing_driven, timing_summary, unplace, post_place_opt, no_psip, no_bufg_opt, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Automatically place a set of ports<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: place_ports [-skip_unconnected_ports] [-check_only] [-iobank &lt;args&gt;] [-quiet] [-verbose] [&lt;ports&gt;...]
		/// <br/>
		/// <para>
		/// Assign ports to the pins of the Xilinx FPGA package, by automatically or manually placing ports.<br/>
		/// • Automatically places ports on an available I/O or clocking site, or into the specified I/O banks.<br/>
		/// • Manually assigns ports to the specified package_pin when both the port and pin are specified.<br/>
		/// The place_ports command will not replace ports that are currently placed by the user, or<br/>
		/// ports that are placed and fixed.<br/>
		/// Note: This command operates silently and does not return direct feedback of its operation.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example places the port objects returned by the get_ports command, onto I/O<br/>
		/// bank 13 of the device, as returned by get_iobanks:<br/>
		/// place_ports -iobank [get_iobanks 13] [get_ports DataOut_pad_1_o]<br/>
		/// The follow example uses port_name package_pin pairs to manually place multiple ports:<br/>
		/// place_ports {LEDS_n[2] AA11 LEDS_n[3] AA10 LEDS_n[0] Y11 LEDS_n[1] Y10}<br/>
		/// The following example places all input ports onto I/O banks 12, 13, 14 and 15 of the device:<br/>
		/// place_ports -iobank [get_iobanks {12 13 14 15}] [all_inputs]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1129<br/>
		/// </para>
		/// </summary>
		/// <param name="skip_unconnected_ports">(Optional) Do not place unconnected ports</param>
		/// <param name="check_only">(Optional) Only check IO/Clock placement DRCs</param>
		/// <param name="iobank">(Optional) Limit placement to the following banks</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="ports">
		/// <para>
		/// (Optional)<br/>
		/// Ports to place (if omitted, all ports will be placed). If the<br/>
		/// arguments are interleaved objects of ports and package<br/>
		/// pins, then manual placement is performed<br/>
		/// </para>
		/// </param>
		public VivadoTCL place_ports(bool? skip_unconnected_ports = null, bool? check_only = null, TCLParameterList iobank = null, bool? quiet = null, bool? verbose = null, TCLParameterList ports = null)
		{
			// TCL Syntax: place_ports [-skip_unconnected_ports] [-check_only] [-iobank <args>] [-quiet] [-verbose] [<ports>...]
			this.Entry(_builder.place_ports(skip_unconnected_ports, check_only, iobank, quiet, verbose, ports));
			return this;
		}
		/// <summary>
		/// <para>
		/// Optimize dynamic power using intelligent clock gating<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: power_opt_design [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Optimizes the dynamic power consumption of the design by changing clock gating to take<br/>
		/// advantage of clock enable on a flop. Clock gating optimizations are automatically performed on<br/>
		/// the entire design to improve power consumption while making no changes to the existing logic<br/>
		/// or the clocks that would alter the behavior of the design.<br/>
		/// You can configure the power optimization to include or exclude specific cells using the<br/>
		/// set_power_opt command.<br/>
		/// Note: Block RAM power optimizations are performed by default with the opt_design command. You can<br/>
		/// disable BRAM optimization by changing the defaults of opt_design, or by excluding specific cells from<br/>
		/// optimization using the set_power_opt command.<br/>
		/// You can also use the read_saif command prior to optimization, and power_opt_design will<br/>
		/// consider the activity data while optimizing the design.<br/>
		/// You can run power optimization after synthesis, or after placement. When run before placement,<br/>
		/// this command optimizes the design to save power. When run after placement, this command<br/>
		/// optimizes the design to save power while preserving timing. Running after placement limits the<br/>
		/// optimizations available to the power_opt_design command. To achieve the best results, the<br/>
		/// command should be run prior to placement.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example performs power optimization of the open design:<br/>
		/// power_opt_design<br/>
		/// This example optimizes the design, excluding the BRAM power optimization by specifying the<br/>
		/// optimizations to run, and then runs power optimization on the design:<br/>
		/// opt_design -retarget -propconst -sweep<br/>
		/// power_opt_design<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1134<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL power_opt_design(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: power_opt_design [-quiet] [-verbose]
			this.Entry(_builder.power_opt_design(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Re-establish a parent cell as a Reconfigurable Partition while removing a lower-level<br/>
		/// Reconfigurable Partition when using the Hierarchical Dynamic Function eXchange solution.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: pr_recombine [-cell &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1136<br/>
		/// </para>
		/// </summary>
		/// <param name="cell">(Optional) (Required) Specify reconfigurable container module name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL pr_recombine(String cell = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: pr_recombine [-cell <arg>] [-quiet] [-verbose]
			this.Entry(_builder.pr_recombine(cell, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Subdivide a Reconfigurable Partition into one or more lower-level Reconfigurable Partitions when<br/>
		/// using the Hierarchical Dynamic Function eXchange solution.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: pr_subdivide [-cell &lt;arg&gt;] [-subcells &lt;arg&gt;] [-quiet] [-verbose] [&lt;from_dcp&gt;]
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1137<br/>
		/// </para>
		/// </summary>
		/// <param name="cell">(Optional) (Required) Specify parent reconfigurable partition module name</param>
		/// <param name="subcells">(Optional) (Required) Specify child reconfigurable partition module names</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="from_dcp">
		/// <para>
		/// (Optional)<br/>
		/// (Required) Specify OOC synthesized checkpoint path for the<br/>
		/// reconfigurable module specified by option -cell<br/>
		/// </para>
		/// </param>
		public VivadoTCL pr_subdivide(String cell = null, String subcells = null, bool? quiet = null, bool? verbose = null, String from_dcp = null)
		{
			// TCL Syntax: pr_subdivide [-cell <arg>] [-subcells <arg>] [-quiet] [-verbose] [<from_dcp>]
			this.Entry(_builder.pr_subdivide(cell, subcells, quiet, verbose, from_dcp));
			return this;
		}
		/// <summary>
		/// <para>
		/// Verify whether the design check points are replaceable on board. This command supports these<br/>
		/// formats: (1) 'pr_verify DCP1 DCP2 -full_check'; (2) 'pr_verify -initial DCP1 -additional {DCP2<br/>
		/// DCP3 DCP4 ...}'; (3) 'pr_verify -in_memory -additional {DCP2 DCP3 ...}'; For format (3), it must<br/>
		/// have an in-memory design opened.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: pr_verify [-full_check] [-file &lt;arg&gt;] [-initial &lt;arg&gt;] [-additional &lt;arg&gt;] [-in_memory] [-quiet] [-verbose] [&lt;file1&gt;] [&lt;file2&gt;]
		/// <br/>
		/// <para>
		/// This command is used to compare design checkpoint files for use in the Partial Reconfiguration<br/>
		/// flow.<br/>
		/// For Partial Reconfigurable designs to work in hardware, the placement and routing of static logic<br/>
		/// must be consistent between all configurations. In addition, proxy logic must be placed in the<br/>
		/// same locations and clock spine routing must match. The pr_verify command compares routed<br/>
		/// design checkpoint files (DCP) created for a Partial Reconfiguration design to verify that all<br/>
		/// imported resources match. For more information refer to the Vivado Design Suite User Guide:<br/>
		/// Dynamic Function eXchange (UG909).<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The two modes for pr_verify let you specify two DCP files to compare, or multiple DCP files<br/>
		/// to compare against the first DCP file. The syntax for the two modes is:<br/>
		/// • pr_verify DCP1 DCP2<br/>
		/// • pr_verify -initial DCP1 -additional {DCP2 DCP3 DCP4}<br/>
		/// The second mode is the same as repeating the pr_verify command to compare each<br/>
		/// additional DCP with the initial DCP, but keeps the initial DCP open to speed the additional<br/>
		/// comparisons:<br/>
		/// pr_verify DCP1 DCP2<br/>
		/// pr_verify DCP1 DCP3<br/>
		/// pr_verify DCP1 DCP4<br/>
		/// This command returns the results of the comparison, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example compares the two corner DCPs, specified with the -additional option,<br/>
		/// against the inital DCP, running a full check on the designs:<br/>
		/// pr_verify -full_check -initial FastConfig.dcp \<br/>
		/// -additional {corner1.dcp corner2.dcp}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1138<br/>
		/// </para>
		/// </summary>
		/// <param name="full_check">
		/// <para>
		/// (Optional)<br/>
		/// Default behavior is to report the first difference only; if this<br/>
		/// option is set to true, pr_verify will report complete<br/>
		/// difference in placement or routing<br/>
		/// </para>
		/// </param>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. Send output to console if -file<br/>
		/// is not used.<br/>
		/// </para>
		/// </param>
		/// <param name="initial">(Optional) Initial checkpoint (.dcp)</param>
		/// <param name="additional">(Optional) Additional checkpoints (.dcp)</param>
		/// <param name="in_memory">(Optional) use in-memory design for comparison, combined with - additional option</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="file1">(Optional) Design checkpoint (.dcp) file one</param>
		/// <param name="file2">(Optional) Design checkpoint (.dcp) file two</param>
		public VivadoTCL pr_verify(bool? full_check = null, String file = null, String initial = null, String additional = null, bool? in_memory = null, bool? quiet = null, bool? verbose = null, String file1 = null, String file2 = null)
		{
			// TCL Syntax: pr_verify [-full_check] [-file <arg>] [-initial <arg>] [-additional <arg>] [-in_memory] [-quiet] [-verbose] [<file1>] [<file2>]
			this.Entry(_builder.pr_verify(full_check, file, initial, additional, in_memory, quiet, verbose, file1, file2));
			return this;
		}
		/// <summary>
		/// <para>
		/// Program Cfgmem object<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: program_hw_cfgmem [-svf_file &lt;arg&gt;] [-force] [-append] [-quiet] [-verbose] [&lt;hw_cfgmem&gt;...]
		/// <br/>
		/// <para>
		/// Erase, blank check, program, and/or verify the specified hw_cfgmem object with the memory<br/>
		/// configuration file defined in the object's PROGRAM.FILE property. The memory configuration file<br/>
		/// is created with the write_cfgmem command, and associated with the hw_cfgmem object using<br/>
		/// the set_property command as shown in the example.<br/>
		/// The process whereby the design specific data is loaded or programmed into the Xilinx FPGA is<br/>
		/// called configuration. The create_hw_cfgmem command defines a flash memory device used<br/>
		/// for configuring and booting the FPGA device.<br/>
		/// After the hw_cfgmem object is created, and associated with the hw_device, the configuration<br/>
		/// memory can be programmed with the bitstream and other data from a memory configuration file<br/>
		/// created with the write_cfgmem command. The hw_cfgmem object is programmed using the<br/>
		/// program_hw_cfgmem command.<br/>
		/// The program_hw_cfgmem command will run a multi-step process to erase the configuration<br/>
		/// memory device, perform a blank check to validate that the device is empty, program the device<br/>
		/// with the memory configuration file, and verify the programming on the device. Properties on the<br/>
		/// hw_cfgmem object determine which steps of the programming process are performed. These<br/>
		/// properties include:<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// • PROGRAM.FILES - Specifies the memory configuration files to use for programming the<br/>
		/// device. The memory configuration files are created with the write_cfgmem command.<br/>
		/// • PROGRAM.ADDRESS_RANGE - Specifies the address range of the configuration memory<br/>
		/// device to program. The address range values can be:<br/>
		/// ○ {use_file} - Use only the address space required by the memory configuration file to<br/>
		/// erase, blank check, program, and verify.<br/>
		/// ○ {entire_device} - Erase, blank check, program, and verify the entire device.<br/>
		/// • PROGRAM.ERASE - Erases the contents of the flash memory when true. This is a boolean<br/>
		/// property with a value of 0 (false) or 1 (true).<br/>
		/// • PROGRAM.BLANK_CHECK - Checks the device to make sure the device is void of data prior<br/>
		/// to programming. This is a boolean property with a value of 0 (false) or 1 (true).<br/>
		/// • PROGRAM.CFG_PROGRAM - Program the device with the specified PROGRAM.FILE. This is<br/>
		/// a boolean property with a value of 0 (false) or 1 (true).<br/>
		/// • PROGRAM.VERIFY - Verify the device after programming. This is a boolean property with a<br/>
		/// value of 0 (false) or 1 (true).<br/>
		/// The program_hw_cfgmem command can also generate an SVF file for in-system and remote<br/>
		/// programming of Xilinx devices. SVF is an industry standard file format that is used to describe<br/>
		/// JTAG chain operations by describing the information that needs to be shifted into the device<br/>
		/// chain. SVF files are ASCII files that can be written and modified in any text editor. Many third-party programming utilities can use the SVF file to program Xilinx devices in a JTAG chain.<br/>
		/// This command returns a transcript of its process when successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1141<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_cfgmem">(Required) list of hardware cfgmems Default: current hardware cfgmem</param>
		/// <param name="svf_file">(Optional) svf file to be generated</param>
		/// <param name="force">(Optional) overwrite svf_file if it already exists</param>
		/// <param name="append">(Optional) append to svf file</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL program_hw_cfgmem(TCLParameterList hw_cfgmem, String svf_file = null, bool? force = null, bool? append = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: program_hw_cfgmem [-svf_file <arg>] [-force] [-append] [-quiet] [-verbose] [<hw_cfgmem>...]
			this.Entry(_builder.program_hw_cfgmem(hw_cfgmem, svf_file, force, append, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Program hardware devices<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: program_hw_devices [-key &lt;arg&gt;] [-clear] [-skip_program_keys] [-skip_program_rsa] [-user_efuse &lt;arg&gt;] [-user_efuse_128 &lt;arg&gt;] [-control_efuse &lt;arg&gt;] [-security_efuse &lt;arg&gt;] [-only_export_efuse] [-svf_file &lt;arg&gt;] [-efuse_export_file &lt;arg&gt;] [-disable_eos_check] [-skip_reset] [-force] [-append] [-type &lt;arg&gt;] [-quiet] [-verbose] [&lt;hw_device&gt;...]
		/// <br/>
		/// <para>
		/// Program the specified hardware device object or objects on the open hardware target of the<br/>
		/// current hardware server.<br/>
		/// To access a Xilinx FPGA through the Hardware Manager, you must use the following Tcl<br/>
		/// command sequence:<br/>
		/// 1. open_hw - Opens the Hardware Manager in the Vivado Design Suite.<br/>
		/// 2. connect_hw_server - Makes a connection to a local or remote Vivado hardware server<br/>
		/// application.<br/>
		/// 3. current_hw_target - Defines the hardware target of the connected server.<br/>
		/// 4. open_hw_target - Opens a connection to the hardware target.<br/>
		/// 5. current_hw_device - Specifies the Xilinx FPGA to use for programming and debugging.<br/>
		/// After connecting to the target hardware device, you must associate the bitstream file<br/>
		/// (.bit, .rbt, .bin) from the design with the device, using the set_property command:<br/>
		/// set_property PROGRAM.FILE {C:/Data/design.bit} [current_hw_device]<br/>
		/// For debug purposes, you can also associate a probes file (.ltx) with the device using the<br/>
		/// PROBES.FILE property:<br/>
		/// set_property PROBES.FILE {C:/Data/debug_nets.ltx} [current_hw_device]<br/>
		/// Once the programming file has been associated with the hardware device, you can program the<br/>
		/// hardware device using the program_hw_devices command, and debug the device using any<br/>
		/// of a number of Hardware Manager Tcl commands. To interactively debug the device open the<br/>
		/// Hardware Manager in the Vivado Design Suite IDE.<br/>
		/// You can also program an encrypted bitstream into the specified hw_device. This requires the<br/>
		/// implemented design to have encryption properties assigned prior to generating the bitstream<br/>
		/// with the write_bitstream command. You can add ENCRYPTION properties to the design<br/>
		/// most easily using the Encryption page of the Edit Device Properties dialog box in the Vivado IDE.<br/>
		/// Refer to the Vivado Design Suite User Guide: Programming and Debugging (UG908) for more<br/>
		/// information on the Edit Device Properties dialog box.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Programming a device for an encrypted bitstream is a two-step process that requires running<br/>
		/// program_hw_devices once to program the encryption key into the BBR or eFUSE registers,<br/>
		/// and a second time to program the encrypted bitstream into the device:<br/>
		/// program_hw_devices -key bbr [current_hw_device]<br/>
		/// program_hw_device [current_hw_device]<br/>
		/// CAUTION! eFUSEs are one-time programmable cells on the hardware device, used to store the factory-programmed Device DNA, AES-GCM encryption key, and user specified values. Refer to the UltraScale<br/>
		/// Architecture Configuration (UG570) or 7 Series FPGAs Configuration User Guide (UG470) for more<br/>
		/// information on eFUSE registers.<br/>
		/// The program_hw_devices command can also generate a Serial Vector Format (SVF) file for in-system and remote programming of Xilinx devices. SVF is an industry standard file format that is<br/>
		/// used to describe JTAG chain operations by describing the information that needs to be shifted<br/>
		/// into the device chain. SVF files are ASCII files that can be written and modified in any text editor.<br/>
		/// Many third-party programming utilities can use the SVF file to program Xilinx devices in a JTAG<br/>
		/// chain.<br/>
		/// This command returns a transcript of its actions, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1144<br/>
		/// </para>
		/// </summary>
		/// <param name="key">(Optional) key option value for encryption programming: efuse,bbr,none</param>
		/// <param name="clear">(Optional) clear bbr registers, only valid for bbr</param>
		/// <param name="skip_program_keys">(Optional) skip programming keys specified in NKY file, if any</param>
		/// <param name="skip_program_rsa">(Optional) skip programming RSA key specified in NKY file, if any</param>
		/// <param name="user_efuse">(Optional) hex user fuse value for encryption programming</param>
		/// <param name="user_efuse_128">(Optional) hex user fuse 128 bit value for encryption programming</param>
		/// <param name="control_efuse">(Optional) hex control fuse value for encryption programming</param>
		/// <param name="security_efuse">(Optional) hex security fuse value for encryption programming</param>
		/// <param name="only_export_efuse">(Optional) do not program eFUSE; just export settings to efuse_export_file</param>
		/// <param name="svf_file">(Optional) svf file used to program device</param>
		/// <param name="efuse_export_file">(Optional) output file to store programmed eFUSE settings</param>
		/// <param name="disable_eos_check">(Optional) Disables End of Startup check after programming</param>
		/// <param name="skip_reset">(Optional) Skips resetting the device before programming</param>
		/// <param name="force">(Optional) overwrites svf file and creates empty file</param>
		/// <param name="append">(Optional) append to svf file</param>
		/// <param name="type">(Optional) bitstream file type to be used for programming: bit,bin,rbt</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_device">
		/// <para>
		/// (Optional)<br/>
		/// list of hardware devices Default: current hardware device<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// </param>
		/// <returns>hardware devices</returns>
		public VivadoTCL program_hw_devices(String key = null, bool? clear = null, bool? skip_program_keys = null, bool? skip_program_rsa = null, String user_efuse = null, String user_efuse_128 = null, String control_efuse = null, String security_efuse = null, bool? only_export_efuse = null, String svf_file = null, String efuse_export_file = null, bool? disable_eos_check = null, bool? skip_reset = null, bool? force = null, bool? append = null, String type = null, bool? quiet = null, bool? verbose = null, TCLParameterList hw_device = null)
		{
			// TCL Syntax: program_hw_devices [-key <arg>] [-clear] [-skip_program_keys] [-skip_program_rsa] [-user_efuse <arg>] [-user_efuse_128 <arg>] [-control_efuse <arg>] [-security_efuse <arg>] [-only_export_efuse] [-svf_file <arg>] [-efuse_export_file <arg>] [-disable_eos_check] [-skip_reset] [-force] [-append] [-type <arg>] [-quiet] [-verbose] [<hw_device>...]
			this.Entry(_builder.program_hw_devices(key, clear, skip_program_keys, skip_program_rsa, user_efuse, user_efuse_128, control_efuse, security_efuse, only_export_efuse, svf_file, efuse_export_file, disable_eos_check, skip_reset, force, append, type, quiet, verbose, hw_device));
			return this;
		}
		/// <summary>
		/// <para>
		/// Turns on or off printing of name of the hdl process being simulated<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: ptrace [-quiet] [-verbose] &lt;value&gt;
		/// <br/>
		/// <para>
		/// Enables process tracing for simulation debugging purposes.<br/>
		/// During simulation the name of the HDL process that is evaluated will be written to the Tcl<br/>
		/// console, as well as the simulation source file and line number associated with the process.<br/>
		/// TIP: Process tracing provides more detailed information than is available with line tracing and the<br/>
		/// ltrace command.<br/>
		/// This feature can also be enabled using the PROCESS_TRACING property on the current<br/>
		/// simulation object:<br/>
		/// set_property PROCESS_TRACING on [current_sim]<br/>
		/// The command returns the state of process tracing, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1149<br/>
		/// </para>
		/// </summary>
		/// <param name="value">(Required) value: on, true, yes. Otherwise set to off, false, no</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL ptrace(String value, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: ptrace [-quiet] [-verbose] <value>
			this.Entry(_builder.ptrace(value, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Read one or more IPIntegrator design files<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: read_bd [-quiet] [-verbose] &lt;files&gt;...
		/// <br/>
		/// <para>
		/// Read the specified IP subsystem design files, or block designs, into the current project or the in-memory design. This command is similar to the add_files command. The block design file is<br/>
		/// added to the source fileset as it is read.<br/>
		/// RECOMMENDED: Files are read and referenced from their current location, and are not moved into the<br/>
		/// local project directories. To bring the file into the local project, use the import_files command<br/>
		/// instead.<br/>
		/// You can use this command to read block designs into the in-memory design, when running the<br/>
		/// Vivado tool in Non Project mode, in which there is no project file to maintain and manage the<br/>
		/// various project source files. Refer to the Vivado Design Suite User Guide: Design Flows Overview<br/>
		/// (UG892) for more information on Non Project mode.<br/>
		/// This command returns the name of the IP subsystem design files read, or returns an error if it<br/>
		/// fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reads the specified IP subsystem design into the current project:<br/>
		/// read_bd C:/Data/block_designs/design1.bd<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1151<br/>
		/// </para>
		/// </summary>
		/// <param name="files">(Required) IPIntegrator design file name(s)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of IPIntegrator design file objects that were added</returns>
		public VivadoTCL read_bd(TCLParameterList files, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_bd [-quiet] [-verbose] <files>...
			this.Entry(_builder.read_bd(files, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Read a design checkpoint<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: read_checkpoint [-cell &lt;arg&gt;] [-incremental] [-directive &lt;arg&gt;] [-auto_incremental] [-reuse_objects &lt;args&gt;] [-fix_objects &lt;args&gt;] [-dcp_cell_list &lt;args&gt;] [-quiet] [-verbose] [&lt;file&gt;]
		/// <br/>
		/// <para>
		/// Reads a design checkpoint file (DCP) that contains the netlist, constraints, and may optionally<br/>
		/// have the placement and routing information of an implemented design. You can save design<br/>
		/// checkpoints at any stage in the design using the write_checkpoint command.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The read_checkpoint command simply reads the associated checkpoint file, without opening<br/>
		/// a design or project in-memory. To create a project from the imported checkpoint, use the<br/>
		/// open_checkpoint command instead of read_checkpoint, or use the link_design<br/>
		/// command after read_checkpoint to open the in-memory design from the checkpoint or<br/>
		/// checkpoint files currently read.<br/>
		/// Note: When multiple design checkpoints are open in the Vivado tool, you must use the<br/>
		/// current_project command to switch between the open designs. You can use current_design to<br/>
		/// check which checkpoint is the active design.<br/>
		/// IMPORTANT! The -incremental switch is not intended to merge two DCP files into a single design. It<br/>
		/// applies the placement and routing of the incremental checkpoint to the netlist objects in the current<br/>
		/// design.<br/>
		/// After loading an incremental design checkpoint, you can use the<br/>
		/// report_incremental_reuse command to determine the percentage of physical data reused<br/>
		/// from the incremental checkpoint, in the current design. The place_design and<br/>
		/// route_design commands will run incremental place and route, preserving reused placement<br/>
		/// and routing information and incorporating it into the design solution.<br/>
		/// Reading a design checkpoint with -incremental, loads the physical data into the current in-memory design. To clear out the incremental design data, you must either reload the current<br/>
		/// design, using open_run to open the synthesis run for instance, or read a new incremental<br/>
		/// checkpoint to overwrite the one previously loaded.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example imports the specified checkpoint file into the tool, and then links the<br/>
		/// various design elements to create an in-memory design of the specified name:<br/>
		/// read_checkpoint C:/Data/checkpoint.dcp<br/>
		/// link_design -name Test1<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This example reads a design checkpoint on top of the current design for incremental place and<br/>
		/// route of the design:<br/>
		/// read_checkpoint -incremental C:/Data/routed.dcp<br/>
		/// This example reads a design checkpoint. Incremental algorithms will be used only if the timing is<br/>
		/// nearly met and if there is a high reuse:<br/>
		/// read_checkpoint -auto_incremental C:/Data/routed.dcp<br/>
		/// Reuse and fix the placement and routing associated with the DSPs and Block RAMs:<br/>
		/// read_checkpoint -incremental C:/Data/routed.dcp \<br/>
		/// -reuse_objects [all_rams] -reuse_objects [all_dsps] -fix_objects<br/>
		/// [current_design]<br/>
		/// TIP: The -reuse_objects option could also be written as:<br/>
		/// -reuse_objects [get_cells -hier -filter {PRIMITIVE_TYPE =~ BMEM.*.* ||<br/>
		/// PRIMITIVE_TYPE =~ MULT.dsp.* }]<br/>
		/// The following example reuses the placement and routing of the cells inside the hierarchical<br/>
		/// cpuEngine cell, and fixes the placement of the DSP cells:<br/>
		/// read_checkpoint -incremental C:/Data/routed.dcp -reuse_objects [get_cells<br/>
		/// cpuEngine] -fix_objects [all_dsps]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1153<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) Design checkpoint file</param>
		/// <param name="cell">(Optional) Replace this cell with the checkpoint. The cell must be a black box.</param>
		/// <param name="incremental">(Optional) Input design checkpoint file to be used for re-using implementation.</param>
		/// <param name="directive">
		/// <para>
		/// (Optional)<br/>
		/// Mode of behavior (directive) for this command. Please refer<br/>
		/// to Arguments section of this help for values for this option.<br/>
		/// Default: RuntimeOptimized<br/>
		/// </para>
		/// </param>
		/// <param name="auto_incremental">
		/// <para>
		/// (Optional)<br/>
		/// Enters automatic mode for incremental compile. This is less<br/>
		/// aggressive than the standard incremental mode and will<br/>
		/// readily switch from incremental algorithms to the default<br/>
		/// algorithms if results might not be maintained. Should not<br/>
		/// be used with -reuse_objects.<br/>
		/// </para>
		/// </param>
		/// <param name="reuse_objects">(Optional) Reuse only given list of cells, clock regions, SLRs and Designs</param>
		/// <param name="fix_objects">(Optional) Fix only given list of cells, clock regions, SLRs or Design</param>
		/// <param name="dcp_cell_list">
		/// <para>
		/// (Optional)<br/>
		/// A list of cell/dcp pairs, e.g. {&lt;cell1&gt; &lt;dcp1&gt; &lt;cell2&gt; &lt;dcp2&gt;}.<br/>
		/// The option value should be in curly braces.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL read_checkpoint(String file, String cell = null, bool? incremental = null, String directive = null, bool? auto_incremental = null, TCLParameterList reuse_objects = null, TCLParameterList fix_objects = null, TCLParameterList dcp_cell_list = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_checkpoint [-cell <arg>] [-incremental] [-directive <arg>] [-auto_incremental] [-reuse_objects <args>] [-fix_objects <args>] [-dcp_cell_list <args>] [-quiet] [-verbose] [<file>]
			this.Entry(_builder.read_checkpoint(file, cell, incremental, directive, auto_incremental, reuse_objects, fix_objects, dcp_cell_list, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Import package pin and port placement information<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: read_csv [-quiet_diff_pairs] [-quiet] [-verbose] &lt;file&gt;
		/// <br/>
		/// <para>
		/// Imports port definition and package pin placement information from a comma separated value<br/>
		/// (CSV) file.<br/>
		/// The port definitions in a CSV file can be imported into an I/O Pin Planning project. In a Pin<br/>
		/// Planning project, importing a CSV file replaces the current port definitions. Any ports in the<br/>
		/// design that are not found in the imported CSV file will be removed.<br/>
		/// In all other projects the port definitions are defined in the source design data, however package<br/>
		/// pin assignments and port attributes can be read from the specified CSV file.<br/>
		/// The ports read from the CSV file can not have spaces in the name, or the tool will return an error.<br/>
		/// The specific format and requirements of the CSV file are described in the Vivado Design Suite User<br/>
		/// Guide: I/O and Clock Planning (UG899).<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example imports a CSV file into an open project:<br/>
		/// read_csv C/Data/pinList.csv<br/>
		/// The following example sets up a new IO Pin Planning project, and then imports the specified CSV<br/>
		/// file into it, and infers any differential pairs in the CSV file:<br/>
		/// create_project myPinPlan C:/Data/myPinPlan -part xc7v285tffg1157-1<br/>
		/// set_property design_mode PinPlanning [current_fileset]<br/>
		/// open_io_design -name io_1<br/>
		/// read_csv C:/Data/import.csv<br/>
		/// infer_diff_pairs -filetype csv C:/Data/import.csv<br/>
		/// Note: The design_mode property on the source fileset is what determines the nature of the project.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1157<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) Pin Planning CSV file</param>
		/// <param name="quiet_diff_pairs">
		/// <para>
		/// (Optional)<br/>
		/// Suppress warnings about differential pair inference when<br/>
		/// importing I/O ports<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL read_csv(String file, bool? quiet_diff_pairs = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_csv [-quiet_diff_pairs] [-quiet] [-verbose] <file>
			this.Entry(_builder.read_csv(file, quiet_diff_pairs, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Read one or more EDIF or NGC files<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: read_edif [-quiet] [-verbose] &lt;files&gt;
		/// <br/>
		/// <para>
		/// Imports an EDIF or NGC netlist file into the Design Source fileset of the current project.<br/>
		/// IMPORTANT! NGC format files are not supported in the Vivado Design Suite for UltraScale devices. It is<br/>
		/// recommended that you regenerate the IP using the Vivado Design Suite IP customization tools with native<br/>
		/// output products. Alternatively, you can use the NGC2EDIF command to migrate the NGC file to EDIF<br/>
		/// format for importing. For more information refer to the ISE to Vivado Design Suite Migration Guide<br/>
		/// (UG911).<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example imports an EDIF file into the open project:<br/>
		/// read_edif C/Data/bft_top.edf<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1159<br/>
		/// </para>
		/// </summary>
		/// <param name="files">(Required) EDIF or NGC file name(s)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of file objects that were added</returns>
		public VivadoTCL read_edif(String files, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_edif [-quiet] [-verbose] <files>
			this.Entry(_builder.read_edif(files, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Read hardware ILA data from a file<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: read_hw_ila_data [-quiet] [-verbose] &lt;file&gt;
		/// <br/>
		/// <para>
		/// Read ILA debug core data from the specified file, and create an hw_ila_data object.<br/>
		/// The ILA debug sample data is acquired from a running device using the upload_hw_ila_data<br/>
		/// command. This creates a hw_ila_data object that can be written to a file on disk using the<br/>
		/// write_hw_ila_data command. This command reads that ILA data file.<br/>
		/// The hw_ila_data object that is created by read_hw_ila_data is named after the &lt;file&gt; it is<br/>
		/// read from. If a hw_ila_data object of the same name already exists, the name of the object is<br/>
		/// assigned a number extension starting at 1: &lt;file&gt;_1.<br/>
		/// The new hw_ila_data object is not connected with, or associated with, any ILA debug cores in the<br/>
		/// design.<br/>
		/// After being read from disk, the ILA debug data can be viewed in the waveform viewer of the<br/>
		/// Vivado logic analyzer by using the display_hw_ila_data command.<br/>
		/// This command returns an ILA data object, or returns an error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1161<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) hardware ILA data file name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Name of the output file</returns>
		public VivadoTCL read_hw_ila_data(String file, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_hw_ila_data [-quiet] [-verbose] <file>
			this.Entry(_builder.read_hw_ila_data(file, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Read hardware SIO scan data from a file. A hardware SIO scan object will be created if not<br/>
		/// provided.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: read_hw_sio_scan [-quiet] [-verbose] &lt;file&gt; [&lt;hw_sio_scan&gt;]
		/// <br/>
		/// <para>
		/// Read a hardware SIO scan data file and create a hw_sio_scan object in the Hardware Manager<br/>
		/// feature of the Vivado Design Suite.<br/>
		/// The SIO scan data can be written to disk using the write_hw_sio_scan command, after<br/>
		/// running the scan using the run_hw_sio_scan command. This command reads that data file.<br/>
		/// If no hw_sio_scan object is specified, a new hw_sio_scan object is created and is named<br/>
		/// sequentially following any existing hw_sio_scan objects. After being read from disk, the SIO scan<br/>
		/// data can be plotted and viewed in the Vivado serial I/O analyzer by using the<br/>
		/// display_hw_sio_scan command.<br/>
		/// This command returns a hw_sio_scan object, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1163<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) hardware SIO scan file name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_sio_scan">(Optional) hardware SIO scan data object Default: None</param>
		/// <returns>hardware SIO scan object</returns>
		public VivadoTCL read_hw_sio_scan(String file, bool? quiet = null, bool? verbose = null, String hw_sio_scan = null)
		{
			// TCL Syntax: read_hw_sio_scan [-quiet] [-verbose] <file> [<hw_sio_scan>]
			this.Entry(_builder.read_hw_sio_scan(file, quiet, verbose, hw_sio_scan));
			return this;
		}
		/// <summary>
		/// <para>
		/// Read hardware SIO sweep data from a directory. A hardware SIO sweep object will be created if<br/>
		/// not provided.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: read_hw_sio_sweep [-quiet] [-verbose] &lt;directory&gt; [&lt;hw_sio_sweep&gt;]
		/// <br/>
		/// <para>
		/// Read a hardware SIO sweep data directory and create a hw_sio_sweep object in the Hardware<br/>
		/// Manager feature of the Vivado Design Suite.<br/>
		/// The SIO sweep data can be written to disk using the write_hw_sio_sweep command, after<br/>
		/// running the sweep using the run_hw_sio_sweep command. This command reads the sweep<br/>
		/// directory containing multiple SIO scan data files.<br/>
		/// If no hw_sio_sweep object is specified, a new hw_sio_sweep object is created and is named<br/>
		/// sequentially following any existing hw_sio_sweep objects. After being read from disk, any of the<br/>
		/// SIO scans in the sweep can be plotted and viewed in the Vivado serial I/O analyzer by using the<br/>
		/// display_hw_sio_scan command.<br/>
		/// This command returns a hw_sio_sweep object, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1165<br/>
		/// </para>
		/// </summary>
		/// <param name="directory">(Required) hardware SIO sweep directory name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_sio_sweep">(Optional) hardware SIO sweep data object Default: None</param>
		/// <returns>hardware SIO sweep object</returns>
		public VivadoTCL read_hw_sio_sweep(String directory, bool? quiet = null, bool? verbose = null, String hw_sio_sweep = null)
		{
			// TCL Syntax: read_hw_sio_sweep [-quiet] [-verbose] <directory> [<hw_sio_sweep>]
			this.Entry(_builder.read_hw_sio_sweep(directory, quiet, verbose, hw_sio_sweep));
			return this;
		}
		/// <summary>
		/// <para>
		/// Read one or more IP files<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: read_ip [-quiet] [-verbose] &lt;files&gt;
		/// <br/>
		/// <para>
		/// Read the specified list of IP files (XCI) and add them to the design and the current fileset. Files are<br/>
		/// added by reference into the current project, just as in the add_files command.<br/>
		/// You can use this command to read the contents of source files into the in-memory design, when<br/>
		/// running the Vivado tool in Non Project mode, in which there is no project file to maintain and<br/>
		/// manage the various project source files. Refer to the Vivado Design Suite User Guide: Design Flows<br/>
		/// Overview (UG892) for more information on Non Project mode.<br/>
		/// When using the read_ip command all output products associated with the IP core, including<br/>
		/// the design checkpoint file (DCP) will be read into the in-memory design.<br/>
		/// TIP: In the project-based design flow, the Vivado tool will automatically generate the necessary output<br/>
		/// products associated with an IP core. However, in a non-project flow you must generate the necessary<br/>
		/// output products using the synth_ip or generate_target commands. For more information on<br/>
		/// working with IP refer to the Vivado Design Suite User Guide: Designing with IP (UG896).<br/>
		/// Use the import_ip command to add the IP cores and import the files into the local project<br/>
		/// directory.<br/>
		/// This command returns the list of files read.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reads the specified IP files:<br/>
		/// read_ip C:/test_ip/char_fifo.xci<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1167<br/>
		/// </para>
		/// </summary>
		/// <param name="files">(Required) IP file name(s)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of IP file objects that were added</returns>
		public VivadoTCL read_ip(String files, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_ip [-quiet] [-verbose] <files>
			this.Entry(_builder.read_ip(files, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// load iPhysOpt script and run it.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: read_iphys_opt_tcl [-fanout_opt] [-critical_cell_opt] [-placement_opt] [-rewire] [-dsp_register_opt] [-bram_register_opt] [-uram_register_opt] [-shift_register_opt] [-auto_pipeline] [-critical_pin_opt] [-equ_drivers_opt] [-include_skipped_optimizations] [-insert_negative_edge_ffs] [-hold_fix] [-slr_crossing_opt] [-quiet] [-verbose] [&lt;input&gt;]
		/// <br/>
		/// <para>
		/// Interactive physical optimization can be used in two ways:<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// • Applying post-placement physical optimizations to the pre-placement netlist to improve the<br/>
		/// overall placement result and improve design performance.<br/>
		/// • Saving the physical optimizations in a Tcl script to be repeated as needed.<br/>
		/// To apply post-placement optimizations to the pre-placement netlist, you can reset the<br/>
		/// implementation run and open the synthesized design, or open the opt_design checkpoint, and<br/>
		/// read the iphys_opt Tcl script to apply the physical optimizations.<br/>
		/// You can apply all optimizations from the iphys_opt Tcl script, or apply specific optimizations using<br/>
		/// the options of the read_iphys_opt_tcl command. You can also include any optimizations<br/>
		/// that were defined but skipped during physical optimization.<br/>
		/// If the iphys_opt Tcl script includes placement data, you can use that data to place the optimized<br/>
		/// cells in the design.<br/>
		/// After reading the iphys_opt Tcl script, and placing the optimized cells, you can rerun placement<br/>
		/// for the overall design. The design now incorporates the benefits of the phys_opt_design<br/>
		/// optimizations before placement, such as fewer high-fanout nets due to replication, and fewer<br/>
		/// long distance paths from block RAM outputs. The results should be a better placement, and<br/>
		/// improved design performance, due to the early application of netlist optimizations.<br/>
		/// This command returns a transcript of its processes, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example applies the BRAM optimizations that are defined in the specified<br/>
		/// interactive physical optimization Tcl script, and applies any placement data for the optimized<br/>
		/// cells:<br/>
		/// open_checkpoint C:/Data/opt_design.dcp<br/>
		/// read_iphys_opt_tcl -shift_register_opt -placement_opt C:/Data/<br/>
		/// my_iphys_opt.tcl<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1169<br/>
		/// </para>
		/// </summary>
		/// <param name="input">(Required) iPhysOpt.tcl file</param>
		/// <param name="fanout_opt">(Optional) Fanout optimization including very high fanout optimizations</param>
		/// <param name="critical_cell_opt">(Optional) Do cell-duplication based optimization on timing critical nets</param>
		/// <param name="placement_opt">(Optional) Move cells to reduce delay on timing-critical nets</param>
		/// <param name="rewire">(Optional) Do rewiring optimization</param>
		/// <param name="dsp_register_opt">(Optional) DSP register optimization</param>
		/// <param name="bram_register_opt">(Optional) BRAM register optimization</param>
		/// <param name="uram_register_opt">(Optional) UltraRAM register optimization</param>
		/// <param name="shift_register_opt">(Optional) Shift register optimization</param>
		/// <param name="auto_pipeline">(Optional) Auto pipeline</param>
		/// <param name="critical_pin_opt">(Optional) Pin Swap optimization</param>
		/// <param name="equ_drivers_opt">(Optional) Equivalent driver rewiring</param>
		/// <param name="include_skipped_optimizations">(Optional) Apply undo changes</param>
		/// <param name="insert_negative_edge_ffs">(Optional) Inserting negative edge triggered FFs for high hold mitigation</param>
		/// <param name="hold_fix">(Optional) Inserting buffers for hold fix optimization</param>
		/// <param name="slr_crossing_opt">(Optional) Optimize slr crossing nets</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL read_iphys_opt_tcl(String input, bool? fanout_opt = null, bool? critical_cell_opt = null, bool? placement_opt = null, bool? rewire = null, bool? dsp_register_opt = null, bool? bram_register_opt = null, bool? uram_register_opt = null, bool? shift_register_opt = null, bool? auto_pipeline = null, bool? critical_pin_opt = null, bool? equ_drivers_opt = null, bool? include_skipped_optimizations = null, bool? insert_negative_edge_ffs = null, bool? hold_fix = null, bool? slr_crossing_opt = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_iphys_opt_tcl [-fanout_opt] [-critical_cell_opt] [-placement_opt] [-rewire] [-dsp_register_opt] [-bram_register_opt] [-uram_register_opt] [-shift_register_opt] [-auto_pipeline] [-critical_pin_opt] [-equ_drivers_opt] [-include_skipped_optimizations] [-insert_negative_edge_ffs] [-hold_fix] [-slr_crossing_opt] [-quiet] [-verbose] [<input>]
			this.Entry(_builder.read_iphys_opt_tcl(input, fanout_opt, critical_cell_opt, placement_opt, rewire, dsp_register_opt, bram_register_opt, uram_register_opt, shift_register_opt, auto_pipeline, critical_pin_opt, equ_drivers_opt, include_skipped_optimizations, insert_negative_edge_ffs, hold_fix, slr_crossing_opt, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Read one or more data files (.mem .mif .dat).<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: read_mem [-quiet] [-verbose] &lt;files&gt;...
		/// <br/>
		/// <para>
		/// This command reads memory files of type MEM, DAT, or COE, and adds the files to the in-memory design, or the current project, to initialize BRAM memory for behavioral simulation,<br/>
		/// synthesis and post-synthesis simulation.<br/>
		/// If the memory is not initialized in the design, then it will be initialized to all 0s.<br/>
		/// This command returns the name of the files read, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example:<br/>
		/// read_mem C:/Data/design1.mem<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1172<br/>
		/// </para>
		/// </summary>
		/// <param name="files">(Required) Data (.mem .coe .dat) file name(s)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of file objects that were added</returns>
		public VivadoTCL read_mem(TCLParameterList files, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_mem [-quiet] [-verbose] <files>...
			this.Entry(_builder.read_mem(files, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Read QoR Suggestions from the given file<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: read_qor_suggestions [-quiet] [-verbose] &lt;file&gt;
		/// <br/>
		/// <para>
		/// Read the specified file and extract the QoR suggestions from the file.<br/>
		/// This command returns the name of the QoR file read, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reads the QoR suggestions from the specified file, and then reports the<br/>
		/// QoR suggestions in the open design:<br/>
		/// read_qor_suggestions C:/Data/qor_results.rqs<br/>
		/// report_qor_suggestions -of_objects [get_qor_suggestions]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1174<br/>
		/// </para>
		/// </summary>
		/// <param name="file">
		/// <para>
		/// (Required)<br/>
		/// QoR suggestions file Values: Path to the QoR suggestions<br/>
		/// file, typically ending with .rqs.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL read_qor_suggestions(String file, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_qor_suggestions [-quiet] [-verbose] <file>
			this.Entry(_builder.read_qor_suggestions(file, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Import simulation data in saif format<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: read_saif [-strip_path &lt;arg&gt;] [-no_strip] [-out_file &lt;arg&gt;] [-quiet] [-verbose] &lt;file&gt;
		/// <br/>
		/// <para>
		/// Reads a Switching Activity Interchange Format (SAIF) file for use during power analysis by the<br/>
		/// report_power command, or power optimization by power_opt_design. The read_saif<br/>
		/// command will annotate the design nodes with activity from the SAIF file and estimate power<br/>
		/// appropriately.<br/>
		/// Running report_power or power_opt_design after reading the SAIF file will use the activity<br/>
		/// rates from the specified file during optimization and analysis.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example:<br/>
		/// read_saif -strip_path design/top/F1 C:/Data/design1.saif<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1176<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) Specifies the name of the SAIF file to be read</param>
		/// <param name="strip_path">
		/// <para>
		/// (Optional)<br/>
		/// Specifies the name of the instance of the current design as<br/>
		/// it appears in the SAIF file<br/>
		/// </para>
		/// </param>
		/// <param name="no_strip">(Optional) Do not strip first two levels of hierarchy from SAIF file</param>
		/// <param name="out_file">
		/// <para>
		/// (Optional)<br/>
		/// Specifies the name of the output file that contains nets that<br/>
		/// could not be matched<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL read_saif(String file, String strip_path = null, bool? no_strip = null, String out_file = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_saif [-strip_path <arg>] [-no_strip] [-out_file <arg>] [-quiet] [-verbose] <file>
			this.Entry(_builder.read_saif(file, strip_path, no_strip, out_file, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Import schematic<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: read_schematic [-name &lt;arg&gt;] [-quiet] [-verbose] &lt;file&gt;
		/// <br/>
		/// <para>
		/// Import a native schematic file that was previously exported from the Vivado Design Suite using<br/>
		/// the write_schematic command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1178<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) Input file</param>
		/// <param name="name">(Optional) Schematic window title</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>name of the file previously exported</returns>
		public VivadoTCL read_schematic(String file, String name = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_schematic [-name <arg>] [-quiet] [-verbose] <file>
			this.Entry(_builder.read_schematic(file, name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Read timing results from Trace STA tool<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: read_twx [-cell &lt;arg&gt;] [-pblock &lt;arg&gt;] [-quiet] [-verbose] &lt;name&gt; &lt;file&gt;
		/// <br/>
		/// <para>
		/// Imports timing results in the TWX format timing report files generated by the Xilinx Timing<br/>
		/// Reporter And Circuit Evaluator (TRACE) tool. The TWX file can be imported at the top-level,<br/>
		/// which is the default, or at a specific cell-level or relative to a specific Pblock.<br/>
		/// After the TWX files are imported, the timing results display in the Timing Results view in GUI<br/>
		/// mode.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reads the specified TWX file into the top-level of the design:<br/>
		/// read_twx C:/Data/timing_files/bft.twx<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1180<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name for the set of results</param>
		/// <param name="file">(Required) Name of the Trace import file</param>
		/// <param name="cell">(Optional) Interpret names in the report file as relative to the specified cell</param>
		/// <param name="pblock">(Optional) Interpret names in the report file as relative to the specified pblock</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL read_twx(String name, String file, String cell = null, String pblock = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_twx [-cell <arg>] [-pblock <arg>] [-quiet] [-verbose] <name> <file>
			this.Entry(_builder.read_twx(name, file, cell, pblock, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Read one or more Verilog files<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: read_verilog [-library &lt;arg&gt;] [-sv] [-quiet] [-verbose] &lt;files&gt;...
		/// <br/>
		/// <para>
		/// Reads Verilog or SystemVerilog source files. This command is similar to the add_files<br/>
		/// command. The Verilog file is added to the source fileset as it is read. If the -library argument<br/>
		/// is specified, the file is added with the Library property defined appropriately.<br/>
		/// You can use this command to read the contents of source files into the in-memory design, when<br/>
		/// running the Vivado tool in Non Project mode, in which there is no project file to maintain and<br/>
		/// manage the various project source files. Refer to the Vivado Design Suite User Guide: Design Flows<br/>
		/// Overview (UG892) for more information on Non Project mode.<br/>
		/// Because SystemVerilog is a superset of the Verilog language, the read_verilog command can<br/>
		/// read both file types. However, for SystemVerilog files, the -sv option needs to be specified for<br/>
		/// read_verilog to enable compilation in the SystemVerilog mode. In this mode, the tool<br/>
		/// recognizes and honors the SystemVerilog keywords and constructs.<br/>
		/// You can have a mixture of both Verilog files (.v files), and SystemVerilog files (.sv files), as well as<br/>
		/// VHDL (using read_vhdl). When the tool compiles these files for synthesis, it creates separate<br/>
		/// "compilation units" for each file type. All files of the same type are compiled together.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reads the specified Verilog file and adds it to the source fileset:<br/>
		/// read_verilog C:/Data/FPGA_Design/new_module.v<br/>
		/// The following example creates two compilation units, one for SystemVerilog files and one for<br/>
		/// Verilog files:<br/>
		/// read_verilog -sv { file1.sv file2.sv file3.sv }<br/>
		/// read_verilog { file1.v file2.v file3.v}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1182<br/>
		/// </para>
		/// </summary>
		/// <param name="files">(Required) Verilog file name(s)</param>
		/// <param name="library">(Optional) Library name (ignored by Vivado synthesis) Default: default lib</param>
		/// <param name="sv">(Optional) Enable system verilog compilation</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of file objects that were added</returns>
		public VivadoTCL read_verilog(TCLParameterList files, String library = null, bool? sv = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_verilog [-library <arg>] [-sv] [-quiet] [-verbose] <files>...
			this.Entry(_builder.read_verilog(files, library, sv, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Read one or more VHDL files<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: read_vhdl -library &lt;arg&gt; [-vhdl2008] [-quiet] [-verbose] &lt;files&gt;
		/// <br/>
		/// <para>
		/// Reads VHDL source files. This command is similar to the add_files command. The VHDL files<br/>
		/// are added to the source fileset as the file is read. If the -library argument is specified, the file<br/>
		/// is added with the Library property defined.<br/>
		/// You can use this command to read the contents of source files into the in-memory design, when<br/>
		/// running the Vivado tool in Non Project mode, in which there is no project file to maintain and<br/>
		/// manage the various project source files. Refer to the Vivado Design Suite User Guide: Design Flows<br/>
		/// Overview (UG892) for more information on Non Project mode.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reads the specified VHDL file and adds it to the source fileset:<br/>
		/// read_vhdl C:/Data/FPGA_Design/new_module.vhdl<br/>
		/// This example reads multiple specified VHDL 2008 files:<br/>
		/// read_vhdl -vhdl2008 {file1.vhd file2.vhd file3.vhd}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1184<br/>
		/// </para>
		/// </summary>
		/// <param name="library">(Required) VHDL library</param>
		/// <param name="files">(Required) VHDL file name(s)</param>
		/// <param name="vhdl2008">(Optional) VHDL file is version 2008.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of file objects that were added</returns>
		public VivadoTCL read_vhdl(String library, String files, bool? vhdl2008 = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_vhdl -library <arg> [-vhdl2008] [-quiet] [-verbose] <files>
			this.Entry(_builder.read_vhdl(library, files, vhdl2008, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// read physical and timing constraints from one of more files.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: read_xdc [-cells &lt;args&gt;] [-ref &lt;arg&gt;] [-quiet_diff_pairs] [-mode &lt;arg&gt;] [-unmanaged] [-no_add] [-quiet] [-verbose] &lt;files&gt;
		/// <br/>
		/// <para>
		/// Imports physical and timing constraints from a Xilinx Design Constraints file (XDC). The XDC is<br/>
		/// imported into the current_instance level of the design hierarchy, which defaults to the top-level of the design, or can be imported into specified cells. When imported at the top-level, the<br/>
		/// specified XDC file is added to the active constraint fileset.<br/>
		/// IMPORTANT! Constraints from the XDC file will overwrite any current constraints of the same name.<br/>
		/// Therefore, exercise some caution when reading a XDC file to be sure you will not overwrite important<br/>
		/// constraints.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This command is similar to the add_files command in that the XDC file is added by reference<br/>
		/// rather than imported into the local project directory.<br/>
		/// You can use this command to read the contents of source files into the in-memory design, when<br/>
		/// running the Vivado tool in Non Project mode, in which there is no project file to maintain and<br/>
		/// manage the various project source files. Refer to the Vivado Design Suite User Guide: Design Flows<br/>
		/// Overview (UG892) for more information on Non Project mode.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reads the XDC file and applies it to the current design:<br/>
		/// read_xdc file_1.xdc<br/>
		/// The following example reads the XDC file and applies it ALL instances of the referenced module<br/>
		/// found in the current design:<br/>
		/// read_xdc -ref hex2led file_2.xdc<br/>
		/// The following example reads the XDC file and applies it ONLY to the specified instance within<br/>
		/// the referenced module:<br/>
		/// read_xdc -ref sixty -cells lsbcount file_3.xdc<br/>
		/// The following example reads the XDC file and applies it to the specified instances in the current<br/>
		/// design, even though they are instances of different modules:<br/>
		/// read_xdc -cells {one_decode sixty/msbcount} file_4.xdc<br/>
		/// Note: Multiple cells must be enclosed in quotes, "", or braces, {}.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1186<br/>
		/// </para>
		/// </summary>
		/// <param name="files">(Required) Input file(s) to read</param>
		/// <param name="cells">(Optional) Import constraints for these cells</param>
		/// <param name="ref">(Optional) Import constraints for this ref</param>
		/// <param name="quiet_diff_pairs">
		/// <para>
		/// (Optional)<br/>
		/// Suppress warnings about differential pair inference when<br/>
		/// importing I/O ports<br/>
		/// </para>
		/// </param>
		/// <param name="mode">
		/// <para>
		/// (Optional)<br/>
		/// Import constraints as out_of_context. Values: default,<br/>
		/// out_of_context Default: default<br/>
		/// </para>
		/// </param>
		/// <param name="unmanaged">(Optional) treat this file as unmanaged constraints file</param>
		/// <param name="no_add">(Optional) don't add this file to constraints fileset</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of files</returns>
		public VivadoTCL read_xdc(String files, TCLParameterList cells = null, String @ref = null, bool? quiet_diff_pairs = null, read_xdc_mode? mode = null, bool? unmanaged = null, bool? no_add = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: read_xdc [-cells <args>] [-ref <arg>] [-quiet_diff_pairs] [-mode <arg>] [-unmanaged] [-no_add] [-quiet] [-verbose] <files>
			this.Entry(_builder.read_xdc(files, cells, @ref, quiet_diff_pairs, mode, unmanaged, no_add, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Readback data from the hw_cfgmem object<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: readback_hw_cfgmem [-checksum] [-force] [-all] [-offset &lt;arg&gt;] -file &lt;arg&gt; [-format &lt;arg&gt;] [-datacount &lt;arg&gt;] [-quiet] [-verbose] [&lt;hw_cfgmem&gt;...]
		/// <br/>
		/// <para>
		/// Read programming data off of the hardware configuration memory device, specified as a<br/>
		/// hw_cfgmem object.<br/>
		/// This command reads back the memory configuration file data programmed into a flash memory<br/>
		/// device by the program_hw_cfgmem command and writes it to the specified file. The memory<br/>
		/// configuration file is created by the write_cfgmem command and combines the bitstream<br/>
		/// (.bit) file, and any specified data files, into the memory configuration file format.<br/>
		/// Readback is the process of reading data from the configuration memory device to verify that the<br/>
		/// bitstream and any additional data files were properly programmed into the flash memory device.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1189<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) File to write readback to</param>
		/// <param name="checksum">(Optional) readback and calculate checksum; cannot be used with -file option</param>
		/// <param name="force">(Optional) force write of file</param>
		/// <param name="all">(Optional) specify readback of all memory locations</param>
		/// <param name="offset">(Optional) memory offset value Default: 0x0</param>
		/// <param name="format">(Optional) File format of readback file</param>
		/// <param name="datacount">(Optional) number of data units to readback Default: 0x0</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_cfgmem">(Optional) list of hardware cfgmems Default: current hardware cfgmem</param>
		public VivadoTCL readback_hw_cfgmem(String file, bool? checksum = null, bool? force = null, bool? all = null, String offset = null, String format = null, Int32? datacount = null, bool? quiet = null, bool? verbose = null, TCLParameterList hw_cfgmem = null)
		{
			// TCL Syntax: readback_hw_cfgmem [-checksum] [-force] [-all] [-offset <arg>] -file <arg> [-format <arg>] [-datacount <arg>] [-quiet] [-verbose] [<hw_cfgmem>...]
			this.Entry(_builder.readback_hw_cfgmem(file, checksum, force, all, offset, format, datacount, quiet, verbose, hw_cfgmem));
			return this;
		}
		/// <summary>
		/// <para>
		/// Readback hardware devices<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: readback_hw_device [-force] [-capture] [-readback_file &lt;arg&gt;] [-bin_file &lt;arg&gt;] [-quiet] [-verbose] [&lt;hw_device&gt;...]
		/// <br/>
		/// <para>
		/// Read bitstream data from the current hardware device and write it to the specified readback or<br/>
		/// binary file.<br/>
		/// The Vivado device programmer will readback bitstream data from the Xilinx device through the<br/>
		/// open target.<br/>
		/// IMPORTANT! If the bitstream on the hw_device is encrypted, readback is not permitted.<br/>
		/// This command returns the name of the readback file created, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1193<br/>
		/// </para>
		/// </summary>
		/// <param name="force">(Optional) force write of file</param>
		/// <param name="capture">(Optional) capture configuration readback data (ultrascale only)</param>
		/// <param name="readback_file">(Optional) readback file for rbd file output</param>
		/// <param name="bin_file">(Optional) bin file for bin file output</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_device">(Optional) list of hardware devices Default: current hardware device</param>
		/// <returns>hardware devices</returns>
		public VivadoTCL readback_hw_device(bool? force = null, bool? capture = null, String readback_file = null, String bin_file = null, bool? quiet = null, bool? verbose = null, TCLParameterList hw_device = null)
		{
			// TCL Syntax: readback_hw_device [-force] [-capture] [-readback_file <arg>] [-bin_file <arg>] [-quiet] [-verbose] [<hw_device>...]
			this.Entry(_builder.readback_hw_device(force, capture, readback_file, bin_file, quiet, verbose, hw_device));
			return this;
		}
		/// <summary>
		/// <para>
		/// Re-do previous command<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: redo [-list] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// IMPORTANT! The UNDO and REDO commands are intended for use in the Vivado IDE, and are not<br/>
		/// recommended for use in Tcl scripts to restore designs to a former state. To restore a design to a specific<br/>
		/// condition, you must write a design checkpoint using the write_checkpoint command, to be restored<br/>
		/// using read_checkpoint.<br/>
		/// Redo a command that has been previously undone. This command can be used repeatedly to<br/>
		/// redo a series of commands.<br/>
		/// If a command group has been created using the startgroup and endgroup commands, the<br/>
		/// redo command will redo the group of commands as a sequence.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns a list of commands that can be redone:<br/>
		/// redo -list<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1196<br/>
		/// </para>
		/// </summary>
		/// <param name="list">(Optional) Show a list of redoable tasks</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>with -list, the list of redoable tasks</returns>
		public VivadoTCL redo(bool? list = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: redo [-list] [-quiet] [-verbose]
			this.Entry(_builder.redo(list, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Refresh the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: refresh_design [-part &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Reloads the current design from the project data on the hard drive. This overwrites the in-memory view of the design to undo any recent design changes.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following command reloads the current design from the project data on hard disk. This will<br/>
		/// overwrite the unsaved changes of the design which are in memory.<br/>
		/// refresh_design<br/>
		/// Note: You can use the command to undo a series of changes to the design and revert to the previously<br/>
		/// saved design.<br/>
		/// The following example refreshes the current design using the specified V6 part as the target<br/>
		/// device. The second command is required to make the selected part the target device for the<br/>
		/// active implementation run.<br/>
		/// refresh_design -part xc6vcx75tff784-1<br/>
		/// set_property part xc6vcx75tff784-1 [get_runs impl_6]<br/>
		/// Note: The second command is not required if the target part is not changed.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1198<br/>
		/// </para>
		/// </summary>
		/// <param name="part">(Optional) Target part</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL refresh_design(String part = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: refresh_design [-part <arg>] [-quiet] [-verbose]
			this.Entry(_builder.refresh_design(part, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Refresh hardware AXI object status.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: refresh_hw_axi [-quiet] [-verbose] [&lt;hw_axis&gt;...]
		/// <br/>
		/// <para>
		/// Refresh the STATUS properties of the hw_axi object with the values from the current hw_device.<br/>
		/// The refresh command takes the values from the status registers of the JTAG to AXI MASTER on<br/>
		/// the hardware device, and populates them into the appropriate properties of the hw_axi object in<br/>
		/// the hardware manager.<br/>
		/// Refresh the STATUS properties of the specified hw_axi objects. THE STATUS properties include:<br/>
		/// STATUS.AXI_READ_BUSY, STATUS.AXI_READ_DONE, STATUS.AXI_WRITE_BUSY,<br/>
		/// STATUS.AXI_WRITE_DONE, STATUS.BRESP, and STATUS.RRESP.<br/>
		/// This command updates the properties on the hw_axi object, but otherwise returns nothing if<br/>
		/// successful. The command returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1200<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_axis">(Required) List of hardware AXI objects.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL refresh_hw_axi(TCLParameterList hw_axis, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: refresh_hw_axi [-quiet] [-verbose] [<hw_axis>...]
			this.Entry(_builder.refresh_hw_axi(hw_axis, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Refresh the status of the current hardware object. Inputs need to be any DDRMC object. At least<br/>
		/// one object is required. If properties are specified, but do not exist in the object, those properties<br/>
		/// will not be refreshed.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: refresh_hw_ddrmc [-regexp] [-properties &lt;args&gt;] [-quiet] [-verbose] &lt;hw_objects&gt;
		/// <br/>
		/// <para>
		/// Refreshes the in-memory contents of all of the properties, or specified properties, of the<br/>
		/// specified Versal DDR Memory Controller (DDRMC) objects with values read from the current<br/>
		/// hardware device.<br/>
		/// The refresh command takes the values from the DDRMC object implemented on the hardware<br/>
		/// device, and populates them into the appropriate properties of the hw_ddrmc object in the Vivado<br/>
		/// hardware manager. If only certain properties are specified, then those properties are updated<br/>
		/// from the hw device.<br/>
		/// At least one object is required. If properties are specified that do not exist in the object, that<br/>
		/// property will not be refreshed.<br/>
		/// This command updates the properties on the hw_ddrmc object, but otherwise returns nothing if<br/>
		/// successful. The command returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example refreshes all of the properties of the DDRMC objects in the Vivado<br/>
		/// hardware manager with the properties from the current hw_device:<br/>
		/// refresh_hw_ddrmc -properties {PHY_RANKS} [lindex [get_hw_ddrmcs] 3]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1202<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_objects">(Required) hardware DDRMC objects</param>
		/// <param name="regexp">(Optional) Properties list contains full regular expressions</param>
		/// <param name="properties">(Optional) List of properties to refresh Default: All properties in object</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL refresh_hw_ddrmc(String hw_objects, bool? regexp = null, TCLParameterList properties = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: refresh_hw_ddrmc [-regexp] [-properties <args>] [-quiet] [-verbose] <hw_objects>
			this.Entry(_builder.refresh_hw_ddrmc(hw_objects, regexp, properties, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Refresh a hardware device. Read device and core information from device.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: refresh_hw_device [-update_hw_probes &lt;arg&gt;] [-disable_done_check] [-force_poll] [-quiet] [-verbose] [&lt;hw_device&gt;]
		/// <br/>
		/// <para>
		/// Refreshes the in-memory view of the device by scanning for debug and IBERT cores on the<br/>
		/// specified hw_device object, and also reads a probe file when directed.<br/>
		/// The Hardware Manager in the Vivado Design Suite creates, deletes, or updates the hw_ila,<br/>
		/// hw_vio, hw_sio*, and hw_axi objects based on the core information found in the device, and also<br/>
		/// what is read from the probes file in the case of ILA and VIO debug cores.<br/>
		/// Use the refresh_hw_device after the program_hw_devices to keep the in-memory<br/>
		/// hardware debug objects in sync with the state of the actual cores on the physical device.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1204<br/>
		/// </para>
		/// </summary>
		/// <param name="update_hw_probes">(Optional) Update hardware probe information, read from probes file</param>
		/// <param name="disable_done_check">(Optional) Disable done check for refresh device</param>
		/// <param name="force_poll">(Optional) Force poll of all targets</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_device">(Optional) hardware device Default: current hardware device</param>
		public VivadoTCL refresh_hw_device(String update_hw_probes = null, bool? disable_done_check = null, bool? force_poll = null, bool? quiet = null, bool? verbose = null, String hw_device = null)
		{
			// TCL Syntax: refresh_hw_device [-update_hw_probes <arg>] [-disable_done_check] [-force_poll] [-quiet] [-verbose] [<hw_device>]
			this.Entry(_builder.refresh_hw_device(update_hw_probes, disable_done_check, force_poll, quiet, verbose, hw_device));
			return this;
		}
		/// <summary>
		/// <para>
		/// Refresh the status of the current hardware object. Inputs can be HBM or device hardware object.<br/>
		/// At least one object is required. If properties are specified that do not exist in the object, that<br/>
		/// property will not be refreshed.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: refresh_hw_hbm [-regexp] [-properties &lt;args&gt;] [-quiet] [-verbose] &lt;hw_objects&gt;
		/// <br/>
		/// <para>
		/// Refreshes the in-memory view of all of the properties, or specified properties, of the specified<br/>
		/// HBM controller objects with values read from the current hardware device.<br/>
		/// The refresh command takes the values from the HBM controller implemented on the hardware<br/>
		/// device, and populates them into the appropriate properties of the hw_hbm object in the Vivado<br/>
		/// hardware manager. If only certain properties are specified, then those properties are updated<br/>
		/// from the hw device.<br/>
		/// At least one object is required. If properties are specified that do not exist in the object, that<br/>
		/// property will not be refreshed.<br/>
		/// This command updates the properties on the hw_hbm object, but otherwise returns nothing if<br/>
		/// successful. The command returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example refreshes all of the properties of the HBM controller in the Vivado<br/>
		/// hardware manager with the properties from the current hw_device:<br/>
		/// refresh_hw_hbm [lindex [get_hw_hbms] 1]<br/>
		/// The following example refreshes the specified property of the HBM controller from the current<br/>
		/// hw_device:<br/>
		/// refresh_hw_hbm -properties {MC2.INIT.AM_REPEAT_EN} [get_hw_hbms *HBM_2]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1206<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_objects">(Required) hardware objects</param>
		/// <param name="regexp">(Optional) Properties list contains full regular expressions</param>
		/// <param name="properties">(Optional) List of properties to refresh Default: All properties in object</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL refresh_hw_hbm(String hw_objects, bool? regexp = null, TCLParameterList properties = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: refresh_hw_hbm [-regexp] [-properties <args>] [-quiet] [-verbose] <hw_objects>
			this.Entry(_builder.refresh_hw_hbm(hw_objects, regexp, properties, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Refresh the status of the current hardware object. Inputs can be any mig, device, target, or server<br/>
		/// hardware object. At least one object is required. If properties are specified that do not exist in the<br/>
		/// object, that property will not be refreshed.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: refresh_hw_mig [-regexp] [-properties &lt;args&gt;] [-quiet] [-verbose] &lt;hw_objects&gt;
		/// <br/>
		/// <para>
		/// Refreshes the in-memory view of all of the properties, or specified properties, of the specified<br/>
		/// hw_mig objects with values read from the current hardware device.<br/>
		/// The refresh command takes the values from the memory controller implemented on the<br/>
		/// hardware device, and populates them into the appropriate properties of the hw_mig debug core<br/>
		/// in the Vivado logic analyzer, or standalone Vivado Lab Edition.<br/>
		/// At least one object is required. If properties are specified that do not exist in the object, that<br/>
		/// property will not be refreshed.<br/>
		/// This command updates the properties on the hw_mig object, but otherwise returns nothing if<br/>
		/// successful. The command returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1208<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_objects">(Required) hardware objects</param>
		/// <param name="regexp">(Optional) Properties list contains full regular expressions</param>
		/// <param name="properties">(Optional) List of properties to refresh Default: All properties in object</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL refresh_hw_mig(String hw_objects, bool? regexp = null, TCLParameterList properties = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: refresh_hw_mig [-regexp] [-properties <args>] [-quiet] [-verbose] <hw_objects>
			this.Entry(_builder.refresh_hw_mig(hw_objects, regexp, properties, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Refresh the PCIe core properties, by reading from HW.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: refresh_hw_pcie [-quiet] [-verbose] &lt;hw_pcie&gt;
		/// <br/>
		/// <para>
		/// Refresh for the Peripheral Component Interconnect Express (PCIe) debug core object, hw_pcie,<br/>
		/// defined on the current hardware device.<br/>
		/// The customizable LogiCORE IP PCIe core for Xilinx ACAPs is designed for evaluating and<br/>
		/// monitoring the PCIe Link Training and Status State Machine (LTSSM) running on the Gigabit<br/>
		/// Transceivers (GTs). In the Vivado Hardware Manager, Versal PCIe soft cores implemented in the<br/>
		/// design, are represented as hw_pcie objects. You can use these PCIe debug cores to solve a range<br/>
		/// of debug and validation problems; from viewing the PCIe link information to the LTSSM state<br/>
		/// transition diagram.<br/>
		/// This command reads data from the PCIe debug core and updates the relevant properties in the<br/>
		/// hw_pcie object.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example refreshes the PCIe core at index 0<br/>
		/// refresh_hw_pcie [lindex [get_hw_pcies] 0]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1210<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_pcie">(Required) Hardware PCIe object</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL refresh_hw_pcie(String hw_pcie, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: refresh_hw_pcie [-quiet] [-verbose] <hw_pcie>
			this.Entry(_builder.refresh_hw_pcie(hw_pcie, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Refresh a connection to a hardware server<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: refresh_hw_server [-force_poll] [-quiet] [-verbose] [&lt;hw_server&gt;]
		/// <br/>
		/// <para>
		/// Refresh or reopen the connection to the current or specified hardware server.<br/>
		/// This command returns the connection messages from the hardware server, or returns an error if<br/>
		/// it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1212<br/>
		/// </para>
		/// </summary>
		/// <param name="force_poll">(Optional) Force poll of all targets</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_server">(Optional) hardware server</param>
		public VivadoTCL refresh_hw_server(bool? force_poll = null, bool? quiet = null, bool? verbose = null, String hw_server = null)
		{
			// TCL Syntax: refresh_hw_server [-force_poll] [-quiet] [-verbose] [<hw_server>]
			this.Entry(_builder.refresh_hw_server(force_poll, quiet, verbose, hw_server));
			return this;
		}
		/// <summary>
		/// <para>
		/// Refresh the status of the specified hardware objects. Inputs can be any serial I/O (except scan<br/>
		/// and sweep), device, target, or server hardware object. At least one object is required. If properties<br/>
		/// are specified that do not exist in the object, that property will not be refreshed.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: refresh_hw_sio [-regexp] [-properties &lt;args&gt;] [-quiet] [-verbose] &lt;hw_objects&gt;
		/// <br/>
		/// <para>
		/// Refreshes the in-memory view of all of the properties, or specified properties, of the specified<br/>
		/// hw_sio objects with values read from the actual object on the hardware device.<br/>
		/// Specified objects can include any serial I/O object such as GTs, RXs, TXs, PLLs, or Commons,<br/>
		/// excluding hw_sio_scan and hw_sio_sweep objects. SIO objects also include device, target, or<br/>
		/// server hardware objects.<br/>
		/// The refresh_hw_sio command reads the values of the specified objects on the hardware<br/>
		/// device, and applies the value to the associated property of the IBERT core in the Hardware<br/>
		/// Manager.<br/>
		/// This command returns no feedback of its operation if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1214<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_objects">(Required) hardware objects</param>
		/// <param name="regexp">(Optional) Properties list contains full regular expressions</param>
		/// <param name="properties">(Optional) List of properties to refresh Default: All properties in object</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL refresh_hw_sio(String hw_objects, bool? regexp = null, TCLParameterList properties = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: refresh_hw_sio [-regexp] [-properties <args>] [-quiet] [-verbose] <hw_objects>
			this.Entry(_builder.refresh_hw_sio(hw_objects, regexp, properties, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Refresh the status of the current hardware object. Inputs need to be any Soft MC object. At least<br/>
		/// one object is required. If properties are specified, but do not exist in the object, those properties<br/>
		/// will not be refreshed.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: refresh_hw_softmc [-regexp] [-properties &lt;args&gt;] [-quiet] [-verbose] &lt;hw_objects&gt;
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1216<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_objects">(Required) hardware Soft MC objects</param>
		/// <param name="regexp">(Optional) Properties list contains full regular expressions</param>
		/// <param name="properties">(Optional) List of properties to refresh Default: All properties in object</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL refresh_hw_softmc(String hw_objects, bool? regexp = null, TCLParameterList properties = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: refresh_hw_softmc [-regexp] [-properties <args>] [-quiet] [-verbose] <hw_objects>
			this.Entry(_builder.refresh_hw_softmc(hw_objects, regexp, properties, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Refresh the status of the current hardware object. Inputs can be hw_server, hw_target,<br/>
		/// hw_device or hw_sysmon objects. At least one object is required. If properties are specified that<br/>
		/// do not exist in the object, that property will not be refreshed.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: refresh_hw_sysmon [-regexp] [-properties &lt;args&gt;] [-quiet] [-verbose] &lt;hw_objects&gt;
		/// <br/>
		/// <para>
		/// Refresh the properties of the hw_sysmon object with the values on the system monitor (XADC)<br/>
		/// from the current hw_device.<br/>
		/// The refresh command takes the values from the status registers of the system monitor on the<br/>
		/// hardware device, and populates them into the appropriate properties of the hw_sysmon object in<br/>
		/// the hardware manager.<br/>
		/// TIP: The hw_sysmon object is automatically refreshed at the rate specified by the<br/>
		/// SYSMON_REFRESH_RATE_MS on the object.<br/>
		/// This command updates the properties on the hw_sysmon object, but otherwise returns nothing if<br/>
		/// successful. The command returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1217<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_objects">(Required) hardware objects</param>
		/// <param name="regexp">(Optional) Properties list contains full regular expressions</param>
		/// <param name="properties">(Optional) List of properties to refresh Default: All properties in object</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL refresh_hw_sysmon(String hw_objects, bool? regexp = null, TCLParameterList properties = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: refresh_hw_sysmon [-regexp] [-properties <args>] [-quiet] [-verbose] <hw_objects>
			this.Entry(_builder.refresh_hw_sysmon(hw_objects, regexp, properties, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Refresh a hardware target<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: refresh_hw_target [-force_poll] [-quiet] [-verbose] [&lt;hw_target&gt;]
		/// <br/>
		/// <para>
		/// Refresh the connection to the specified hardware target on the current hardware server, and<br/>
		/// reload the hw_target object in the Hardware Manager of the Vivado Design Suite. If no<br/>
		/// hw_target object is specified, the current_hw_target will be refreshed.<br/>
		/// The hardware target is a system board containing a JTAG chain of one or more Xilinx devices that<br/>
		/// you can program with a bitstream file, or use to debug your design. Connections between<br/>
		/// hardware targets on the system board and the Vivado Design Suite are managed by the Xilinx<br/>
		/// hardware server application, and the connect_hw_server command. Refer to Vivado Design<br/>
		/// Suite User Guide: Programming and Debugging (UG908) for a list of supported JTAG download<br/>
		/// cables and devices.<br/>
		/// Each hardware target can have one or more Xilinx devices to program, or to use for debugging<br/>
		/// purposes. The current device is specified or returned by the current_hw_device command.<br/>
		/// After specifying the current hardware target, you can open the connection through the hardware<br/>
		/// target, to the Xilinx FPGA using the open_hw_target command.<br/>
		/// refresh_hw_target scans the devices on the hardware target and creates, deletes, or<br/>
		/// updates the hw_device objects available through the target. Available devices are returned using<br/>
		/// the get_hw_devices command.<br/>
		/// This command returns a transcript of the refresh process, or returns an error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1219<br/>
		/// </para>
		/// </summary>
		/// <param name="force_poll">(Optional) Force poll of all targets</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_target">(Optional) hardware target</param>
		public VivadoTCL refresh_hw_target(bool? force_poll = null, bool? quiet = null, bool? verbose = null, String hw_target = null)
		{
			// TCL Syntax: refresh_hw_target [-force_poll] [-quiet] [-verbose] [<hw_target>]
			this.Entry(_builder.refresh_hw_target(force_poll, quiet, verbose, hw_target));
			return this;
		}
		/// <summary>
		/// <para>
		/// Update hardware probe INPUT_VALUE and ACTIVITY_VALUE properties with values read from<br/>
		/// hardware VIO core(s).<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: refresh_hw_vio [-update_output_values] [-quiet] [-verbose] &lt;hw_vios&gt;...
		/// <br/>
		/// <para>
		/// Update the INPUT_VALUE and ACTIVITY_VALUE properties of the input probes of the specified<br/>
		/// VIO debug cores with values read from the hw_vio core on the hardware device.<br/>
		/// The Virtual Input/Output (VIO) debug core can both monitor and drive internal signals on a<br/>
		/// programmed Xilinx device in real time. The VIO core uses hardware probes, hw_probe objects, to<br/>
		/// monitor and drive signals on the device. Input probes monitor signals as inputs to the VIO core.<br/>
		/// Output probes drive signals to specified values from the VIO core.<br/>
		/// The refresh_hw_vio command reads the signal values at the input probes of the VIO debug<br/>
		/// core on the device, and applies the value to the INPUT_VALUE property of the hw_probe, and<br/>
		/// updates the ACTIVITY_VALUE property on the probe as well.<br/>
		/// This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1221<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_vios">(Required) List of hardware VIO objects.</param>
		/// <param name="update_output_values">
		/// <para>
		/// (Optional)<br/>
		/// Update hardware probe OUTPUT_VALUE property with<br/>
		/// values read from VIO core(s).<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL refresh_hw_vio(TCLParameterList hw_vios, bool? update_output_values = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: refresh_hw_vio [-update_output_values] [-quiet] [-verbose] <hw_vios>...
			this.Entry(_builder.refresh_hw_vio(hw_vios, update_output_values, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Update and initialize the BRAM initialization strings with contents of elf files.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: refresh_meminit [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1223<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL refresh_meminit(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: refresh_meminit [-quiet] [-verbose]
			this.Entry(_builder.refresh_meminit(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Regenerate layout.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: regenerate_bd_layout [-hierarchy &lt;arg&gt;] [-layout_file &lt;arg&gt;] [-routing] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Regenerate the layout of the current IP integrator subsystem design in the open canvas. This<br/>
		/// command updates and redraws the graphical elements of the subsystem design in the Vivado<br/>
		/// IDE.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1224<br/>
		/// </para>
		/// </summary>
		/// <param name="hierarchy">(Optional) Hierarchy path to the window</param>
		/// <param name="layout_file">(Optional) layout file previously exported by write_bd_layout using native format</param>
		/// <param name="routing">(Optional) Preserve placement of blocks and regenerate routing</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL regenerate_bd_layout(String hierarchy = null, String layout_file = null, bool? routing = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: regenerate_bd_layout [-hierarchy <arg>] [-layout_file <arg>] [-routing] [-quiet] [-verbose]
			this.Entry(_builder.regenerate_bd_layout(hierarchy, layout_file, routing, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Register a Tcl proc with Vivado.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: register_proc [-quiet] [-verbose] &lt;proc&gt; [&lt;tasknm&gt;]
		/// <br/>
		/// <para>
		/// Register a Tcl procedure (proc) with the Vivado Tcl command interpretor to register the command<br/>
		/// with the Vivado Design Suite help system.<br/>
		/// The following is an example Tcl proc defined for use with the Vivado Design Suite:<br/>
		/// proc findCommand {option} {<br/>
		/// # Summary:<br/>
		/// # Searches through all Vivado Tcl commands for commands implementing<br/>
		/// # the specified argument.<br/>
		/// # Argument Usage:<br/>
		/// # option: Specifies the argument to search for.<br/>
		/// # Return Value:<br/>
		/// # Returns a list of Tcl commands that implement the option.<br/>
		/// # Categories: personal<br/>
		/// foreach cmd [lsort [info commands *]]<br/>
		/// {<br/>
		/// catch {<br/>
		/// if {[regexp "$option" [help -syntax $cmd]]}<br/>
		/// {<br/>
		/// puts $cmd<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// }<br/>
		/// }<br/>
		/// }<br/>
		/// } ;<br/>
		/// # End<br/>
		/// The commented lines beginning with '#' are used to define the help text for the registered<br/>
		/// command in the Vivado Design Suite help system.<br/>
		/// • # Summary: provides a brief description of the command.<br/>
		/// • # Argument Usage: provides a list and description of the various arguments for the proc.<br/>
		/// • # Return Value: provides a description of what is returned by the proc.<br/>
		/// • # Categories: provides an ability to define categories for registered procedures.<br/>
		/// After registering the procedure as a Tcl command, the Vivado help system will return this text<br/>
		/// when queried with:<br/>
		/// tasknm -help<br/>
		/// -or-<br/>
		/// help tasknm<br/>
		/// This command returns the name of the registered proc.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1226<br/>
		/// </para>
		/// </summary>
		/// <param name="proc">(Required) Name of proc to register. Proc must be known to Tcl</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="tasknm">
		/// <para>
		/// (Optional)<br/>
		/// Name of Tcl task that wraps the proc. Default: Register the<br/>
		/// proc using the root name proc (no namespaces).<br/>
		/// </para>
		/// </param>
		/// <returns>Nothing</returns>
		public VivadoTCL register_proc(String proc, bool? quiet = null, bool? verbose = null, String tasknm = null)
		{
			// TCL Syntax: register_proc [-quiet] [-verbose] <proc> [<tasknm>]
			this.Entry(_builder.register_proc(proc, quiet, verbose, tasknm));
			return this;
		}
		/// <summary>
		/// <para>
		/// Reimport files when they are found out-of-date<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: reimport_files [-force] [-quiet] [-verbose] [&lt;files&gt;...]
		/// <br/>
		/// <para>
		/// Reimports project files. This updates the local project files from the original referenced source<br/>
		/// files.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reimports all project files regardless of whether they are out of date, or<br/>
		/// the local files are newer than the referenced source file:<br/>
		/// reimport_files -force<br/>
		/// Note: No warnings will be issued for newer local files that will be overwritten.<br/>
		/// The following example reimports the specified files to the project, but only if the original source<br/>
		/// file is newer than the local project file:<br/>
		/// reimport_files C:/Data/FPGA_Design/source1.v \<br/>
		/// C:/Data/FPGA_Design/source2.vhdl<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1229<br/>
		/// </para>
		/// </summary>
		/// <param name="force">(Optional) Force a reimport to happen even when the local files may be newer</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="files">
		/// <para>
		/// (Optional)<br/>
		/// List of files to reimport. If no files are specified, all files in<br/>
		/// the project that are out-of-date, will be reimported<br/>
		/// </para>
		/// </param>
		/// <returns>list of file objects that were imported</returns>
		public VivadoTCL reimport_files(bool? force = null, bool? quiet = null, bool? verbose = null, TCLParameterList files = null)
		{
			// TCL Syntax: reimport_files [-force] [-quiet] [-verbose] [<files>...]
			this.Entry(_builder.reimport_files(force, quiet, verbose, files));
			return this;
		}
		/// <summary>
		/// <para>
		/// Recompile the design without changing compilation options and restart the current simulation<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: relaunch_sim [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Relaunch the simulator to perform analysis and verification of an updated design.<br/>
		/// The relaunch_sim command suspends the current simulation, recompiles the current design<br/>
		/// into a new simulation snapshot, then connects the current simulation to the new snapshot, and<br/>
		/// restarts the simulation.<br/>
		/// In the typical HDL debug cycle you will compile a design into a simulation snapshot and launch a<br/>
		/// simulation, configuring the Vivado simulator IDE to display the signals of interest in the<br/>
		/// waveform viewer, as well as the scopes and objects of interest. During the debug process you<br/>
		/// may discover issues with your code or test bench, make corrections to your design, recompile<br/>
		/// and relaunch the simulator.<br/>
		/// This command lets you recompile the design, and relaunch the simulator while preserving the<br/>
		/// current Vivado simulator configuration, such as open waveform and code windows, Scopes and<br/>
		/// Objects window settings.<br/>
		/// IMPORTANT! The relaunch_sim command applies only to simulations running in the Vivado Design<br/>
		/// Suite IDE, not stand-alone or batch Vivado simulator runs.<br/>
		/// This command returns a transcript of its process, or returns an error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following command relaunches the current simulation:<br/>
		/// relaunch_sim<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1231<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Current simulation object</returns>
		public VivadoTCL relaunch_sim(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: relaunch_sim [-quiet] [-verbose]
			this.Entry(_builder.relaunch_sim(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Remove breakpoints from a simulation<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: remove_bps [-all] [-file &lt;arg&gt;] [-line &lt;arg&gt;] [-quiet] [-verbose] [&lt;BreakPointObjsOrIds&gt;...]
		/// <br/>
		/// <para>
		/// Remove specified breakpoints from the current simulation. You must have an open simulation to<br/>
		/// use this command.<br/>
		/// A breakpoint is a user-determined stopping point in the source code used for debugging the<br/>
		/// design. When simulating a design with breakpoints, simulation of the design stops at each<br/>
		/// breakpoint to let you examine values and verify the design behavior.<br/>
		/// The breakpoints in the current simulation can be reported using the report_bps command.<br/>
		/// This command returns nothing, or an error if the command fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example removes all the breakpoints in the current simulation:<br/>
		/// remove_bps -all<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1233<br/>
		/// </para>
		/// </summary>
		/// <param name="all">(Optional) Remove all breakpoints</param>
		/// <param name="file">(Optional) The specific file to remove the breakpoint from given a line number</param>
		/// <param name="line">
		/// <para>
		/// (Optional)<br/>
		/// The specific line number to remove the breakpoint given a<br/>
		/// filename Default: -1<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="BreakPointObjsOrIds">
		/// <para>
		/// (Optional)<br/>
		/// A list of one or more breakpoint objects and/or breakpoint<br/>
		/// object ID's to be removed<br/>
		/// </para>
		/// </param>
		public VivadoTCL remove_bps(bool? all = null, String file = null, String line = null, bool? quiet = null, bool? verbose = null, TCLParameterList BreakPointObjsOrIds = null)
		{
			// TCL Syntax: remove_bps [-all] [-file <arg>] [-line <arg>] [-quiet] [-verbose] [<BreakPointObjsOrIds>...]
			this.Entry(_builder.remove_bps(all, file, line, quiet, verbose, BreakPointObjsOrIds));
			return this;
		}
		/// <summary>
		/// <para>
		/// Remove cells from the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: remove_cell [-quiet] [-verbose] &lt;cells&gt;...
		/// <br/>
		/// <para>
		/// Remove cells from the current netlist in either an open Synthesized or Implemented design.<br/>
		/// Note: You cannot remove cells from library macros, also called macro-primitives.<br/>
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not<br/>
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made<br/>
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or<br/>
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*<br/>
		/// command.<br/>
		/// Note: Netlist editing is not allowed on the elaborated RTL design.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example removes the fftEngine from the in-memory netlist of the current design:<br/>
		/// remove_cell fftEngine<br/>
		/// remove_cell usbEngine0/usb_out<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1235<br/>
		/// </para>
		/// </summary>
		/// <param name="cells">(Required) List of cells to remove</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL remove_cell(TCLParameterList cells, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_cell [-quiet] [-verbose] <cells>...
			this.Entry(_builder.remove_cell(cells, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Remove cells from a Pblock<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: remove_cells_from_pblock [-quiet] [-verbose] &lt;pblock&gt; &lt;cells&gt;...
		/// <br/>
		/// <para>
		/// Removes the specified logic instances from a Pblock. Cells are added to a Pblock with the<br/>
		/// add_cells_to_pblock command.<br/>
		/// Note: Cells that have been placed will not be unplaced as they are removed from a Pblock. Any current<br/>
		/// LOC assignments are left intact.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example removes the specified cells from the pb_cpuEngine Pblock:<br/>
		/// remove_cells_from_pblock pb_cpuEngine [get_cells cpuEngine/cpu_dwb_dat_o/*]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1237<br/>
		/// </para>
		/// </summary>
		/// <param name="pblock">(Required) Pblock to remove cells from</param>
		/// <param name="cells">(Required) Cells to remove</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL remove_cells_from_pblock(String pblock, TCLParameterList cells, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_cells_from_pblock [-quiet] [-verbose] <pblock> <cells>...
			this.Entry(_builder.remove_cells_from_pblock(pblock, cells, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Removes list of cluster configurations<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: remove_cluster_configurations [-quiet] [-verbose] &lt;cluster_configurations&gt;
		/// <br/>
		/// <para>
		/// Removes a list of cluster configurations. The list of cluster configurations to be removed is<br/>
		/// specified as input. This command can only remove user defined cluster configurations and cannot<br/>
		/// remove Vivado default cluster configurations. To identify if a cluster configuration is default or<br/>
		/// user-defined, use the following snippet:<br/>
		/// # if it returns 1 cluster configuration is Vivado default otherwise user<br/>
		/// defined.<br/>
		/// get_property IS_DEFAULT [get_cluster_configurations &lt;cluster configuration<br/>
		/// name&gt;]<br/>
		/// Currently, Vivado supports following clusters management tools:<br/>
		/// • Load Sharing Facility (LSF)<br/>
		/// • Sun Grid Engine (SGE)<br/>
		/// • Simple Linux Utility For Resource Management (SLURM)<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example removes the cluster configuration with name lsf_medium.<br/>
		/// remove_cluster_configurations [get_cluster_configurations lsf_medium]<br/>
		/// The following example removes all the user defined cluster configurations.<br/>
		/// remove_cluster_configurations [get_cluster_configurations -filter<br/>
		/// {IS_DEFAULT == 0}]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1239<br/>
		/// </para>
		/// </summary>
		/// <param name="cluster_configurations">(Required) List of cluster configurations</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL remove_cluster_configurations(String cluster_configurations, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_cluster_configurations [-quiet] [-verbose] <cluster_configurations>
			this.Entry(_builder.remove_cluster_configurations(cluster_configurations, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Remove conditions from a simulation. The names can be specified as Tcl glob pattern<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: remove_conditions [-all] [-quiet] [-verbose] [&lt;ConditionObjs&gt;]
		/// <br/>
		/// <para>
		/// Remove specified conditions from the current simulation. You must have an open simulation to<br/>
		/// use this command.<br/>
		/// Conditions can be defined prior to starting the simulation. When a condition is added, the<br/>
		/// simulator evaluates the condition expression anytime a signal change is detected. When a<br/>
		/// specified condition expression becomes TRUE, the condition commands are run.<br/>
		/// The conditions in the current simulation can be reported using the report_conditions<br/>
		/// command.<br/>
		/// This command returns nothing, or an error if the command fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example removes the specified condition from the current simulation:<br/>
		/// remove_conditions condition3<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1241<br/>
		/// </para>
		/// </summary>
		/// <param name="all">(Optional) Remove all conditions</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="ConditionObjs">(Optional) ConditionObjs, id's or names</param>
		public VivadoTCL remove_conditions(bool? all = null, bool? quiet = null, bool? verbose = null, String ConditionObjs = null)
		{
			// TCL Syntax: remove_conditions [-all] [-quiet] [-verbose] [<ConditionObjs>]
			this.Entry(_builder.remove_conditions(all, quiet, verbose, ConditionObjs));
			return this;
		}
		/// <summary>
		/// <para>
		/// Remove DRC rule check objects from a user rule deck<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: remove_drc_checks [-of_objects &lt;args&gt;] [-regexp] [-nocase] [-filter &lt;arg&gt;] -ruledeck &lt;arg&gt; [-quiet] [-verbose] [&lt;patterns&gt;]
		/// <br/>
		/// <para>
		/// Remove the specified design rule checks from a drc_ruledeck object.<br/>
		/// A rule deck is a collection of design rule checks grouped for convenience, to be run with the<br/>
		/// report_drc command at different stages of the FPGA design flow, such as during I/O planning<br/>
		/// or placement. The tool comes with a set of factory defined rule decks, but you can also create<br/>
		/// new user-defined rule decks with the create_drc_ruledeck command.<br/>
		/// Checks are added to a rule deck using the add_drc_checks command.<br/>
		/// The DRC rule check object features the IS_ENABLED property that can be set to true or false<br/>
		/// using the set_property command. When a new rule check is created, the IS_ENABLED<br/>
		/// property is set to true as a default. Set the IS_ENABLED property to false to disable the rule<br/>
		/// check from being used by report_drc without having to remove the rule from the rule deck.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// TIP: Use the reset_drc_check command to restore the DRC rule, and its properties, to the default<br/>
		/// settings.<br/>
		/// This command returns the list of design rule checks that were removed from the specified rule<br/>
		/// deck.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example removes the rule checks matching the specified filter pattern from the<br/>
		/// my_rules rule deck:<br/>
		/// remove_drc_checks -filter {GROUP == AVAL} -ruledeck my_rules<br/>
		/// The following example disables the specified DRC check without removing it from the rule deck:<br/>
		/// set_property IS_ENABLED FALSE [get_drc_checks RAMW-1]<br/>
		/// The following example removes all rule checks from the specified rule deck:<br/>
		/// remove_drc_checks -ruledeck my_rules<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1243<br/>
		/// </para>
		/// </summary>
		/// <param name="ruledeck">(Required) DRC rule deck to modify</param>
		/// <param name="of_objects">(Optional) Get 'rule_check' objects of these types: 'drc_ruledeck'.</param>
		/// <param name="regexp">(Optional) Patterns are full regular expressions</param>
		/// <param name="nocase">(Optional) Perform case-insensitive matching. (valid only when -regexp specified)</param>
		/// <param name="filter">(Optional) Filter list with expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="patterns">(Optional) Match the 'rule_check' objects against patterns. Default: *</param>
		/// <returns>drc_check</returns>
		public VivadoTCL remove_drc_checks(String ruledeck, TCLParameterList of_objects = null, bool? regexp = null, bool? nocase = null, String filter = null, bool? quiet = null, bool? verbose = null, String patterns = null)
		{
			// TCL Syntax: remove_drc_checks [-of_objects <args>] [-regexp] [-nocase] [-filter <arg>] -ruledeck <arg> [-quiet] [-verbose] [<patterns>]
			this.Entry(_builder.remove_drc_checks(ruledeck, of_objects, regexp, nocase, filter, quiet, verbose, patterns));
			return this;
		}
		/// <summary>
		/// <para>
		/// Remove files or directories from a fileset<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: remove_files [-fileset &lt;arg&gt;] [-quiet] [-verbose] &lt;files&gt;...
		/// <br/>
		/// <para>
		/// Removes the specified file objects from the current or specified fileset. The file is removed from<br/>
		/// the current project, but is not removed from the disk.<br/>
		/// Files can be specified as file name strings, or as file objects returned by the get_files<br/>
		/// command. When specified as strings, the file is looked for in the current or specified fileset.<br/>
		/// When the file object is specified by get_files, the fileset is defined by the object, and -<br/>
		/// fileset is ignored.<br/>
		/// When successful, this command returns nothing. If the specified file is not found, an error is<br/>
		/// returned.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example removes the file named C:/Design/top.xdc from the constraint set<br/>
		/// constrs_1:<br/>
		/// remove_files -fileset constrs_1 C:/Design/top.xdc<br/>
		/// Multiple files can be specified as follows:<br/>
		/// remove_files -fileset sim_1 top_tb1.vhdl top_tb2.vhdl<br/>
		/// The following example gets all the file objects in the current project, and removes them:<br/>
		/// remove_files [get_files]<br/>
		/// CAUTION! This will remove ALL files from your design.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1247<br/>
		/// </para>
		/// </summary>
		/// <param name="files">(Required) Name of the file(s) to be removed</param>
		/// <param name="fileset">(Optional) Fileset name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of files that were removed</returns>
		public VivadoTCL remove_files(TCLParameterList files, String fileset = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_files [-fileset <arg>] [-quiet] [-verbose] <files>...
			this.Entry(_builder.remove_files(files, fileset, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Release force on signal, wire, or reg applied using 'add_force' command<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: remove_forces [-all] [-quiet] [-verbose] [&lt;ForceObj&gt;...]
		/// <br/>
		/// <para>
		/// Remove the specified force objects, or force IDs from the current simulation.<br/>
		/// Forces are applied to specific HDL objects using the add_forces command. This command<br/>
		/// removes those forces from the current simulation.<br/>
		/// IMPORTANT! If there are force/release statements on an HDL object in the test bench or module,<br/>
		/// these statements are overridden by the add_force command. When the remove_force command<br/>
		/// releases these objects to resume their normal operation, the Verilog force/release statements<br/>
		/// resume their effect.<br/>
		/// This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates a force object using the add_force command, and captures the<br/>
		/// force ID in a Tcl variable, then removes that force object:<br/>
		/// set f10 [ add_force reset 1 300 ]<br/>
		/// remove_forces $f10<br/>
		/// The following example removes all force objects from the current simulation:<br/>
		/// remove_forces -all<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1249<br/>
		/// </para>
		/// </summary>
		/// <param name="all">(Optional) Remove all forces</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="ForceObj">(Optional) ForceObj or id's</param>
		public VivadoTCL remove_forces(bool? all = null, bool? quiet = null, bool? verbose = null, TCLParameterList ForceObj = null)
		{
			// TCL Syntax: remove_forces [-all] [-quiet] [-verbose] [<ForceObj>...]
			this.Entry(_builder.remove_forces(all, quiet, verbose, ForceObj));
			return this;
		}
		/// <summary>
		/// <para>
		/// Remove power sources from Power Rail<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: remove_from_power_rail [-power_sources &lt;args&gt;] [-quiet] [-verbose] &lt;power_rail&gt;
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1251<br/>
		/// </para>
		/// </summary>
		/// <param name="power_rail">(Required) Power rail to remove power sources from</param>
		/// <param name="power_sources">
		/// <para>
		/// (Optional)<br/>
		/// List of power sources to remove. Can be power rails and/or<br/>
		/// power supplies<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL remove_from_power_rail(String power_rail, TCLParameterList power_sources = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_from_power_rail [-power_sources <args>] [-quiet] [-verbose] <power_rail>
			this.Entry(_builder.remove_from_power_rail(power_rail, power_sources, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Remove one or more custom command arguments<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: remove_gui_custom_command_args -command_name &lt;arg&gt; [-quiet] [-verbose] &lt;names&gt;...
		/// <br/>
		/// <para>
		/// Remove one or more GUI custom command arguments of a particular GUI custom command.<br/>
		/// You can use the get_gui_custom_commands to determine the list of defined custom<br/>
		/// commands. You can use the get_gui_custom_command_args to determine the list of<br/>
		/// defined GUI custom command arguments for a particular GUI custom command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// Remove GUI custom command arguments with name 'arg1' and 'arg2' of a GUI custom command<br/>
		/// with name 'cmd_1' :<br/>
		/// remove_gui_custom_command_args -command_name cmd_1 {arg1 arg2}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1252<br/>
		/// </para>
		/// </summary>
		/// <param name="command_name">(Required) name of custom command whose arguments are being removed.</param>
		/// <param name="names">(Required) name of one or more custom command arguments to remove.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL remove_gui_custom_command_args(String command_name, TCLParameterList names, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_gui_custom_command_args -command_name <arg> [-quiet] [-verbose] <names>...
			this.Entry(_builder.remove_gui_custom_command_args(command_name, names, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Remove one or more custom commands<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: remove_gui_custom_commands [-quiet] [-verbose] &lt;names&gt;...
		/// <br/>
		/// <para>
		/// Remove one or more GUI custom commands.<br/>
		/// You can use the get_gui_custom_commands to determine the list of defined custom<br/>
		/// commands.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example removes the GUI custom commands with names 'abc' and 'xyz':<br/>
		/// remove_gui_custom_commands {abc xyz}<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1254<br/>
		/// </para>
		/// </summary>
		/// <param name="names">(Required) name of one or more custom commands to remove</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL remove_gui_custom_commands(TCLParameterList names, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_gui_custom_commands [-quiet] [-verbose] <names>...
			this.Entry(_builder.remove_gui_custom_commands(names, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// De-select Pseudo Channel from Activity Monitor on the specified hardware HBM(s). Must<br/>
		/// specify the Memory Controller number first, follow by Pseudo Channel number.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: remove_hw_hbm_pc [-quiet] [-verbose] &lt;mc_num&gt; &lt;pc_num&gt; &lt;hw_objects&gt;
		/// <br/>
		/// <para>
		/// The remove_hw_hbm_pc command removes a memory channel (mc)/psuedo channel (pc) that<br/>
		/// has been previously added to an HBM activity monitor using the add_hw_hbm_pc command.<br/>
		/// TIP: The HBM activity monitor must not be running when adding or removing psuedo channels.<br/>
		/// This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example removes the previously added psuedo channel from the HBM activity<br/>
		/// monitor, and then runs the activity monitor:<br/>
		/// remove_hw_hbm_pc 2 0 [get_hw_hbms *HBM_2]<br/>
		/// run_hw_hbm_amon [get_hw_hbms *HBM_2]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1256<br/>
		/// </para>
		/// </summary>
		/// <param name="mc_num">(Required) Memory Controller number to de-select: 0 to 7</param>
		/// <param name="pc_num">(Required) Pseudo Channel number to de-select: 0 or 1</param>
		/// <param name="hw_objects">(Required) hardware objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL remove_hw_hbm_pc(String mc_num, String pc_num, String hw_objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_hw_hbm_pc [-quiet] [-verbose] <mc_num> <pc_num> <hw_objects>
			this.Entry(_builder.remove_hw_hbm_pc(mc_num, pc_num, hw_objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Remove enumerated name-value pairs from a hw_probe enumeration.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: remove_hw_probe_enum [-no_gui_update] [-list &lt;args&gt;] [-remove_all] [-quiet] [-verbose] &lt;hw_probe&gt;
		/// <br/>
		/// <para>
		/// Remove the enumerated name/value pairs defined on a specified hw_probe object.<br/>
		/// The enumerated names (ENUM property) are added to a hw_probe object using the<br/>
		/// add_hw_probe_enum command. This command removes those defined properties.<br/>
		/// This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example removes the list of enumerated names from the specified hw_probe<br/>
		/// object:<br/>
		/// remove_hw_probe_enum -list {WHITE YELLOW GREY} \<br/>
		/// [get_hw_probes op1 -of_objects [current_hw_ila]]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1258<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_probe">(Required) ILA hardware probe object.</param>
		/// <param name="no_gui_update">(Optional) Defer GUI update.</param>
		/// <param name="list">(Optional) List of enumerated names to remove.</param>
		/// <param name="remove_all">(Optional) Remove the whole enumeration for a hardware probe. Default: 0</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL remove_hw_probe_enum(String hw_probe, bool? no_gui_update = null, TCLParameterList list = null, bool? remove_all = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_hw_probe_enum [-no_gui_update] [-list <args>] [-remove_all] [-quiet] [-verbose] <hw_probe>
			this.Entry(_builder.remove_hw_probe_enum(hw_probe, no_gui_update, list, remove_all, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Remove an existing hardware SIO link.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: remove_hw_sio_link [-quiet] [-verbose] &lt;hw_sio_links&gt;
		/// <br/>
		/// <para>
		/// Removes the specified communication links between TX and RX objects on the GTs of the IBERT<br/>
		/// debug core defined on the current hardware device.<br/>
		/// Vivado Serial I/O analyzer is a link-based analyzer, which lets you link between any transmitter<br/>
		/// and receiver within the IBERT design. The links define the communication paths and protocols<br/>
		/// between transmitters and receivers of the GigaBit transceivers on the device. This command<br/>
		/// removes those links.<br/>
		/// This command returns a list of link objects on the IBERT debug core, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1260<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_sio_links">(Required) hardware SIO links</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL remove_hw_sio_link(String hw_sio_links, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_hw_sio_link [-quiet] [-verbose] <hw_sio_links>
			this.Entry(_builder.remove_hw_sio_link(hw_sio_links, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Remove an existing hardware SIO link group.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: remove_hw_sio_linkgroup [-quiet] [-verbose] &lt;hw_sio_linkgroups&gt;
		/// <br/>
		/// <para>
		/// Removes the specified group that associates communication links between TX and RX objects on<br/>
		/// the GTs of the IBERT debug core defined on the current hardware device.<br/>
		/// Vivado Serial I/O analyzer is a link-based analyzer. The links define the communication paths and<br/>
		/// protocols between transmitters and receivers of the GigaBit transceivers on the device. Link<br/>
		/// groups, or hw_sio_linkgroup objects, let you associate links into related groups, to collectively<br/>
		/// configure properties and run scans.<br/>
		/// TIP: The remove_hw_sio_linkgroup command removes the specified association, but does not<br/>
		/// remove the underlying communication links. Us the remove_hw_sio_link command to remove those<br/>
		/// objects.<br/>
		/// This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1262<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_sio_linkgroups">(Required) hardware SIO linkgroups</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL remove_hw_sio_linkgroup(String hw_sio_linkgroups, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_hw_sio_linkgroup [-quiet] [-verbose] <hw_sio_linkgroups>
			this.Entry(_builder.remove_hw_sio_linkgroup(hw_sio_linkgroups, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Remove an existing hardware SIO scan.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: remove_hw_sio_scan [-quiet] [-verbose] &lt;hw_sio_scans&gt;
		/// <br/>
		/// <para>
		/// Remove the specified serial I/O analyzer scan object.<br/>
		/// This command returns nothing if successful, or returns an error if the command fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1264<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_sio_scans">(Required) hardware SIO scans</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL remove_hw_sio_scan(String hw_sio_scans, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_hw_sio_scan [-quiet] [-verbose] <hw_sio_scans>
			this.Entry(_builder.remove_hw_sio_scan(hw_sio_scans, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Remove an existing hardware SIO sweep.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: remove_hw_sio_sweep [-quiet] [-verbose] &lt;hw_sio_sweeps&gt;
		/// <br/>
		/// <para>
		/// Remove the specified serial I/O analyzer sweep scan object.<br/>
		/// This command returns nothing if successful, or returns an error if the command fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1266<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_sio_sweeps">(Required) hardware SIO sweeps</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL remove_hw_sio_sweep(String hw_sio_sweeps, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_hw_sio_sweep [-quiet] [-verbose] <hw_sio_sweeps>
			this.Entry(_builder.remove_hw_sio_sweep(hw_sio_sweeps, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Remove nets from the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: remove_net [-prune] [-quiet] [-verbose] &lt;nets&gt;...
		/// <br/>
		/// <para>
		/// Remove the specified net from the netlist of an open Synthesized or Implemented Design.<br/>
		/// Note: You cannot remove nets from library macros, also called macro-primitives.<br/>
		/// To remove a bus, you must specify the primary bus name, and not specify a bus index. This<br/>
		/// ensures that the entire bus is removed, and not just a portion of the bits associated with the bus.<br/>
		/// You can resize a bus, eliminating bits of the bus, using the resize_net_bus command.<br/>
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not<br/>
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made<br/>
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or<br/>
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*<br/>
		/// command.<br/>
		/// Note: Netlist editing is not allowed on the elaborated RTL design.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1268<br/>
		/// </para>
		/// </summary>
		/// <param name="nets">(Required) List of nets to remove</param>
		/// <param name="prune">
		/// <para>
		/// (Optional)<br/>
		/// When performing net removal, remove pins and ports which<br/>
		/// are left unconnected as a result of the remove_net<br/>
		/// operation.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL remove_net(TCLParameterList nets, bool? prune = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_net [-prune] [-quiet] [-verbose] <nets>...
			this.Entry(_builder.remove_net(nets, prune, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Remove pins from the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: remove_pin [-quiet] [-verbose] &lt;pins&gt;...
		/// <br/>
		/// <para>
		/// Remove pins from the current netlist in either an open Synthesized or Implemented design.<br/>
		/// Note: You cannot remove pins from library macros, or macro-primitives.<br/>
		/// To remove a bus pin, you must specify the primary pin name, and not specify a bus index. This<br/>
		/// ensures that the entire bus pin is removed, and not just a portion of the bits associated with the<br/>
		/// bus. You can resize a bus pin, eliminating bits, using the resize_pin_bus command.<br/>
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not<br/>
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made<br/>
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or<br/>
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*<br/>
		/// command.<br/>
		/// Note: Netlist editing is not allowed on the elaborated RTL design.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example removes the specified pin from the cpuEngine in the in-memory netlist of<br/>
		/// the current design:<br/>
		/// remove_pin cpuEngine/inPin<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1270<br/>
		/// </para>
		/// </summary>
		/// <param name="pins">(Required) List of pins to remove</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL remove_pin(TCLParameterList pins, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_pin [-quiet] [-verbose] <pins>...
			this.Entry(_builder.remove_pin(pins, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Remove the given list of top ports from the netlist.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: remove_port [-quiet] [-verbose] &lt;ports&gt;...
		/// <br/>
		/// <para>
		/// Removes the specified ports or buses.<br/>
		/// To remove a bus port, you must specify the primary port name, and not specify a bus index. This<br/>
		/// ensures that the entire bus port is removed, and not just a portion of the bits associated with the<br/>
		/// bus. You can resize a bus port, eliminating bits, using the resize_port_bus command.<br/>
		/// The remove_port command will remove ports that have been added with the create_port<br/>
		/// command, but cannot delete ports that are defined in the RTL or netlist design.<br/>
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not<br/>
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made<br/>
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or<br/>
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*<br/>
		/// command.<br/>
		/// Note: Netlist editing is not allowed on the elaborated RTL design.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example deletes the specified port:<br/>
		/// remove_port PORT0<br/>
		/// The following example deletes the two specified ports of a bus:<br/>
		/// remove_port BUS[1] BUS[2]<br/>
		/// The following example deletes both the N and P sides of a differential pair port:<br/>
		/// remove_port D_BUS_P[0]<br/>
		/// Note: Deleting either the N or the P side of a differential pair will also delete the other side of the pair.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1272<br/>
		/// </para>
		/// </summary>
		/// <param name="ports">(Required) Ports and/or bus ports to remove</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL remove_port(TCLParameterList ports, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_port [-quiet] [-verbose] <ports>...
			this.Entry(_builder.remove_port(ports, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Removes wave objects from the current wave configuration<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: remove_wave [-of &lt;args&gt;] [-quiet] [-verbose] &lt;items&gt;...
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1274<br/>
		/// </para>
		/// </summary>
		/// <param name="items">(Required) wave objects to remove</param>
		/// <param name="of">
		/// <para>
		/// (Optional)<br/>
		/// the wave configuration, group, or virtual bus to search<br/>
		/// Default: the current wave configuration<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL remove_wave(TCLParameterList items, TCLParameterList of = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: remove_wave [-of <args>] [-quiet] [-verbose] <items>...
			this.Entry(_builder.remove_wave(items, of, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// rename a cell<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: rename_cell -to &lt;arg&gt; [-quiet] [-verbose] &lt;cell&gt;...
		/// <br/>
		/// <para>
		/// Rename a single hierarchical or leaf-level cell in the current synthesized or implemented design.<br/>
		/// TIP: You cannot rename cells with DONT_TOUCH property set to TRUE.<br/>
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not<br/>
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made<br/>
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or<br/>
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*<br/>
		/// command.<br/>
		/// Note: Netlist editing is not allowed on the elaborated RTL design.<br/>
		/// Changes to the names of cells, nets, pins, and ports, will also affect the design constraints defined<br/>
		/// in the in-memory design. Constraints are automatically modified to target the new object name,<br/>
		/// however these are not written back to the source XDC file. Saving the modified in-memory<br/>
		/// design using write_checkpoint will save both the renamed objects and modified constraints.<br/>
		/// This command returns nothing if successful, or an error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example changes the name of the hierarchical or1200_cpu cell as specified:<br/>
		/// rename_cell -to or1200_gpu or1200_cpu<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1275<br/>
		/// </para>
		/// </summary>
		/// <param name="to">(Required) New name</param>
		/// <param name="cell">(Required) Cell to rename</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL rename_cell(String to, TCLParameterList cell, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: rename_cell -to <arg> [-quiet] [-verbose] <cell>...
			this.Entry(_builder.rename_cell(to, cell, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// rename a net<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: rename_net -to &lt;arg&gt; [-quiet] [-verbose] &lt;net&gt;...
		/// <br/>
		/// <para>
		/// Rename a net in the current synthesized or implemented design.<br/>
		/// The following are limitations with regard to renaming nets:<br/>
		/// • You cannot rename nets that have DONT_TOUCH or MARK_DEBUG properties set to TRUE.<br/>
		/// • You cannot rename individual bits of a bus net, but you can collectively rename the whole bus.<br/>
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not<br/>
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made<br/>
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or<br/>
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*<br/>
		/// command.<br/>
		/// Note: Netlist editing is not allowed on the elaborated RTL design.<br/>
		/// Changes to the names of cells, nets, pins, and ports, will also affect the design constraints defined<br/>
		/// in the in-memory design. Constraints are automatically modified to target the new object name,<br/>
		/// however these are not written back to the source XDC file. Saving the modified in-memory<br/>
		/// design using write_checkpoint will save both the renamed objects and modified constraints.<br/>
		/// This command returns nothing if successful, or an error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example renames the specified bus signal:<br/>
		/// rename_net -to dataOut dout<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1277<br/>
		/// </para>
		/// </summary>
		/// <param name="to">(Required) New name</param>
		/// <param name="net">(Required) Net to rename</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL rename_net(String to, TCLParameterList net, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: rename_net -to <arg> [-quiet] [-verbose] <net>...
			this.Entry(_builder.rename_net(to, net, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// rename a pin<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: rename_pin -to &lt;arg&gt; [-quiet] [-verbose] &lt;pin&gt;...
		/// <br/>
		/// <para>
		/// Rename the specified pin on a hierarchical cell in the current synthesized or implemented design.<br/>
		/// The following are limitations with regard to renaming pins:<br/>
		/// • Pins on primitive cells cannot be renamed.<br/>
		/// • A pin on a hierarchical cell that has the DONT_TOUCH property can be renamed, but a pin on<br/>
		/// an hierarchical cell inside a DON'T_TOUCH cell cannot be renamed.<br/>
		/// • You cannot rename individual bits of a bus pin, but you can collectively rename the whole bus.<br/>
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not<br/>
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made<br/>
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or<br/>
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*<br/>
		/// command.<br/>
		/// Note: Netlist editing is not allowed on the elaborated RTL design.<br/>
		/// Changes to the names of cells, nets, pins, and ports, will also affect the design constraints defined<br/>
		/// in the in-memory design. Constraints are automatically modified to target the new object name,<br/>
		/// however these are not written back to the source XDC file. Saving the modified in-memory<br/>
		/// design using write_checkpoint will save both the renamed objects and modified constraints.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This command returns nothing if successful, or an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example renames the specified pin:<br/>
		/// rename_pin -to in1 egressLoop[0].egressFifo/I1<br/>
		/// The following example shows the error that is returned when you try to rename a single bit of a<br/>
		/// bus, and then renames the whole bus pin:<br/>
		/// rename_pin -to din[0] egressLoop[0].egressFifo/buffer_fifo/dataInput[0]<br/>
		/// WARNING: [Coretcl 2-1480] rename_pin can not rename bits of a bus, \<br/>
		/// use resize_pin_bus instead.<br/>
		/// rename_pin -to dataInput egressLoop[0].egressFifo/buffer_fifo/din<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1279<br/>
		/// </para>
		/// </summary>
		/// <param name="to">(Required) New name</param>
		/// <param name="pin">(Required) Pin to rename</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL rename_pin(String to, TCLParameterList pin, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: rename_pin -to <arg> [-quiet] [-verbose] <pin>...
			this.Entry(_builder.rename_pin(to, pin, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// rename a port<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: rename_port -to &lt;arg&gt; [-quiet] [-verbose] &lt;port&gt;...
		/// <br/>
		/// <para>
		/// Rename a single port in the current synthesized or implemented design.<br/>
		/// TIP: You cannot rename individual bits of a bus port, but you can collectively rename the whole bus.<br/>
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not<br/>
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made<br/>
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or<br/>
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*<br/>
		/// command.<br/>
		/// Note: Netlist editing is not allowed on the elaborated RTL design.<br/>
		/// Changes to the names of cells, nets, pins, and ports, will also affect the design constraints defined<br/>
		/// in the in-memory design. Constraints are automatically modified to target the new object name,<br/>
		/// however these are not written back to the source XDC file. Saving the modified in-memory<br/>
		/// design using write_checkpoint will save both the renamed objects and modified constraints.<br/>
		/// This command returns nothing if successful, or an error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example renames the specified bus port:<br/>
		/// rename_port -to wbInputData wbInDat<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1282<br/>
		/// </para>
		/// </summary>
		/// <param name="to">(Required) New name</param>
		/// <param name="port">(Required) Port to rename</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL rename_port(String to, TCLParameterList port, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: rename_port -to <arg> [-quiet] [-verbose] <port>...
			this.Entry(_builder.rename_port(to, port, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// rename a cell ref<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: rename_ref [-ref &lt;arg&gt;] [-to &lt;arg&gt;] [-prefix_all &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Rename the reference name of a single non-primitive cell, or apply a reference prefix to all non-primitive cells in the current synthesized or implemented design.<br/>
		/// This command provides a mechanism to change the non-primitive reference names in the current<br/>
		/// design so that they do not collide with the reference names in another design. This lets two<br/>
		/// modules or designs be synthesized or simulated together, while avoiding any name collisions<br/>
		/// between the two designs.<br/>
		/// This command returns nothing when renaming the reference a single cell, and returns the<br/>
		/// number of cells renamed when used with -prefix_all. If the command fails, an error is<br/>
		/// returned.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example changes the specified reference name to the value indicated:<br/>
		/// rename_ref -ref usbf_top -to MOD1_usbf_top<br/>
		/// The following example applies the specified reference name prefix to all non-primitive cells in the<br/>
		/// current design:<br/>
		/// rename_ref -prefix_all MOD1_<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1284<br/>
		/// </para>
		/// </summary>
		/// <param name="ref">(Optional) Cell ref to rename</param>
		/// <param name="to">(Optional) New name</param>
		/// <param name="prefix_all">
		/// <para>
		/// (Optional)<br/>
		/// Rename all eligible hierarchical cell refs in the current<br/>
		/// design. Construct the new name using the given prefix plus<br/>
		/// the original name<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL rename_ref(String @ref = null, String to = null, String prefix_all = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: rename_ref [-ref <arg>] [-to <arg>] [-prefix_all <arg>] [-quiet] [-verbose]
			this.Entry(_builder.rename_ref(@ref, to, prefix_all, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Change the order of source files in the active fileset<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: reorder_files [-fileset &lt;arg&gt;] [-before &lt;arg&gt;] [-after &lt;arg&gt;] [-front] [-back] [-auto] [-disable_unused] [-quiet] [-verbose] &lt;files&gt;...
		/// <br/>
		/// <para>
		/// Reorders source files in the specified fileset. Takes the files indicated and places them at the front<br/>
		/// of, the back of, or before or after other files within the fileset. This command also has an auto<br/>
		/// reorder feature that reorders the files based on the requirements of the current top module in<br/>
		/// the design.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example takes the specified files and moves them to the front of the source fileset:<br/>
		/// reorder_files -front {C:/Data/FPGA/file1.vhdl C:/Data/FPGA/file2.vhdl}<br/>
		/// Note: The default source fileset is used in the preceding example since the -fileset argument is not<br/>
		/// specified.<br/>
		/// The following example sets a new top_module in the design, and then automatically reorders and<br/>
		/// disables unused files based on the hierarchy of the new top-module:<br/>
		/// set_property top block1 [current_fileset]<br/>
		/// reorder_files -auto -disable_unused<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1286<br/>
		/// </para>
		/// </summary>
		/// <param name="files">(Required) Files to move</param>
		/// <param name="fileset">(Optional) Fileset to reorder</param>
		/// <param name="before">(Optional) Move the listed files before this file</param>
		/// <param name="after">(Optional) Move the listed files after this file</param>
		/// <param name="front">(Optional) Move the listed files to the front (default)</param>
		/// <param name="back">(Optional) Move the listed files to the back</param>
		/// <param name="auto">(Optional) Automatically re-orders the given fileset</param>
		/// <param name="disable_unused">(Optional) Disables all files not associated with the TOP design unit</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL reorder_files(TCLParameterList files, String fileset = null, String before = null, String after = null, bool? front = null, bool? back = null, bool? auto = null, bool? disable_unused = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reorder_files [-fileset <arg>] [-before <arg>] [-after <arg>] [-front] [-back] [-auto] [-disable_unused] [-quiet] [-verbose] <files>...
			this.Entry(_builder.reorder_files(files, fileset, before, after, front, back, auto, disable_unused, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Replace cell1 with cell2 by disconnecting connections to cell1 and connecting those connections<br/>
		/// to cell2.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: replace_bd_cell [-preserve_name] [-preserve_configuration] [-quiet] [-verbose] [&lt;cell1&gt;] [&lt;cell2&gt;...]
		/// <br/>
		/// <para>
		/// Move the connections currently assigned to one IP integrator cell to another IP integrator cell in<br/>
		/// the current design. This is intended to help you quickly replace one cell with another by moving<br/>
		/// connections from the source cell to the target cell.<br/>
		/// The current, or existing cell, will be relocated from its current position in the block design, and<br/>
		/// the new replacing cell will be placed at that location. Connections to the pins and interface pins<br/>
		/// on the cell are preserved where possible, and result in a Critical Warning when connections must<br/>
		/// be removed.<br/>
		/// IMPORTANT! This command is not supported by the UNDO command.<br/>
		/// This command returns TCL_OK if it is successful, or returns TCL_ERROR if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1288<br/>
		/// </para>
		/// </summary>
		/// <param name="cell1">(Required) Cell with connections that are to be disconnected.</param>
		/// <param name="preserve_name">(Optional) cell2 will rename as cell1's name, cell1 rename as cell1name_old</param>
		/// <param name="preserve_configuration">(Optional) preserve configuration of cell1 on cell2</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="cell2">(Optional) Cell to be connected to connections that were disconnected from cell1.</param>
		/// <returns>TCL_OK, TCL_ERROR if failed.</returns>
		public VivadoTCL replace_bd_cell(String cell1, bool? preserve_name = null, bool? preserve_configuration = null, bool? quiet = null, bool? verbose = null, TCLParameterList cell2 = null)
		{
			// TCL Syntax: replace_bd_cell [-preserve_name] [-preserve_configuration] [-quiet] [-verbose] [<cell1>] [<cell2>...]
			this.Entry(_builder.replace_bd_cell(cell1, preserve_name, preserve_configuration, quiet, verbose, cell2));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report differences between two block designs. Note this TCL command may compare bus-interface parameters from IP .xit files that are not reported in the stand-alone diffbd executable.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_bd_diffs [-format &lt;arg&gt;] [-file &lt;arg&gt;] [-open_html] [-brief] [-strict] [-fast] [-return_string] [-depth &lt;arg&gt;] [-crossprobe] [-repository &lt;arg&gt;] [-take_snapshot] [-diff_snapshot] [-quiet] [-verbose] &lt;design1&gt; &lt;design2&gt;
		/// <br/>
		/// <para>
		/// Analyze and report the difference between two block design files (.bd).<br/>
		/// TIP: There is also a standalone version of this command, diffbd , that can be run from the command<br/>
		/// line. You can find out more information about this command by typing diffbd -h from the command<br/>
		/// line. Refer to the Vivado Design Suite User Guide: Designing IP Subsystems using IP Integrator (UG994) for<br/>
		/// more informaiton.<br/>
		/// This command performs a non-graphical comparison of two block designs to let you compare<br/>
		/// revisions of a block design from within revision control systems. Block designs must be specified<br/>
		/// as BD objects, as returned by current_bd_design, or get_bd_designs commands. The<br/>
		/// design objects can have the same name, but be returned from different .bd files. An error will be<br/>
		/// returned if the BD objects refer to the same design.<br/>
		/// The differences reported include additions, or changes to the IP in use in the block diagram,<br/>
		/// changes to design properties or parameters, changes to the design hierarchy, changes to<br/>
		/// connectivity, and changes memory addressing.<br/>
		/// This command returns the difference report for the two block designs specified, or returns an<br/>
		/// error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example compares the two specified block designs, one from a file path, the<br/>
		/// second from the current open block design, and creates and opens an HTML report format with<br/>
		/// the specified depth:<br/>
		/// report_bd_diffs C:/Data/Base_Zynq_MPSoC.bd [current_bd_design] \<br/>
		/// -file C:/Data/diffs5.htm -open_html -depth 5<br/>
		/// The following example takes a snapshot of the current open block design:<br/>
		/// report_bd_diffs -take_snapshot<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1291<br/>
		/// </para>
		/// </summary>
		/// <param name="design1">(Required) Name or file path of first block design to compare</param>
		/// <param name="design2">(Required) Name or file path of second block design to compare</param>
		/// <param name="format">(Optional) Format: html or text Default: text</param>
		/// <param name="file">(Optional) Optional output file name. *.htm* implies HTML format</param>
		/// <param name="open_html">(Optional) Open HTML report in a browser. Sets format to HTML</param>
		/// <param name="brief">(Optional) Output only whether files differ. Don't write report</param>
		/// <param name="strict">(Optional) Non-functional changes are treated as functional changes</param>
		/// <param name="fast">
		/// <para>
		/// (Optional)<br/>
		/// Read BD JSON directly instead of creating in-memory BDs<br/>
		/// when possible. Will not compare Bus-Interface parameters<br/>
		/// from .XIT files (same as stand-alone diffbd)<br/>
		/// </para>
		/// </param>
		/// <param name="return_string">(Optional) (Text only) Return the report as a string</param>
		/// <param name="depth">
		/// <para>
		/// (Optional)<br/>
		/// HTML Display Depth for equal items. Used to limit HTML file<br/>
		/// size. Does not affect not-equal items. Implies HTML format.<br/>
		/// Default: 4<br/>
		/// </para>
		/// </param>
		/// <param name="crossprobe">
		/// <para>
		/// (Optional)<br/>
		/// Enable links on HTML report to select Vivado objects.<br/>
		/// Implies open_html<br/>
		/// </para>
		/// </param>
		/// <param name="repository">(Optional) User repository for designs on disk</param>
		/// <param name="take_snapshot">(Optional) Take a snapshot of the current block design</param>
		/// <param name="diff_snapshot">(Optional) Compare the current block design against a snapshot</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>0 if no functional differences, &gt;0 if different, -1 on error</returns>
		public VivadoTCL report_bd_diffs(String design1, String design2, String format = null, String file = null, bool? open_html = null, bool? brief = null, bool? strict = null, bool? fast = null, bool? return_string = null, String depth = null, bool? crossprobe = null, String repository = null, bool? take_snapshot = null, bool? diff_snapshot = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_bd_diffs [-format <arg>] [-file <arg>] [-open_html] [-brief] [-strict] [-fast] [-return_string] [-depth <arg>] [-crossprobe] [-repository <arg>] [-take_snapshot] [-diff_snapshot] [-quiet] [-verbose] <design1> <design2>
			this.Entry(_builder.report_bd_diffs(design1, design2, format, file, open_html, brief, strict, fast, return_string, depth, crossprobe, repository, take_snapshot, diff_snapshot, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Print details of the given breakpoint objects<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_bps [-quiet] [-verbose] [&lt;BreakPointObjs&gt;...]
		/// <br/>
		/// <para>
		/// Report a specific breakpoint object, or report all breakpoints in the current simulation. You must<br/>
		/// have an open simulation for this command to return anything.<br/>
		/// A breakpoint is a user-determined stopping point in the source code used for debugging the<br/>
		/// design. When simulating a design with breakpoints, simulation of the design stops at each<br/>
		/// breakpoint to let you examine values and verify the design behavior.<br/>
		/// This command returns the filename and line number of the specified breakpoints, or of all<br/>
		/// breakpoints in the current simulation, or returns an error if the command fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports all breakpoints in the current simulation:<br/>
		/// report_bps<br/>
		/// This example reports the specified breakpoints in the current simulation:<br/>
		/// report_bps bp1 bp2 bp5<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1295<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="BreakPointObjs">(Optional) List of breakpoint objects to report</param>
		/// <returns>Print the breakpoints id, file_name and line_number to the console in textual format</returns>
		public VivadoTCL report_bps(bool? quiet = null, bool? verbose = null, TCLParameterList BreakPointObjs = null)
		{
			// TCL Syntax: report_bps [-quiet] [-verbose] [<BreakPointObjs>...]
			this.Entry(_builder.report_bps(quiet, verbose, BreakPointObjs));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report timing paths<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_bus_skew [-delay_type &lt;arg&gt;] [-setup] [-hold] [-no_detailed_paths] [-max_paths &lt;arg&gt;] [-nworst &lt;arg&gt;] [-unique_pins] [-path_type &lt;arg&gt;] [-sort_by_slack] [-input_pins] [-no_header] [-significant_digits &lt;arg&gt;] [-file &lt;arg&gt;] [-append] [-return_string] [-warn_on_violation] [-rpx &lt;arg&gt;] [-cells &lt;args&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Report the calculated bus skew among the signals constrained by set_bus_skew.<br/>
		/// The bus skew requirement applies to both the slow and fast corners. The Vivado tool determines<br/>
		/// the earliest and the latest arrival among all the signals of the bus and calculates the bus skew for<br/>
		/// both the Slow and Fast process corner, and reports the worst case skew. Each signal of the bus is<br/>
		/// reported relative to a reference signal from the same bus. Note that the reference signal can be<br/>
		/// different for each signal of the bus, which ever results in the worst bus skew for that signal.<br/>
		/// The bus skew report can be written to the Tcl console or command shell, assigned to a return<br/>
		/// string, or saved to a file.<br/>
		/// This command returns the bus skew report as specified, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports the bus skew for the 32 worst signals of each bus skew<br/>
		/// constraints in the design, reporting 1 path per bit of the bus with the full timing path, including<br/>
		/// input pins, with timing values:<br/>
		/// report_bus_skew -max 32 -nworst 1 -path_type full -input_pins<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1297<br/>
		/// </para>
		/// </summary>
		/// <param name="delay_type">(Optional) Type of path delay: Values: max, min, min_max Default: min_max</param>
		/// <param name="setup">
		/// <para>
		/// (Optional)<br/>
		/// Report max delay endpoint timing paths (equivalent to -<br/>
		/// delay_type max)<br/>
		/// </para>
		/// </param>
		/// <param name="hold">
		/// <para>
		/// (Optional)<br/>
		/// Report min delay endpoint timing paths (equivalent to -<br/>
		/// delay_type min)<br/>
		/// </para>
		/// </param>
		/// <param name="no_detailed_paths">(Optional) Only report top level summary table</param>
		/// <param name="max_paths">
		/// <para>
		/// (Optional)<br/>
		/// Maximum number of paths to output per bus skew<br/>
		/// constraint: Value &gt;=1 Default: 1<br/>
		/// </para>
		/// </param>
		/// <param name="nworst">
		/// <para>
		/// (Optional)<br/>
		/// List up to N worst paths per endpoint per constraint: Value<br/>
		/// &gt;=1 Default: 1<br/>
		/// </para>
		/// </param>
		/// <param name="unique_pins">
		/// <para>
		/// (Optional)<br/>
		/// For each unique set of pins, show at most 1 path per bus<br/>
		/// skew constraint<br/>
		/// </para>
		/// </param>
		/// <param name="path_type">
		/// <para>
		/// (Optional)<br/>
		/// Format for path report: Values: short, full, full_clock,<br/>
		/// full_clock_expanded Default: full_clock_expanded<br/>
		/// </para>
		/// </param>
		/// <param name="sort_by_slack">(Optional) Sort summary and per-constraint sections by slack</param>
		/// <param name="input_pins">(Optional) Show input pins in path</param>
		/// <param name="no_header">(Optional) Do not generate a report header</param>
		/// <param name="significant_digits">(Optional) Number of digits to display: Range: 0 to 3 Default: 3</param>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="return_string">(Optional) Return report as string</param>
		/// <param name="warn_on_violation">(Optional) Issue a critical warning when the report contains a timing violation</param>
		/// <param name="rpx">(Optional) Filename to output interactive results to.</param>
		/// <param name="cells">(Optional) run report_bus_skew on the specified hierarchical cell(s)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">
		/// <para>
		/// (Optional)<br/>
		/// Suspend message limits during command execution<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// </param>
		public VivadoTCL report_bus_skew(report_bus_skew_delay_type? delay_type = null, bool? setup = null, bool? hold = null, bool? no_detailed_paths = null, Int32? max_paths = null, String nworst = null, bool? unique_pins = null, report_bus_skew_path_type? path_type = null, bool? sort_by_slack = null, bool? input_pins = null, bool? no_header = null, Int32? significant_digits = null, String file = null, bool? append = null, bool? return_string = null, bool? warn_on_violation = null, String rpx = null, TCLParameterList cells = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_bus_skew [-delay_type <arg>] [-setup] [-hold] [-no_detailed_paths] [-max_paths <arg>] [-nworst <arg>] [-unique_pins] [-path_type <arg>] [-sort_by_slack] [-input_pins] [-no_header] [-significant_digits <arg>] [-file <arg>] [-append] [-return_string] [-warn_on_violation] [-rpx <arg>] [-cells <args>] [-quiet] [-verbose]
			this.Entry(_builder.report_bus_skew(delay_type, setup, hold, no_detailed_paths, max_paths, nworst, unique_pins, path_type, sort_by_slack, input_pins, no_header, significant_digits, file, append, return_string, warn_on_violation, rpx, cells, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report carry chains<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_carry_chains [-file &lt;arg&gt;] [-append] [-return_string] [-cell &lt;args&gt;] [-max_chains &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Report the details of the carry chains used by the current open design. The report includes the<br/>
		/// average depth of all carry chains, as well as the specific depth of each carry chain reported.<br/>
		/// By default, the longest carry chain is reported, but the number of chains reported can be<br/>
		/// specified.<br/>
		/// The command returns the carry chain report.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the 10 longest carry chains in the design:<br/>
		/// report_carry_chains -max_chains 10<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1301<br/>
		/// </para>
		/// </summary>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="append">(Optional) Append to existing file</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="cell">(Optional) Report Carry Chains only for given cell</param>
		/// <param name="max_chains">(Optional) Number of chains for which report is to be generated Default: 1</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Report</returns>
		public VivadoTCL report_carry_chains(String file = null, bool? append = null, bool? return_string = null, TCLParameterList cell = null, Int32? max_chains = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_carry_chains [-file <arg>] [-append] [-return_string] [-cell <args>] [-max_chains <arg>] [-quiet] [-verbose]
			this.Entry(_builder.report_carry_chains(file, append, return_string, cell, max_chains, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report the clock domain crossing (CDC) paths in the current design.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_cdc [-from &lt;args&gt;] [-to &lt;args&gt;] [-cells &lt;args&gt;] [-details] [-summary] [-all_checks_per_endpoint] [-severity &lt;arg&gt;] [-no_header] [-show_waiver] [-no_waiver] [-waived] [-file &lt;arg&gt;] [-append] [-return_string] [-name &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// This report shows in detail the clock domain crossing (CDC) paths in the current synthesized or<br/>
		/// implemented design. The command analyzes paths between asynchronous clocks, or clocks with<br/>
		/// no common period, as well as synchronous paths ignored by the user due to false path or max<br/>
		/// delay datapath_only exceptions.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// By default the report_cdc command reports domain crossing between all clocks in the design.<br/>
		/// However, you can limit the clocks of interest using the -from and -to options to specify the<br/>
		/// clock domains of interest.<br/>
		/// The report_cdc command only reports on paths where both source and destination clocks are<br/>
		/// defined. You should run the check_timing command prior to report_cdc to ensure that<br/>
		/// there are no unconstrained clocks in the design. I/O paths are only covered by report_cdc<br/>
		/// when input or output delay constraints have been specified on the I/O ports.<br/>
		/// The severity of the path report could be Critical, Warning or Info depending on the CDC<br/>
		/// topology identified. An unknown synchronization topology is Critical and needs to be reviewed.<br/>
		/// A double register synchronizer with missing ASYNC_REG property is a Warning. Clock Enable,<br/>
		/// MUX, and MUX Hold CDC structures are categorized as Warnings because you should check to<br/>
		/// ensure that the structure is safe. Other CDC paths are of severity Info.<br/>
		/// The report_cdc command returns the following information:<br/>
		/// • Severity<br/>
		/// • Source Clock<br/>
		/// • Destination Clock<br/>
		/// • CDC Type<br/>
		/// • Exceptions<br/>
		/// • Endpoints<br/>
		/// • Safe<br/>
		/// • Unknown<br/>
		/// • No ASYNC_REG property<br/>
		/// IMPORTANT! You cannot use the set_msg_config command to configure the severity of messages<br/>
		/// returned by the report_cdc command. This command does not generate messages through the<br/>
		/// message manager.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports the clock domain crossings in the current design, including any<br/>
		/// waived paths, using a verbose report form, and saving the results to a file:<br/>
		/// report_cdc -details -show_waiver -file C:/Data/cdc_report.txt<br/>
		/// The following example reports the clock domain crossings from a clock specified by name, to<br/>
		/// another specified as a clock object:<br/>
		/// report_cdc -from clk_pin_p -to [get_clocks clk_rx_clk_core]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1303<br/>
		/// </para>
		/// </summary>
		/// <param name="from">(Optional) From clocks</param>
		/// <param name="to">(Optional) To clocks</param>
		/// <param name="cells">(Optional) run report_cdc on the cells</param>
		/// <param name="details">(Optional) report the detail of the CDC timing paths not safely timed</param>
		/// <param name="summary">(Optional) report a summary by clocks of the CDC</param>
		/// <param name="all_checks_per_endpoint">(Optional) report all checks per endpoint</param>
		/// <param name="severity">(Optional) report only the severity specified (Info, Warning or Critical)</param>
		/// <param name="no_header">(Optional) Do not generate a report header</param>
		/// <param name="show_waiver">(Optional) Show the waived paths</param>
		/// <param name="no_waiver">(Optional) Ignore the waiver</param>
		/// <param name="waived">(Optional) Show only the waived paths</param>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_cdc(TCLParameterList from = null, TCLParameterList to = null, TCLParameterList cells = null, bool? details = null, bool? summary = null, bool? all_checks_per_endpoint = null, String severity = null, bool? no_header = null, bool? show_waiver = null, bool? no_waiver = null, bool? waived = null, String file = null, bool? append = null, bool? return_string = null, String name = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_cdc [-from <args>] [-to <args>] [-cells <args>] [-details] [-summary] [-all_checks_per_endpoint] [-severity <arg>] [-no_header] [-show_waiver] [-no_waiver] [-waived] [-file <arg>] [-append] [-return_string] [-name <arg>] [-quiet] [-verbose]
			this.Entry(_builder.report_cdc(from, to, cells, details, summary, all_checks_per_endpoint, severity, no_header, show_waiver, no_waiver, waived, file, append, return_string, name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report on clock timing paths and unclocked registers<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_clock_interaction [-delay_type &lt;arg&gt;] [-setup] [-hold] [-significant_digits &lt;arg&gt;] [-no_header] [-file &lt;arg&gt;] [-append] [-name &lt;arg&gt;] [-return_string] [-cells &lt;args&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Reports clock interactions and signals that cross clock domains to identify potential problems<br/>
		/// such a metastability, or data loss, or incoherency, where some visibility into the paths that cross<br/>
		/// clock domains is beneficial. This command requires an open synthesized or implemented design.<br/>
		/// Note: By default the report is written to the Tcl console or STD output. However, the results can also be<br/>
		/// written to a file or returned as a string if desired.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example sets the model for interconnect delay, selects a device speed grade, and<br/>
		/// then runs report_clock_interaction:<br/>
		/// set_delay_model -interconnect none<br/>
		/// set_speed_grade -3<br/>
		/// report_clock_interaction -delay_type min_max \<br/>
		/// -significant_digits 3 -name "results_1"<br/>
		/// The following example returns the clock interactions, writing the report to the GUI, to the<br/>
		/// specified file, and returns a string which is assigned to the specified variable:<br/>
		/// set clk_int [report_clock_interaction -file clk_int.txt -name clk_int1 \<br/>
		/// -return_string]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1307<br/>
		/// </para>
		/// </summary>
		/// <param name="delay_type">(Optional) Type of path delay: Values: max, min, min_max Default: max</param>
		/// <param name="setup">(Optional) Consider max delay timing paths (equivalent to -delay_type max)</param>
		/// <param name="hold">(Optional) Consider min delay timing paths (equivalent to -delay_type min)</param>
		/// <param name="significant_digits">(Optional) Number of digits to display: Range: 0 to 3 Default: 2</param>
		/// <param name="no_header">(Optional) do not generate a report header</param>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="return_string">(Optional) Return report as string</param>
		/// <param name="cells">(Optional) run report_clock_interaction on the specified cell(s)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_clock_interaction(report_clock_interaction_delay_type? delay_type = null, bool? setup = null, bool? hold = null, Int32? significant_digits = null, bool? no_header = null, String file = null, bool? append = null, String name = null, bool? return_string = null, TCLParameterList cells = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_clock_interaction [-delay_type <arg>] [-setup] [-hold] [-significant_digits <arg>] [-no_header] [-file <arg>] [-append] [-name <arg>] [-return_string] [-cells <args>] [-quiet] [-verbose]
			this.Entry(_builder.report_clock_interaction(delay_type, setup, hold, significant_digits, no_header, file, append, name, return_string, cells, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report clock networks<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_clock_networks [-file &lt;arg&gt;] [-append] [-name &lt;arg&gt;] [-return_string] [-endpoints_only] [-levels &lt;arg&gt;] [-expand_buckets] [-suppress_endpoints &lt;arg&gt;] [-clocks &lt;args&gt;] [-unconstrained_roots &lt;args&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Reports the network fanout of each clock net in the open synthesized or implemented design.<br/>
		/// The graphical form of the report, returned when the -name argument is specified, provides a<br/>
		/// hierarchical tree view of the clock network.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The default report simply specifies the clock net names and the instance pins that are the<br/>
		/// startpoint of the clock.<br/>
		/// The report is returned to the standard output unless the -file, -return_string, or -name<br/>
		/// arguments are specified.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports the clock network names and startpoints to the specified file:<br/>
		/// report_clock_networks -file C:/Data/ClkNets.txt<br/>
		/// The following example reports the endpoints of the specified clock:<br/>
		/// report_clock_networks -endpoints_only -clocks wbClk<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1310<br/>
		/// </para>
		/// </summary>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="endpoints_only">
		/// <para>
		/// (Optional)<br/>
		/// dump clock network endpoints only; Not to be used in<br/>
		/// conjunction with -levels option<br/>
		/// </para>
		/// </param>
		/// <param name="levels">
		/// <para>
		/// (Optional)<br/>
		/// expands clock network upto n levels of instances, Value: n &gt;<br/>
		/// 0; Not to be used in conjunction with -endpoints_only option<br/>
		/// Default: 0<br/>
		/// </para>
		/// </param>
		/// <param name="expand_buckets">
		/// <para>
		/// (Optional)<br/>
		/// expands bucketed endpoints and displays pins; By default,<br/>
		/// endpoint pins are bucketed by celltype; This option only<br/>
		/// works in conjunction with -levels option or -endpoints_only<br/>
		/// option<br/>
		/// </para>
		/// </param>
		/// <param name="suppress_endpoints">
		/// <para>
		/// (Optional)<br/>
		/// suppress paths to clock or nonclock endpoint pins; Values:<br/>
		/// clock, nonclock<br/>
		/// </para>
		/// </param>
		/// <param name="clocks">
		/// <para>
		/// (Optional)<br/>
		/// List of clocks for clock network dump; if not specified, all<br/>
		/// clock networks are dumped<br/>
		/// </para>
		/// </param>
		/// <param name="unconstrained_roots">
		/// <para>
		/// (Optional)<br/>
		/// List of unconstrained root pins/ports for clock network<br/>
		/// dump; if not specified, all unconstrained clock roots are<br/>
		/// dumped<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_clock_networks(String file = null, bool? append = null, String name = null, bool? return_string = null, bool? endpoints_only = null, String levels = null, bool? expand_buckets = null, report_clock_networks_suppress_endpoints? suppress_endpoints = null, TCLParameterList clocks = null, TCLParameterList unconstrained_roots = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_clock_networks [-file <arg>] [-append] [-name <arg>] [-return_string] [-endpoints_only] [-levels <arg>] [-expand_buckets] [-suppress_endpoints <arg>] [-clocks <args>] [-unconstrained_roots <args>] [-quiet] [-verbose]
			this.Entry(_builder.report_clock_networks(file, append, name, return_string, endpoints_only, levels, expand_buckets, suppress_endpoints, clocks, unconstrained_roots, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report information about clock nets in design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_clock_utilization [-file &lt;arg&gt;] [-append] [-write_xdc &lt;arg&gt;] [-cells &lt;args&gt;] [-clock_roots_only] [-return_string] [-name &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Returns information related to clock nets in the design and clock resource usage on the target<br/>
		/// device.<br/>
		/// The generated clock utilization report can generate placement constraints for the currently<br/>
		/// placed clock resources. You can use these constraints to preserve the placement of clock<br/>
		/// resources for future iterations of the design, by using the -write_xdc option.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// IMPORTANT! For Ultrascale devices, if the intent is to recreate the current clock placement then use the<br/>
		/// BUFGCE LOC properties from the written XDC file. However, if the intent is to use the constraints as a<br/>
		/// starting point for the clocking architecture, while allowing the Vivado Design Suite some flexibility in<br/>
		/// placing clock resources, use the equivalent CLOCK_REGION properties instead of the BUFGCE LOC<br/>
		/// properties.<br/>
		/// By default the report is written to the Tcl console or STD output. However, the results can also<br/>
		/// be written to a file or returned as a string if desired.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns information about the clock nets in the design and the clock<br/>
		/// resources utilized on the target device, and writes it to the specified file:<br/>
		/// report_clock_utilization -file C:/Data/FPGA_Design/clock_util.txt<br/>
		/// The following example reports the clock nets and clock resource utilization to the standard<br/>
		/// output, but writes the XDC location constraints to the specified file:<br/>
		/// report_clock_utilization -write_xdc clock_util_xdc.txt<br/>
		/// Note: Because the path is not specified as part of the XDC file name, the file will be created in the current<br/>
		/// working directory, or the directory from which the tool was launched.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1313<br/>
		/// </para>
		/// </summary>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="append">(Optional) Append to existing file</param>
		/// <param name="write_xdc">(Optional) file to output clock constraint. File name must be given.</param>
		/// <param name="cells">(Optional) Cells/bel_instances for which to report clock utilization</param>
		/// <param name="clock_roots_only">(Optional) Report only the Clock Root Assignments</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Report</returns>
		public VivadoTCL report_clock_utilization(String file = null, bool? append = null, String write_xdc = null, TCLParameterList cells = null, bool? clock_roots_only = null, bool? return_string = null, String name = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_clock_utilization [-file <arg>] [-append] [-write_xdc <arg>] [-cells <args>] [-clock_roots_only] [-return_string] [-name <arg>] [-quiet] [-verbose]
			this.Entry(_builder.report_clock_utilization(file, append, write_xdc, cells, clock_roots_only, return_string, name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report clocks<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_clocks [-file &lt;arg&gt;] [-append] [-return_string] [-quiet] [-verbose] [&lt;clocks&gt;]
		/// <br/>
		/// <para>
		/// Returns a table showing all the clocks in a design, including propagated clocks, generated and<br/>
		/// auto-generated clocks, virtual clocks, and inverted clocks in the current synthesized or<br/>
		/// implemented design. More detailed information about each clock net can be obtained with the<br/>
		/// report_clock_utilization command.<br/>
		/// Note: By default the report is written to the Tcl console or STD output. However, the results can also be<br/>
		/// written to a file or returned as a string if desired.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the name, period, waveform, and sources of the clocks in the<br/>
		/// current design:<br/>
		/// report_clocks -file C:/Data/FPGA_Design/clock_out.txt<br/>
		/// The following example reports the clocks in the design with "Clock" in the name:<br/>
		/// report_clocks *Clock*<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1316<br/>
		/// </para>
		/// </summary>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="clocks">(Optional) List of clocks Default: *</param>
		public VivadoTCL report_clocks(String file = null, bool? append = null, bool? return_string = null, bool? quiet = null, bool? verbose = null, String clocks = null)
		{
			// TCL Syntax: report_clocks [-file <arg>] [-append] [-return_string] [-quiet] [-verbose] [<clocks>]
			this.Entry(_builder.report_clocks(file, append, return_string, quiet, verbose, clocks));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report the compile order by analyzing files and constructing a hierarchy.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_compile_order [-fileset &lt;arg&gt;] [-missing_instances] [-constraints] [-sources] [-used_in &lt;arg&gt;] [-file &lt;arg&gt;] [-append] [-of_objects &lt;args&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Report the compilation order of files in the various active filesets: constraints, design sources,<br/>
		/// and simulation sources.<br/>
		/// This command returns the order of file processing for synthesis, implementation, and simulation.<br/>
		/// The report can be limited by specifying the fileset of interest with -fileset, or using the -<br/>
		/// constraints option or -sources option.<br/>
		/// The -used_in option lets you report the processing order of files used in Synthesis, Simulation, or<br/>
		/// one of the implementation steps, according to the value of the USED_IN property.<br/>
		/// By default the report is returned to the Tcl console, or standard output, but it can also be written<br/>
		/// to a file.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports the compilation order of the active filesets in the current design:<br/>
		/// report_compile_order<br/>
		/// The following returns a list of cells with missing source files in the current design, and appends<br/>
		/// the report to the specified file:<br/>
		/// report_compile_order -missing_instances -file C:/Data/report1.txt -append<br/>
		/// The following command lists the compile order of the files in the active constraint set:<br/>
		/// report_compile_order -constraints<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1318<br/>
		/// </para>
		/// </summary>
		/// <param name="fileset">(Optional) FileSet to parse to determine compile order</param>
		/// <param name="missing_instances">(Optional) Report missing instances in the design hierarchy</param>
		/// <param name="constraints">(Optional) Report the constraint compile order</param>
		/// <param name="sources">(Optional) Report the source compile order</param>
		/// <param name="used_in">(Optional) Specify the used in filter.</param>
		/// <param name="file">(Optional) Filename to output results to.</param>
		/// <param name="append">(Optional) Append output to existing file</param>
		/// <param name="of_objects">(Optional) Get 'file' objects of these types: 'file fileset ip reconfig_module'.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_compile_order(String fileset = null, bool? missing_instances = null, bool? constraints = null, bool? sources = null, String used_in = null, String file = null, bool? append = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_compile_order [-fileset <arg>] [-missing_instances] [-constraints] [-sources] [-used_in <arg>] [-file <arg>] [-append] [-of_objects <args>] [-quiet] [-verbose]
			this.Entry(_builder.report_compile_order(fileset, missing_instances, constraints, sources, used_in, file, append, of_objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Print details of the given condition objects<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_conditions [-quiet] [-verbose] [&lt;ConditionObjs&gt;...]
		/// <br/>
		/// <para>
		/// Report a specific simulation condition, or report all conditions in the current simulation. You must<br/>
		/// have an open simulation for this command to return anything.<br/>
		/// Conditions can be defined prior to starting the simulation. When a condition is added, the<br/>
		/// simulator evaluates the condition expression anytime a signal change is detected. When a<br/>
		/// specified condition expression becomes TRUE, the condition commands are run.<br/>
		/// This command returns the condition identifier, expression, commands, and names of conditions,<br/>
		/// or returns an error if the command fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports conditions in the current simulation. The condition identifier,<br/>
		/// expression, commands, and names are reported:<br/>
		/// report_conditions<br/>
		/// #2: condition2<br/>
		/// Expression: {/testbench/reset == 0 }<br/>
		/// Command: {<br/>
		/// puts "Condition Reset was encountered at [current_time]. \<br/>
		/// Stopping simulation."<br/>
		/// stop }<br/>
		/// Name: resetLow<br/>
		/// #3: condition3<br/>
		/// Expression: {/testbench/leds_n == X000 }<br/>
		/// Command: {<br/>
		/// puts "Condition LED Unknown was encountered at [current_time]. \<br/>
		/// Stopping simulation."<br/>
		/// stop }<br/>
		/// Name: ledUnknown<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1321<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="ConditionObjs">(Optional) ConditionObjs, id's or names</param>
		/// <returns>Prints name, id, condition_expression and commands of each condition object on the console</returns>
		public VivadoTCL report_conditions(bool? quiet = null, bool? verbose = null, TCLParameterList ConditionObjs = null)
		{
			// TCL Syntax: report_conditions [-quiet] [-verbose] [<ConditionObjs>...]
			this.Entry(_builder.report_conditions(quiet, verbose, ConditionObjs));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report Implementation flow Config param<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_config_implementation [-file &lt;arg&gt;] [-force] [-append] [-return_string] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Report the user-definable implementation flow configuration parameters for the implementation<br/>
		/// processes. These are parameters that can be modified using the config_implementation<br/>
		/// command.<br/>
		/// This command returns the selected report or the name of the output file, or returns an error if it<br/>
		/// fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// This example reports the user-configurable implementation parameters to the Tcl console:<br/>
		/// report_config_implementation<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1323<br/>
		/// </para>
		/// </summary>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. Send output to console if -file<br/>
		/// is not used.<br/>
		/// </para>
		/// </param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="append">(Optional) Append to existing file</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Report</returns>
		public VivadoTCL report_config_implementation(String file = null, bool? force = null, bool? append = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_config_implementation [-file <arg>] [-force] [-append] [-return_string] [-quiet] [-verbose]
			this.Entry(_builder.report_config_implementation(file, force, append, return_string, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report settings affecting timing analysis<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_config_timing [-file &lt;arg&gt;] [-append] [-name &lt;arg&gt;] [-return_string] [-all] [-no_header] [-rpx &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Report the configuration of timing constraints of the current design.<br/>
		/// By default the report is abbreviated, containing only a few key timing constraints. Use the -all<br/>
		/// argument to return all timing related configuration.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports the current timing configuration, returns the information as a<br/>
		/// string, and sets that string into the specified Tcl variable:<br/>
		/// set timeConfig [report_config_timing -all -no_header -return_string]<br/>
		/// puts $timeConfig<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1325<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Optional) Output the results to file</param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="all">
		/// <para>
		/// (Optional)<br/>
		/// report all configuration settings (by default, only the<br/>
		/// typically important settings are reported<br/>
		/// </para>
		/// </param>
		/// <param name="no_header">(Optional) do not generate a report header</param>
		/// <param name="rpx">(Optional) Filename to output interactive results to.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_config_timing(String file = null, bool? append = null, String name = null, bool? return_string = null, bool? all = null, bool? no_header = null, String rpx = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_config_timing [-file <arg>] [-append] [-name <arg>] [-return_string] [-all] [-no_header] [-rpx <arg>] [-quiet] [-verbose]
			this.Entry(_builder.report_config_timing(file, append, name, return_string, all, no_header, rpx, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report the unique control sets in design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_control_sets [-file &lt;arg&gt;] [-append] [-hierarchical] [-hierarchical_depth &lt;arg&gt;] [-sort_by &lt;args&gt;] [-cells &lt;args&gt;] [-return_string] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Report the control sets of the current design.<br/>
		/// Control sets are the list of control signals (Clock, CE, SR) for SLICE registers and LUTs. Registers<br/>
		/// must belong to the same control set in order to be packed into the same device resource.<br/>
		/// Registers without a control signal cannot be packed into devices with registers having control<br/>
		/// signals. A high number of control sets can cause difficulty fitting the device and can cause routing<br/>
		/// congestion and timing issues.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// By default the report_control_sets command returns an abbreviated report indicating only<br/>
		/// the number of unique control sets. However, the -verbose arguments returns a detailed report<br/>
		/// of all control sets, for either the whole design or for the specified cells.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports the control sets of the current design, sorted by the clk and clkEn<br/>
		/// signals:<br/>
		/// report_control_sets -verbose -sort_by {clk clkEn}<br/>
		/// The following example reports the control sets of the specified cells, sorted by clk and set:<br/>
		/// report_control_sets -verbose -sort_by {clk set} -cells [get_cells usb*]<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1328<br/>
		/// </para>
		/// </summary>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="append">(Optional) Append to existing file</param>
		/// <param name="hierarchical">(Optional) Generates text-based hierarchical report.</param>
		/// <param name="hierarchical_depth">(Optional) Specifies the depth level for textual hierarchical report Default: 0</param>
		/// <param name="sort_by">
		/// <para>
		/// (Optional)<br/>
		/// Sort criterion: can be used only when -verbose is used.<br/>
		/// Options are clk, clkEn, set. Ex: report_control_sets -verbose -<br/>
		/// sort_by {clk clkEn}<br/>
		/// </para>
		/// </param>
		/// <param name="cells">(Optional) Cells/bel_instances for which to report control sets</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Report</returns>
		public VivadoTCL report_control_sets(String file = null, bool? append = null, bool? hierarchical = null, String hierarchical_depth = null, TCLParameterList sort_by = null, TCLParameterList cells = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_control_sets [-file <arg>] [-append] [-hierarchical] [-hierarchical_depth <arg>] [-sort_by <args>] [-cells <args>] [-return_string] [-quiet] [-verbose]
			this.Entry(_builder.report_control_sets(file, append, hierarchical, hierarchical_depth, sort_by, cells, return_string, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report data sheet<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_datasheet [-significant_digits &lt;arg&gt;] [-file &lt;arg&gt;] [-append] [-return_string] [-sort_by &lt;arg&gt;] [-name &lt;arg&gt;] [-show_all_corners] [-show_oe_timing] [-group &lt;args&gt;] [-rpx &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Create a "datasheet" report for the current design. Reports setup and hold times of input I/Os in<br/>
		/// relation to clocks, max/min delays from clocks to output pads, skews of input/ output buses.<br/>
		/// The datasheet report has the timing characteristics of a design at the package balls/pads,<br/>
		/// including the package trace flight times. To disable flight times use the following command:<br/>
		/// config_timing_analysis -disable_flight_delays true<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The source synchronous output skew can be automatically calculated by the Vivado Design Suite<br/>
		/// by using the -group switch for report_datasheet and grouping together all the ports of the<br/>
		/// data bus including the sourced clock output port. The sourced clock output port must be first in<br/>
		/// the group list. For example:<br/>
		/// report_datasheet -file output_filename -group [get_ports \<br/>
		/// {clock_port data_bit[0] data_bit[1] data_bit[2]}]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the datasheet sorted by ports, for all process corners:<br/>
		/// report_datasheet -sort_by port -show_all_corners<br/>
		/// The following example reports the datasheet with the skew calculation for two groups of ports,<br/>
		/// with the first port of each group providing the reference for the skew calculation for that group.<br/>
		/// In this example, CLK0OUT is the forwarded clock for DATA0-4 and CLK1OUT is the forwarded<br/>
		/// clock for DATA4-7:<br/>
		/// report_datasheet -file ds.txt -group [get_ports \<br/>
		/// {CLK0OUT DATA0 DATA1 DATA2 DATA3}] \<br/>
		/// -group [get_ports {CLK1OUT DATA4 DATA5 DATA6 DATA7}]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1331<br/>
		/// </para>
		/// </summary>
		/// <param name="significant_digits">(Optional) Number of digits to display: Range: 0 to 3 Default: 3</param>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="sort_by">(Optional) Sorting order: Values: clock, port Default: clock</param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="show_all_corners">(Optional) provide all corners</param>
		/// <param name="show_oe_timing">(Optional) show output enable (tristate) timing</param>
		/// <param name="group">(Optional) List of output ports for skew calculation</param>
		/// <param name="rpx">(Optional) Filename to output interactive results to.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_datasheet(Int32? significant_digits = null, String file = null, bool? append = null, bool? return_string = null, report_datasheet_sort_by? sort_by = null, String name = null, bool? show_all_corners = null, bool? show_oe_timing = null, TCLParameterList group = null, String rpx = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_datasheet [-significant_digits <arg>] [-file <arg>] [-append] [-return_string] [-sort_by <arg>] [-name <arg>] [-show_all_corners] [-show_oe_timing] [-group <args>] [-rpx <arg>] [-quiet] [-verbose]
			this.Entry(_builder.report_datasheet(significant_digits, file, append, return_string, sort_by, name, show_all_corners, show_oe_timing, group, rpx, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report details on debug cores<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_debug_core [-file &lt;arg&gt;] [-append] [-return_string] [-full_path] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Writes a report of the various Vivado device tool debug cores in the current project, and the<br/>
		/// parameters of those cores. Debug cores can be added to a project using the<br/>
		/// create_debug_core command.<br/>
		/// Note: By default the report is written to the Tcl console or STD output. However, the results can also be<br/>
		/// written to a file or returned as a string if desired.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example writes the debug core report to the specified file name at the specified<br/>
		/// location:<br/>
		/// report_debug_core -file C:/Data/FPGA_Design/project_1_cores.txt<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1334<br/>
		/// </para>
		/// </summary>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="return_string">(Optional) Return report as a string</param>
		/// <param name="full_path">(Optional) Display full hierarchical net path in report</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_debug_core(String file = null, bool? append = null, bool? return_string = null, bool? full_path = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_debug_core [-file <arg>] [-append] [-return_string] [-full_path] [-quiet] [-verbose]
			this.Entry(_builder.report_debug_core(file, append, return_string, full_path, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report Design Analysis<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_design_analysis [-file &lt;arg&gt;] [-append] [-return_string] [-complexity] [-cells &lt;args&gt;] [-bounding_boxes &lt;args&gt;] [-hierarchical_depth &lt;arg&gt;] [-congestion] [-min_congestion_level &lt;arg&gt;] [-timing] [-setup] [-hold] [-show_all] [-full_logical_pin] [-routed_vs_estimated] [-logic_level_distribution] [-logic_level_dist_paths &lt;arg&gt;] [-min_level &lt;arg&gt;] [-max_level &lt;arg&gt;] [-return_timing_paths] [-of_timing_paths &lt;args&gt;] [-max_paths &lt;arg&gt;] [-extend] [-routes] [-end_point_clocks &lt;args&gt;] [-logic_levels &lt;arg&gt;] [-qor_summary] [-name &lt;arg&gt;] [-no_pr_attribute] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Provides timing data on critical path characteristics and complexity of the design to help identify<br/>
		/// and analyze problem areas that are subject to timing closure issues and routing congestion. For<br/>
		/// more information on this command refer to the Vivado Design Suite User Guide: Design Analysis<br/>
		/// and Closure Techniques (UG906).<br/>
		/// The report_design_analysis command currently has three modes of operation:<br/>
		/// • Timing: reports timing and physical characteristics of timing paths.<br/>
		/// • Complexity: analyzes the design for routing complexity and LUT distribution.<br/>
		/// • Congestion: analyzes the design for routing congestion.<br/>
		/// In timing mode, the command calls the static timing engine to analyze critical path data and<br/>
		/// report the characteristics of each path. The path characteristics include important elements such<br/>
		/// as clock skew, placement obstacles such as crossing clock regions, and physical constraints such<br/>
		/// as Pblocks and LOCs. The list of paths can be extended to include a number of top critical paths<br/>
		/// or specific paths can be analyzed by providing timing path objects to the command. The reports<br/>
		/// can also be extended to show the paths preceding and following the critical path.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following are definitions of the characteristics of the paths reported in timing mode:<br/>
		/// • PATH_TYPE: either SETUP or HOLD.<br/>
		/// • REQUIREMENT: delay requirement from static timing analysis.<br/>
		/// • PATH DELAY: data path delay from static timing analysis.<br/>
		/// • LOGIC DELAY: the portion of the PATH DELAY attributed to logic on the path.<br/>
		/// • NET DELAY: the portion of the PATH DELAY attributed to wires on the path. Note that the<br/>
		/// net delay is based on the estimated or actual routing delay as specified by the<br/>
		/// set_delay_model command.<br/>
		/// • CLOCK SKEW: difference in delay between the source and destination clocks.<br/>
		/// • SLACK: path timing slack from static timing analysis.<br/>
		/// • CLOCK RELATIONSHIP: SAME_CLOCK or RELATED_CLOCK. Helps identify potentially<br/>
		/// missed inter-clock constraints.<br/>
		/// • TIMING EXCEPTION: the timing exceptions, like set_false_path or<br/>
		/// set_multicycle_path, that are assigned to the path.<br/>
		/// • LOGIC LEVELS: number of logic levels between the source and destination, reported when<br/>
		/// the -logic_level_distribution is specified.<br/>
		/// • LOGICAL PATH: shorthand notation showing the ordered list of cells in the path including the<br/>
		/// start point and end point.<br/>
		/// Note: For Partial Reconfiguration (PR) designs, the logical path is appended to identify the cell as<br/>
		/// belonging to a reconfigurable partition (:RP#), or to the static region of the design (:S). A translation<br/>
		/// table at the bottom of the report maps :RP# to a specific reconfigurable partition.<br/>
		/// • START POINT CLOCK: the clock domain of the start point of the path.<br/>
		/// • END POINT CLOCK: the clock domain of the end point of the path.<br/>
		/// • START POINT PIN PRIMITIVE: the library cell and pin of the start point of the path.<br/>
		/// • END POINT PIN PRIMITIVE: the library cell and pin of the end point of the path.<br/>
		/// • START POINT PIN: the instance and pin name of the start point.<br/>
		/// • END POINT PIN: the instance and pin name of the end point.<br/>
		/// • COMB DSP: number of combinational DSP blocks in the path.<br/>
		/// • DOA REG: the number of DOA registers on the path.<br/>
		/// • DOB REG: the number of DOB registers on the path.<br/>
		/// • MREG: the number of MREG registers on the path.<br/>
		/// • PREG: the number of PREG registers on the path.<br/>
		/// • BRAM CROSSINGS: number of block RAM columns traversed by the path.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// • DSP CROSSINGS: number of DSP block columns traversed by the path.<br/>
		/// • IO CROSSINGS: number of IO columns traversed by the path.<br/>
		/// • CONFIG CROSSINGS: the number of CONFIG tile traversed by the path.<br/>
		/// • SLR CROSSINGS: number of SLRs traversed by the path.<br/>
		/// • BOUNDING BOX SIZE: the rectangular area covered by the critical path, measured in RPM<br/>
		/// GRID units which are based on the device RPM_X (horizontal) and RPM_Y (vertical) site<br/>
		/// coordinates. Since different sites (slices, DSP, block RAM, etc.) have different sizes, each site<br/>
		/// has unique RPM_X and RPM_Y properties to pinpoint its location within the device.<br/>
		/// • CLOCK REGION DISTANCE: An ordered pair showing the number of clock regions traversed<br/>
		/// in the horizontal and vertical directions from path startpoint to endpoint. Minimizing clock<br/>
		/// region crossings can improve critical path delay and clock skew.<br/>
		/// ○ Example 1: A critical path begins in clock region X1Y1 and ends in clock region X3Y3,<br/>
		/// resulting in a CLOCK_REGION_DISTANCE of (2, 2).<br/>
		/// ○ Example 2: a critical path begins in clock region X2Y1 and ends in X0Y0, resulting in a<br/>
		/// CLOCK_REGION_DISTANCE of (-2, -1).<br/>
		/// • PBLOCKS: number of Pblocks traversed by the path.<br/>
		/// • HIGH FANOUT: the greatest fanout of a net in the path.<br/>
		/// • CUMULATIVE FANOUT: the total fanout on the path.<br/>
		/// • DONT TOUCH: number of cells in the path with DONT_TOUCH value of TRUE. A value of<br/>
		/// TRUE for DONT_TOUCH on a cell prevents it from being optimized, disabling potentially<br/>
		/// beneficial optimizations such as phys_opt_design replication.<br/>
		/// • MARK DEBUG: number of cells in the path with a MARK_DEBUG value of TRUE. By default a<br/>
		/// net with MARK_DEBUG has DONT_TOUCH set to TRUE which disables optimization on that<br/>
		/// net. The DONT_TOUCH can be set to FALSE to enable optimization and potentially improve<br/>
		/// timing.<br/>
		/// • FIXED LOC: number of placed cells in the path with an IS_LOC_FIXED value of TRUE. FIXED<br/>
		/// cells cannot be moved by either place_design or phys_opt_design.<br/>
		/// • FIXED ROUTE: number of routed nets in the path with IS_ROUTE_FIXED value of TRUE.<br/>
		/// FIXED routes cannot be ripped up and rerouted by route_design.<br/>
		/// • HOLD FIX DETOUR: the amount of routing detour provided to fix hold timing to post-route<br/>
		/// critical paths.<br/>
		/// • COMBINED LUT PAIRS: number of LUT cells in the path that have been combined with other<br/>
		/// LUT cells into the same LUT BEL to use both the O6 and O5 outputs. LUT cells that have been<br/>
		/// combined with LUTNM, HLUTNM, or SOFT_HLUTNM can be uncombined and re-placed by<br/>
		/// setting their HLUTNM properties to an empty string. This allows exploring LUT combining and<br/>
		/// un-combining effects on timing and congestion reduction.<br/>
		/// • The following fields are reported for Partial Reconfiguration (PR) designs. Refer to the Vivado<br/>
		/// Design Suite User Guide: Dynamic Function eXchange (UG909) for more information.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// ○ PR PATH TYPE: Specifies the path as being completely in the static region, completely in a<br/>
		/// reconfigurable partition (RP), or as crossing the boundary between regions. The delay<br/>
		/// elements for the timing path are also broken down between the regions .<br/>
		/// ○ STATIC CROSSINGS: Reports the number of times a reconfigurable partition (RP) path<br/>
		/// crosses into the static region.<br/>
		/// ○ RP CROSSINGS: Reports the number of times a static region path crosses into a<br/>
		/// reconfigurable partition (RP) region.<br/>
		/// ○ BOUNDARY FANOUT: Reports the fanout of a boundary path at the PPLOC to its<br/>
		/// downstream loads .<br/>
		/// In complexity mode, the command performs complexity analysis of the current design and<br/>
		/// reports the Rent Exponent which is a measure of complexity, the Average Fanout, and a Primitive<br/>
		/// Histogram. The analysis can be performed on the top-level design or recursively on hierarchical<br/>
		/// levels of the design, with the ability to control the level of recursion.<br/>
		/// The following are definitions of the characteristics reported in complexity mode:<br/>
		/// • Rent: The Rent exponent, as defined by Rent's rule, is a measure of interconnect complexity in<br/>
		/// a netlist. Higher Rent indicates higher complexity and greater difficulty to avoid routing<br/>
		/// congestion. Most designs have a Rent in the 0.5 to 0.6 range. A Rent value of 0.65 is<br/>
		/// considered high and 0.85 is considered very high.<br/>
		/// • Average Fanout: This is the average fanout of a logic cell in the design, excluding global<br/>
		/// buffers. Higher average fanout may result in more difficulty for placement and routing. While<br/>
		/// absolute values may not predict difficultly, relative values between designs or between<br/>
		/// hierarchical levels may be more indicative.<br/>
		/// • Primitive Histogram: This displays the totals of certain primitive types used in the design. A<br/>
		/// high Rent may be caused by a predominance of LUT6 cells. If there are many more LUT6 than<br/>
		/// other size LUTs, the Rent may be reduced by adopting a more area-focused synthesis strategy.<br/>
		/// TIP: The complexity characteristics may not always predict routing congestion but can be used to pinpoint<br/>
		/// problem areas when congestion issues occur.<br/>
		/// In congestion mode the command analyzes the design and provides metrics to help you alleviate<br/>
		/// routing congestion. Using the results from the report_design_analysis command, you can<br/>
		/// change placement to avoid specific routing hot spots.<br/>
		/// The command returns the file created, or returns the analysis results to the Tcl console, or returns<br/>
		/// an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example performs complexity analysis of the two specified cells:<br/>
		/// report_design_analysis -complexity -cells {cpuEngine fftEngine}<br/>
		/// The following example performs complexity analysis of the specified bounding boxes:<br/>
		/// report_design_analysis -complexity \<br/>
		/// -bounding_boxes { "CLE_M_X21Y239:CLEL_R_X28Y254"<br/>
		/// "CLEL_R_X18Y171:CLE_M_X26Y186" }<br/>
		/// The following example provides an extended analysis of the worst critical path from the Block<br/>
		/// RAMs in the design:<br/>
		/// report_design_analysis -timing -of_timing_paths \<br/>
		/// [get_timing_paths -from [all_rams]]<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example performs complexity analysis for the specified cell, to a depth of two<br/>
		/// hierarchical levels, and performs timing and congestion analysis on the design:<br/>
		/// report_design_analysis -complexity -hierarchical_depth 2 -timing -setup \<br/>
		/// -hold -max_paths 10 -logic_level_distribution -logic_level_dist_paths 20 -<br/>
		/// congestion<br/>
		/// The following example uses the report_design_analysis command to return the timing<br/>
		/// paths with the specified end point clock and logic levels, and passes those paths to the<br/>
		/// report_timing command for analysis:<br/>
		/// report_timing -of_objects [report_design_analysis -end_point_clock cpuClk \<br/>
		/// -logic_levels 10 -timing -return_timing_paths]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1336<br/>
		/// </para>
		/// </summary>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="return_string">(Optional) Return report as string</param>
		/// <param name="complexity">(Optional) Finds the interconnection complexity (Rent) of the design</param>
		/// <param name="cells">(Optional) Report analysis information for given list of cells</param>
		/// <param name="bounding_boxes">
		/// <para>
		/// (Optional)<br/>
		/// Report interconnection complexity (Rent) for given list of<br/>
		/// bounding boxes Default: empty<br/>
		/// </para>
		/// </param>
		/// <param name="hierarchical_depth">(Optional) Hierarchical depth option for -complexity Default: 1</param>
		/// <param name="congestion">(Optional) Reports congestion of the design</param>
		/// <param name="min_congestion_level">
		/// <para>
		/// (Optional)<br/>
		/// Minimum congestion level for reporting router congestion,<br/>
		/// integer value between 3 and 8 Default: 5<br/>
		/// </para>
		/// </param>
		/// <param name="timing">(Optional) Reports characteristics of critical path</param>
		/// <param name="setup">(Optional) Reports characteristics of critical SETUP path</param>
		/// <param name="hold">(Optional) Reports characteristics of critical HOLD path</param>
		/// <param name="show_all">(Optional) Adds more characteristics to the timing characteristics report</param>
		/// <param name="full_logical_pin">(Optional) Display hierarchical pin names in the report</param>
		/// <param name="routed_vs_estimated">(Optional) Reports relevant characteristics of critical path in estimated mode</param>
		/// <param name="logic_level_distribution">(Optional) Reports logic level distribution</param>
		/// <param name="logic_level_dist_paths">
		/// <para>
		/// (Optional)<br/>
		/// Number of critical paths for analyzing logic level distribution<br/>
		/// used along with -logic_level_distribution Default: 1000<br/>
		/// </para>
		/// </param>
		/// <param name="min_level">
		/// <para>
		/// (Optional)<br/>
		/// Group all paths with logic levels &lt;min_level-1&gt; and below<br/>
		/// into a single bin, value passed must be at least 1 Default:<br/>
		/// Not Used<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Name Description<br/>
		/// </para>
		/// </param>
		/// <param name="max_level">
		/// <para>
		/// (Optional)<br/>
		/// Group all paths with logic levels &lt;max_level+1&gt; and above<br/>
		/// into a single bin, where &lt;max_level&gt; must be the greater of<br/>
		/// zero or &lt;min_level + 1&gt; if -min_level is used Default: Not<br/>
		/// Used<br/>
		/// </para>
		/// </param>
		/// <param name="return_timing_paths">(Optional) Returns timing path objects</param>
		/// <param name="of_timing_paths">(Optional) Reports characteristics for these paths</param>
		/// <param name="max_paths">(Optional) Number of paths to consider for -timing option Default: 1</param>
		/// <param name="extend">
		/// <para>
		/// (Optional)<br/>
		/// Reports characteristics of worst path before the start point<br/>
		/// of critical path and worst path after the end of the critical<br/>
		/// path<br/>
		/// </para>
		/// </param>
		/// <param name="routes">(Optional) Reports distribution with respect to Routes instead of logic levels</param>
		/// <param name="end_point_clocks">
		/// <para>
		/// (Optional)<br/>
		/// Returns timing path objects filtered by endpoint clock<br/>
		/// names as passed to this option<br/>
		/// </para>
		/// </param>
		/// <param name="logic_levels">
		/// <para>
		/// (Optional)<br/>
		/// Returns timing path objects bucketed under the bin name<br/>
		/// as passed to this option<br/>
		/// </para>
		/// </param>
		/// <param name="qor_summary">(Optional) Design Flow summary</param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="no_pr_attribute">(Optional) Report without PR attributes</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_design_analysis(String file = null, bool? append = null, bool? return_string = null, bool? complexity = null, TCLParameterList cells = null, TCLParameterList bounding_boxes = null, String hierarchical_depth = null, bool? congestion = null, String min_congestion_level = null, bool? timing = null, bool? setup = null, bool? hold = null, bool? show_all = null, bool? full_logical_pin = null, bool? routed_vs_estimated = null, bool? logic_level_distribution = null, Int32? logic_level_dist_paths = null, String min_level = null, String max_level = null, bool? return_timing_paths = null, TCLParameterList of_timing_paths = null, Int32? max_paths = null, bool? extend = null, bool? routes = null, TCLParameterList end_point_clocks = null, String logic_levels = null, bool? qor_summary = null, String name = null, bool? no_pr_attribute = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_design_analysis [-file <arg>] [-append] [-return_string] [-complexity] [-cells <args>] [-bounding_boxes <args>] [-hierarchical_depth <arg>] [-congestion] [-min_congestion_level <arg>] [-timing] [-setup] [-hold] [-show_all] [-full_logical_pin] [-routed_vs_estimated] [-logic_level_distribution] [-logic_level_dist_paths <arg>] [-min_level <arg>] [-max_level <arg>] [-return_timing_paths] [-of_timing_paths <args>] [-max_paths <arg>] [-extend] [-routes] [-end_point_clocks <args>] [-logic_levels <arg>] [-qor_summary] [-name <arg>] [-no_pr_attribute] [-quiet] [-verbose]
			this.Entry(_builder.report_design_analysis(file, append, return_string, complexity, cells, bounding_boxes, hierarchical_depth, congestion, min_congestion_level, timing, setup, hold, show_all, full_logical_pin, routed_vs_estimated, logic_level_distribution, logic_level_dist_paths, min_level, max_level, return_timing_paths, of_timing_paths, max_paths, extend, routes, end_point_clocks, logic_levels, qor_summary, name, no_pr_attribute, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report disabled timing arcs<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_disable_timing [-user_disabled] [-column_style &lt;arg&gt;] [-file &lt;arg&gt;] [-append] [-cells &lt;args&gt;] [-return_string] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Displays a report of timing paths that will be excluded from timing analysis in the current<br/>
		/// synthesized or implemented design.<br/>
		/// The format of the report is organized into columns for "Cell or Port" to define the object<br/>
		/// associated with the timing path, "From" and "To" to define the timing path, the condition, and the<br/>
		/// reason for excluding the path from timing. The various reasons for exclusion are as follows:<br/>
		/// • constraint - set_disable_timing constraint is specified<br/>
		/// • constant - Logic constant<br/>
		/// • loop - Breaks a logic loop<br/>
		/// • bidirect instance path - Feedback path through bidirectional instances<br/>
		/// • bidirect net path - Feedback path on nets with bidirectional pins<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Note: By default the report is written to the Tcl console or STD output. However, the results can also be<br/>
		/// written to a file or returned as a string if desired.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports all timing paths that will not be included in timing analysis:<br/>
		/// report_disable_timing<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example outputs the disable timing report as a string, stores it in a variable, and<br/>
		/// then puts it to the display:<br/>
		/// set bad_time [report_disable_timing -return_string]<br/>
		/// puts $bad_time<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1346<br/>
		/// </para>
		/// </summary>
		/// <param name="user_disabled">(Optional) report only user disabled arcs</param>
		/// <param name="column_style">
		/// <para>
		/// (Optional)<br/>
		/// style for path report columns: Values: variable_width,<br/>
		/// anchor_left Default: variable_width<br/>
		/// </para>
		/// </param>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="cells">(Optional) run report_disable_timing on the specified cell(s)</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_disable_timing(bool? user_disabled = null, report_disable_timing_column_style? column_style = null, String file = null, bool? append = null, TCLParameterList cells = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_disable_timing [-user_disabled] [-column_style <arg>] [-file <arg>] [-append] [-cells <args>] [-return_string] [-quiet] [-verbose]
			this.Entry(_builder.report_disable_timing(user_disabled, column_style, file, append, cells, return_string, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Run DRC<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_drc [-name &lt;arg&gt;] [-upgrade_cw] [-checks &lt;args&gt;] [-ruledecks &lt;args&gt;] [-file &lt;arg&gt;] [-rpx &lt;arg&gt;] [-append] [-waived] [-no_waivers] [-return_string] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Check the current design against a specified set of design rule checks, or rule decks, and report<br/>
		/// any errors or violations that are found.<br/>
		/// The report_drc command requires an open design to check the design rules against. The<br/>
		/// command returns a report with the results of violations found by the design rule checks.<br/>
		/// Violations are returned as Vivado objects that can be listed with the get_drc_violations<br/>
		/// command, and are associated with cells, pins, ports, nets, and sites in the current design. You can<br/>
		/// get the cells, nets, and other design objects that are associated with DRC violation objects, using<br/>
		/// the -of_objects option of the get_cells command for instance.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// TIP: The report_drc can be multi-threaded to speed the process. Refer to the set_param command<br/>
		/// for more information on setting the general.maxThreads parameter.<br/>
		/// The Vivado tools include a large number of predefined design rule checks to be used by the<br/>
		/// report_drc command. Use the get_drc_checks command to list the currently defined<br/>
		/// design rule checks. You can also create new custom design rule checks using the<br/>
		/// create_drc_check command.<br/>
		/// A rule deck is a collection of design rule checks grouped for convenience, to be run at different<br/>
		/// stages of the FPGA design flow, such as during I/O planning or placement. The tool comes with a<br/>
		/// set of factory defined rule decks, but you can also create new user-defined rule decks with the<br/>
		/// create_drc_ruledeck command. Use the get_drc_ruledecks command to return a list<br/>
		/// of the currently defined rule decks available for use in the report_drc command.<br/>
		/// The report_drc command runs a default rule deck when the -checks or -ruledeck options<br/>
		/// are not specified. Creating a user-defined DRC automatically adds the new design rule check to<br/>
		/// the default rule deck.<br/>
		/// DRC rules can be enabled or disabled using the IS_ENABLED property on the rule check object.<br/>
		/// If a rule IS_ENABLED false, the rule will not be run by the report_drc command, whether it is<br/>
		/// specified directly using -checks, or indirectly with -ruledeck.<br/>
		/// TIP: You can reset the properties of a DRC rule to the factory default settings using the<br/>
		/// reset_drc_check command.<br/>
		/// You can reset the current results of the report_drc command, clearing any found violations,<br/>
		/// using the reset_drc command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example lists the available rule decks. The results include all factory rule decks and<br/>
		/// all user-defined rule decks.<br/>
		/// get_drc_ruledecks<br/>
		/// The following example returns the list of DRC rules defined in the specified rule deck:<br/>
		/// get_drc_checks -of_objects [get_drc_ruledecks placer_checks]<br/>
		/// The following examples run the specified DRC rule deck and rules against the current design, and<br/>
		/// writes the results to the specified file:<br/>
		/// report_drc -ruledecks placer_checks -file C:/Data/DRC_Rpt1.txt<br/>
		/// report_drc -checks {IOCNT-1 IOPCPR-1 IOPCMGT-1 IOCTMGT-1 IODIR-1} \<br/>
		/// -file C:/Data/DRC_Rpt1.txt -append<br/>
		/// Note: The -append option adds the result of the second report_drc command to the specified file.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1349<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="upgrade_cw">
		/// <para>
		/// (Optional)<br/>
		/// Specifies if report_drc should upgrade all<br/>
		/// CRITICAL_WARNING violations to ERROR.<br/>
		/// </para>
		/// </param>
		/// <param name="checks">(Optional) DRC checks (see get_drc_checks for available checks)</param>
		/// <param name="ruledecks">(Optional) Containers of DRC rule checks Default: default</param>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="rpx">(Optional) Report filename for persisted results.</param>
		/// <param name="append">(Optional) Append the results to file, do not overwrite the results file</param>
		/// <param name="waived">(Optional) Output result is Waived checks</param>
		/// <param name="no_waivers">(Optional) Disable waivers for checks</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_drc(String name = null, bool? upgrade_cw = null, TCLParameterList checks = null, TCLParameterList ruledecks = null, String file = null, String rpx = null, bool? append = null, bool? waived = null, bool? no_waivers = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_drc [-name <arg>] [-upgrade_cw] [-checks <args>] [-ruledecks <args>] [-file <arg>] [-rpx <arg>] [-append] [-waived] [-no_waivers] [-return_string] [-quiet] [-verbose]
			this.Entry(_builder.report_drc(name, upgrade_cw, checks, ruledecks, file, rpx, append, waived, no_waivers, return_string, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Print drivers along with current driving values for an HDL wire or signal object<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_drivers [-quiet] [-verbose] &lt;hdl_object&gt;
		/// <br/>
		/// <para>
		/// The report_drivers command prints the name and value of the driving signal, as well as the<br/>
		/// current value of a signal type HDL object.<br/>
		/// Use this command to determine what signal or process is driving the value on a specific HDL<br/>
		/// signal, or net object. A driver of a signal is the statement in the HDL source file that is performing<br/>
		/// assignment to the signal.<br/>
		/// The output format of report_drivers is as follows:<br/>
		/// Drivers for &lt;hdl_object&gt;<br/>
		/// &lt;Value of HDL Object&gt;: Net &lt;Hierarchical name of the probed signal&gt;<br/>
		/// [ Declared Net : &lt;The declared signal to which the probed signal is<br/>
		/// connected&gt;]<br/>
		/// &lt;Value of Driver&gt; : Driver &lt;Hierarchical name of the HDL process<br/>
		/// containing<br/>
		/// the driver&gt; at &lt;file_name&gt;:&lt;line number&gt;<br/>
		/// Note: The Declared Net is returned when the probed signal name is different from the hierarchical name of<br/>
		/// the actual declared signal due to the current scope of the simulation. Each bit of the declared net is printed<br/>
		/// for the probed signal.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The values of signals returned by the report_drivers command depend on the state of the<br/>
		/// simulation. In the following example, the report is run before and after simulation:<br/>
		/// current_scope /testbench/dut<br/>
		/// report_drivers leds_n[3:0]<br/>
		/// Drivers for /testbench/dut/LEDS_n[3:0]<br/>
		/// 0 : Net /testbench/dut/LEDS_n[0]<br/>
		/// Declared Net : /testbench/leds_n[3]<br/>
		/// 0 : Driver /testbench/dut/line__187 at C:/Data/sources/sinegen_demo.vhd:187<br/>
		/// 0 : Driver /testbench/dut/line__186 at C:/Data/sources/sinegen_demo.vhd:186<br/>
		/// 0 : Driver /testbench/dut/line__185 at C:/Data/sources/sinegen_demo.vhd:185<br/>
		/// 0 : Driver /testbench/dut/line__184 at C:/Data/sources/sinegen_demo.vhd:184<br/>
		/// 0 : Net /testbench/dut/LEDS_n[1]<br/>
		/// Declared Net : /testbench/leds_n[2]<br/>
		/// 0 : Driver /testbench/dut/line__187 at C:/Data/sources/sinegen_demo.vhd:187<br/>
		/// 0 : Driver /testbench/dut/line__186 at C:/Data/sources/sinegen_demo.vhd:186<br/>
		/// 0 : Driver /testbench/dut/line__185 at C:/Data/sources/sinegen_demo.vhd:185<br/>
		/// 0 : Driver /testbench/dut/line__184 at C:/Data/sources/sinegen_demo.vhd:184<br/>
		/// 0 : Net /testbench/dut/LEDS_n[2]<br/>
		/// Declared Net : /testbench/leds_n[1]<br/>
		/// 0 : Driver /testbench/dut/line__187 at C:/Data/sources/sinegen_demo.vhd:187<br/>
		/// 1 : Driver /testbench/dut/line__186 at C:/Data/sources/sinegen_demo.vhd:186<br/>
		/// 1 : Driver /testbench/dut/line__185 at C:/Data/sources/sinegen_demo.vhd:185<br/>
		/// 1 : Driver /testbench/dut/line__184 at C:/Data/sources/sinegen_demo.vhd:184<br/>
		/// X : Net /testbench/dut/LEDS_n[3]<br/>
		/// Declared Net : /testbench/leds_n[0]<br/>
		/// 0 : Driver /testbench/dut/line__187 at C:/Data/sources/sinegen_demo.vhd:187<br/>
		/// 0 : Driver /testbench/dut/line__186 at C:/Data/sources/sinegen_demo.vhd:186<br/>
		/// 0 : Driver /testbench/dut/line__185 at C:/Data/sources/sinegen_demo.vhd:185<br/>
		/// 0 : Driver /testbench/dut/line__184 at C:/Data/sources/sinegen_demo.vhd:184<br/>
		/// run all<br/>
		/// report_drivers leds_n[3:0]<br/>
		/// Drivers for /testbench/dut/LEDS_n[3:0]<br/>
		/// 0 : Net /testbench/dut/LEDS_n[0]<br/>
		/// Declared Net : /testbench/leds_n[3]<br/>
		/// 0 : Driver /testbench/dut/line__187 at C:/Data/sources/sinegen_demo.vhd:187<br/>
		/// 0 : Driver /testbench/dut/line__186 at C:/Data/sources/sinegen_demo.vhd:186<br/>
		/// 0 : Driver /testbench/dut/line__185 at C:/Data/sources/sinegen_demo.vhd:185<br/>
		/// 0 : Driver /testbench/dut/line__184 at C:/Data/sources/sinegen_demo.vhd:184<br/>
		/// 1 : Net /testbench/dut/LEDS_n[1]<br/>
		/// Declared Net : /testbench/leds_n[2]<br/>
		/// 0 : Driver /testbench/dut/line__187 at C:/Data/sources/sinegen_demo.vhd:187<br/>
		/// 0 : Driver /testbench/dut/line__186 at C:/Data/sources/sinegen_demo.vhd:186<br/>
		/// 0 : Driver /testbench/dut/line__185 at C:/Data/sources/sinegen_demo.vhd:185<br/>
		/// 0 : Driver /testbench/dut/line__184 at C:/Data/sources/sinegen_demo.vhd:184<br/>
		/// 0 : Net /testbench/dut/LEDS_n[2]<br/>
		/// Declared Net : /testbench/leds_n[1]<br/>
		/// 1 : Driver /testbench/dut/line__187 at C:/Data/sources/sinegen_demo.vhd:187<br/>
		/// 1 : Driver /testbench/dut/line__186 at C:/Data/sources/sinegen_demo.vhd:186<br/>
		/// 1 : Driver /testbench/dut/line__185 at C:/Data/sources/sinegen_demo.vhd:185<br/>
		/// 1 : Driver /testbench/dut/line__184 at C:/Data/sources/sinegen_demo.vhd:184<br/>
		/// 0 : Net /testbench/dut/LEDS_n[3]<br/>
		/// Declared Net : /testbench/leds_n[0]<br/>
		/// 0 : Driver /testbench/dut/line__187 at C:/Data/sources/sinegen_demo.vhd:187<br/>
		/// 0 : Driver /testbench/dut/line__186 at C:/Data/sources/sinegen_demo.vhd:186<br/>
		/// 1 : Driver /testbench/dut/line__185 at C:/Data/sources/sinegen_demo.vhd:185<br/>
		/// 0 : Driver /testbench/dut/line__184 at C:/Data/sources/sinegen_demo.vhd:184<br/>
		/// Note: Notice the declared net is reported, because the current scope of the simulation is set to a different<br/>
		/// level than the top-level of the test bench.<br/>
		/// This command returns a report of the drivers on the specified objects, or returns an error if it<br/>
		/// fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports the drivers for the HDL objects returned by the get_objects<br/>
		/// command:<br/>
		/// report_drivers [get_objects leds_n]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1353<br/>
		/// </para>
		/// </summary>
		/// <param name="hdl_object">(Required) Which hdl_object to report</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_drivers(String hdl_object, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_drivers [-quiet] [-verbose] <hdl_object>
			this.Entry(_builder.report_drivers(hdl_object, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report system information.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_environment [-file &lt;arg&gt;] [-format &lt;arg&gt;] [-append] [-return_string] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Report the details of the system environment that the tool is running under. The details of the<br/>
		/// environment report include: operating system version, CPU, memory, available disk space, and<br/>
		/// specific settings of various environment variables.<br/>
		/// The default is to write the report to the standard output. However, the report can be written to a<br/>
		/// file instead.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports the current environment to the specified file:<br/>
		/// report_environment -file C:/Data/toolEnv.txt<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1356<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Optional) Write system information to specified file.</param>
		/// <param name="format">
		/// <para>
		/// (Optional)<br/>
		/// Specifies how to format the report. Default is 'text', another<br/>
		/// option is 'xml'. Only applies if -file is used. If xml output is<br/>
		/// used, -append is not allowed. Default: text<br/>
		/// </para>
		/// </param>
		/// <param name="append">(Optional) Append report to existing file</param>
		/// <param name="return_string">(Optional) Return report content as a string value</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_environment(String file = null, String format = null, bool? append = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_environment [-file <arg>] [-format <arg>] [-append] [-return_string] [-quiet] [-verbose]
			this.Entry(_builder.report_environment(file, format, append, return_string, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report timing exceptions<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_exceptions [-from &lt;args&gt;] [-rise_from &lt;args&gt;] [-fall_from &lt;args&gt;] [-to &lt;args&gt;] [-rise_to &lt;args&gt;] [-fall_to &lt;args&gt;] [-through &lt;args&gt;] [-rise_through &lt;args&gt;] [-fall_through &lt;args&gt;] [-ignored] [-summary] [-coverage] [-ignored_objects] [-count_objects] [-write_merged_exceptions] [-write_valid_exceptions] [-no_header] [-file &lt;arg&gt;] [-append] [-return_string] [-name &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Report all timing exceptions applied to setup and hold checks defined by timing constraints in the<br/>
		/// current design, or report the exceptions on the specified timing paths.<br/>
		/// Timing exceptions can be defined by timing constraints such as set_false_path or<br/>
		/// set_multicycle_path that change the default assumptions for timing paths in the design.<br/>
		/// The exceptions are reported to the standard output by default, but can be redirected to a file or<br/>
		/// to a Tcl string variable.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// This example reports all timing exceptions in the current design:<br/>
		/// report_exceptions<br/>
		/// This example reports all timing exceptions ignored or overridden in the current design:<br/>
		/// report_exceptions -ignored<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1358<br/>
		/// </para>
		/// </summary>
		/// <param name="from">(Optional) From pins, ports, cells or clocks</param>
		/// <param name="rise_from">(Optional) Rising from pins, ports, cells or clocks</param>
		/// <param name="fall_from">(Optional) Falling from pins, ports, cells or clocks</param>
		/// <param name="to">(Optional) To pins, ports, cells or clocks</param>
		/// <param name="rise_to">(Optional) Rising to pins, ports, cells or clocks</param>
		/// <param name="fall_to">(Optional) Falling to pins, ports, cells or clocks</param>
		/// <param name="through">(Optional) Through pins, ports, cells or nets</param>
		/// <param name="rise_through">(Optional) Rising through pins, ports, cells or nets</param>
		/// <param name="fall_through">(Optional) Falling through pins, ports, cells or nets</param>
		/// <param name="ignored">(Optional) Only report exceptions which are fully ignored</param>
		/// <param name="summary">(Optional) Report a summary of all exceptions</param>
		/// <param name="coverage">(Optional) Report the coverage of all timing exceptions</param>
		/// <param name="ignored_objects">(Optional) Report the list of ignored startpoints and endpoints</param>
		/// <param name="count_objects">(Optional) Report the number of objects in the timing exceptions</param>
		/// <param name="write_merged_exceptions">(Optional) Write merged timing exceptions</param>
		/// <param name="write_valid_exceptions">(Optional) Write timing exceptions with the valid objects only</param>
		/// <param name="no_header">(Optional) Do not generate a report header</param>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="return_string">(Optional) Return report as string</param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">
		/// <para>
		/// (Optional)<br/>
		/// Suspend message limits during command execution<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// </param>
		public VivadoTCL report_exceptions(TCLParameterList from = null, TCLParameterList rise_from = null, TCLParameterList fall_from = null, TCLParameterList to = null, TCLParameterList rise_to = null, TCLParameterList fall_to = null, TCLParameterList through = null, TCLParameterList rise_through = null, TCLParameterList fall_through = null, bool? ignored = null, bool? summary = null, bool? coverage = null, bool? ignored_objects = null, bool? count_objects = null, bool? write_merged_exceptions = null, bool? write_valid_exceptions = null, bool? no_header = null, String file = null, bool? append = null, bool? return_string = null, String name = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_exceptions [-from <args>] [-rise_from <args>] [-fall_from <args>] [-to <args>] [-rise_to <args>] [-fall_to <args>] [-through <args>] [-rise_through <args>] [-fall_through <args>] [-ignored] [-summary] [-coverage] [-ignored_objects] [-count_objects] [-write_merged_exceptions] [-write_valid_exceptions] [-no_header] [-file <arg>] [-append] [-return_string] [-name <arg>] [-quiet] [-verbose]
			this.Entry(_builder.report_exceptions(from, rise_from, fall_from, to, rise_to, fall_to, through, rise_through, fall_through, ignored, summary, coverage, ignored_objects, count_objects, write_merged_exceptions, write_valid_exceptions, no_header, file, append, return_string, name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Print, in textual format, stack frames when current_scope is a process waiting inside subprogram<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_frames [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Returns a list of strings of sub-program names, and the calling HDL process in the sub-program<br/>
		/// call hierarchy for the current HDL process scope, or current_scope. The list starts with the<br/>
		/// HDL process till the most recent sub-program in the hierarchy. Each frame has an associated<br/>
		/// frame-index. The most recent sub-program is shown at the top, and has an index "0". The symbol<br/>
		/// (-&gt;) is used to indicate the current_frame.<br/>
		/// By default, the most recently called sub-program frame is the current_frame. Other frames<br/>
		/// can be selected using current_frame command. In verbose mode, output gives the source<br/>
		/// line-file information for each and every call.<br/>
		/// IMPORTANT! report_frames strictly follows the current_scope . If the current_scope is not<br/>
		/// an HDL process scope waiting inside a sub-program, the command returns an empty list.<br/>
		/// This command returns the name of the design object of the current_instance, or returns nothing<br/>
		/// when set to the top of current design.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// Example design:<br/>
		/// module top;<br/>
		/// int i;<br/>
		/// function void f(input int in1);<br/>
		/// automatic int a;<br/>
		/// a = in1 + 7;<br/>
		/// $display($time, " in f :: a %d in1 %d ", a, in1);<br/>
		/// endfunction<br/>
		/// task automatic t(input int in2);<br/>
		/// int b;<br/>
		/// b = in2 + 10;<br/>
		/// $display($time, " in t :: in2 %d b %d ", in2, b);<br/>
		/// #5;<br/>
		/// f(b); // Case C<br/>
		/// $display($time, " Back in t : after wait and f(%d) ", b);<br/>
		/// endtask<br/>
		/// initial begin // "/top/Initial18_0"<br/>
		/// $display($time, " in initial 1 ");<br/>
		/// i = 200;<br/>
		/// t(i); // Case B<br/>
		/// $display($time, " Back in initial 1 after t(%d) ", i);<br/>
		/// end<br/>
		/// initial begin // "/top/Initial25_1"<br/>
		/// $display($time, " in initial 2 ");<br/>
		/// #2;<br/>
		/// f(50); // Case A<br/>
		/// $display($time, " Back in initial 2 after f(50) ");<br/>
		/// end<br/>
		/// endmodule<br/>
		/// When simulation is stopped inside function "f" for its call at 'Case C', function "f" is called from<br/>
		/// task "t" at 'Case C', which itself is called from process "/top/Initial18_0" at 'Case B':<br/>
		/// &gt; current_scope<br/>
		/// /top/Initial18_0<br/>
		/// 1. &gt; report_frames<br/>
		/// -&gt; 0 : f<br/>
		/// 1 : t<br/>
		/// 2: /top/Initial18_0<br/>
		/// 2. &gt; report_frames -verbose<br/>
		/// -&gt; 0 : f @top.v:6<br/>
		/// 1 : t @top.v:15<br/>
		/// 2 : /top/Initial18_0 @top.v:21<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1362<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Returns string</returns>
		public VivadoTCL report_frames(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_frames [-quiet] [-verbose]
			this.Entry(_builder.report_frames(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report high fanout nets<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_high_fanout_nets [-file &lt;arg&gt;] [-format &lt;arg&gt;] [-append] [-ascending] [-timing] [-histogram] [-load_types] [-clock_regions] [-slr] [-max_nets &lt;arg&gt;] [-fanout_greater_than &lt;arg&gt;] [-fanout_lesser_than &lt;arg&gt;] [-name &lt;arg&gt;] [-cells &lt;args&gt;] [-clocks &lt;args&gt;] [-return_string] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Report the fanout of nets in the design, starting with the highest fanout nets, and working down.<br/>
		/// Options allow you to control various aspects of the report.<br/>
		/// This command can be run on an implemented design, or on the synthesized netlist. However, the<br/>
		/// results will be more complete on the implemented design.<br/>
		/// The command returns the fanout report of nets in the design, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports the fanout of nets for the specified clocks:<br/>
		/// report_high_fanout_nets -clocks [get_clocks gt*]<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example reports the nets with fanouts less than 10 loads, and returns the results to<br/>
		/// a string stored as a Tcl variable:<br/>
		/// set myRep [report_high_fanout_nets -fanout_lesser_than 10 -return_string]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1365<br/>
		/// </para>
		/// </summary>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// (Optional)<br/>
		/// Specifies how to format the report: text, xml. Default is<br/>
		/// 'text'. Only applies if -file is used. If xml output is used, -<br/>
		/// append is not allowed. Default: text<br/>
		/// </para>
		/// </param>
		/// <param name="append">(Optional) Append to existing file</param>
		/// <param name="ascending">(Optional) Report nets in ascending order</param>
		/// <param name="timing">(Optional) Report worst slack and worst delay values on nets</param>
		/// <param name="histogram">(Optional) Report histogram for high fanout nets</param>
		/// <param name="load_types">(Optional) Report load details</param>
		/// <param name="clock_regions">(Optional) Report clock region wise load distribution</param>
		/// <param name="slr">(Optional) Report SLR wise load distribution</param>
		/// <param name="max_nets">(Optional) Number of nets for which report is to be generated Default: 10</param>
		/// <param name="fanout_greater_than">
		/// <para>
		/// (Optional)<br/>
		/// Report nets that have fanout greater than the specified<br/>
		/// integer, default 0 Default: 0<br/>
		/// </para>
		/// </param>
		/// <param name="fanout_lesser_than">
		/// <para>
		/// (Optional)<br/>
		/// Report nets that have fanout less than the specified integer,<br/>
		/// default INT_MAX Default: INT_MAX<br/>
		/// </para>
		/// </param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="cells">(Optional) Report the nets of the specified cells</param>
		/// <param name="clocks">(Optional) Report the nets of the specified clocks</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">
		/// <para>
		/// (Optional)<br/>
		/// Suspend message limits during command execution<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// </param>
		/// <returns>Report</returns>
		public VivadoTCL report_high_fanout_nets(String file = null, String format = null, bool? append = null, bool? ascending = null, bool? timing = null, bool? histogram = null, bool? load_types = null, bool? clock_regions = null, bool? slr = null, Int32? max_nets = null, String fanout_greater_than = null, String fanout_lesser_than = null, String name = null, TCLParameterList cells = null, TCLParameterList clocks = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_high_fanout_nets [-file <arg>] [-format <arg>] [-append] [-ascending] [-timing] [-histogram] [-load_types] [-clock_regions] [-slr] [-max_nets <arg>] [-fanout_greater_than <arg>] [-fanout_lesser_than <arg>] [-name <arg>] [-cells <args>] [-clocks <args>] [-return_string] [-quiet] [-verbose]
			this.Entry(_builder.report_high_fanout_nets(file, format, append, ascending, timing, histogram, load_types, clock_regions, slr, max_nets, fanout_greater_than, fanout_lesser_than, name, cells, clocks, return_string, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report formatted hardware AXI Transaction data<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_hw_axi_txn [-w &lt;arg&gt;] [-t &lt;arg&gt;] [-quiet] [-verbose] &lt;hw_axi_txns&gt;...
		/// <br/>
		/// <para>
		/// Report the results of the specified AXI transactions on the JTAG to AXI Master, hw_axi.<br/>
		/// You can use this command after creating hw_axi_txn objects on existing hw_axi objects, and<br/>
		/// then running the hw_axi to exercise the defined transaction.<br/>
		/// The JTAG to AXI Master core can only be controlled using Tcl commands. You can issue AXI read<br/>
		/// and write transactions using the create_hw_axi_txns command. However, before issuing<br/>
		/// these commands, it is important to reset the JTAG to AXI Master core using the reset_hw_axi<br/>
		/// command.<br/>
		/// This command reports the transaction data in the specified format, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1369<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_axi_txns">(Required) hardware AXI Transaction object to report</param>
		/// <param name="w">(Optional) Output data bytes per output line. Default: 8</param>
		/// <param name="t">
		/// <para>
		/// (Optional)<br/>
		/// d[SIZE] signed decimal, SIZE bytes per integer, b[SIZE]<br/>
		/// binary, SIZE bytes per integer, o[SIZE] octal, SIZE bytes per<br/>
		/// integer, u[SIZE] unsigned decimal, SIZE bytes per integer,<br/>
		/// x[SIZE] hexadecimal, SIZE bytes per integer Default: x4 (4-<br/>
		/// bytes in hex)<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_hw_axi_txn(TCLParameterList hw_axi_txns, String w = null, String t = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_hw_axi_txn [-w <arg>] [-t <arg>] [-quiet] [-verbose] <hw_axi_txns>...
			this.Entry(_builder.report_hw_axi_txn(hw_axi_txns, w, t, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Formatted report on Versal integrated and soft Memory Controllers' (DDRMCs) memory<br/>
		/// configurations, calibration status, stages, and window margins data.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_hw_ddrmc [-file &lt;arg&gt;] [-append] [-return_string] [-quiet] [-verbose] &lt;hw_objects&gt;
		/// <br/>
		/// <para>
		/// Report formatted information on memory IP hardware configuration, calibration, and margin.<br/>
		/// Does not include the graphical margin scan plots that are available within the Vivado logic<br/>
		/// analyzer, or Vivado Lab Edition.<br/>
		/// In the Vivado tools, Versal memory controllers implemented into a design are associated with<br/>
		/// hw_ddrmc objects. These hw_ddrmc objects let you verify the calibration, read, and write<br/>
		/// window margins in your memory interface design. You can use the hardware manager GUI to<br/>
		/// check the calibration status, verify the read margin for both rising and falling edges of the clock,<br/>
		/// and write margin for both simple and complex patterns. You can also use an ILA and VIO core to<br/>
		/// verify the data integrity for the read and write operations.<br/>
		/// This command returns the reported data, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example generates the report on the hw_ddrmc objects and outputs them to the<br/>
		/// text file specified:<br/>
		/// report_hw_ddrmc -file C:/Data/ddrmc_report.txt [get_hw_ddrmcs]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1372<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_objects">(Required) hardware DDRMC objects</param>
		/// <param name="file">(Optional) file name (including full path) to output the report results to</param>
		/// <param name="append">(Optional) set this option to append the report results to a file</param>
		/// <param name="return_string">(Optional) set this option to have report results returned as a string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_hw_ddrmc(String hw_objects, String file = null, bool? append = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_hw_ddrmc [-file <arg>] [-append] [-return_string] [-quiet] [-verbose] <hw_objects>
			this.Entry(_builder.report_hw_ddrmc(hw_objects, file, append, return_string, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report formatted hardware MIG calibration status and margin data<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_hw_mig [-file &lt;arg&gt;] [-append] [-return_string] [-quiet] [-verbose] &lt;hw_objects&gt;
		/// <br/>
		/// <para>
		/// Report formatted information on memory IP hardware configuration, calibration, and margin.<br/>
		/// Does not include the graphical margin scan plots that are available within the Vivado logic<br/>
		/// analyzer, or Vivado Lab Edition.<br/>
		/// In the Vivado tools, memory controllers implemented into a design are associated with hw_mig<br/>
		/// objects. These hw_mig objects let you verify the calibration, read, and write window margins in<br/>
		/// your memory interface design. You can use the hardware manager GUI to check the calibration<br/>
		/// status, verify the read margin for both rising and falling edges of the clock, and write margin for<br/>
		/// both simple and complex patterns, or DQS. You can also use an ILA core to verify the data<br/>
		/// integrity for the read and write operations.<br/>
		/// This command returns the reported data, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example generates the report on the hw_mig objects and outputs to the text file<br/>
		/// specified:<br/>
		/// report_hw_mig -file C:/Data/hw_mig_report.txt [get_hw_migs]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1374<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_objects">(Required) hardware mig objects</param>
		/// <param name="file">(Optional) file name (including full path) to output the report results to</param>
		/// <param name="append">(Optional) set this option to append the report results to a file</param>
		/// <param name="return_string">(Optional) set this option to have report results return as a string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_hw_mig(String hw_objects, String file = null, bool? append = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_hw_mig [-file <arg>] [-append] [-return_string] [-quiet] [-verbose] <hw_objects>
			this.Entry(_builder.report_hw_mig(hw_objects, file, append, return_string, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Formatted report for PCIe core.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_hw_pcie [-file &lt;arg&gt;] [-append] [-return_string] [-quiet] [-verbose] &lt;hw_pcie&gt;
		/// <br/>
		/// <para>
		/// Generate a report for the Peripheral Component Interconnect Express (PCIe) debug core object,<br/>
		/// hw_pcie, defined on the current hardware device.<br/>
		/// The customizable LogiCORE IP PCIe core for Xilinx ACAPs is designed for evaluating and<br/>
		/// monitoring the PCIe Link Training and Status State Machine (LTSSM) running on the Gigabit<br/>
		/// Transceivers (GTs). In the Vivado Hardware Manager, Versal PCIe soft cores implemented in the<br/>
		/// design, are represented as hw_pcie objects. You can use these PCIe debug cores to solve a range<br/>
		/// of debug and validation problems; from viewing the PCIe link info to the LTSSM state transition<br/>
		/// diagram.<br/>
		/// This command generates a report with general information about the PCIe core, the LTSSM state<br/>
		/// visitation status and the trace data for the LTSSM transition graph.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example generates a report for the PCIe core at index 0<br/>
		/// report_hw_pcie [lindex [get_hw_pcies] 0]<br/>
		/// The following example generates the report for the hw_pcie objects and outputs them to the text<br/>
		/// file specified<br/>
		/// report_hw_pcie -file C:/data/pcie_report.txt [get_hw_pcies]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1376<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_pcie">(Required) Hardware PCIe object</param>
		/// <param name="file">(Optional) File name (including full path) to output the report results to</param>
		/// <param name="append">(Optional) Append the report results to a file</param>
		/// <param name="return_string">(Optional) Return report results as a string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_hw_pcie(String hw_pcie, String file = null, bool? append = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_hw_pcie [-file <arg>] [-append] [-return_string] [-quiet] [-verbose] <hw_pcie>
			this.Entry(_builder.report_hw_pcie(hw_pcie, file, append, return_string, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Formatted report on Versal soft Memory Controller cores' (Soft MCs) memory configurations,<br/>
		/// calibration status, stages, and window margins data.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_hw_softmc [-file &lt;arg&gt;] [-append] [-return_string] [-quiet] [-verbose] &lt;hw_objects&gt;
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1378<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_objects">(Required) hardware Soft MC objects</param>
		/// <param name="file">(Optional) file name (including full path) to output the report results to</param>
		/// <param name="append">(Optional) set this option to append the report results to a file</param>
		/// <param name="return_string">(Optional) set this option to have report results returned as a string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_hw_softmc(String hw_objects, String file = null, bool? append = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_hw_softmc [-file <arg>] [-append] [-return_string] [-quiet] [-verbose] <hw_objects>
			this.Entry(_builder.report_hw_softmc(hw_objects, file, append, return_string, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report properties on hardware objects<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_hw_targets [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// This command returns properties related to the configuration of all hw_targets on the<br/>
		/// current_hw_server object. The information reported by this command includes:<br/>
		/// • Server Property Information: The properties of the current_hw_server, including HOST and<br/>
		/// PORT.<br/>
		/// • Target Property Information: Reported for each target on the hw_server, including NAME,<br/>
		/// FREQUENCY, DEVICE_COUNT, and SVF.<br/>
		/// • Device Property Information: Reported for each device on a specific hw_target, including<br/>
		/// PART, ID CODE, IR LENGTH, MASK, PROGRAMMING and PROBES FILE.<br/>
		/// This command returns the requested information if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports the property information for all targets on the connected<br/>
		/// hw_server:<br/>
		/// report_hw_targets<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1379<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>hardware objects</returns>
		public VivadoTCL report_hw_targets(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_hw_targets [-quiet] [-verbose]
			this.Entry(_builder.report_hw_targets(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Compute achievable incremental reuse for the given design-checkpoint and report<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_incremental_reuse [-file &lt;arg&gt;] [-append] [-cells &lt;args&gt;] [-hierarchical] [-hierarchical_depth &lt;arg&gt;] [-return_string] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// For use with the incremental implementation flow, this command reports on the amount of<br/>
		/// design overlap between the current design and an incremental checkpoint loaded using the<br/>
		/// read_checkpoint -incremental command.<br/>
		/// This report analyzes the loaded incremental checkpoint against the current design to see if the<br/>
		/// two are sufficiently correlated to drive incremental placement and routing. A low correlation<br/>
		/// between the current design and the checkpoint should discourage using the checkpoint as a<br/>
		/// basis for incremental place and route. Refer to the Vivado Design Suite User Guide: Implementation<br/>
		/// (UG904) for more information on incremental place and route.<br/>
		/// If there is a low correlation of reuse between the current design and the loaded incremental<br/>
		/// checkpoint, you will need to restore the original design using open_run or read_checkpoint.<br/>
		/// Alternatively, you can overload the incremental checkpoint in the current design by issuing the<br/>
		/// read_checkpoint -incremental command again to specify a new incremental checkpoint.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// For Partial Reconfiguration (PR) designs, the % of cells matching in Reconfigurable Modules (RM)<br/>
		/// are reported, the % of cells reused in RMs, and the % of cells fixed in RMs are also reported.<br/>
		/// There is also a Reconfigurable Modules Summary table added to the report.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example loads an incremental checkpoint into the current design, and then reports<br/>
		/// the correlation of the loaded incremental checkpoint to the current design:<br/>
		/// read_checkpoint -incremental C:/Data/reuse_checkpoint1.dcp<br/>
		/// report_incremental_reuse<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1381<br/>
		/// </para>
		/// </summary>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="append">(Optional) Append to existing file</param>
		/// <param name="cells">(Optional) Report incremental reuse of given list of cells</param>
		/// <param name="hierarchical">(Optional) Generates text-based hierarchical incremental reuse report.</param>
		/// <param name="hierarchical_depth">
		/// <para>
		/// (Optional)<br/>
		/// Specifies the depth level for textual hierachical incremental<br/>
		/// reuse report Default: 0<br/>
		/// </para>
		/// </param>
		/// <param name="return_string">(Optional) Return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_incremental_reuse(String file = null, bool? append = null, TCLParameterList cells = null, bool? hierarchical = null, String hierarchical_depth = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_incremental_reuse [-file <arg>] [-append] [-cells <args>] [-hierarchical] [-hierarchical_depth <arg>] [-return_string] [-quiet] [-verbose]
			this.Entry(_builder.report_incremental_reuse(file, append, cells, hierarchical, hierarchical_depth, return_string, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Display information about all the IO sites on the device<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_io [-file &lt;arg&gt;] [-name &lt;arg&gt;] [-append] [-format &lt;arg&gt;] [-return_string] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Report details of the IO banks of the current design. Details include device specific information<br/>
		/// such as target part, package, and speed grade, and also provides information related to each pin<br/>
		/// on the device.<br/>
		/// This command returns the requested report, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports the IO blocks of the current design:<br/>
		/// report_io<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1384<br/>
		/// </para>
		/// </summary>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. Send output to console if -file<br/>
		/// is not used.<br/>
		/// </para>
		/// </param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="append">(Optional) Append to existing file</param>
		/// <param name="format">
		/// <para>
		/// (Optional)<br/>
		/// Specifies how to format the report: text, xml. Default is<br/>
		/// 'text'. Only applies if -file is used. If xml output is used, -<br/>
		/// append is not allowed. Default: text<br/>
		/// </para>
		/// </param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Report</returns>
		public VivadoTCL report_io(String file = null, String name = null, bool? append = null, String format = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_io [-file <arg>] [-name <arg>] [-append] [-format <arg>] [-return_string] [-quiet] [-verbose]
			this.Entry(_builder.report_io(file, name, append, format, return_string, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report on the status of the IP instances in the project.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_ip_status [-name &lt;arg&gt;] [-file &lt;arg&gt;] [-append] [-return_string] [-license_status] [-resource_data] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// This command examines the IP cores in the current project, and reports the state of the IP with<br/>
		/// regard to the latest IP catalog. The following information is included in the IP Status report:<br/>
		/// • Instance Name - The name of the IP core in the current project.<br/>
		/// • IP Status - A description of the state of the IP in the current project.<br/>
		/// • Recommendation - A recommended action based on the status.<br/>
		/// • Lock Status - An explanation of the lock status of the IP in the current project.<br/>
		/// • Change Log - A reference to the change log for the IP update in the catalog. This will provide a<br/>
		/// description of the changes in the latest IP.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// • IP Name - The name of the IP core in the catalog.<br/>
		/// • IP Version - The version of the IP in use in the current project.<br/>
		/// • New Version - The latest version of the IP in the catalog.<br/>
		/// • New license - The license status for the new IP version.<br/>
		/// • Original Part - The original part associated with the IP in the catalog.<br/>
		/// IP cores that are out of date, or locked, may need to be upgraded and the output products<br/>
		/// regenerated. Refer to the Vivado Design Suite User Guide: Designing with IP (UG896) for more<br/>
		/// information.<br/>
		/// The report_ip_status command checks the available licenses on the local machine, or on the<br/>
		/// license server, for all IP cores in the current project. If a license can be found, the license<br/>
		/// information is printed. If the license cannot be found, this information is also printed.<br/>
		/// This command returns the IP status report, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports the IP status to the specified file, appending the results if the file<br/>
		/// already exists:<br/>
		/// report_ip_status -file C:/Data/reports/ip_status.txt -append<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1386<br/>
		/// </para>
		/// </summary>
		/// <param name="name">
		/// <para>
		/// (Optional)<br/>
		/// Output the results to GUI panel with this name Values: The<br/>
		/// name of the GUI dialog<br/>
		/// </para>
		/// </param>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to (send output to console if -file<br/>
		/// is not used) Values: The report filename<br/>
		/// </para>
		/// </param>
		/// <param name="append">(Optional) Append to existing file</param>
		/// <param name="return_string">(Optional) Return report as string</param>
		/// <param name="license_status">(Optional) Report the license status of the generated outputs for each IP</param>
		/// <param name="resource_data">(Optional) Report the resource data usage for each IP instance</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>True for success</returns>
		public VivadoTCL report_ip_status(String name = null, String file = null, bool? append = null, bool? return_string = null, bool? license_status = null, bool? resource_data = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_ip_status [-name <arg>] [-file <arg>] [-append] [-return_string] [-license_status] [-resource_data] [-quiet] [-verbose]
			this.Entry(_builder.report_ip_status(name, file, append, return_string, license_status, resource_data, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Methodology Checks<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_methodology [-name &lt;arg&gt;] [-cells &lt;args&gt;] [-checks &lt;args&gt;] [-file &lt;arg&gt;] [-rpx &lt;arg&gt;] [-append] [-waived] [-no_waivers] [-slack_lesser_than &lt;arg&gt;] [-return_string] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Check the current design against a specified set of methodology checks and report any errors or<br/>
		/// violations that are found.<br/>
		/// Methodology checks are a special class of design rule checks (DRC) that are accessible through<br/>
		/// this separate Tcl command. The methodology checks are a necessary part of the design flow, and<br/>
		/// should be considered mandatory after implementation and prior to generating the bitstream.<br/>
		/// TIP: Other than their availability through the separate report_methodology command, the checks<br/>
		/// are standard design rule checks in every other way.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The report_methodology command requires an open design to check the design rules<br/>
		/// against. The command returns a report with the results of violations found by the design rule<br/>
		/// checks. Violations are returned as Vivado objects that can be listed with the<br/>
		/// get_methodology_violations command, and are associated with cells, pins, ports, nets,<br/>
		/// and sites in the current design. You can get the cells, nets, and other design objects that are<br/>
		/// associated with methodology violation objects, using the -of_objects option of the<br/>
		/// get_cells command for instance.<br/>
		/// The report_methodology command runs the methodology rule deck, or you can use the -<br/>
		/// checks option to specify the set of checks to run. Methodology checks can also be enabled or<br/>
		/// disabled in the default rule decks using the IS_ENABLED property on the rule check object:<br/>
		/// set_property IS_ENABLED FALSE [get_methodology_checks PDRC-190]<br/>
		/// If a rule IS_ENABLED false, the rule will not be run by the report_methodology command.<br/>
		/// TIP: You can reset the properties of a methodology rule to the factory default settings using the<br/>
		/// reset_methodology_check command.<br/>
		/// You can reset the current results of the report_methodology command, clearing any found<br/>
		/// violations, using the reset_methodology command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following examples run the default methodology checks against the current design, and<br/>
		/// writes the results to the specified file:<br/>
		/// report_methodology -file C:/Data/methodology_Rpt1.txt -append<br/>
		/// Note: The -append option adds the result to the specified file.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1389<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="cells">(Optional) Run report_methodology on the specified cell(s).</param>
		/// <param name="checks">
		/// <para>
		/// (Optional)<br/>
		/// Report Methodology checks (see get_methodology_checks<br/>
		/// for available checks)<br/>
		/// </para>
		/// </param>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="rpx">(Optional) Report filename for persisted results.</param>
		/// <param name="append">(Optional) Append the results to file, do not overwrite the results file</param>
		/// <param name="waived">(Optional) Output result is Waived checks</param>
		/// <param name="no_waivers">(Optional) Disable waivers for checks</param>
		/// <param name="slack_lesser_than">(Optional) Set SYNTH rules Slack Threshold value in 'ns' (float) Default: 2.0</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_methodology(String name = null, TCLParameterList cells = null, TCLParameterList checks = null, String file = null, String rpx = null, bool? append = null, bool? waived = null, bool? no_waivers = null, String slack_lesser_than = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_methodology [-name <arg>] [-cells <args>] [-checks <args>] [-file <arg>] [-rpx <arg>] [-append] [-waived] [-no_waivers] [-slack_lesser_than <arg>] [-return_string] [-quiet] [-verbose]
			this.Entry(_builder.report_methodology(name, cells, checks, file, rpx, append, waived, no_waivers, slack_lesser_than, return_string, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Print details of the given hdl objects (variable, signal, wire, or reg)<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_objects [-quiet] [-verbose] [&lt;hdl_objects&gt;...]
		/// <br/>
		/// <para>
		/// The report_objects command reports the type, name, and language of the specified HDL<br/>
		/// objects to the Tcl Console or Tcl shell. You must have an open simulation to use this command.<br/>
		/// This command returns a brief description of the specified objects. Use the describe command<br/>
		/// to return more detailed information.<br/>
		/// HDL objects include HDL signals, variables, or constants as defined in the Verilog or VHDL test<br/>
		/// bench and source files. An HDL signal includes Verilog wire or reg entities, and VHDL signals.<br/>
		/// Examples of HDL variables include Verilog real, realtime, time, and event. HDL constants include<br/>
		/// Verilog parameters and localparams, and VHDL generic and constants.<br/>
		/// The command returns the HDL object type, the name, and the code type (Verilog/VHDL) for<br/>
		/// each object, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// Verilog parameters and localparams, and VHDL generic and constants.<br/>
		/// The command returns the HDL object type, the name, and the code type (Verilog/VHDL) for<br/>
		/// each object, or returns an error if it fails.<br/>
		/// Arguments<br/>
		/// -quiet - (Optional) Execute the command quietly, returning no messages from the command.<br/>
		/// The command also returns TCL_OK regardless of any errors encountered during execution.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Note: Any errors encountered on the command-line, while launching the command, will be returned. Only<br/>
		/// errors occurring inside the command will be trapped.<br/>
		/// -verbose - (Optional) Temporarily override any message limits and return all messages from this<br/>
		/// command.<br/>
		/// Note: Message limits can be defined with the set_msg_config command.<br/>
		/// &lt;hdl_objects&gt; - (Optional) Specifies the objects to report. The default command reports all<br/>
		/// objects found in the current scope of the simulation, or current_scope.<br/>
		/// Note: Objects can be specified by name, or returned as objects by the get_objects command.<br/>
		/// Examples<br/>
		/// The following example shows how the specified objects reported depend upon the current scope<br/>
		/// of the simulation:<br/>
		/// current_scope testbench<br/>
		/// /testbench<br/>
		/// report_objects [get_objects leds_n]<br/>
		/// Declared: {leds_n[3:0]} Verilog<br/>
		/// current_scope dut<br/>
		/// /testbench/dut<br/>
		/// report_objects leds_n<br/>
		/// Out: {LEDS_n[3:0]} VHDL<br/>
		/// This example reports the specified HDL objects of the current simulation scope:<br/>
		/// report_objects [get_objects GPIO*]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1393<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hdl_objects">(Optional) The hdl_objects to report. Default is report_objects [get_objects *]</param>
		/// <returns>Print name, type, data_type of the HDL objects on console in textual format</returns>
		public VivadoTCL report_objects(bool? quiet = null, bool? verbose = null, TCLParameterList hdl_objects = null)
		{
			// TCL Syntax: report_objects [-quiet] [-verbose] [<hdl_objects>...]
			this.Entry(_builder.report_objects(quiet, verbose, hdl_objects));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get operating conditions values for power estimation<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_operating_conditions [-voltage &lt;args&gt;] [-voltage_range &lt;args&gt;] [-grade] [-process] [-junction_temp] [-ambient_temp] [-thetaja] [-thetasa] [-airflow] [-heatsink] [-thetajb] [-board] [-board_temp] [-board_layers] [-design_power_budget] [-all] [-file &lt;arg&gt;] [-return_string] [-append] [-supply_current_budget &lt;args&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Displays the real-world operating conditions that are used when performing analysis of the<br/>
		/// design. The reported values of operating conditions can be defined by the<br/>
		/// set_operating_conditions command.<br/>
		/// The environmental operating conditions of the device are used for power analysis when running<br/>
		/// the report_power command, but are not used during timing analysis.<br/>
		/// Note: By default the report is written to the Tcl console or STD output. However, the results can also be<br/>
		/// written to a file or returned as a string if desired.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// Specify an industrial temperature grade device with an ambient temperature of 75 degrees C and<br/>
		/// then write those settings to a file on disk.<br/>
		/// set_operating_conditions -grade industrial -junction_temp 75<br/>
		/// report_operating_conditions -grade -junction_temp -return_string -file \<br/>
		/// ~/conditions.txt<br/>
		/// Get voltage ranges of VCCINT and VCCAUX for the target device.<br/>
		/// report_operating_conditions -voltage_range {VCCINT VCCAUX}<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1395<br/>
		/// </para>
		/// </summary>
		/// <param name="voltage">(Optional) Gets voltage value. Supported voltage supplies vary by family.</param>
		/// <param name="voltage_range">(Optional) Gets voltage range. Supported voltage supplies vary by family.</param>
		/// <param name="grade">(Optional) Temperature grade. Supported values vary by family.</param>
		/// <param name="process">(Optional) Gets process</param>
		/// <param name="junction_temp">(Optional) Junction Temperature (C): auto|degC</param>
		/// <param name="ambient_temp">(Optional) Ambient Temperature (C): default|degC</param>
		/// <param name="thetaja">(Optional) ThetaJA (C/W): auto|degC/W</param>
		/// <param name="thetasa">(Optional) Gets ThetaSA</param>
		/// <param name="airflow">(Optional) Airflow (LFM): 0 to 750</param>
		/// <param name="heatsink">(Optional) Gets dimensions of heatsink</param>
		/// <param name="thetajb">(Optional) Gets ThetaJB</param>
		/// <param name="board">(Optional) Board type: jedec, small, medium, large, custom</param>
		/// <param name="board_temp">(Optional) Board Temperature degC</param>
		/// <param name="board_layers">(Optional) Board layers: 4to7, 8to11, 12to15, 16+</param>
		/// <param name="design_power_budget">(Optional) Design Power Budget (W)</param>
		/// <param name="all">(Optional) Gets all operating conditions listed in this help message</param>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="return_string">(Optional) return operating conditions as string</param>
		/// <param name="append">(Optional) append operating conditions to end of file</param>
		/// <param name="supply_current_budget">
		/// <para>
		/// (Optional)<br/>
		/// Reports a list of supply current budget 'name value' pairs.<br/>
		/// Supported voltage supplies vary by family.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">
		/// <para>
		/// (Optional)<br/>
		/// Suspend message limits during command execution<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// </param>
		public VivadoTCL report_operating_conditions(TCLParameterList voltage = null, TCLParameterList voltage_range = null, bool? grade = null, bool? process = null, bool? junction_temp = null, bool? ambient_temp = null, bool? thetaja = null, bool? thetasa = null, bool? airflow = null, bool? heatsink = null, bool? thetajb = null, bool? board = null, bool? board_temp = null, bool? board_layers = null, bool? design_power_budget = null, bool? all = null, String file = null, bool? return_string = null, bool? append = null, TCLParameterList supply_current_budget = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_operating_conditions [-voltage <args>] [-voltage_range <args>] [-grade] [-process] [-junction_temp] [-ambient_temp] [-thetaja] [-thetasa] [-airflow] [-heatsink] [-thetajb] [-board] [-board_temp] [-board_layers] [-design_power_budget] [-all] [-file <arg>] [-return_string] [-append] [-supply_current_budget <args>] [-quiet] [-verbose]
			this.Entry(_builder.report_operating_conditions(voltage, voltage_range, grade, process, junction_temp, ambient_temp, thetaja, thetasa, airflow, heatsink, thetajb, board, board_temp, board_layers, design_power_budget, all, file, return_string, append, supply_current_budget, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get information about all parameters<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_param [-file &lt;arg&gt;] [-append] [-non_default] [-return_string] [-quiet] [-verbose] [&lt;pattern&gt;]
		/// <br/>
		/// <para>
		/// Gets a list of all user-definable parameters, the current value, and a description of what the<br/>
		/// parameter configures or controls.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the name, value, and description of all user-definable parameters:<br/>
		/// report_param<br/>
		/// The following example returns the name, value, and description of user-definable parameters<br/>
		/// that match the specified search pattern:<br/>
		/// report_param *coll*<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1399<br/>
		/// </para>
		/// </summary>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="non_default">(Optional) Report only params that are set to a non default value</param>
		/// <param name="return_string">(Optional) Return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="pattern">(Optional) Display params matching pattern Default: *</param>
		/// <returns>param report</returns>
		public VivadoTCL report_param(String file = null, bool? append = null, bool? non_default = null, bool? return_string = null, bool? quiet = null, bool? verbose = null, String pattern = null)
		{
			// TCL Syntax: report_param [-file <arg>] [-append] [-non_default] [-return_string] [-quiet] [-verbose] [<pattern>]
			this.Entry(_builder.report_param(file, append, non_default, return_string, quiet, verbose, pattern));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report details of Physical Synthesis transformations.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_phys_opt [-file &lt;arg&gt;] [-append] [-return_string] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Reports the results of the fanout driver replication and load redistribution optimizations<br/>
		/// performed by the phys_opt_design command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports the physical optimizations performed in the current design by the<br/>
		/// phys_opt_design command:<br/>
		/// report_phys_opt -file C:/Data/physOpt_Report.txt<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1401<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Optional) Output file</param>
		/// <param name="append">(Optional) Append the results to file</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_phys_opt(String file = null, bool? append = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_phys_opt [-file <arg>] [-append] [-return_string] [-quiet] [-verbose]
			this.Entry(_builder.report_phys_opt(file, append, return_string, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Perform pipeline register insertion analysis and display report.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_pipeline_analysis [-cells &lt;args&gt;] [-verbose] [-clocks &lt;args&gt;] [-file &lt;arg&gt;] [-include_paths_to_pipeline] [-append] [-max_added_latency &lt;arg&gt;] [-report_loops] [-return_string] [-quiet]
		/// <br/>
		/// <para>
		/// This command performs an analysis of a synthesized design, hypothetically inserting pipeline<br/>
		/// stages in the design and reports the potential frequency (Fmax) increase of each clock domain.<br/>
		/// The analysis includes a search for loops in the design, which may not be improved by pipelining,<br/>
		/// and determines if such loops are critical paths in the design.<br/>
		/// Returns a table showing the pipeline stages and the Fmax improvement. The report begins with<br/>
		/// the original design and adds stages of latency (1, 2, ... ) until there is no further improvement in<br/>
		/// Fmax. This reports a theoretical upper limit to the frequency performance of the design.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The analysis is typically run on the un-placed synthesized netlist where the logical netlist<br/>
		/// structure determines the performance. The report can be run on the top-level design, or on out-of-context (OOC) sub-modules. This report confirms whether the design frequency can be<br/>
		/// increased, as well as how many pipeline registers must be added to the design to achieve the<br/>
		/// Fmax improvement.<br/>
		/// Note: By default the report is written to the Tcl console or STD output. However, the results can also be<br/>
		/// written to a file.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns the name, period, waveform, and sources of the clocks in the<br/>
		/// current design:<br/>
		/// report_pipeline_analysis -file C:/Data/FPGA_Design/pipeline_report.txt<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1403<br/>
		/// </para>
		/// </summary>
		/// <param name="cells">
		/// <para>
		/// (Optional)<br/>
		/// Analyze each of the specified hierarchical cells separately<br/>
		/// and ignore feedback loops external to the cells.<br/>
		/// </para>
		/// </param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="clocks">(Optional) Filter report output to show only the specified clocks</param>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="include_paths_to_pipeline">(Optional) Report paths to cut. (only available if -file is used)</param>
		/// <param name="append">(Optional) Append to existing file</param>
		/// <param name="max_added_latency">
		/// <para>
		/// (Optional)<br/>
		/// Maximum extra latency that can be inserted into the system<br/>
		/// (0 = unlimited). Default: 100<br/>
		/// </para>
		/// </param>
		/// <param name="report_loops">(Optional) Report loop information as well</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		public VivadoTCL report_pipeline_analysis(TCLParameterList cells = null, bool? verbose = null, TCLParameterList clocks = null, String file = null, bool? include_paths_to_pipeline = null, bool? append = null, String max_added_latency = null, bool? report_loops = null, bool? return_string = null, bool? quiet = null)
		{
			// TCL Syntax: report_pipeline_analysis [-cells <args>] [-verbose] [-clocks <args>] [-file <arg>] [-include_paths_to_pipeline] [-append] [-max_added_latency <arg>] [-report_loops] [-return_string] [-quiet]
			this.Entry(_builder.report_pipeline_analysis(cells, verbose, clocks, file, include_paths_to_pipeline, append, max_added_latency, report_loops, return_string, quiet));
			return this;
		}
		/// <summary>
		/// <para>
		/// Run power estimation and display report<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_power [-no_propagation] [-hier &lt;arg&gt;] [-hierarchical_depth &lt;arg&gt;] [-vid] [-advisory] [-file &lt;arg&gt;] [-name &lt;arg&gt;] [-format &lt;arg&gt;] [-xpe &lt;arg&gt;] [-l &lt;arg&gt;] [-return_string] [-append] [-rpx &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Run power analysis on the current design, and report details of power consumption based on the<br/>
		/// current operating conditions of the device, and the switching rates of the design. The operating<br/>
		/// conditions can be set using the set_operating_conditions command. The switching<br/>
		/// activity can be defined using the set_switching_activity command.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Switching activity can also be read in from an SAIF file with the read_saif command. The<br/>
		/// Vivado tool will annotate the design nodes with activity from the SAIF file and estimate power<br/>
		/// appropriately.<br/>
		/// Power analysis requires an open synthesized design, or implemented design.<br/>
		/// Note: By default the report is written to the Tcl console or STD output. However, the results can also be<br/>
		/// written to a file or returned as a string if desired.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example performs power analysis, without net propagation, and writes the results<br/>
		/// to an XML file for use in XPE:<br/>
		/// report_power -no_propagation -xpe C:/Data/design1.xpe<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1406<br/>
		/// </para>
		/// </summary>
		/// <param name="no_propagation">
		/// <para>
		/// (Optional)<br/>
		/// Disables the propagation engine to estimate the switching<br/>
		/// activity of nets.<br/>
		/// </para>
		/// </param>
		/// <param name="hier">(Optional) Hierarchy report style (logic, power, or all) Default: power</param>
		/// <param name="hierarchical_depth">(Optional) Specifies the depth level for textual hierarchical report Default: 4</param>
		/// <param name="vid">(Optional) Voltage ID (VID) of device is used</param>
		/// <param name="advisory">(Optional) Dump power advisory text report</param>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="format">(Optional) Format for the power estimation report: text, xml Default: text</param>
		/// <param name="xpe">(Optional) Output the results to XML file for importing into XPE</param>
		/// <param name="l">
		/// <para>
		/// (Optional)<br/>
		/// Maximum number of lines to report in detailed reports (l &gt;=<br/>
		/// 0) Default: 10<br/>
		/// </para>
		/// </param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="append">(Optional) append power report to end of file</param>
		/// <param name="rpx">(Optional) Filename to output interactive results to.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_power(bool? no_propagation = null, String hier = null, String hierarchical_depth = null, bool? vid = null, bool? advisory = null, String file = null, String name = null, String format = null, String xpe = null, Int32? l = null, bool? return_string = null, bool? append = null, String rpx = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_power [-no_propagation] [-hier <arg>] [-hierarchical_depth <arg>] [-vid] [-advisory] [-file <arg>] [-name <arg>] [-format <arg>] [-xpe <arg>] [-l <arg>] [-return_string] [-append] [-rpx <arg>] [-quiet] [-verbose]
			this.Entry(_builder.report_power(no_propagation, hier, hierarchical_depth, vid, advisory, file, name, format, xpe, l, return_string, append, rpx, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report power optimizations<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_power_opt [-cell &lt;args&gt;] [-file &lt;arg&gt;] [-format &lt;arg&gt;] [-name &lt;arg&gt;] [-append] [-return_string] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Report power optimizations that have been performed on the design with the<br/>
		/// power_opt_design command.<br/>
		/// Note: By default the report is written to the Tcl console or STD output. However, the results can also be<br/>
		/// written to a file or returned as a string if desired.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports the power optimizations performed on the current design, writing<br/>
		/// them to the specified file in an XML format:<br/>
		/// report_power_opt -format xml -file C:/Data/power_opt.xml<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1410<br/>
		/// </para>
		/// </summary>
		/// <param name="cell">(Optional) list of instance names Default: empty</param>
		/// <param name="file">(Optional) output file</param>
		/// <param name="format">
		/// <para>
		/// (Optional)<br/>
		/// Specifies how to format the report. Default is 'text', another<br/>
		/// option is 'xml'. Only applies if -file is used. If xml output is<br/>
		/// used, -append is not allowed. Default: text<br/>
		/// </para>
		/// </param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="append">(Optional) append if existing file. Otherwise overwrite existing file.</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_power_opt(TCLParameterList cell = null, String file = null, String format = null, String name = null, bool? append = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_power_opt [-cell <args>] [-file <arg>] [-format <arg>] [-name <arg>] [-append] [-return_string] [-quiet] [-verbose]
			this.Entry(_builder.report_power_opt(cell, file, format, name, append, return_string, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report reconfigurable partition analysis across multiple configurations<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_pr_configuration_analysis [-complexity] [-clocking] [-timing] [-cells &lt;args&gt;] [-dcps &lt;args&gt;] [-rent] [-nworst &lt;arg&gt;] [-file &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// IMPORTANT! You must first define the project as a Partial Reconfiguration (PR) project by setting the<br/>
		/// PR_FLOW property on the project to TRUE, or by using the Tools → Enable Partial Reconfiguration<br/>
		/// command.<br/>
		/// Report reconfigurable partition analysis across multiple configurations as defined by<br/>
		/// create_pr_configuration. This report compares each Reconfigurable Module that you<br/>
		/// select to give you input on your PR design. It examines resource usage, floorplanning, clocking,<br/>
		/// and timing metrics to help you manage the overall PR design. For more information on this<br/>
		/// command refer to the Vivado Design Suite User Guide: Dynamic Function eXchange (UG909).<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// When this analysis is done, each RM is examined based on information in the checkpoints<br/>
		/// provided. While post-synthesis checkpoints can be supplied, the most complete information is<br/>
		/// not available until after opt_design when all the linking and expansion has been done.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example performs complexity analysis of the design:<br/>
		/// report_pr_configuration_analysis -complexity<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1412<br/>
		/// </para>
		/// </summary>
		/// <param name="complexity">(Optional) Run complexity analysis</param>
		/// <param name="clocking">(Optional) Run clocking analysis</param>
		/// <param name="timing">(Optional) Run boundary net timing analysis</param>
		/// <param name="cells">(Optional) List of reconfigurable cell names</param>
		/// <param name="dcps">
		/// <para>
		/// (Optional)<br/>
		/// List of design checkpoints for each reconfigurable cell. The<br/>
		/// order of dcps must match that of the -cells option.<br/>
		/// </para>
		/// </param>
		/// <param name="rent">
		/// <para>
		/// (Optional)<br/>
		/// Compute Rents component as part of complexity analysis.<br/>
		/// Runtime intensive for large designs.<br/>
		/// </para>
		/// </param>
		/// <param name="nworst">(Optional) Specifies the N worst boundary paths. Default: 10</param>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_pr_configuration_analysis(bool? complexity = null, bool? clocking = null, bool? timing = null, TCLParameterList cells = null, TCLParameterList dcps = null, bool? rent = null, String nworst = null, String file = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_pr_configuration_analysis [-complexity] [-clocking] [-timing] [-cells <args>] [-dcps <args>] [-rent] [-nworst <arg>] [-file <arg>] [-quiet] [-verbose]
			this.Entry(_builder.report_pr_configuration_analysis(complexity, clocking, timing, cells, dcps, rent, nworst, file, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report properties of object<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_property [-all] [-class &lt;arg&gt;] [-return_string] [-file &lt;arg&gt;] [-append] [-regexp] [-quiet] [-verbose] [&lt;object&gt;] [&lt;pattern&gt;]
		/// <br/>
		/// <para>
		/// Gets the property name, property type, and property value for all of the properties on a specified<br/>
		/// object, or class of objects.<br/>
		/// Note: list_property also returns a list of all properties on an object, but does not include the property<br/>
		/// type or value.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// You can specify objects for report_property using the get_* series of commands to get a<br/>
		/// specific object. You can use the lindex command to return a specific object from a list of<br/>
		/// objects:<br/>
		/// report_property [lindex [get_cells] 0]<br/>
		/// However, if you are looking for the properties on a class of objects, you should use the -<br/>
		/// classoption instead of an actual object.<br/>
		/// This command returns a report of properties on the object, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns all properties of the specified object:<br/>
		/// report_property -all [get_cells cpuEngine]<br/>
		/// The following example returns the properties of the specified class of objects, rather than an<br/>
		/// actual object:<br/>
		/// report_property -class bel<br/>
		/// The following example returns properties on the current hw_device that match the specified<br/>
		/// pattern, specified as a regular expression:<br/>
		/// report_property [current_hw_device] -regexp .*PROG.*<br/>
		/// To determine which properties are available for the different design objects supported by the<br/>
		/// tool, you can use multiple report_property commands in sequence. The following example<br/>
		/// returns all properties of the specified current objects:<br/>
		/// report_property -all [current_project]<br/>
		/// report_property -all [current_fileset]<br/>
		/// report_property -all [current_design]<br/>
		/// report_property -all [current_run]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1415<br/>
		/// </para>
		/// </summary>
		/// <param name="all">(Optional) Report all properties of object even if not set</param>
		/// <param name="class">(Optional) Object type to query for properties. Not valid with &lt;object&gt;</param>
		/// <param name="return_string">
		/// <para>
		/// (Optional)<br/>
		/// Set the result of running report_property in the Tcl<br/>
		/// interpreter's result variable<br/>
		/// </para>
		/// </param>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output result to. Send output to console if -file<br/>
		/// is not used<br/>
		/// </para>
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="regexp">(Optional) Pattern is treated as a regular expression</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="object">(Optional) Object to query for properties</param>
		/// <param name="pattern">(Optional) Pattern to match properties against Default: *</param>
		/// <returns>property report</returns>
		public VivadoTCL report_property(bool? all = null, String @class = null, bool? return_string = null, String file = null, bool? append = null, bool? regexp = null, bool? quiet = null, bool? verbose = null, String @object = null, String pattern = null)
		{
			// TCL Syntax: report_property [-all] [-class <arg>] [-return_string] [-file <arg>] [-append] [-regexp] [-quiet] [-verbose] [<object>] [<pattern>]
			this.Entry(_builder.report_property(all, @class, return_string, file, append, regexp, quiet, verbose, @object, pattern));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report pulse width check<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_pulse_width [-file &lt;arg&gt;] [-append] [-name &lt;arg&gt;] [-return_string] [-warn_on_violation] [-all_violators] [-significant_digits &lt;arg&gt;] [-limit &lt;arg&gt;] [-min_period] [-max_period] [-low_pulse] [-high_pulse] [-max_skew] [-clocks &lt;args&gt;] [-no_header] [-cells &lt;args&gt;] [-rpx &lt;arg&gt;] [-quiet] [-verbose] [&lt;objects&gt;]
		/// <br/>
		/// <para>
		/// Reports the pulse width of the specified clock signals in the clock network and upon reaching the<br/>
		/// flip-flop. This command also performs high pulse width checking, using maximum delay for the<br/>
		/// rising edge and minimum delay for the falling edge of the clock. Performs low pulse width<br/>
		/// checking using minimum delay for the rising edge, and maximum delay for the falling edge. This<br/>
		/// results in a worst case analysis for the current Synthesis or Implemented Design because it<br/>
		/// assumes worst-case delays for both rising and falling edges. This command also reports the<br/>
		/// maximum skew, or maximum timing separation allowed between clock signals.<br/>
		/// The report includes minimum pulse width, maximum pulse width, low pulse width, high pulse<br/>
		/// width, and max skew checks by default. However, selecting a specific check will disable the other<br/>
		/// checks unless they are also specified.<br/>
		/// The default report is returned to the standard output, but can be redirected to a file, or to a Tcl<br/>
		/// string variable for further processing. The report is returned to the standard output by default,<br/>
		/// unless the -file, -return_string, or -name arguments are specified.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example performs the minimum period and low pulse width check, returning the<br/>
		/// results to a named results set in the GUI:<br/>
		/// report_pulse_width -min_period -low_pulse -name timing_1<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1419<br/>
		/// </para>
		/// </summary>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="name">(Optional) Results name in which to store output</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="warn_on_violation">(Optional) issue a critical warning when the report contains a timing violation</param>
		/// <param name="all_violators">(Optional) Only report pins/ports where check violations occur</param>
		/// <param name="significant_digits">(Optional) Number of digits to display: Range: 0 to 3 Default: 3</param>
		/// <param name="limit">
		/// <para>
		/// (Optional)<br/>
		/// Number of checks of a particular type to report per clock:<br/>
		/// Default is 1 Default: 1<br/>
		/// </para>
		/// </param>
		/// <param name="min_period">(Optional) Only report min period checks</param>
		/// <param name="max_period">(Optional) Only report max period checks</param>
		/// <param name="low_pulse">(Optional) Only report min low pulse width checks</param>
		/// <param name="high_pulse">(Optional) Only report min high pulse width checks</param>
		/// <param name="max_skew">(Optional) Only report max skew checks</param>
		/// <param name="clocks">(Optional) List of clocks for which to report min pulse width/min period checks</param>
		/// <param name="no_header">(Optional) Do not generate a report header</param>
		/// <param name="cells">(Optional) run report_pulse_width on the specified cell(s)</param>
		/// <param name="rpx">(Optional) Filename to output interactive results to.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">(Optional) List of objects to check min pulse width with</param>
		public VivadoTCL report_pulse_width(String file = null, bool? append = null, String name = null, bool? return_string = null, bool? warn_on_violation = null, bool? all_violators = null, Int32? significant_digits = null, Int32? limit = null, bool? min_period = null, bool? max_period = null, bool? low_pulse = null, bool? high_pulse = null, bool? max_skew = null, TCLParameterList clocks = null, bool? no_header = null, TCLParameterList cells = null, String rpx = null, bool? quiet = null, bool? verbose = null, String objects = null)
		{
			// TCL Syntax: report_pulse_width [-file <arg>] [-append] [-name <arg>] [-return_string] [-warn_on_violation] [-all_violators] [-significant_digits <arg>] [-limit <arg>] [-min_period] [-max_period] [-low_pulse] [-high_pulse] [-max_skew] [-clocks <args>] [-no_header] [-cells <args>] [-rpx <arg>] [-quiet] [-verbose] [<objects>]
			this.Entry(_builder.report_pulse_width(file, append, name, return_string, warn_on_violation, all_violators, significant_digits, limit, min_period, max_period, low_pulse, high_pulse, max_skew, clocks, no_header, cells, rpx, quiet, verbose, objects));
			return this;
		}
		/// <summary>
		/// <para>
		/// Feasibility Checks<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_qor_assessment [-file &lt;arg&gt;] [-max_paths &lt;arg&gt;] [-append] [-return_string] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// This command look for trouble spots in the design and assesses the likelihood of a design<br/>
		/// meeting design goals. This command requires an open elaborated, synthesized or implemented<br/>
		/// design for analysis.<br/>
		/// The Report QoR Assessment covers multiple categories:<br/>
		/// • Design Methodology<br/>
		/// • Synthesis<br/>
		/// • Implementation<br/>
		/// • Design Hierarchy<br/>
		/// • Partial Reconfiguration<br/>
		/// • Floorplanning<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The report_qor_assessment command includes a subset of report_methodology checks<br/>
		/// identifying bad practices that can lead to an expected problem. Yet, report_qor_assessment<br/>
		/// is also more comprehensive than report_methodology, because it includes other checks that<br/>
		/// are not necessarily bad practices but may have low success due to the structure, style, size, or<br/>
		/// complexity of the current design.<br/>
		/// A key feature of Report QOR Assessment is the ability to predict certain conditions that lead to<br/>
		/// congestion and performance degradation. This command can be run at any stage of the<br/>
		/// implementation flow after synthesis. The report_qor_assessment command will return a<br/>
		/// score from 1 - 5, where 1 is a failing grade, and 5 means the design will likely pass<br/>
		/// implementation and meet timing.<br/>
		/// For violations found by Report QOR Assessment, the Report QOR Suggestions command will<br/>
		/// make recommendations on how to avoid issues, or modify the design to improve results.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports suggestions after analyzing the worst 10 paths:<br/>
		/// report_qor_assessment -max_paths 10<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1423<br/>
		/// </para>
		/// </summary>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="max_paths">(Optional) Number of paths to consider for suggestion analysis Default: 100</param>
		/// <param name="append">(Optional) Append the results to file, do not overwrite the results file</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_qor_assessment(String file = null, Int32? max_paths = null, bool? append = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_qor_assessment [-file <arg>] [-max_paths <arg>] [-append] [-return_string] [-quiet] [-verbose]
			this.Entry(_builder.report_qor_assessment(file, max_paths, append, return_string, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Recommend QoR Suggestions<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_qor_suggestions [-file &lt;arg&gt;] [-name &lt;arg&gt;] [-append] [-return_string] [-max_strategies &lt;arg&gt;] [-max_paths &lt;arg&gt;] [-no_split] [-report_all_suggestions] [-cells &lt;args&gt;] [-of_objects &lt;args&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Report design and tool option recommendations related to improving the quality of results (QoR).<br/>
		/// The report looks at timing constraints, netlist characteristics, failing timing paths, and congestion<br/>
		/// information to determine suggestions that can enhance the QoR. The report can be generated<br/>
		/// after synthesis, or after any implementation step, but requires a design to be open.<br/>
		/// The report_qor_suggestions command creates QoR suggestion objects related to the<br/>
		/// suggestions identified. These suggestion objects can be enabled for use by the Vivado tools to<br/>
		/// improve the quality of synthesis and implementation results. Some of these suggestions can be<br/>
		/// automatically applied, and some may require more manual intervention to implement design<br/>
		/// changes, or write Tcl design constraints.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Suggestion objects can be obtained using the get_qor_suggestions command. The QoR<br/>
		/// objects have properties that define what step they are APPLICABLE_FOR, if they are ENABLED<br/>
		/// to be used, if they can be automatically applied (AUTO), or what step the suggestions was<br/>
		/// GENERATED_AT. A suggestion must be ENABLED and the APPLICABLE_FOR synthesis or<br/>
		/// implementation step run in order for a suggestion to be applied to the design.<br/>
		/// You can write the suggestions from the design into an RQS file using the<br/>
		/// write_qor_suggestions command. After resetting the design flow to the appropriate step,<br/>
		/// you can read suggestions back into the design using the read_qor_suggestions command,<br/>
		/// and then run the synthesis or implementation step to apply the enabled suggestions.<br/>
		/// The recommended method for working with QoR suggestions is:<br/>
		/// 1. Run the report to create recommendations (report_qor_suggestions)<br/>
		/// 2. Write the suggestions to an RQS file on disk (write_qor_suggestions).<br/>
		/// 3. Reset the design to the appropriate step.<br/>
		/// 4. Read the RQS file into the design to restore the suggestions (read_qor_suggestions).<br/>
		/// 5. Run the synthesis or implementation step to apply the suggestion (synth_design,<br/>
		/// opt_design...).<br/>
		/// For strategy suggestions, a machine learning based analysis is conducted and the best 3<br/>
		/// strategies are reported. This analysis is only conducted on a routed design that has been<br/>
		/// implemented with<br/>
		/// • either default or explore directives for opt_design and<br/>
		/// • either all default or all explore directives for place_design, phys_opt_design, and<br/>
		/// route_design commands.<br/>
		/// Strategy suggestions do not apply to synthesis. Unlike the non-strategy suggestions, only one<br/>
		/// strategy suggestion can be applied to each run.<br/>
		/// The recommended method for working with QoR strategy suggestions is:<br/>
		/// 1. Run the report to create strategies and other<br/>
		/// recommendations(report_qor_suggestions).<br/>
		/// 2. Write the suggestions to a directory disk. There is one RQS file per strategy<br/>
		/// (write_qor_suggestions -strategy_dir).<br/>
		/// 3. Update all the directive settings to -directive RQS for opt_design, place_design,<br/>
		/// phys_opt_design, and route_design commands.<br/>
		/// 4. For each run, read one RQS file into the design. This will contain the strategy suggestion and<br/>
		/// all exported non-strategy suggestions(read_qor_suggestions).<br/>
		/// 5. Run the implementation step from the opt_design command to apply the strategy and all<br/>
		/// the design suggestions.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports suggestions after analyzing the worst 10 paths:<br/>
		/// report_qor_suggestions -max_paths 10<br/>
		/// This example reports existing suggestions in the design from a prior run of<br/>
		/// report_qor_suggestions:<br/>
		/// report_qor_suggestions -of_objects [get_qor_suggestions]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1426<br/>
		/// </para>
		/// </summary>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="return_string">(Optional) Return report as string</param>
		/// <param name="max_strategies">(Optional) Number of strategies to suggest Default: 3</param>
		/// <param name="max_paths">(Optional) Number of paths to consider for suggestion analysis Default: 100</param>
		/// <param name="no_split">(Optional) Report without spliting the lines in tables</param>
		/// <param name="report_all_suggestions">(Optional) Report all suggestions</param>
		/// <param name="cells">(Optional) Report QOR suggestions for a given cell</param>
		/// <param name="of_objects">(Optional) List of QoR suggestion objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_qor_suggestions(String file = null, String name = null, bool? append = null, bool? return_string = null, Int32? max_strategies = null, Int32? max_paths = null, bool? no_split = null, bool? report_all_suggestions = null, TCLParameterList cells = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_qor_suggestions [-file <arg>] [-name <arg>] [-append] [-return_string] [-max_strategies <arg>] [-max_paths <arg>] [-no_split] [-report_all_suggestions] [-cells <args>] [-of_objects <args>] [-quiet] [-verbose]
			this.Entry(_builder.report_qor_suggestions(file, name, append, return_string, max_strategies, max_paths, no_split, report_all_suggestions, cells, of_objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report configuration about RAMs in design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_ram_utilization [-append] [-file &lt;arg&gt;] [-csv &lt;arg&gt;] [-return_string] [-cells &lt;args&gt;] [-include_path_info] [-include_lutram] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Reports RAM usage in the current design at any stage after synthesis. It is recommended to run<br/>
		/// this report after optimizations in opt_design have been run. The report is returned to the<br/>
		/// standard output, unless the -file or -return_string arguments are used.<br/>
		/// The report details the following tables:<br/>
		/// • Summary: The Summary table shows the utilization by RAM type, broken down into URAM,<br/>
		/// Block RAM and LUTRAM. For each RAM type, it is broken down into the individual primitives.<br/>
		/// Also detailed is the inferred primitive %. If using a synthesis tool other than Vivado Synthesis<br/>
		/// or instantiation of primitives, then rams will be reported under instantiated primitives.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The information in the summary can be used to determine if there are imbalances in the<br/>
		/// utilization of different types of RAMs. Based on the summary, a design might benefit from<br/>
		/// retargeting heavily used primitives to lesser used ones at the cost of being less efficient.<br/>
		/// Additionally LUTRAM implementation can be evaluated. LUTRAM primitives vary in their<br/>
		/// efficiency of Bits/LUT. For example, a RAM32M16 uses 8 LUTs and can have up to 14 data<br/>
		/// bits. Using RAM32X1D primitives, 8 LUTs yields a maximum of 8 bits when LUT combined.<br/>
		/// • Memory Description: The Memory Description table gives an RTL look at the inferred<br/>
		/// memories. It refers to memories that are inferred directly or indirectly using XPMs. The table is<br/>
		/// ordered by the total number of bits in the memory array. Items reported are memory type and<br/>
		/// mapping.<br/>
		/// The mapping format is &lt;report&gt;:&lt;physical&gt;:&lt;depth&gt;x&lt;width&gt;<br/>
		/// The following tables are repeated for inferred and instantiated primitives.Collectively they are<br/>
		/// refered to as the detailed tables.<br/>
		/// • Memory Utilization: The Memory Utilization table details how each memory array is mapped<br/>
		/// to primitives. Also provided is information on how efficient the mapping is and whether the<br/>
		/// mapping is limited by depth or width.<br/>
		/// • Memory Performance: The Memory Performance table details performance aspects of the<br/>
		/// RAM. It includes information whether the output register is used, cascading has been used. If<br/>
		/// the -include_path_info switch is specified there is extra information on the worst path<br/>
		/// from each pin listed.<br/>
		/// • Memory Power: The Memory Power table details what power aspects of the RAM have been<br/>
		/// used. It includes information on cascading and whether the enable pin is tied to POWER or a<br/>
		/// signal.<br/>
		/// This command returns the requested report to the Tcl console, to a file, or as a string; or returns<br/>
		/// an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example provides a full report of the inferred and non-inferred BlockRAM and<br/>
		/// UltraRAM resources and writes the results to both the specified text and CSV files:<br/>
		/// report_ram_utilization -csv ./ram_util.csv -file ./ram_util.txt<br/>
		/// The following example provides a full report of the inferred and non-inferred BlockRAM,<br/>
		/// UltraRAM and LUTRAM resources and writes the results to the specified CSV file:<br/>
		/// report_ram_utilization -csv ./ram_util.csv -include_lutram<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1430<br/>
		/// </para>
		/// </summary>
		/// <param name="append">(Optional) Append to existing file</param>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="csv">(Optional) Write detailed tables to the CSV filename specified</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="cells">
		/// <para>
		/// (Optional)<br/>
		/// Limits the reporting to only those memory arrays that are<br/>
		/// contained within the specified cells.<br/>
		/// </para>
		/// </param>
		/// <param name="include_path_info">(Optional) Adds path info to the RAM inputs/outputs</param>
		/// <param name="include_lutram">(Optional) Adds LUTRAMs to the report</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Report</returns>
		public VivadoTCL report_ram_utilization(bool? append = null, String file = null, String csv = null, bool? return_string = null, TCLParameterList cells = null, bool? include_path_info = null, bool? include_lutram = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_ram_utilization [-append] [-file <arg>] [-csv <arg>] [-return_string] [-cells <args>] [-include_path_info] [-include_lutram] [-quiet] [-verbose]
			this.Entry(_builder.report_ram_utilization(append, file, csv, return_string, cells, include_path_info, include_lutram, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report on status of the routing.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_route_status [-return_nets] [-return_string] [-file &lt;arg&gt;] [-append] [-of_objects &lt;args&gt;] [-route_type &lt;arg&gt;] [-list_all_nets] [-show_all] [-dump_routes] [-has_routing] [-boolean_check &lt;arg&gt;] [-ignore_cache] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Reports the state of routing in the current design.<br/>
		/// The route status report can include a wide range of information, from a simple 1 if the design has<br/>
		/// routing, to a complete route tree for each net in the design.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports the route status for the specified nets:<br/>
		/// report_route_status -of_objects [get_nets u4*]<br/>
		/// The following example returns a list of nets that have routing but are not fully routed to the Find<br/>
		/// Results window in the Vivado IDE.<br/>
		/// show_objects [report_route_status -return_nets -route_type PARTIAL]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1433<br/>
		/// </para>
		/// </summary>
		/// <param name="return_nets">(Optional) Return a list of nets that match the given -route_type type</param>
		/// <param name="return_string">
		/// <para>
		/// (Optional)<br/>
		/// Set the result of running the report in the Tcl interpreter's<br/>
		/// result variable<br/>
		/// </para>
		/// </param>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="of_objects">(Optional) Report detailed routing for these routes</param>
		/// <param name="route_type">
		/// <para>
		/// (Optional)<br/>
		/// Only show routes with the given status: UNPLACED|<br/>
		/// UNPLACED_ALL|UNROUTED|PARTIAL|GAPS|CONFLICTS|<br/>
		/// ANT ENNAS|NODRIVER|MULTI_DRIVER|LOCKED_NODES|<br/>
		/// HAS_ROUTING|INTR ASITE|NOLOADS|HIERPORT|ROUTED<br/>
		/// (ignored if -of_objects is used)<br/>
		/// </para>
		/// </param>
		/// <param name="list_all_nets">
		/// <para>
		/// (Optional)<br/>
		/// list full route information for every net in the design<br/>
		/// (ignored if -of_objects is used)<br/>
		/// </para>
		/// </param>
		/// <param name="show_all">
		/// <para>
		/// (Optional)<br/>
		/// list all relevant pins for routes marked as UNPLACED or<br/>
		/// PARTIAL routes and list all relevant nodes for routes marked<br/>
		/// as ANTENNAS or CONFLICTS routes (by default only the first<br/>
		/// 15 pins or nodes are listed for a route)<br/>
		/// </para>
		/// </param>
		/// <param name="dump_routes">
		/// <para>
		/// (Optional)<br/>
		/// show the full routing tree for every routed net in the design.<br/>
		/// This is VERY VERBOSE.<br/>
		/// </para>
		/// </param>
		/// <param name="has_routing">
		/// <para>
		/// (Optional)<br/>
		/// returns 0 if there is no routing currently stored for this<br/>
		/// design and 1 if there is. All other options are ignored.<br/>
		/// </para>
		/// </param>
		/// <param name="boolean_check">
		/// <para>
		/// (Optional)<br/>
		/// returns 1 if the given flag is true and 0 if it is not. Value flags<br/>
		/// that can be checked are: PLACED_FULLY|<br/>
		/// PARTIALLY_ROUTED|ROUTED_FULLY|ERRORS_IN_ROUT ES.<br/>
		/// All other options are ignored (cannot be used with -<br/>
		/// has_routing).<br/>
		/// </para>
		/// </param>
		/// <param name="ignore_cache">
		/// <para>
		/// (Optional)<br/>
		/// throw away all cached information and recalculate the route<br/>
		/// status for the entire design (slow)<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_route_status(bool? return_nets = null, bool? return_string = null, String file = null, bool? append = null, TCLParameterList of_objects = null, String route_type = null, bool? list_all_nets = null, bool? show_all = null, bool? dump_routes = null, bool? has_routing = null, String boolean_check = null, bool? ignore_cache = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_route_status [-return_nets] [-return_string] [-file <arg>] [-append] [-of_objects <args>] [-route_type <arg>] [-list_all_nets] [-show_all] [-dump_routes] [-has_routing] [-boolean_check <arg>] [-ignore_cache] [-quiet] [-verbose]
			this.Entry(_builder.report_route_status(return_nets, return_string, file, append, of_objects, route_type, list_all_nets, show_all, dump_routes, has_routing, boolean_check, ignore_cache, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Print names of the children scopes (declarative regions) of given scope(s) or the current scope<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_scopes [-quiet] [-verbose] [&lt;hdl_scopes&gt;...]
		/// <br/>
		/// <para>
		/// Reports the names and types of HDL Scopes in the current scope of the current simulation, or of<br/>
		/// specified scopes.<br/>
		/// An HDL Scope is a declarative region of an HDL file, where objects are declared. The following<br/>
		/// are examples of HDL Scopes in Verilog and VHDL:<br/>
		/// • Verilog scopes: module, function, task, process, other begin-end blocks<br/>
		/// • VHDL scopes: entity/architecture pair, block, function, procedure, process<br/>
		/// You must have an open simulation to use this command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports the children scopes of /tb/UUT:<br/>
		/// report_scopes [get_scopes /tb/UUT/* filter {type==module}<br/>
		/// The following example reports the children scopes of the current scope:<br/>
		/// report_scopes<br/>
		/// VHDL Instance: {U_DEBOUNCE_0}<br/>
		/// VHDL Instance: {U_DEBOUNCE_1}<br/>
		/// VHDL Instance: {U_SINEGEN}<br/>
		/// VHDL Instance: {U_FSM}<br/>
		/// VHDL Process: {line__138}<br/>
		/// VHDL Process: {line__184}<br/>
		/// VHDL Process: {line__185}<br/>
		/// VHDL Process: {line__186}<br/>
		/// VHDL Process: {line__187}<br/>
		/// VHDL Process: {line__191}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1437<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hdl_scopes">(Optional) The hdl_objects to report. Default is report_scopes [get_scopes *]</param>
		/// <returns>report_scopes prints a subset of properties of the HDL scope on console in textual format</returns>
		public VivadoTCL report_scopes(bool? quiet = null, bool? verbose = null, TCLParameterList hdl_scopes = null)
		{
			// TCL Syntax: report_scopes [-quiet] [-verbose] [<hdl_scopes>...]
			this.Entry(_builder.report_scopes(quiet, verbose, hdl_scopes));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report the list of correct SIM_DEVICE attribute values for cell types in the target part<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_sim_device [-part &lt;arg&gt;] [-file &lt;arg&gt;] [-append] [-return_string] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1439<br/>
		/// </para>
		/// </summary>
		/// <param name="part">(Optional) Part</param>
		/// <param name="file">(Optional) Output file</param>
		/// <param name="append">(Optional) Append the results to file</param>
		/// <param name="return_string">(Optional) Return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Report</returns>
		public VivadoTCL report_sim_device(String part = null, String file = null, bool? append = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_sim_device [-part <arg>] [-file <arg>] [-append] [-return_string] [-quiet] [-verbose]
			this.Entry(_builder.report_sim_device(part, file, append, return_string, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report info of simulation libraries<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_simlib_info [-file &lt;arg&gt;] [-append] [-quiet] [-verbose] &lt;path&gt;
		/// <br/>
		/// <para>
		/// Report information on libraries compiled by the compile_simlib command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports information related to the compiled simulation library at the<br/>
		/// specified path:<br/>
		/// report_simlib_info C:/Data/compiled_simlib<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1440<br/>
		/// </para>
		/// </summary>
		/// <param name="path">(Required) Specify the path for pre-compiled libraries</param>
		/// <param name="file">(Optional) Output file Default: report_simlib_info.log</param>
		/// <param name="append">(Optional) Append mode</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_simlib_info(String path, String file = null, bool? append = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_simlib_info [-file <arg>] [-append] [-quiet] [-verbose] <path>
			this.Entry(_builder.report_simlib_info(path, file, append, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Run SSN analysis on the current package and pinout<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_ssn [-name &lt;arg&gt;] [-return_string] [-format &lt;arg&gt;] [-file &lt;arg&gt;] [-append] [-phase] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Perform a simultaneous switching noise (SSN) analysis of the current design. The SSN analysis is<br/>
		/// an accurate method for predicting how output switching affects interface noise margins. The<br/>
		/// calculation and estimates are based on a range of variables intended to identify potential noise-related issues in your design and should not be used as final design "sign off" criteria.<br/>
		/// SSN analysis provides estimates of the disruption that simultaneously switching outputs can<br/>
		/// cause on other output ports in the I/O bank. The SSN predictor incorporates I/O bank-specific<br/>
		/// electrical characteristics into the prediction to better model package effects on SSN.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The report_ssn command can be affected by the temperature grade of the selected device as<br/>
		/// defined by the -grade option of the set_operating_condition command. Setting the<br/>
		/// temperature grade prior to running noise analysis lets you see how noisy signals can be on<br/>
		/// Commercial, Extended, Industrial, Q-Grade, or Military grade devices.<br/>
		/// By default, report_ssn assumes that every port toggles asynchronously. This results in a<br/>
		/// worst-case noise analysis, which may be overly pessimistic. The -phase option lets you consider<br/>
		/// clocking information available in the design to more accurately report SSN noise. Clocks must be<br/>
		/// defined using the create_clock and create_generated_clock commands. The period,<br/>
		/// phase shift and duty cycle of the generated clocks have significant impact on SSN analysis.<br/>
		/// The report_ssn command provides a detailed SSN analysis for Xilinx UltraScale architecture<br/>
		/// devices, Virtex-7, Kintex-7, and Artix-7 devices. The report is returned to the standard output,<br/>
		/// unless the -file, -return_string, or -name arguments are specified.<br/>
		/// TIP: Not all parts support the report_ssn command. The Vivado Design Suite will return an error if you<br/>
		/// run report_ssn on a target part that does not support SSN analysis. You can query the SSN_REPORT<br/>
		/// property of a part to see if it supports the command. Refer to the Examples for more information.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example performs an SSN analysis on the current design, formats the output as<br/>
		/// HTML, and writes the output to the specified file:<br/>
		/// report_ssn -format html -file C:/Data/devSSN.html<br/>
		/// The following example performs an SSN analysis, with phase analysis, and returns the output to a<br/>
		/// string which is stored in the specified variable:<br/>
		/// set devSSN [report_ssn -phase -format html -return_string]<br/>
		/// Note: The -format argument in the preceding example is ignored in the absence of -file.<br/>
		/// The following example queries the part in the current project to see if it supports the<br/>
		/// report_ssn command, and then gets a list of parts from the same part family that support the<br/>
		/// command:<br/>
		/// get_property SSN_REPORT [get_property PART [current_project]]<br/>
		/// get_parts -filter "FAMILY == [get_property FAMILY [get_property PART \<br/>
		/// [current_project]]] &amp;&amp; SSN_REPORT"<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1442<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="return_string">(Optional) Return report as string</param>
		/// <param name="format">(Optional) Report format. Valid arguments are CSV, HTML, TXT Default: csv</param>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="append">(Optional) Append the report to the specified file</param>
		/// <param name="phase">(Optional) Account for multi-clock phase in the analysis</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>ssn report</returns>
		public VivadoTCL report_ssn(String name = null, bool? return_string = null, String format = null, String file = null, bool? append = null, bool? phase = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_ssn [-name <arg>] [-return_string] [-format <arg>] [-file <arg>] [-append] [-phase] [-quiet] [-verbose]
			this.Entry(_builder.report_ssn(name, return_string, format, file, append, phase, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Print names of processes in a design, which are waiting inside a subprogram, in textual format<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_stacks [-of_instance &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Print name of the HDL process scopes waiting inside a subprogram in textual format.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// Example design:<br/>
		/// module top;<br/>
		/// int i;<br/>
		/// function void f(input int in1);<br/>
		/// automatic int a;<br/>
		/// a = in1 + 7;<br/>
		/// $display($time, " in f :: a %d in1 %d ", a, in1);<br/>
		/// endfunction<br/>
		/// task automatic t(input int in2);<br/>
		/// int b;<br/>
		/// b = in2 + 10;<br/>
		/// $display($time, " in t :: in2 %d b %d ", in2, b);<br/>
		/// #5;<br/>
		/// f(b); // Case C<br/>
		/// $display($time, " Back in t : after wait and f(%d) ", b);<br/>
		/// endtask<br/>
		/// initial begin // "/top/Initial18_0"<br/>
		/// $display($time, " in initial 1 ");<br/>
		/// i = 200;<br/>
		/// t(i); // Case B<br/>
		/// $display($time, " Back in initial 1 after t(%d) ", i);<br/>
		/// end<br/>
		/// initial begin // "/top/Initial25_1"<br/>
		/// $display($time, " in initial 2 ");<br/>
		/// #2;<br/>
		/// f(50); // Case A<br/>
		/// $display($time, " Back in initial 2 after f(50) ");<br/>
		/// end<br/>
		/// endmodule<br/>
		/// When simulation is stopped inside function "f" for its call at 'Case A' , the two processes /top/<br/>
		/// Initial18_0 and /top/Initial25_1, are waiting inside task "t" (call at 'CaseB') and<br/>
		/// function "f" (call at 'CaseA') respectively.<br/>
		/// 1. &gt; report_stacks<br/>
		/// Verilog Process: {/top/Initial18_0}<br/>
		/// Verilog Process: {/top/Initial25_1}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1445<br/>
		/// </para>
		/// </summary>
		/// <param name="of_instance">(Optional) Default: NULL</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Returns string</returns>
		public VivadoTCL report_stacks(String of_instance = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_stacks [-of_instance <arg>] [-quiet] [-verbose]
			this.Entry(_builder.report_stacks(of_instance, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Get switching activity on specified objects<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_switching_activity [-static_probability] [-signal_rate] [-toggle_rate] [-default_static_probability] [-default_toggle_rate] [-average] [-file &lt;arg&gt;] [-return_string] [-append] [-hier] [-all] [-type &lt;args&gt;] [-quiet] [-verbose] [&lt;objects&gt;...]
		/// <br/>
		/// <para>
		/// This command is used to report different kinds of switching activity on design nets, ports, pins,<br/>
		/// and cells in the current synthesized or implemented design. These include simple signal rate and<br/>
		/// simple static probability on nets, ports, and pins; and state dependent static probabilities on cells.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The reported values are defined using the set_switching_activity command.<br/>
		/// Note: This command returns the switching activity for the specified objects, or the current design.<br/>
		/// By default the report is written to the Tcl console or STD output. However, the results can also<br/>
		/// be written to a file or returned as a string if desired.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports the signal_rate and static probability value on all output ports:<br/>
		/// report_switching_activity -signal_rate -static_probability [all_outputs]<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example reports the signal_rate and static probability value on all LUT objects in<br/>
		/// the design:<br/>
		/// report_switching_activity -signal_rate -static_probability -type lut -all<br/>
		/// The following example reports the average toggle rate on all output ports:<br/>
		/// report_switching_activity -toggle_rate -average [all_outputs]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1447<br/>
		/// </para>
		/// </summary>
		/// <param name="static_probability">(Optional) report static probability</param>
		/// <param name="signal_rate">(Optional) report signal rate</param>
		/// <param name="toggle_rate">(Optional) report toggle rate</param>
		/// <param name="default_static_probability">(Optional) report default static probability</param>
		/// <param name="default_toggle_rate">(Optional) report default toggle rate</param>
		/// <param name="average">(Optional) Report the average switching activity for the specified objects.</param>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="return_string">(Optional) return switching activity as string</param>
		/// <param name="append">(Optional) append switching activity to end of file</param>
		/// <param name="hier">
		/// <para>
		/// (Optional)<br/>
		/// Hierarchically reports the switching activity on nets within a<br/>
		/// hierarchical instance provided via &lt;objects&gt; option.<br/>
		/// </para>
		/// </param>
		/// <param name="all">(Optional) Report switching activities for all nets for the design.</param>
		/// <param name="type">
		/// <para>
		/// (Optional)<br/>
		/// Specify nodes in a specific category. List of valid type values:<br/>
		/// io_output, io_bidir_enable, register, lut_ram, lut, dsp,<br/>
		/// bram_enable, bram_wr_enable, gt_txdata, gt_rxdata.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">(Optional) objects</param>
		public VivadoTCL report_switching_activity(bool? static_probability = null, bool? signal_rate = null, bool? toggle_rate = null, bool? default_static_probability = null, bool? default_toggle_rate = null, bool? average = null, String file = null, bool? return_string = null, bool? append = null, bool? hier = null, bool? all = null, TCLParameterList type = null, bool? quiet = null, bool? verbose = null, TCLParameterList objects = null)
		{
			// TCL Syntax: report_switching_activity [-static_probability] [-signal_rate] [-toggle_rate] [-default_static_probability] [-default_toggle_rate] [-average] [-file <arg>] [-return_string] [-append] [-hier] [-all] [-type <args>] [-quiet] [-verbose] [<objects>...]
			this.Entry(_builder.report_switching_activity(static_probability, signal_rate, toggle_rate, default_static_probability, default_toggle_rate, average, file, return_string, append, hier, all, type, quiet, verbose, objects));
			return this;
		}
		/// <summary>
		/// <para>
		/// Compute mean time between failures and display report<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_synchronizer_mtbf [-file &lt;arg&gt;] [-append] [-return_string] [-warn_if_mtbf_below &lt;arg&gt;] [-quiet] [-no_header] [-report_endpoints] [-verbose]
		/// <br/>
		/// <para>
		/// RECOMMENDED: This command is supported for Xilinx UltraScale devices only, and does not support 7<br/>
		/// series devices.<br/>
		/// The report_synchronizer_mtbf command reports mean time between failures (MTBF) of<br/>
		/// each clock domain crossing (CDC) synchronizer chain in a design, and provides an overall MTBF<br/>
		/// covering all synchronizers. Synchronizer registers must have ASYNC_REG properties with value<br/>
		/// TRUE to be properly identified as synchronizers for reporting.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Asynchronous clock domain crossings (CDCs) can fail due to metastability as data is captured<br/>
		/// asynchronously and may settle to different values on different loads in the circuit. Synchronizer<br/>
		/// registers are used to improve overall circuit reliability for designs which contain multiple clock<br/>
		/// domains, in which asynchronous data transfers occur, or in which external asynchronous signals<br/>
		/// are captured with an internal clock. A synchronizer chain consists of two or more registers<br/>
		/// connected sequentially with the first stage capturing the data signal from the asynchronous clock<br/>
		/// domain. The successive register stages provide additional settling time for metastable events and<br/>
		/// increase MTBF. The synchronizer registers must have ASYNC_REG properties with values of<br/>
		/// TRUE. Besides reporting MTBF, the ASYNC_REG properties instruct synthesis, simulation and<br/>
		/// implementation tools to optimize for increased MTBF and improve overall behavior of the<br/>
		/// synchronizer circuit.<br/>
		/// TIP: Avoid using different set/reset or clock enable control signals on registers within a synchronizer chain.<br/>
		/// This command returns the MTBF report, or returns an error if it fails. The command issues a<br/>
		/// warning message when the MTBF cannot be calculated correctly, for example when a CDC is<br/>
		/// improperly constrained. The following conditions result in an UNDEFINED synchronizer MTBF<br/>
		/// value:<br/>
		/// • One or both clocks of the CDC are unconstrained.<br/>
		/// • There is a timing violation involving registers in the synchronizer chain.<br/>
		/// • There is a zero toggle rate detected for the CDC data.<br/>
		/// In the case of a zero toggle rate, it may be necessary to use the set_switching_activity<br/>
		/// command to manually override the toggle rate on the CDC net with a realistic value. This<br/>
		/// involves assigning the Toggle Rate and the Static Probability:<br/>
		/// • Toggle Rate: The number of CDC data signal transitions measured in Million Transitions per<br/>
		/// Second.<br/>
		/// • Static Probability: The percentage of time during which the CDC data signal is driven at a high<br/>
		/// logic level.<br/>
		/// Example: to assign a toggle rate of 12.5% with 0.5 static probability on a CDC net named<br/>
		/// resync[0]:<br/>
		/// set_switching_activity -toggle_rate 12.5 -static_probability 0.5 \<br/>
		/// [get_nets resync[0]]<br/>
		/// The report contents include the following data for each synchronizer chain in the design:<br/>
		/// • MTBF: The Mean Time Between Failures for the CDC synchronizer reported in dynamic time<br/>
		/// units, from seconds to years. An invalid MTBF value is reported as UNDEFINED.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// • Data Toggle Rate: The rate at which the CDC data switches, based on the default switching<br/>
		/// activity for the design as reported by report_switching_activity. Measured in (Mts)<br/>
		/// Millions of Transitions per Second. The rate can be overridden using the<br/>
		/// set_switching_activity command targeting the CDC net object.<br/>
		/// • Data Sample Rate: The rate at which the CDC data is sampled, equivalent to the synchronizer<br/>
		/// chain frequency, measured in MHz.<br/>
		/// • Settling Time: The total amount of positive slack in nanoseconds on the timing paths from<br/>
		/// synchronizer register outputs. Higher Settling Time increases MTBF.<br/>
		/// • Sending Domain: The clock domain of the source of the CDC data. A value of<br/>
		/// UNCONSTRAINED is reported if the source clock is not defined.<br/>
		/// • Receiving Domain: The clock domain of the destination of the CDC data. A value of<br/>
		/// UNCONSTRAINED is reported if the destination clock is not defined.<br/>
		/// • Number of Stages: This is the length of the synchronizer chain, which equals the number of<br/>
		/// registers with ASYNC_REG value of TRUE. The MTBF calculation will determine the likelihood<br/>
		/// that the output register or registers (should the fanout be greater than 1) will experience a<br/>
		/// metastable event. For example in a typical synchronizer containing 2 registers with the<br/>
		/// ASYNC_REG property set, the MTBF calculation indicates the probability that the output<br/>
		/// register(s) following the last ASYNC_REG register will capture an incorrect value resulting from<br/>
		/// the metastable event. When a synchronizer is connected to more than 1 output register, the<br/>
		/// minimum slack from all the paths will be used in the MTBF calculation to ensure that all<br/>
		/// registers capture the same logic level.<br/>
		/// • CDC Net Name: This is the logical net name of the CDC data, the data that is captured<br/>
		/// asynchronously.<br/>
		/// This command returns the MTBF report, or returns an error if it fails.<br/>
		/// The report also includes an overall MTBF calculated using the MTBF of all synchronizers in the<br/>
		/// design, calculated as the inverse of the sum of the reciprocals of the individual synchronizer<br/>
		/// MTBF values: (1 / (1/MTBF_1 + 1/MTBF_2 + … + 1/MTBF_N) ) for N synchronizers.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example writes the MTBF report to the specified file:<br/>
		/// report_synchronizer_mtbf -file C:/Data/mtbf_report.txt<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1451<br/>
		/// </para>
		/// </summary>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="return_string">(Optional) Return the report output as a string</param>
		/// <param name="warn_if_mtbf_below">(Optional) Default: 1e+12</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="no_header">(Optional) Report without the header</param>
		/// <param name="report_endpoints">(Optional) Report cdc path end points</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Report</returns>
		public VivadoTCL report_synchronizer_mtbf(String file = null, bool? append = null, bool? return_string = null, String warn_if_mtbf_below = null, bool? quiet = null, bool? no_header = null, bool? report_endpoints = null, bool? verbose = null)
		{
			// TCL Syntax: report_synchronizer_mtbf [-file <arg>] [-append] [-return_string] [-warn_if_mtbf_below <arg>] [-quiet] [-no_header] [-report_endpoints] [-verbose]
			this.Entry(_builder.report_synchronizer_mtbf(file, append, return_string, warn_if_mtbf_below, quiet, no_header, report_endpoints, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report timing paths<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_timing [-from &lt;args&gt;] [-rise_from &lt;args&gt;] [-fall_from &lt;args&gt;] [-to &lt;args&gt;] [-rise_to &lt;args&gt;] [-fall_to &lt;args&gt;] [-through &lt;args&gt;] [-rise_through &lt;args&gt;] [-fall_through &lt;args&gt;] [-delay_type &lt;arg&gt;] [-setup] [-hold] [-max_paths &lt;arg&gt;] [-nworst &lt;arg&gt;] [-unique_pins] [-path_type &lt;arg&gt;] [-input_pins] [-no_header] [-no_reused_label] [-slack_lesser_than &lt;arg&gt;] [-slack_greater_than &lt;arg&gt;] [-group &lt;args&gt;] [-sort_by &lt;arg&gt;] [-no_report_unconstrained] [-user_ignored] [-of_objects &lt;args&gt;] [-significant_digits &lt;arg&gt;] [-column_style &lt;arg&gt;] [-file &lt;arg&gt;] [-append] [-name &lt;arg&gt;] [-no_pr_attribute] [-routable_nets] [-return_string] [-warn_on_violation] [-cells &lt;args&gt;] [-rpx &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// IMPORTANT! If the design has no timing constraints, report_timing reports on unconstrained paths<br/>
		/// in the design. However, if even one path has timing constraints then report_timing only reports on<br/>
		/// the constrained paths in the design, unless unconstrained timing paths are specified by the -from /-to<br/>
		/// options.<br/>
		/// This command performs timing analysis on the specified timing paths of the current Synthesized<br/>
		/// or Implemented Design. By default the tool reports the timing path with the worst calculated<br/>
		/// slack within each path group. However, you can optionally increase the number of paths and<br/>
		/// delays reported with the use of the -nworst or -max_paths arguments.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// TIP: The report_timing can be multi-threaded to speed the process. Refer to the set_param<br/>
		/// command for more information on setting the general.maxThreads parameter.<br/>
		/// The timing engine runs in "quad" timing mode, analyzing min and max delays for both slow and<br/>
		/// fast corners. You can configure the type of analysis performed by the<br/>
		/// config_timing_corners command. However, it is not recommended to change the default<br/>
		/// because this reduces the timing analysis coverage.<br/>
		/// Note: By default the report is written to the Tcl console or STD output. However, the results can also be<br/>
		/// written to the GUI, to a file, or returned as a string if desired.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports the timing for the 5 worst paths in the design, reporting the full<br/>
		/// timing path, including input pins, with timing values:<br/>
		/// report_timing -nworst 5 -path_type full -input_pins<br/>
		/// The following example shows the use of the multiple through points to define both a specific<br/>
		/// path (through state_reg1) and alternate paths (through count_3 or count_4), and writes the<br/>
		/// timing results to the specified file:<br/>
		/// report_timing -from go -through {state_reg1} \<br/>
		/// -through { count_3 count_4 } \<br/>
		/// -to done -path_type summary -file C:/Data/timing1.txt<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1455<br/>
		/// </para>
		/// </summary>
		/// <param name="from">(Optional) From pins, ports, cells or clocks</param>
		/// <param name="rise_from">(Optional) Rising from pins, ports, cells or clocks</param>
		/// <param name="fall_from">(Optional) Falling from pins, ports, cells or clocks</param>
		/// <param name="to">(Optional) To pins, ports, cells or clocks</param>
		/// <param name="rise_to">(Optional) Rising to pins, ports, cells or clocks</param>
		/// <param name="fall_to">(Optional) Falling to pins, ports, cells or clocks</param>
		/// <param name="through">(Optional) Through pins, ports, cells or nets</param>
		/// <param name="rise_through">(Optional) Rising through pins, ports, cells or nets</param>
		/// <param name="fall_through">(Optional) Falling through pins, ports, cells or nets</param>
		/// <param name="delay_type">
		/// <para>
		/// (Optional)<br/>
		/// Type of path delay: Values: max, min, min_max, max_rise,<br/>
		/// max_fall, min_rise, min_fall Default: max<br/>
		/// </para>
		/// </param>
		/// <param name="setup">(Optional) Report max delay timing paths (equivalent to -delay_type max)</param>
		/// <param name="hold">(Optional) Report min delay timing paths (equivalent to -delay_type min)</param>
		/// <param name="max_paths">
		/// <para>
		/// (Optional)<br/>
		/// Maximum number of paths to output when sorted by slack,<br/>
		/// or per path group when sorted by group: Value &gt;=1 Default:<br/>
		/// 1<br/>
		/// </para>
		/// </param>
		/// <param name="nworst">(Optional) List up to N worst paths to endpoint: Value &gt;=1 Default: 1</param>
		/// <param name="unique_pins">(Optional) for each unique set of pins, show at most 1 path per path group</param>
		/// <param name="path_type">
		/// <para>
		/// (Optional)<br/>
		/// Format for path report: Values: end, summary, short, full,<br/>
		/// full_clock, full_clock_expanded Default: full_clock_expanded<br/>
		/// </para>
		/// </param>
		/// <param name="input_pins">(Optional) Show input pins in path</param>
		/// <param name="no_header">(Optional) Do not generate a report header</param>
		/// <param name="no_reused_label">
		/// <para>
		/// (Optional)<br/>
		/// Do not label reuse status on pins in the report<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Name Description<br/>
		/// </para>
		/// </param>
		/// <param name="slack_lesser_than">(Optional) Display paths with slack less than this Default: 1e+30</param>
		/// <param name="slack_greater_than">(Optional) Display paths with slack greater than this Default: -1e+30</param>
		/// <param name="group">(Optional) Limit report to paths in this group(s)</param>
		/// <param name="sort_by">(Optional) Sorting order of paths: Values: group, slack Default: slack</param>
		/// <param name="no_report_unconstrained">(Optional) Do not report infinite slack paths</param>
		/// <param name="user_ignored">
		/// <para>
		/// (Optional)<br/>
		/// Only report paths which have infinite slack because of<br/>
		/// set_false_path or set_clock_groups timing constraints<br/>
		/// </para>
		/// </param>
		/// <param name="of_objects">(Optional) Report timing for these paths</param>
		/// <param name="significant_digits">(Optional) Number of digits to display: Range: 0 to 3 Default: 3</param>
		/// <param name="column_style">
		/// <para>
		/// (Optional)<br/>
		/// style for path report columns: Values: variable_width,<br/>
		/// anchor_left, fixed_width Default: anchor_left<br/>
		/// </para>
		/// </param>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="no_pr_attribute">
		/// <para>
		/// (Optional)<br/>
		/// for Dynamic Function eXchange designs, do not report<br/>
		/// whether netlist resources are in the static or reconfigurable<br/>
		/// regions<br/>
		/// </para>
		/// </param>
		/// <param name="routable_nets">
		/// <para>
		/// (Optional)<br/>
		/// store the number of routable nets traversed as a property<br/>
		/// on timing paths.<br/>
		/// </para>
		/// </param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="warn_on_violation">(Optional) issue a critical warning when the report contains a timing violation</param>
		/// <param name="cells">(Optional) run report_timing on the specified cell(s)</param>
		/// <param name="rpx">(Optional) Filename to output interactive results to.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_timing(TCLParameterList from = null, TCLParameterList rise_from = null, TCLParameterList fall_from = null, TCLParameterList to = null, TCLParameterList rise_to = null, TCLParameterList fall_to = null, TCLParameterList through = null, TCLParameterList rise_through = null, TCLParameterList fall_through = null, report_timing_delay_type? delay_type = null, bool? setup = null, bool? hold = null, Int32? max_paths = null, String nworst = null, bool? unique_pins = null, report_timing_path_type? path_type = null, bool? input_pins = null, bool? no_header = null, bool? no_reused_label = null, String slack_lesser_than = null, String slack_greater_than = null, TCLParameterList group = null, report_timing_sort_by? sort_by = null, bool? no_report_unconstrained = null, bool? user_ignored = null, TCLParameterList of_objects = null, Int32? significant_digits = null, report_timing_column_style? column_style = null, String file = null, bool? append = null, String name = null, bool? no_pr_attribute = null, bool? routable_nets = null, bool? return_string = null, bool? warn_on_violation = null, TCLParameterList cells = null, String rpx = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_timing [-from <args>] [-rise_from <args>] [-fall_from <args>] [-to <args>] [-rise_to <args>] [-fall_to <args>] [-through <args>] [-rise_through <args>] [-fall_through <args>] [-delay_type <arg>] [-setup] [-hold] [-max_paths <arg>] [-nworst <arg>] [-unique_pins] [-path_type <arg>] [-input_pins] [-no_header] [-no_reused_label] [-slack_lesser_than <arg>] [-slack_greater_than <arg>] [-group <args>] [-sort_by <arg>] [-no_report_unconstrained] [-user_ignored] [-of_objects <args>] [-significant_digits <arg>] [-column_style <arg>] [-file <arg>] [-append] [-name <arg>] [-no_pr_attribute] [-routable_nets] [-return_string] [-warn_on_violation] [-cells <args>] [-rpx <arg>] [-quiet] [-verbose]
			this.Entry(_builder.report_timing(from, rise_from, fall_from, to, rise_to, fall_to, through, rise_through, fall_through, delay_type, setup, hold, max_paths, nworst, unique_pins, path_type, input_pins, no_header, no_reused_label, slack_lesser_than, slack_greater_than, group, sort_by, no_report_unconstrained, user_ignored, of_objects, significant_digits, column_style, file, append, name, no_pr_attribute, routable_nets, return_string, warn_on_violation, cells, rpx, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report timing summary<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_timing_summary [-check_timing_verbose] [-delay_type &lt;arg&gt;] [-no_detailed_paths] [-setup] [-hold] [-max_paths &lt;arg&gt;] [-nworst &lt;arg&gt;] [-unique_pins] [-path_type &lt;arg&gt;] [-no_reused_label] [-input_pins] [-no_pr_attribute] [-routable_nets] [-slack_lesser_than &lt;arg&gt;] [-report_unconstrained] [-significant_digits &lt;arg&gt;] [-no_header] [-file &lt;arg&gt;] [-append] [-name &lt;arg&gt;] [-return_string] [-warn_on_violation] [-datasheet] [-cells &lt;args&gt;] [-rpx &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// TIP: The report_timing_summary can be multi-threaded to speed the process. Refer to the<br/>
		/// set_param command for more information on setting the general.maxThreads parameter.<br/>
		/// Generate a timing summary to help understand if the design has met timing requirements. The<br/>
		/// timing summary can be run on an open Synthesized or Implemented Design.<br/>
		/// The timing summary report includes the following information:<br/>
		/// • Timer Settings - Details the timing engine settings used to generate the timing information in<br/>
		/// the report.<br/>
		/// • Check Timing - Contains the same information that is produced by the check_timing<br/>
		/// command, which summarizes potential timing issues.<br/>
		/// • Design Timing Summary - Provides a summary of the timing of the design, including values for<br/>
		/// worst and total negative slack (WNS/TNS), worst and total hold slack (WHS/THS), and<br/>
		/// component switching limits (CSL).<br/>
		/// • Clock Definitions - Contains the same information that is produced by the report_clocks<br/>
		/// command, showing all the clocks that were created for the design, either by create_clock,<br/>
		/// create_generated_clock, or automatically by the tool.<br/>
		/// • Intra-Clock Table - Summarizes timing paths with the same source and destination clocks.<br/>
		/// • Inter-Clock Table - Summarizes timing paths with different source and destination clocks.<br/>
		/// • Path Group Table - Shows default path groups and user-defined path groups created by the<br/>
		/// group_path command.<br/>
		/// • Timing Details - Contains detailed timing paths, both max delay and min delay, as well as<br/>
		/// component switching limits for each clock defined, similar to the report_timing command.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// • Data sheet - Contains the same information that is produced by the report_datasheet<br/>
		/// command. It contains the timing characteristics of a design at the I/O ports. The data sheet<br/>
		/// information is added to the summary report only when the -datasheet option is specified.<br/>
		/// This command is automatically run during implementation as part of the launch_runs<br/>
		/// command.<br/>
		/// Note: By default the report is written to the Tcl console or STD output. However, the results can also be<br/>
		/// written to a file or returned as a string if desired.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports the timing summary of the current design:<br/>
		/// report_timing_summary<br/>
		/// The following example reports the hold timing summary of the current design, including<br/>
		/// unconstrained paths, with the specified options:<br/>
		/// report_timing_summary -delay_type min -path_type full_clock_expanded \<br/>
		/// -report_unconstrained -max_paths 2 -nworst 1 -significant_digits 2 \<br/>
		/// -input_pins -name {timing_6}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1462<br/>
		/// </para>
		/// </summary>
		/// <param name="check_timing_verbose">
		/// <para>
		/// (Optional)<br/>
		/// produce a verbose report when checking the design for<br/>
		/// potential timing problems<br/>
		/// </para>
		/// </param>
		/// <param name="delay_type">(Optional) Type of path delay: Values: max, min, min_max Default: min_max</param>
		/// <param name="no_detailed_paths">(Optional) do not report timing paths for each clock and path group analyzed</param>
		/// <param name="setup">(Optional) Report max delay timing paths (equivalent to -delay_type max)</param>
		/// <param name="hold">(Optional) Report min delay timing paths (equivalent to -delay_type min)</param>
		/// <param name="max_paths">
		/// <para>
		/// (Optional)<br/>
		/// Maximum number of paths to report per clock or path<br/>
		/// group: Value &gt;=1 Default: 1<br/>
		/// </para>
		/// </param>
		/// <param name="nworst">(Optional) List up to N worst paths to endpoint: Value &gt;=1 Default: 1</param>
		/// <param name="unique_pins">(Optional) for each unique set of pins, show at most 1 path per path group</param>
		/// <param name="path_type">
		/// <para>
		/// (Optional)<br/>
		/// Format for path report: Values: end summary short full<br/>
		/// full_clock full_clock_expanded Default: full_clock_expanded<br/>
		/// </para>
		/// </param>
		/// <param name="no_reused_label">(Optional) Do not label reuse status on pins in the report</param>
		/// <param name="input_pins">(Optional) Show input pins in path</param>
		/// <param name="no_pr_attribute">
		/// <para>
		/// (Optional)<br/>
		/// for Dynamic Function eXchange designs, do not report<br/>
		/// whether netlist resources are in the static or reconfigurable<br/>
		/// regions<br/>
		/// </para>
		/// </param>
		/// <param name="routable_nets">
		/// <para>
		/// (Optional)<br/>
		/// store the number of routable nets traversed as a property<br/>
		/// on timing paths.<br/>
		/// </para>
		/// </param>
		/// <param name="slack_lesser_than">(Optional) Display paths with slack less than this Default: 1e+30</param>
		/// <param name="report_unconstrained">(Optional) report unconstrained and user ignored paths</param>
		/// <param name="significant_digits">(Optional) Number of digits to display: Range: 0 to 3 Default: 3</param>
		/// <param name="no_header">(Optional) do not generate a report header</param>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Name Description<br/>
		/// </para>
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="warn_on_violation">(Optional) issue a critical warning when the report contains a timing violation</param>
		/// <param name="datasheet">(Optional) Include data sheet report</param>
		/// <param name="cells">(Optional) run report_timing_summary on the specified cell(s)</param>
		/// <param name="rpx">(Optional) Filename to output interactive results to.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_timing_summary(bool? check_timing_verbose = null, report_timing_summary_delay_type? delay_type = null, bool? no_detailed_paths = null, bool? setup = null, bool? hold = null, Int32? max_paths = null, String nworst = null, bool? unique_pins = null, String path_type = null, bool? no_reused_label = null, bool? input_pins = null, bool? no_pr_attribute = null, bool? routable_nets = null, String slack_lesser_than = null, bool? report_unconstrained = null, Int32? significant_digits = null, bool? no_header = null, String file = null, bool? append = null, String name = null, bool? return_string = null, bool? warn_on_violation = null, bool? datasheet = null, TCLParameterList cells = null, String rpx = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_timing_summary [-check_timing_verbose] [-delay_type <arg>] [-no_detailed_paths] [-setup] [-hold] [-max_paths <arg>] [-nworst <arg>] [-unique_pins] [-path_type <arg>] [-no_reused_label] [-input_pins] [-no_pr_attribute] [-routable_nets] [-slack_lesser_than <arg>] [-report_unconstrained] [-significant_digits <arg>] [-no_header] [-file <arg>] [-append] [-name <arg>] [-return_string] [-warn_on_violation] [-datasheet] [-cells <args>] [-rpx <arg>] [-quiet] [-verbose]
			this.Entry(_builder.report_timing_summary(check_timing_verbose, delay_type, no_detailed_paths, setup, hold, max_paths, nworst, unique_pins, path_type, no_reused_label, input_pins, no_pr_attribute, routable_nets, slack_lesser_than, report_unconstrained, significant_digits, no_header, file, append, name, return_string, warn_on_violation, datasheet, cells, rpx, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report details of Unisim primitive transformations.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_transformed_primitives [-file &lt;arg&gt;] [-append] [-return_string] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Report the transformed primitives in the current design.<br/>
		/// As part of the process of opening the Synthesized design, and loading it into memory, the tool<br/>
		/// will transform legacy netlist primitives to the supported subset of Unisim primitives.<br/>
		/// As a default this report will be written to the standard output. However, the report can also be<br/>
		/// written to a file or returned to a Tcl string variable for further processing.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports the transformed primitives in the current design, and returns the<br/>
		/// result to the specified Tcl variable:<br/>
		/// set transPrim [ report_transformed_primitives -return_string ]<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1468<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Optional) Output file</param>
		/// <param name="append">(Optional) Append the results to file</param>
		/// <param name="return_string">(Optional) return report as string</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_transformed_primitives(String file = null, bool? append = null, bool? return_string = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_transformed_primitives [-file <arg>] [-append] [-return_string] [-quiet] [-verbose]
			this.Entry(_builder.report_transformed_primitives(file, append, return_string, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Compute utilization of device and display report<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_utilization [-file &lt;arg&gt;] [-append] [-pblocks &lt;args&gt;] [-evaluate_pblock] [-exclude_child_pblocks] [-exclude_non_assigned] [-cells &lt;args&gt;] [-return_string] [-slr] [-packthru] [-name &lt;arg&gt;] [-no_primitives] [-omit_locs] [-hierarchical] [-spreadsheet_file &lt;arg&gt;] [-spreadsheet_table &lt;arg&gt;] [-spreadsheet_depth &lt;arg&gt;] [-hierarchical_depth &lt;arg&gt;] [-hierarchical_percentages] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Report resource usage on the target part by the current synthesized or implemented design. The<br/>
		/// report is returned to the standard output, unless the -file, -return_string, or -name<br/>
		/// arguments are specified.<br/>
		/// TIP: Though resource usage can be reported early in the design process, the report will be more accurate<br/>
		/// as the design progresses from synthesis through implementation.<br/>
		/// This command returns the requested information, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports the resources collectively utilized by all the Pblocks in the design,<br/>
		/// and writes the results to the specified file:<br/>
		/// report_utilization -pblocks [get_pblocks] -file C:/Data/pblocks_util.txt<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This example reports the utilization for the whole design to the named report in the GUI, but<br/>
		/// exports the "Clocking - BUFGCTRL" table to the specified spreadsheet file:<br/>
		/// report_utilization -name utilization_1 -spreadsheet_file util_table.xlsx \<br/>
		/// -spreadsheet_table "Clocking - BUFGCTRL"<br/>
		/// The following example reports the resources utilized by each Pblock in the design, appending the<br/>
		/// report for each Pblock to a single specified file:<br/>
		/// foreach x [get_pblocks] {<br/>
		/// puts "Reporting Pblock: $x ----------------------------------"<br/>
		/// report_utilization -append -file C:/Data/pblocks_util.txt -pblocks $x<br/>
		/// }<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1470<br/>
		/// </para>
		/// </summary>
		/// <param name="file">
		/// <para>
		/// (Optional)<br/>
		/// Filename to output results to. (send output to console if -file<br/>
		/// is not used)<br/>
		/// </para>
		/// </param>
		/// <param name="append">(Optional) Append the results to file, don't overwrite the results file</param>
		/// <param name="pblocks">(Optional) Report utilization of given pblock</param>
		/// <param name="evaluate_pblock">
		/// <para>
		/// (Optional)<br/>
		/// Report utilization with demand as specified cells and supply<br/>
		/// as specified pblock area<br/>
		/// </para>
		/// </param>
		/// <param name="exclude_child_pblocks">(Optional) Report utilization with out child pblocks</param>
		/// <param name="exclude_non_assigned">(Optional) Pblock utilization with out Non-assigned Cells</param>
		/// <param name="cells">(Optional) Report utilization of given list of cells</param>
		/// <param name="return_string">(Optional) Return report as string</param>
		/// <param name="slr">(Optional) SLR wise utilization of resources</param>
		/// <param name="packthru">(Optional) Reports LUTs used exclusively as pack-thru</param>
		/// <param name="name">(Optional) Output the results to GUI panel with this name</param>
		/// <param name="no_primitives">(Optional) Removes "Primitives Section" from report_utilization o/p.</param>
		/// <param name="omit_locs">(Optional) Removes "Loced" column from report_utilization o/p.</param>
		/// <param name="hierarchical">(Optional) Generates text-based hierarchical report.</param>
		/// <param name="spreadsheet_file">
		/// <para>
		/// (Optional)<br/>
		/// Specify file for exporting utilization tables as spreadsheets.<br/>
		/// This feature is available only in GUI mode.<br/>
		/// </para>
		/// </param>
		/// <param name="spreadsheet_table">
		/// <para>
		/// (Optional)<br/>
		/// Choose a particular utilization table to export as<br/>
		/// spreadsheet file. Default value : Hierarchy<br/>
		/// </para>
		/// </param>
		/// <param name="spreadsheet_depth">
		/// <para>
		/// (Optional)<br/>
		/// Specifies the depth level for spreadsheet. Default value : 8<br/>
		/// Default: 8<br/>
		/// </para>
		/// </param>
		/// <param name="hierarchical_depth">(Optional) Specifies the depth level for textual hierarchical report Default: 0</param>
		/// <param name="hierarchical_percentages">
		/// <para>
		/// (Optional)<br/>
		/// Report percentages in textual hierarchical report<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Name Description<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Report</returns>
		public VivadoTCL report_utilization(String file = null, bool? append = null, TCLParameterList pblocks = null, bool? evaluate_pblock = null, bool? exclude_child_pblocks = null, bool? exclude_non_assigned = null, TCLParameterList cells = null, bool? return_string = null, bool? slr = null, bool? packthru = null, String name = null, bool? no_primitives = null, bool? omit_locs = null, bool? hierarchical = null, String spreadsheet_file = null, String spreadsheet_table = null, String spreadsheet_depth = null, String hierarchical_depth = null, bool? hierarchical_percentages = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_utilization [-file <arg>] [-append] [-pblocks <args>] [-evaluate_pblock] [-exclude_child_pblocks] [-exclude_non_assigned] [-cells <args>] [-return_string] [-slr] [-packthru] [-name <arg>] [-no_primitives] [-omit_locs] [-hierarchical] [-spreadsheet_file <arg>] [-spreadsheet_table <arg>] [-spreadsheet_depth <arg>] [-hierarchical_depth <arg>] [-hierarchical_percentages] [-quiet] [-verbose]
			this.Entry(_builder.report_utilization(file, append, pblocks, evaluate_pblock, exclude_child_pblocks, exclude_non_assigned, cells, return_string, slr, packthru, name, no_primitives, omit_locs, hierarchical, spreadsheet_file, spreadsheet_table, spreadsheet_depth, hierarchical_depth, hierarchical_percentages, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Print current simulated value of given HDL objects (variable, signal, wire, or reg)<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_values [-radix &lt;arg&gt;] [-quiet] [-verbose] [&lt;hdl_objects&gt;...]
		/// <br/>
		/// <para>
		/// Report the values of the specified HDL objects at the current simulation run time.<br/>
		/// HDL objects include HDL signals, variables, or constants as defined in the Verilog or VHDL test<br/>
		/// bench and source files. An HDL signal includes Verilog wire or reg entities, and VHDL signals.<br/>
		/// Examples of HDL variables include Verilog real, realtime, time, and event.<br/>
		/// HDL constants include Verilog parameters and localparams, and VHDL generic and constants.<br/>
		/// The HDL scope, or scope, is defined by a declarative region in the HDL code such as a module,<br/>
		/// function, task, process, or begin-end blocks in Verilog. VHDL scopes include entity/architecture<br/>
		/// definitions, block, function, procedure, and process blocks.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// HDL constants include Verilog parameters and localparams, and VHDL generic and constants.<br/>
		/// The HDL scope, or scope, is defined by a declarative region in the HDL code such as a module,<br/>
		/// function, task, process, or begin-end blocks in Verilog. VHDL scopes include entity/architecture<br/>
		/// definitions, block, function, procedure, and process blocks.<br/>
		/// Arguments<br/>
		/// -radix &lt;arg&gt; - (Optional) Specifies the radix to use when returning the value of the specified<br/>
		/// objects. Allowed values are: default, dec, bin, oct, hex, unsigned, ascii, or smag.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Note: The radix dec indicates a signed decimal. Specify the radix unsigned when dealing with unsigned<br/>
		/// data.<br/>
		/// -quiet - (Optional) Execute the command quietly, returning no messages from the command.<br/>
		/// The command also returns TCL_OK regardless of any errors encountered during execution.<br/>
		/// Note: Any errors encountered on the command-line, while launching the command, will be returned. Only<br/>
		/// errors occurring inside the command will be trapped.<br/>
		/// -verbose - (Optional) Temporarily override any message limits and return all messages from this<br/>
		/// command.<br/>
		/// Note: Message limits can be defined with the set_msg_config command.<br/>
		/// &lt;hdl_objects&gt; - (Required) Specifies one or more HDL objects to return the values of. The object<br/>
		/// can be specified by name, or can be returned as an object from the get_objects command.<br/>
		/// Examples<br/>
		/// The following example reports the value of all objects at the current time:<br/>
		/// report_values [get_objects]<br/>
		/// This example shows the difference between the bin, dec, and unsigned radix on the value<br/>
		/// returned from the specified bus:<br/>
		/// report_values -radix bin /test/bench_VStatus_pad_0_i[7:0]<br/>
		/// Declared: {/test/bench_VStatus_pad_0_i[7:0]} Verilog 10100101<br/>
		/// report_values -radix unsigned /test/bench_VStatus_pad_0_i[7:0]<br/>
		/// Declared: {/test/bench_VStatus_pad_0_i[7:0]} Verilog 165<br/>
		/// report_values -radix dec /test/bench_VStatus_pad_0_i[7:0]<br/>
		/// Declared: {/test/bench_VStatus_pad_0_i[7:0]} Verilog -91<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1475<br/>
		/// </para>
		/// </summary>
		/// <param name="hdl_objects">(Required) The hdl_objects to report. Default is report_objects [get_objects *]</param>
		/// <param name="radix">
		/// <para>
		/// (Optional)<br/>
		/// The radix specifies the radix to use for printing the values of<br/>
		/// the hdl_objects. Allowed values are: default, dec, bin, oct,<br/>
		/// hex, unsigned, ascii, smag.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Print name and value of HDL objects on the console in textual format</returns>
		public VivadoTCL report_values(TCLParameterList hdl_objects, String radix = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_values [-radix <arg>] [-quiet] [-verbose] [<hdl_objects>...]
			this.Entry(_builder.report_values(hdl_objects, radix, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Report status of DRC/METHODOLOGY/CDC message waivers<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: report_waivers [-file &lt;arg&gt;] [-type &lt;arg&gt;] [-write_valid_waivers] [-write_ignored_waivers] [-append] [-return_string] [-show_msgs_with_no_waivers] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Reports DRC, METHODOLOGY, and CDC violation messages and displays what waivers are in<br/>
		/// place in the current design.<br/>
		/// In addition, the report_drc, report_methodology, and report_cdc commands have<br/>
		/// options to run the reports on waived violations or checks.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// This example reports all waivers in the current design:<br/>
		/// report_waivers<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1477<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Optional) Name of file to report waivers</param>
		/// <param name="type">(Optional) Type of waiver - ALL, DRC, METHODOLOGY, CDC</param>
		/// <param name="write_valid_waivers">
		/// <para>
		/// (Optional)<br/>
		/// (special) Specifies writing out the specific waivers which<br/>
		/// were used in the last report_drc/methodology/cdc run(s)<br/>
		/// </para>
		/// </param>
		/// <param name="write_ignored_waivers">
		/// <para>
		/// (Optional)<br/>
		/// (special) Specifies writing out the specific waivers which<br/>
		/// were NOT used in the last report_drc/methodology/cdc<br/>
		/// run(s)<br/>
		/// </para>
		/// </param>
		/// <param name="append">(Optional) Append the current report results to the file specified with - file</param>
		/// <param name="return_string">(Optional) Return report results as a string object</param>
		/// <param name="show_msgs_with_no_waivers">
		/// <para>
		/// (Optional)<br/>
		/// also list report_drc/methodology/cdc messages which have<br/>
		/// no defined waivers<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL report_waivers(String file = null, String type = null, bool? write_valid_waivers = null, bool? write_ignored_waivers = null, bool? append = null, bool? return_string = null, bool? show_msgs_with_no_waivers = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: report_waivers [-file <arg>] [-type <arg>] [-write_valid_waivers] [-write_ignored_waivers] [-append] [-return_string] [-show_msgs_with_no_waivers] [-quiet] [-verbose]
			this.Entry(_builder.report_waivers(file, type, write_valid_waivers, write_ignored_waivers, append, return_string, show_msgs_with_no_waivers, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Remove DRC report<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: reset_drc [-name &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Clear the DRC results from the specified named result set.<br/>
		/// This command operates silently, returning nothing if successful, or returning an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example clears the specified results set from memory and the GUI:<br/>
		/// reset_drc -name DRC1<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1480<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Optional) DRC result name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL reset_drc(String name = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_drc [-name <arg>] [-quiet] [-verbose]
			this.Entry(_builder.reset_drc(name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Reset one or more DRC checks to factory defaults.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: reset_drc_check [-quiet] [-verbose] [&lt;checks&gt;...]
		/// <br/>
		/// <para>
		/// Reset the specified DRC checks to the defaults provided by the Vivado Design Suite. This will<br/>
		/// restore the DRC check to its default configuration, including any changes to the IS_ENABLED or<br/>
		/// SEVERITY properties.<br/>
		/// The IS_ENABLED property can be modified on a specific DRC check to disable the rule from<br/>
		/// being checked, even when it is specified either directly in the report_drc command, or as part<br/>
		/// of a ruledeck.<br/>
		/// The SEVERITY property is a string property that can be modified to change the severity<br/>
		/// associated with a specific DRC rule when a violation is found during the report_drc command.<br/>
		/// The supported values are: FATAL, ERROR, "CRITICAL WARNING", WARNING, ADVISORY<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example modifies the IS_ENABLED property for the ROAS-1 rule, modifies the<br/>
		/// SEVERITY property for the RFFC-1 rule, and then restores the default settings for all checks:<br/>
		/// set_property IS_ENABLED false [get_drc_checks ROAS-1]<br/>
		/// set_property SEVERITY "Critical Warning" [get_drc_checks RFFC-1]<br/>
		/// reset_drc_check [get_drc_checks]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1482<br/>
		/// </para>
		/// </summary>
		/// <param name="checks">(Required) The list of checks to reset.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL reset_drc_check(TCLParameterList checks, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_drc_check [-quiet] [-verbose] [<checks>...]
			this.Entry(_builder.reset_drc_check(checks, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Reset hardware AXI core state.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: reset_hw_axi [-quiet] [-verbose] [&lt;hw_axis&gt;...]
		/// <br/>
		/// <para>
		/// Reset the STATUS properties of the specified hw_axi objects, or the current device.<br/>
		/// The reset_hw_axi restores the hw_axi core on the current device to a known state from which<br/>
		/// to begin running AXI transactions. The STATUS properties include:<br/>
		/// • STATUS.AXI_READ_BUSY<br/>
		/// • STATUS.AXI_READ_DONE<br/>
		/// • STATUS.AXI_WRITE_BUSY<br/>
		/// • STATUS.AXI_WRITE_DONE<br/>
		/// • STATUS.BRESP - Write Response Channel Response. Indicates results of the write transfer.<br/>
		/// • STATUS.RRESP - Read Response Channel Response. Indicates results of the read transfer.<br/>
		/// The command returns nothing if successful, and returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1484<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_axis">(Required) List of hardware AXI objects.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL reset_hw_axi(TCLParameterList hw_axis, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_hw_axi [-quiet] [-verbose] [<hw_axis>...]
			this.Entry(_builder.reset_hw_axi(hw_axis, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Reset hardware ILA control properties to default values.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: reset_hw_ila [-reset_compare_values &lt;arg&gt;] [-quiet] [-verbose] [&lt;hw_ilas&gt;...]
		/// <br/>
		/// <para>
		/// Reset the trigger and capture configuration properties on the specified ILA debug core, and the<br/>
		/// TRIGGER_COMPARE_VALUE and CAPTURE_COMPARE_VALUE properties on the core's debug<br/>
		/// probes.<br/>
		/// Properties of the hw_ila object are configured with the set_property command in preparation<br/>
		/// for the run_hw_ila command to configure the ILA core on the hw_device. This command<br/>
		/// restores the user-configurable properties on the specified hw_ila to their default settings. Refer<br/>
		/// to the Vivado Design Suite User Guide: Programming and Debugging (UG908) for more information<br/>
		/// on these properties.<br/>
		/// The default properties are:<br/>
		/// • CONTROL.DATA_DEPTH is set to the MAX_DATA_DEPTH of the hw_ila object.<br/>
		/// • CONTROL.TRIGGER_POSITION 0<br/>
		/// • CONTROL.WINDOW_COUNT 1<br/>
		/// • CONTROL.TRIGGER_MODE BASIC_ONLY<br/>
		/// • CONTROL.TRIGGER_CONDITION AND<br/>
		/// • CONTROL.TRIG_OUT_MODE DISABLED<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// • CONTROL.CAPTURE_MODE ALWAYS<br/>
		/// • CONTROL.CAPTURE_CONDITION AND<br/>
		/// • TRIGGER_COMPARE_VALUE eq1'bX (on the hw_probes)<br/>
		/// • CAPTURE_COMPARE_VALUE eq1'bX (on the hw_probes)<br/>
		/// This command operates silently, returning nothing if successful, or returning an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1486<br/>
		/// </para>
		/// </summary>
		/// <param name="reset_compare_values">(Optional) Reset associated hardware probe compare values.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_ilas">(Optional) List of hardware ILA objects. Default: Current hardware ILA</param>
		public VivadoTCL reset_hw_ila(String reset_compare_values = null, bool? quiet = null, bool? verbose = null, TCLParameterList hw_ilas = null)
		{
			// TCL Syntax: reset_hw_ila [-reset_compare_values <arg>] [-quiet] [-verbose] [<hw_ilas>...]
			this.Entry(_builder.reset_hw_ila(reset_compare_values, quiet, verbose, hw_ilas));
			return this;
		}
		/// <summary>
		/// <para>
		/// Reset the PCIe core.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: reset_hw_pcie [-quiet] [-verbose] &lt;hw_pcie&gt;
		/// <br/>
		/// <para>
		/// Reset the Peripheral Component Interconnect Express (PCIe) debug core object, hw_pcie,<br/>
		/// defined on the current hardware device.<br/>
		/// The customizable LogiCORE IP PCIe core for Xilinx ACAPs is designed for evaluating and<br/>
		/// monitoring the PCIe Link Training and Status State Machine (LTSSM) running on the Gigabit<br/>
		/// Transceivers (GTs). In the Vivado Hardware Manager, Versal PCIe soft cores implemented in the<br/>
		/// design, are represented as hw_pcie objects. You can use these PCIe debug cores to solve a range<br/>
		/// of debug and validation problems; from viewing the PCIe link info to the LTSSM state transition<br/>
		/// diagram.<br/>
		/// This command resets the PCIe soft IP in hardware.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example resets PCIe core at index 0<br/>
		/// reset_hw_pcie [lindex [get_hw_pcies] 0]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1488<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_pcie">(Required) Hardware PCIe object</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL reset_hw_pcie(String hw_pcie, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_hw_pcie [-quiet] [-verbose] <hw_pcie>
			this.Entry(_builder.reset_hw_pcie(hw_pcie, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Reset hardware VIO ACTIVITY_VALUE properties, for hardware probes associated with specified<br/>
		/// hardware VIO objects.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: reset_hw_vio_activity [-quiet] [-verbose] &lt;hw_vios&gt;...
		/// <br/>
		/// <para>
		/// Resets the ACTIVITY_VALUE properties for all hardware probes on the specified VIO debug core<br/>
		/// objects. The ACTIVITY_VALUE property is used by the Vivado IDE to represent transitions on<br/>
		/// the input probes of the VIO debug cores.<br/>
		/// In addition to reading values from the VIO input probes, you can also monitor the activity of the<br/>
		/// VIO input probes. The ACTIVITY_VALUE property is used to indicate when the values on the<br/>
		/// VIO inputs have changed in between periodic updates to the Vivado IDE. Refer to the Vivado<br/>
		/// Design Suite User Guide: Programming and Debugging (UG908) for more information.<br/>
		/// This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1490<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_vios">(Required) List of hardware VIO objects.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL reset_hw_vio_activity(TCLParameterList hw_vios, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_hw_vio_activity [-quiet] [-verbose] <hw_vios>...
			this.Entry(_builder.reset_hw_vio_activity(hw_vios, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Reset hardware VIO core outputs to initial values.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: reset_hw_vio_outputs [-quiet] [-verbose] &lt;hw_vios&gt;...
		/// <br/>
		/// <para>
		/// Reset the hardware VIO debug core outputs to their initial, or "reset" state.<br/>
		/// The Virtual Input/Output (VIO) debug core can both monitor and drive internal signals on a<br/>
		/// programmed Xilinx FPGA in real time. The VIO core uses hardware probes, hw_probe objects, to<br/>
		/// monitor and drive signals on the device. Input probes monitor signals as inputs to the VIO core.<br/>
		/// Output probes drive signals to specified values from the VIO core.<br/>
		/// The reset_hw_vio_outputs command restores the signal values at the output probes of the<br/>
		/// specified hw_vio debug cores to their initial values. This affects the signal on the hw_device, but<br/>
		/// does not affect the OUTPUT_VALUE property of the hw_probe objects.<br/>
		/// TIP: This command has the effect of resetting the initial value of the signal on the hw_vio debug core,<br/>
		/// without resetting the properties on the hw_probe object.<br/>
		/// This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1492<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_vios">(Required) List of hardware VIO objects.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL reset_hw_vio_outputs(TCLParameterList hw_vios, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_hw_vio_outputs [-quiet] [-verbose] <hw_vios>...
			this.Entry(_builder.reset_hw_vio_outputs(hw_vios, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Remove Methodology report<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: reset_methodology [-name &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Clear the methodology results from the specified named result set.<br/>
		/// This command operates silently, returning nothing if successful, or returning an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example clears the specified results set from memory and the GUI:<br/>
		/// reset_methodology -name ultrafast_methodology_3<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1494<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Optional) Methodology result name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL reset_methodology(String name = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_methodology [-name <arg>] [-quiet] [-verbose]
			this.Entry(_builder.reset_methodology(name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Reset one or more Methodology checks to factory defaults.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: reset_methodology_check [-quiet] [-verbose] [&lt;checks&gt;...]
		/// <br/>
		/// <para>
		/// Reset the specified methodology checks to the defaults provided by the Vivado Design Suite.<br/>
		/// This will restore the check to its default configuration, including any changes to the IS_ENABLED<br/>
		/// or SEVERITY properties.<br/>
		/// The IS_ENABLED property can be modified on a specific methodology check to disable the rule<br/>
		/// from being checked, even when it is specified directly in the report_methodology command.<br/>
		/// The SEVERITY property is an enumerated property that can be modified to change the severity<br/>
		/// associated with a specific methodology check when a violation is found during the<br/>
		/// report_methodology command. The supported values are: FATAL, ERROR, "CRITICAL<br/>
		/// WARNING", WARNING, ADVISORY<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example modifies the IS_ENABLED and SEVERITY properties for the CHECK-4<br/>
		/// methodology check, reports the properties of the check to see the changes, and then resets the<br/>
		/// methodology check to its default setting:<br/>
		/// set_property IS_ENABLED false [get_methodology_checks CHECK-4]<br/>
		/// set_property SEVERITY Warning [get_methodology_checks CHECK-4]<br/>
		/// report_property [get_methodology_checks CHECK-4]<br/>
		/// reset_methodology_check [get_methodology_checks CHECK-4]<br/>
		/// report_property [get_methodology_checks CHECK-4]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1496<br/>
		/// </para>
		/// </summary>
		/// <param name="checks">(Required) The list of checks to reset.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL reset_methodology_check(TCLParameterList checks, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_methodology_check [-quiet] [-verbose] [<checks>...]
			this.Entry(_builder.reset_methodology_check(checks, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Resets or removes a message control rule previously defined by the set_msg_config command.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: reset_msg_config [-string &lt;args&gt;] [-id &lt;arg&gt;] [-severity &lt;arg&gt;] [-limit] [-suppress] [-count] [-default_severity] [-regexp] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// This command restores the default settings of the message limits or severity for messages<br/>
		/// returned by the Vivado tool, or can unsuppress previously suppressed messages, as configured<br/>
		/// by the set_msg_config command.<br/>
		/// You can only perform one reset action for each reset_msg_config command. An error is<br/>
		/// returned if more than one action is attempted in a single reset_msg_config command.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Message qualifiers of string, ID, and severity are used to determine which messages are reset by<br/>
		/// the reset_msg_config command. Multiple qualifiers have an AND relationship; only the<br/>
		/// messages matching the qualifiers will be reset.<br/>
		/// Note: You must supply at least one message qualifier to identify a message or group of messages to apply<br/>
		/// the command to, or an error is returned.<br/>
		/// To report the current rule configurations for messages, use the get_msg_config command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example changes the severity of the specified message ID to a Critical Warning,<br/>
		/// and then resets the message to its default severity:<br/>
		/// set_msg_config -id "Common 17-81" -new_severity "CRITICAL WARNING"<br/>
		/// reset_msg_config -id "Common 17-81" -default_severity<br/>
		/// This example changes the severity of messages with the specified message ID, gets the current<br/>
		/// message configuration rules, and then shows two different command forms to reset the specific<br/>
		/// rule and restore the message:<br/>
		/// set_msg_config -id "Common 17-361" -severity INFO -new_severity WARNING<br/>
		/// get_msg_config -rules<br/>
		/// ---------------------<br/>
		/// Message control rules currently in effect are:<br/>
		/// Rule Name Rule Current<br/>
		/// Message Count<br/>
		/// 1 set_msg_config -ruleid {1} -id {Common 17-361} -severity {INFO} -<br/>
		/// new_severity {WARNING} 0<br/>
		/// ---------------------<br/>
		/// reset_msg_config -id "Common 17-361" -default_severity<br/>
		/// reset_msg_config -ruleid {1}<br/>
		/// TIP: In the preceding example, only one of the reset_msg_config commands is needed to reset the<br/>
		/// message.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1498<br/>
		/// </para>
		/// </summary>
		/// <param name="string">
		/// <para>
		/// (Optional)<br/>
		/// A qualifier, only a rule created with a matching string<br/>
		/// qualifier will be reset/removed Default: empty<br/>
		/// </para>
		/// </param>
		/// <param name="id">
		/// <para>
		/// (Optional)<br/>
		/// A qualifier, only a rule created with a matching id qualifier<br/>
		/// will be reset/removed<br/>
		/// </para>
		/// </param>
		/// <param name="severity">
		/// <para>
		/// (Optional)<br/>
		/// A qualifier, only a rule created with a matching severity<br/>
		/// qualifier will be reset/removed<br/>
		/// </para>
		/// </param>
		/// <param name="limit">
		/// <para>
		/// (Optional)<br/>
		/// reset the limit values for message controls that match the<br/>
		/// given qualifiers for the current project<br/>
		/// </para>
		/// </param>
		/// <param name="suppress">
		/// <para>
		/// (Optional)<br/>
		/// stop suppressing messages that match the given qualifiers<br/>
		/// for the current project<br/>
		/// </para>
		/// </param>
		/// <param name="count">
		/// <para>
		/// (Optional)<br/>
		/// reset the count of messages for all message controls that<br/>
		/// match the given qualifiers for the current project. This will<br/>
		/// prevent messages from being suppressed by a -limit control<br/>
		/// until the message count once again exceeds the specified<br/>
		/// limit.<br/>
		/// </para>
		/// </param>
		/// <param name="default_severity">
		/// <para>
		/// (Optional)<br/>
		/// reset the message severity of all messages controls for the<br/>
		/// current project that match the given qualifiers to their<br/>
		/// default value<br/>
		/// </para>
		/// </param>
		/// <param name="regexp">(Optional) The values used for -string are full regular expressions</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL reset_msg_config(TCLParameterList @string = null, String id = null, String severity = null, bool? limit = null, bool? suppress = null, bool? count = null, bool? default_severity = null, bool? regexp = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_msg_config [-string <args>] [-id <arg>] [-severity <arg>] [-limit] [-suppress] [-count] [-default_severity] [-regexp] [-quiet] [-verbose]
			this.Entry(_builder.reset_msg_config(@string, id, severity, limit, suppress, count, default_severity, regexp, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Reset message count<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: reset_msg_count [-quiet] [-verbose] &lt;id&gt;
		/// <br/>
		/// <para>
		/// Reset the message count for the specified message ID to 0. This restarts the message counter<br/>
		/// toward the specified message limit. This can be used to reset the count of specific messages that<br/>
		/// may be reaching the limit, or reset the count of all messages returned by the tool.<br/>
		/// Every message delivered by the tool has a unique global message ID that consists of an<br/>
		/// application sub-system code and a message identifier. This results in a message ID that looks like<br/>
		/// the following:<br/>
		/// "Common 17-54"<br/>
		/// "Netlist 29-28"<br/>
		/// "Synth 8-3295"<br/>
		/// You can get the current message count for a specific message ID using the get_msg_count<br/>
		/// command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example resets the message count for all messages:<br/>
		/// reset_msg_count *<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1502<br/>
		/// </para>
		/// </summary>
		/// <param name="id">
		/// <para>
		/// (Required)<br/>
		/// Unique message Id to be reset, e.g. "Common 17-99".<br/>
		/// "reset_msg_count -id *" reset all counters<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>new message count</returns>
		public VivadoTCL reset_msg_count(String id, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_msg_count [-quiet] [-verbose] <id>
			this.Entry(_builder.reset_msg_count(id, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Reset operating conditions to tool default for power estimation<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: reset_operating_conditions [-voltage &lt;args&gt;] [-grade] [-process] [-junction_temp] [-ambient_temp] [-thetaja] [-thetasa] [-airflow] [-heatsink] [-thetajb] [-board] [-board_temp] [-board_layers] [-design_power_budget] [-supply_current_budget &lt;args&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Resets the specified operating conditions to their default values. If no operating conditions are<br/>
		/// specified, all operating conditions are reset to their default values.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Operating conditions can be set using the set_operating_conditions command. The<br/>
		/// current values can be determined using the report_operating_conditions command. The<br/>
		/// environmental operating conditions of the device are used for power analysis when running the<br/>
		/// report_power command, but are not used during timing analysis.<br/>
		/// Note: This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example resets all the operating conditions for the design to their default setting:<br/>
		/// reset_operating_conditions<br/>
		/// The following example resets the junction, ambient, and board temperature for the design to<br/>
		/// their default settings:<br/>
		/// reset_operating_conditions -junction_temp -ambient_temp -board_temp<br/>
		/// The following example resets the voltage supply Vccint to its default value:<br/>
		/// reset_operating_conditions -voltage Vccint<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1504<br/>
		/// </para>
		/// </summary>
		/// <param name="voltage">(Optional) Resets voltage value. Supported voltage supplies vary by family.</param>
		/// <param name="grade">(Optional) Resets temperature grade</param>
		/// <param name="process">(Optional) Resets process</param>
		/// <param name="junction_temp">(Optional) Resets Junction Temperature</param>
		/// <param name="ambient_temp">(Optional) Resets Ambient Temperature</param>
		/// <param name="thetaja">(Optional) Resets ThetaJA</param>
		/// <param name="thetasa">(Optional) Resets ThetaSA</param>
		/// <param name="airflow">(Optional) Resets Airflow</param>
		/// <param name="heatsink">(Optional) Resets dimensions of heatsink</param>
		/// <param name="thetajb">(Optional) Resets ThetaJB</param>
		/// <param name="board">(Optional) Resets Board type</param>
		/// <param name="board_temp">(Optional) Resets Board Temperature</param>
		/// <param name="board_layers">(Optional) Resets Board layers</param>
		/// <param name="design_power_budget">(Optional) Design Power Budget (W)</param>
		/// <param name="supply_current_budget">
		/// <para>
		/// (Optional)<br/>
		/// Resets list of supply current budget 'name value' pairs.<br/>
		/// Supported voltage supplies vary by family.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL reset_operating_conditions(TCLParameterList voltage = null, bool? grade = null, bool? process = null, bool? junction_temp = null, bool? ambient_temp = null, bool? thetaja = null, bool? thetasa = null, bool? airflow = null, bool? heatsink = null, bool? thetajb = null, bool? board = null, bool? board_temp = null, bool? board_layers = null, bool? design_power_budget = null, TCLParameterList supply_current_budget = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_operating_conditions [-voltage <args>] [-grade] [-process] [-junction_temp] [-ambient_temp] [-thetaja] [-thetasa] [-airflow] [-heatsink] [-thetajb] [-board] [-board_temp] [-board_layers] [-design_power_budget] [-supply_current_budget <args>] [-quiet] [-verbose]
			this.Entry(_builder.reset_operating_conditions(voltage, grade, process, junction_temp, ambient_temp, thetaja, thetasa, airflow, heatsink, thetajb, board, board_temp, board_layers, design_power_budget, supply_current_budget, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Reset a parameter<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: reset_param [-quiet] [-verbose] &lt;name&gt;
		/// <br/>
		/// <para>
		/// Restores a user-definable configuration parameter that has been changed with the set_param<br/>
		/// command to its default value.<br/>
		/// You can use the report_param command to see which parameters are currently defined.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example restores the tcl.statsThreshold parameter to its default value:<br/>
		/// reset_param tcl.statsThreshold<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1507<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Parameter name</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>original value</returns>
		public VivadoTCL reset_param(String name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_param [-quiet] [-verbose] <name>
			this.Entry(_builder.reset_param(name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Reset current project<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: reset_project [-exclude_runs] [-exclude_ips] [-exclude_sim_runs] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Reset the current project to its starting condition, with source and constraint files, by cleaning<br/>
		/// out the various output files created during synthesis, simulation, implementation, and<br/>
		/// write_bitstream. Also resets the state of the project to the start of the design flow.<br/>
		/// TIP: Any user-defined Tcl variables that are in the global namespace (i.e. not in a project-specific<br/>
		/// namespace) are not reset or cleared by this command. Global variables are persistent with the invocation<br/>
		/// of Vivado and are only cleared when the Vivado Design Suite is closed. You can also use the unset<br/>
		/// command to expressly clear a specific Tcl variable.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1509<br/>
		/// </para>
		/// </summary>
		/// <param name="exclude_runs">(Optional) Do not reset runs</param>
		/// <param name="exclude_ips">(Optional) Do not reset ips</param>
		/// <param name="exclude_sim_runs">(Optional) Do not reset simulation runs</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL reset_project(bool? exclude_runs = null, bool? exclude_ips = null, bool? exclude_sim_runs = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_project [-exclude_runs] [-exclude_ips] [-exclude_sim_runs] [-quiet] [-verbose]
			this.Entry(_builder.reset_project(exclude_runs, exclude_ips, exclude_sim_runs, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Reset property on object(s)<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: reset_property [-quiet] [-verbose] &lt;property_name&gt; &lt;objects&gt;...
		/// <br/>
		/// <para>
		/// Restores the specified property to its default value on the specified object or objects. If no<br/>
		/// default is defined for the property, the property is unassigned on the specified object.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example sets the DOB_REG property on the specified Block RAM, and then resets<br/>
		/// the property:<br/>
		/// set_property DOB_REG 1 [get_cells usbEngine1/usbEngineSRAM/<br/>
		/// snoopyRam_reg_19]<br/>
		/// reset_property DOB_REG [get_cells usbEngine1/usbEngineSRAM/snoopyRam_reg_19]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1511<br/>
		/// </para>
		/// </summary>
		/// <param name="property_name">(Required) Name of property to reset</param>
		/// <param name="objects">(Required) Objects to set properties</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The value that was set if success, "" if failure</returns>
		public VivadoTCL reset_property(String property_name, TCLParameterList objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_property [-quiet] [-verbose] <property_name> <objects>...
			this.Entry(_builder.reset_property(property_name, objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Reset an existing run<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: reset_runs [-prev_step] [-from_step &lt;arg&gt;] [-quiet] [-verbose] &lt;runs&gt;
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1513<br/>
		/// </para>
		/// </summary>
		/// <param name="runs">(Required) Runs to modify</param>
		/// <param name="prev_step">(Optional) Reset last run step</param>
		/// <param name="from_step">(Optional) First Step to reset</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL reset_runs(String runs, bool? prev_step = null, String from_step = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_runs [-prev_step] [-from_step <arg>] [-quiet] [-verbose] <runs>
			this.Entry(_builder.reset_runs(runs, prev_step, from_step, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Reset an existing simulation run<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: reset_simulation [-mode &lt;arg&gt;] [-type &lt;arg&gt;] [-quiet] [-verbose] [&lt;simset&gt;]
		/// <br/>
		/// <para>
		/// Reset the current simulation to its starting condition, by cleaning out the various output files<br/>
		/// created during compilation and simulation for the specified simulation fileset.<br/>
		/// IMPORTANT! Local files will be removed from the project simulation folders without warning.<br/>
		/// The command returns nothing if successful, or an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example resets the post-synthesis timing simulation by removing files for the sim_2<br/>
		/// simset:<br/>
		/// reset_simulation -mode post-synthesis -type timing sim_2<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1514<br/>
		/// </para>
		/// </summary>
		/// <param name="mode">
		/// <para>
		/// (Optional)<br/>
		/// Remove generated data for the specified mode. Values:<br/>
		/// behavioral, post-synthesis, post-implementation Default:<br/>
		/// behavioral<br/>
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// (Optional)<br/>
		/// Remove generated data for the specified type. Applicable<br/>
		/// mode is post-synthesis or post-implementation. Values:<br/>
		/// functional, timing<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="simset">(Optional) Name of the simulation fileset to reset</param>
		public VivadoTCL reset_simulation(reset_simulation_mode? mode = null, reset_simulation_type? type = null, bool? quiet = null, bool? verbose = null, String simset = null)
		{
			// TCL Syntax: reset_simulation [-mode <arg>] [-type <arg>] [-quiet] [-verbose] [<simset>]
			this.Entry(_builder.reset_simulation(mode, type, quiet, verbose, simset));
			return this;
		}
		/// <summary>
		/// <para>
		/// Clear a SSN results set from memory<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: reset_ssn [-quiet] [-verbose] &lt;name&gt;
		/// <br/>
		/// <para>
		/// Clear the SSN results from the specified named result set.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example clears the specified results set from memory:<br/>
		/// reset_ssn SSN1<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1516<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name of the set of results</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL reset_ssn(String name, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_ssn [-quiet] [-verbose] <name>
			this.Entry(_builder.reset_ssn(name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Reset switching activity on specified objects<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: reset_switching_activity [-default] [-type &lt;args&gt;] [-hier] [-all] [-no_deassert_resets] [-quiet] [-verbose] [&lt;objects&gt;...]
		/// <br/>
		/// <para>
		/// Resets the attributes of the switching activity on specified nets, ports, pins, and cells in the<br/>
		/// design.<br/>
		/// The switching activity is defined using the set_switching_activity command. The current<br/>
		/// switching activity defined for a specific port, pin, net, or cell can be found by using the<br/>
		/// report_switching_activity command.<br/>
		/// Note: The reset_switching_activity is used to reset switching activity for specified objects. Use<br/>
		/// set_switching_activity -default_toggle_rate or -default_static_probability to<br/>
		/// change or reset the default values for the current design.<br/>
		/// This command operates silently and does not return direct feedback of its operation.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example resets the signal_rate and static probability value on all output ports:<br/>
		/// reset_switching_activity -default [all_outputs]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1518<br/>
		/// </para>
		/// </summary>
		/// <param name="default">(Optional) Reset default static probability and default toggle rate</param>
		/// <param name="type">
		/// <para>
		/// (Optional)<br/>
		/// Specify nodes in a specific category. List of valid type values:<br/>
		/// io_output, io_bidir_enable, register, lut_ram, lut, dsp,<br/>
		/// bram_enable, bram_wr_enable, gt_txdata, gt_rxdata.<br/>
		/// </para>
		/// </param>
		/// <param name="hier">
		/// <para>
		/// (Optional)<br/>
		/// Hierarchically resets the switching activity on a hierarchical<br/>
		/// cells provided as &lt;objects&gt;.<br/>
		/// </para>
		/// </param>
		/// <param name="all">(Optional) Reset switching activity on all nets</param>
		/// <param name="no_deassert_resets">
		/// <para>
		/// (Optional)<br/>
		/// A switch to undo the deassertion of resets via command<br/>
		/// set_switching_activity -deassert_resets<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">(Optional) Objects to reset switching activity on</param>
		public VivadoTCL reset_switching_activity(bool? @default = null, TCLParameterList type = null, bool? hier = null, bool? all = null, bool? no_deassert_resets = null, bool? quiet = null, bool? verbose = null, TCLParameterList objects = null)
		{
			// TCL Syntax: reset_switching_activity [-default] [-type <args>] [-hier] [-all] [-no_deassert_resets] [-quiet] [-verbose] [<objects>...]
			this.Entry(_builder.reset_switching_activity(@default, type, hier, all, no_deassert_resets, quiet, verbose, objects));
			return this;
		}
		/// <summary>
		/// <para>
		/// Reset target data for the specified source<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: reset_target [-quiet] [-verbose] &lt;name&gt; &lt;objects&gt;
		/// <br/>
		/// <para>
		/// Remove the current target data for the specified IP core. This deletes any files that were<br/>
		/// delivered during generation of the specified targets. This does not remove the core from the<br/>
		/// current project, but does remove the associated target data from its referenced location.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example resets the instantiation template for the specified IP core:<br/>
		/// reset_target instantiation_template [get_ips blk_mem*]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1521<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) List of targets to be reset, or 'all' to reset all generated targets</param>
		/// <param name="objects">(Required) The objects for which data needs to be reset</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL reset_target(String name, String objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_target [-quiet] [-verbose] <name> <objects>
			this.Entry(_builder.reset_target(name, objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Resets the timing information on the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: reset_timing [-invalid] [-clock_reservation] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Reset the timing data and constraints for the current design. Use this command to clear the<br/>
		/// current in-memory timing data and constraints, and force the timing engine to reevaluate the<br/>
		/// design comprehensively rather than iteratively.<br/>
		/// After clearing the constraints from the in-memory design, you must reload any needed<br/>
		/// constraints using the read_xdc command. The Vivado tool will not automatically reload the<br/>
		/// constraints.<br/>
		/// TIP: This command deletes the in-memory timing view, not the timing report. Use the<br/>
		/// delete_timing_results command to delete the reported timing information.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example clears the current timing data from memory, including any invalid timing<br/>
		/// constraints:<br/>
		/// reset_timing -invalid<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1523<br/>
		/// </para>
		/// </summary>
		/// <param name="invalid">
		/// <para>
		/// (Optional)<br/>
		/// Resets invalid timing constraints in addition to valid timing<br/>
		/// constraints.<br/>
		/// </para>
		/// </param>
		/// <param name="clock_reservation">
		/// <para>
		/// (Optional)<br/>
		/// Resets clock name reservations for auto-derived clocks in<br/>
		/// addition to valid timing constraints.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL reset_timing(bool? invalid = null, bool? clock_reservation = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: reset_timing [-invalid] [-clock_reservation] [-quiet] [-verbose]
			this.Entry(_builder.reset_timing(invalid, clock_reservation, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Resize net bus in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: resize_net_bus [-from &lt;arg&gt;] [-to &lt;arg&gt;] [-quiet] [-verbose] &lt;net_bus_name&gt;...
		/// <br/>
		/// <para>
		/// Resize an existing bus net, to grow the bus, shrink the bus, or renumber the current range of<br/>
		/// indexes. You can only do a single grow, shrink, or renumber operation with each command.<br/>
		/// • You can grow the bus by indicating a new range of indexes outside the current range of<br/>
		/// indexes. Growing the bus leaves existing bits connected as they currently are.<br/>
		/// • You can shrink the bus by indicating a new range of indexes inside the current range of<br/>
		/// indexes. Shrinking the bus, eliminates connections to removed bits, but leaves the remaining<br/>
		/// bits connected as they currently are.<br/>
		/// • You can renumber the current bus indexes by providing a new range of indexes with the same<br/>
		/// width as the current range. Renumbering bits changes bus bit numeric identifiers, but doesn't<br/>
		/// otherwise change connections.<br/>
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not<br/>
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made<br/>
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or<br/>
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*<br/>
		/// command.<br/>
		/// Note: Netlist editing is not allowed on the elaborated RTL design.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This command returns nothing if successful, and returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1525<br/>
		/// </para>
		/// </summary>
		/// <param name="net_bus_name">(Required) Name of the net bus to resize</param>
		/// <param name="from">(Optional) New starting bus index</param>
		/// <param name="to">(Optional) New ending bus index</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL resize_net_bus(TCLParameterList net_bus_name, String from = null, String to = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: resize_net_bus [-from <arg>] [-to <arg>] [-quiet] [-verbose] <net_bus_name>...
			this.Entry(_builder.resize_net_bus(net_bus_name, from, to, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Move, resize, add and remove Pblock site-range constraints<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: resize_pblock [-add &lt;args&gt;] [-remove &lt;args&gt;] [-from &lt;args&gt;] [-to &lt;args&gt;] [-replace] [-locs &lt;arg&gt;] [-quiet] [-verbose] &lt;pblock&gt;
		/// <br/>
		/// <para>
		/// Place, resize, move, or remove the specified Pblock. The Pblock must have been created using<br/>
		/// the create_pblock command.<br/>
		/// A Pblock consists of a group of cells that can be assigned to one or more independent or<br/>
		/// overlapping rectangles. Using the various options defined below, you can add sites to a rectangle,<br/>
		/// or remove sites from a rectangle, or define a new rectangle to be associated with an existing<br/>
		/// Pblock.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example resizes the Pblock by adding a range of SLICEs, and removing other<br/>
		/// SLICEs, but keeps all instances placed at their current location:<br/>
		/// resize_pblock block3 -add SLICE_X6Y67:SLICE_X11Y71 \<br/>
		/// -remove SLICE_X6Y71:SLICE_X7Y71 -locs keep_all<br/>
		/// This example create a Pblock region, and defines the Pblock area by adding a range of<br/>
		/// CLOCKREGIONs:<br/>
		/// create_pblock pblock_1<br/>
		/// resize_pblock pblock_1 -add {CLOCKREGION_X0Y10:CLOCKREGION_X1Y11}<br/>
		/// The following example moves the specified Pblock by adding a range of SLICEs, removing the<br/>
		/// existing range of SLICEs, and trims any placed logic that falls outside the new Pblock. Then it<br/>
		/// adds a new range of SLICEs and block ram to the specified Pblock in a second separate rectangle:<br/>
		/// resize_pblock block3 -add SLICE_X3Y8:SLICE_X10Y3 \<br/>
		/// -remove SLICE_X6Y67:SLICE_X11Y71 -locs trim<br/>
		/// resize_pblock block3 -add {SLICE_X6Y67:SLICE_X11Y71 \<br/>
		/// RAMB18_X0Y2:RAMB18_X1Y4}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1527<br/>
		/// </para>
		/// </summary>
		/// <param name="pblock">(Required) Pblock to resize</param>
		/// <param name="add">(Optional) Add site ranges(s)</param>
		/// <param name="remove">(Optional) Remove site ranges(s)</param>
		/// <param name="from">(Optional) Site range(s) to move</param>
		/// <param name="to">(Optional) Site range destination(s)</param>
		/// <param name="replace">(Optional) Remove all existing ranges</param>
		/// <param name="locs">(Optional) LOC treatment Default: keep_all</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL resize_pblock(String pblock, TCLParameterList add = null, TCLParameterList remove = null, TCLParameterList from = null, TCLParameterList to = null, bool? replace = null, String locs = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: resize_pblock [-add <args>] [-remove <args>] [-from <args>] [-to <args>] [-replace] [-locs <arg>] [-quiet] [-verbose] <pblock>
			this.Entry(_builder.resize_pblock(pblock, add, remove, from, to, replace, locs, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Resize pin bus in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: resize_pin_bus [-from &lt;arg&gt;] [-to &lt;arg&gt;] [-quiet] [-verbose] &lt;pin_bus_name&gt;...
		/// <br/>
		/// <para>
		/// Resize an existing bus pin, to grow the bus, shrink the bus, or renumber the current range of pin<br/>
		/// indexes. You can only do a single grow, shrink, or renumber operation with each command.<br/>
		/// • You can grow the bus by indicating a new range of pin indexes outside the current range of<br/>
		/// indexes. Growing the bus leaves existing pins connected as they currently are.<br/>
		/// • You can shrink the bus by indicating a new range of pin indexes inside the current range of<br/>
		/// indexes. Shrinking the bus, eliminates connections to removed bus pins, but leaves the<br/>
		/// remaining pins connected as they currently are.<br/>
		/// • You can renumber the current bus indexes by providing a new range of pin indexes with the<br/>
		/// same width as the current range. Renumbering pins changes the pin index, but does not<br/>
		/// otherwise change connections.<br/>
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not<br/>
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made<br/>
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or<br/>
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*<br/>
		/// command.<br/>
		/// Note: Netlist editing is not allowed on the elaborated RTL design.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This command returns nothing if successful, and returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates a blackbox cell, then creates a 24-bit bidirectional bus for the<br/>
		/// specified hierarchical cell, then resizes the bus pin to expand the width to 32-bits, then<br/>
		/// renumbers the index to include negative bus indexes:<br/>
		/// create_cell -reference dmaBlock -black_box usbEngine0/myDMA<br/>
		/// create_pin -direction INOUT -from 0 -to 23 usbEngine0/myDMA/dataBus<br/>
		/// resize_pin_bus -from 0 -to 31 usbEngine0/myDMA/dataBus<br/>
		/// resize_pin_bus -from -16 -to 15 usbEngine0/myDMA/dataBus<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1530<br/>
		/// </para>
		/// </summary>
		/// <param name="pin_bus_name">(Required) Name of the pin bus to resize</param>
		/// <param name="from">(Optional) New starting bus index</param>
		/// <param name="to">(Optional) New ending bus index</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL resize_pin_bus(TCLParameterList pin_bus_name, String from = null, String to = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: resize_pin_bus [-from <arg>] [-to <arg>] [-quiet] [-verbose] <pin_bus_name>...
			this.Entry(_builder.resize_pin_bus(pin_bus_name, from, to, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Resize port bus in the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: resize_port_bus [-from &lt;arg&gt;] [-to &lt;arg&gt;] [-quiet] [-verbose] &lt;port_bus_name&gt;...
		/// <br/>
		/// <para>
		/// Resize an existing bus port, to grow the bus, shrink the bus, or renumber the current range of<br/>
		/// port indexes. You can only do a single grow, shrink, or renumber operation with each command.<br/>
		/// • You can grow the bus by indicating a new range of port indexes outside the current range of<br/>
		/// indexes. Growing the bus leaves existing port indexes connected as they currently are.<br/>
		/// • You can shrink the bus by indicating a new range of port indexes inside the current range of<br/>
		/// indexes. Shrinking the bus, eliminates connections to removed bus ports, but leaves the<br/>
		/// remaining ports connected as they currently are.<br/>
		/// • You can renumber the current bus indexes by providing a new range of port indexes with the<br/>
		/// same width as the current range. Renumbering ports changes the port index, but does not<br/>
		/// otherwise change connections.<br/>
		/// Netlist editing changes the in-memory view of the netlist in the current design. It does not<br/>
		/// change the files in the source fileset, or change the persistent design on the disk. Changes made<br/>
		/// to the netlist may be saved to a design checkpoint using the write_checkpoint command, or<br/>
		/// may be exported to a netlist file such as Verilog, VHDL, or EDIF, using the appropriate write_*<br/>
		/// command.<br/>
		/// Note: Netlist editing is not allowed on the elaborated RTL design.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This command returns nothing if successful, and returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates a 32-bit output bus port, then renumbers the ports to include<br/>
		/// negative bus indexes, then shrinks the bus width from 32-bits to 16-bits:<br/>
		/// create_port -direction out -from 0 -to 31 outPorts<br/>
		/// resize_port_bus -from -16 -to 15 outPorts<br/>
		/// resize_port_bus -from -8 -to 7 outPorts<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1533<br/>
		/// </para>
		/// </summary>
		/// <param name="port_bus_name">(Required) Name of the port bus to resize</param>
		/// <param name="from">(Optional) New starting bus index</param>
		/// <param name="to">(Optional) New ending bus index</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL resize_port_bus(TCLParameterList port_bus_name, String from = null, String to = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: resize_port_bus [-from <arg>] [-to <arg>] [-quiet] [-verbose] <port_bus_name>...
			this.Entry(_builder.resize_port_bus(port_bus_name, from, to, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Rewind simulation to post loading state (as if design was reloaded), time is set to 0<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: restart [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Return the current simulation to its initial state, as if the design was reloaded, resetting the<br/>
		/// current simulation time to 0.<br/>
		/// The restart command retains breakpoints, Tcl forces, and settings in the waveform<br/>
		/// configuration window, but resets all simulation values, and clears all other Tcl commands.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example restarts the current simulation:<br/>
		/// restart<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1535<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>
		/// </returns>
		public VivadoTCL restart(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: restart [-quiet] [-verbose]
			this.Entry(_builder.restart(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Resume Activity Monitor runs after paused for the specified hardware HBM(s)<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: resume_hw_hbm_amon [-quiet] [-verbose] &lt;hw_objects&gt;
		/// <br/>
		/// <para>
		/// The resume_hw_hbm_amon command restarts a running HBM activity monitor in the Vivado<br/>
		/// hardware manager that has been previously paused using the pause_hw_hbm_amon command.<br/>
		/// This command returns nothing when successful, or returns an error when it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example restarts the HBM activity monitor for the associated HBM core:<br/>
		/// resume_hw_hbm_amon [get_hw_hbms *HBM_2]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1537<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_objects">(Required) hardware objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL resume_hw_hbm_amon(String hw_objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: resume_hw_hbm_amon [-quiet] [-verbose] <hw_objects>
			this.Entry(_builder.resume_hw_hbm_amon(hw_objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Route the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: route_design [-unroute] [-release_memory] [-nets &lt;args&gt;] [-physical_nets] [-pins &lt;arg&gt;] [-directive &lt;arg&gt;] [-tns_cleanup] [-no_timing_driven] [-preserve] [-delay] [-auto_delay] -max_delay &lt;arg&gt; -min_delay &lt;arg&gt; [-timing_summary] [-finalize] [-ultrathreads] [-eco] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Route the nets in the current design to complete logic connections on the target part.<br/>
		/// Predefined routing strategies can be quickly selected using the route_design -directive<br/>
		/// command, or specific route options can be configured to define your own routing strategy.<br/>
		/// Routing can be completed automatically with route_design, or can be completed iteratively<br/>
		/// using the various options of the route_design command to achieve route completion and<br/>
		/// timing closure. Iterative routing provides you some control over the routing process to route<br/>
		/// critical nets first and then route less critical nets, and to control the level of effort and the timing<br/>
		/// algorithms for these various route passes.<br/>
		/// Routing is one step of the complete design implementation process, which can be run<br/>
		/// automatically through the use of the launch_runs command when running the Vivado tools in<br/>
		/// Project Mode.<br/>
		/// In Non-Project Mode, the implementation process must be run manually with the individual<br/>
		/// commands: opt_design, place_design, phys_opt_design, power_opt_design, and<br/>
		/// route_design. Refer to the Vivado Design Suite User Guide: Design Flows Overview (UG892) for a<br/>
		/// complete description of Project Mode and Non-Project Mode.<br/>
		/// TIP: The route_design can be multi-threaded to speed the process. Refer to the set_param<br/>
		/// command for more information on setting the general.maxThreads parameter.<br/>
		/// Both placement and routing can be completed incrementally, based on prior results stored in a<br/>
		/// Design Checkpoint file (DCP), using the incremental implementation flow. Refer to the<br/>
		/// read_checkpoint command, or to Vivado Design Suite User Guide: Implementation (UG904) for<br/>
		/// more information on incremental place and route.<br/>
		/// This command requires a placed design, and it is recommended that you have optimized the<br/>
		/// design with opt_design prior to placement.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// Route the entire design, and direct the router to try multiple algorithms for improving critical<br/>
		/// path delay:<br/>
		/// route_design -directive Explore<br/>
		/// The following example routes the set of timing critical nets, $criticalNets, to the shortest<br/>
		/// interconnect delay, marks the nets as fixed using the IS_ROUTE_FIXED property, and then routes<br/>
		/// the rest of the design using a low effort directive for fast results:<br/>
		/// route_design -delay -nets $criticalNets<br/>
		/// set_property IS_ROUTE_FIXED 1 $criticalNets<br/>
		/// route_design -directive RuntimeOptimized<br/>
		/// Route the specified nets using the fastest runtime:<br/>
		/// route_design -nets [get_nets ctrl0/ctr*]<br/>
		/// Route the specified nets to get the shortest interconnect delays:<br/>
		/// route_design -nets [get_nets ctrl0/ctr*] -delay<br/>
		/// Route to the specified pins:<br/>
		/// route_design -pins [get_pins ctrl0/reset_reg/D ctrl0/ram0/ADDRARDADDR]<br/>
		/// Route to a particular pin, try to achieve less than 500 ps delay:<br/>
		/// route_design -pins [get_pins ctrl0/reset_reg/D] -max_delay 500<br/>
		/// Route to a particular pin, try to achieve more than 200 ps delay:<br/>
		/// route_design -pins [get_pins ctrl0/ram0/ADDRARDADDR] -min_delay 200<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1539<br/>
		/// </para>
		/// </summary>
		/// <param name="max_delay">
		/// <para>
		/// (Required)<br/>
		/// Use with -pins option to specify the max_delay constraint on<br/>
		/// the pins.When specified -delay is implicit.<br/>
		/// </para>
		/// </param>
		/// <param name="min_delay">
		/// <para>
		/// (Required)<br/>
		/// Use with -pins option to specify the max_delay constraint on<br/>
		/// the pins.When specified -delay is implicit.<br/>
		/// </para>
		/// </param>
		/// <param name="unroute">
		/// <para>
		/// (Optional)<br/>
		/// Unroute whole design or the given nets/pins if used with -<br/>
		/// nets or -pins.<br/>
		/// </para>
		/// </param>
		/// <param name="release_memory">(Optional) Release Router memory. Not compatible with any other options.</param>
		/// <param name="nets">(Optional) Operate on the given nets.</param>
		/// <param name="physical_nets">(Optional) Operate on all physical nets.</param>
		/// <param name="pins">(Optional) Operate on the given pins.</param>
		/// <param name="directive">
		/// <para>
		/// (Optional)<br/>
		/// Mode of behavior (directive) for this command. Please refer<br/>
		/// to Arguments section of this help for values for this option.<br/>
		/// Default: Default<br/>
		/// </para>
		/// </param>
		/// <param name="tns_cleanup">(Optional) Do optional TNS clean up.</param>
		/// <param name="no_timing_driven">(Optional) Do not run in timing driven mode.</param>
		/// <param name="preserve">(Optional) Preserve existing routing.</param>
		/// <param name="delay">(Optional) Use with -nets or -pins option to route in delay driven mode.</param>
		/// <param name="auto_delay">(Optional) Use with -nets or -pins option to route in constraint driven mode.</param>
		/// <param name="timing_summary">(Optional) Enable post-router signoff timing summary.</param>
		/// <param name="finalize">(Optional) finalize route_design in interactive mode.</param>
		/// <param name="ultrathreads">(Optional) Enable Turbo mode routing.</param>
		/// <param name="eco">
		/// <para>
		/// (Optional)<br/>
		/// runs incremental router if there was eco modification on<br/>
		/// routed netlist.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL route_design(String max_delay, String min_delay, bool? unroute = null, bool? release_memory = null, TCLParameterList nets = null, bool? physical_nets = null, String pins = null, String directive = null, bool? tns_cleanup = null, bool? no_timing_driven = null, bool? preserve = null, bool? delay = null, bool? auto_delay = null, bool? timing_summary = null, bool? finalize = null, bool? ultrathreads = null, bool? eco = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: route_design [-unroute] [-release_memory] [-nets <args>] [-physical_nets] [-pins <arg>] [-directive <arg>] [-tns_cleanup] [-no_timing_driven] [-preserve] [-delay] [-auto_delay] -max_delay <arg> -min_delay <arg> [-timing_summary] [-finalize] [-ultrathreads] [-eco] [-quiet] [-verbose]
			this.Entry(_builder.route_design(max_delay, min_delay, unroute, release_memory, nets, physical_nets, pins, directive, tns_cleanup, no_timing_driven, preserve, delay, auto_delay, timing_summary, finalize, ultrathreads, eco, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Run the simulation for the specified time<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: run [-all] [-quiet] [-verbose] [&lt;time&gt;] [&lt;unit&gt;]
		/// <br/>
		/// <para>
		/// Run the current simulation from the current time to the specified time, or until the simulation<br/>
		/// stops.<br/>
		/// A running simulation can be stopped at a predetermined time, at a specific breakpoint in the HDL<br/>
		/// source code, by encountering a TRUE condition, by evaluating the circuit until there are no<br/>
		/// remaining events, or by encountering a runtime error such as an out-of-bounds value.<br/>
		/// The run command instructs an existing simulation to run for a specified length of time, or until<br/>
		/// there are no remaining events. The time is specified as a floating point number indicating a<br/>
		/// period of time in the current simulation units, or in the specified units.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example runs an existing simulation for the specified simulation run time, using the<br/>
		/// default units (ns):<br/>
		/// run 1000<br/>
		/// The following example runs an existing simulation for 300 microseconds (us):<br/>
		/// run 300 us<br/>
		/// The following example runs the current simulation until no event is left in the event queue, a<br/>
		/// breakpoint or valid condition is met, or a simulation runtime error occurs:<br/>
		/// run -all<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1545<br/>
		/// </para>
		/// </summary>
		/// <param name="all">
		/// <para>
		/// (Optional)<br/>
		/// Runs simulation till a breakpoint, an exception or no events<br/>
		/// left in the queue<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="time">(Optional) Length of simulation time</param>
		/// <param name="unit">(Optional) Unit for time from the following time units: fs, ps, ns, us, ms, sec</param>
		public VivadoTCL run(bool? all = null, bool? quiet = null, bool? verbose = null, String time = null, String unit = null)
		{
			// TCL Syntax: run [-all] [-quiet] [-verbose] [<time>] [<unit>]
			this.Entry(_builder.run(all, quiet, verbose, time, unit));
			return this;
		}
		/// <summary>
		/// <para>
		/// Run hardware AXI read/write transaction(s)and update transaction status in hw_axi object..<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: run_hw_axi [-queue] [-quiet] [-verbose] &lt;hw_axi_txns&gt;...
		/// <br/>
		/// <para>
		/// Run the AXI transactions defined on the specified JTAG to AXI Master core.<br/>
		/// AXI transactions are created with the create_hw_axi_txns command.<br/>
		/// Run the specified hardware AXI read/write transactions on the AXI bus, and update the<br/>
		/// transaction status on the associated hw_axi object.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1547<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_axi_txns">(Required) hardware AXI Transaction object to execute on the AXI bus.</param>
		/// <param name="queue">(Optional) Queue Transaction. Default: 0</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL run_hw_axi(TCLParameterList hw_axi_txns, bool? queue = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: run_hw_axi [-queue] [-quiet] [-verbose] <hw_axi_txns>...
			this.Entry(_builder.run_hw_axi(hw_axi_txns, queue, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Enable Activity Monitor runs for the specified hardware HBM(s)<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: run_hw_hbm_amon [-quiet] [-verbose] &lt;hw_objects&gt;
		/// <br/>
		/// <para>
		/// The HBM activity monitor (amon) can be used to gain real-time access to performance<br/>
		/// monitoring and temperature sensors certain Xilinx® UltraScale+ devices that include an<br/>
		/// integrated High-Bandwidth Memory (HBM) controller. Refer to the LogiCore IP Product Guide:<br/>
		/// AXI High Bandwidth Memory Controller (PG276) for more information on this core. The HBM<br/>
		/// controller and memory stacks contain both performance counters and temperature sensors that<br/>
		/// can be accessed through the HBM activity monitor from within the Xilinx Vivado hardware<br/>
		/// manager. The HBM activity monitor displays read, write, and overall throughput of data, as well<br/>
		/// as the device temperature. The activity monitor displays, captures, and exports data to a CSV file<br/>
		/// when it is running.<br/>
		/// The run_hw_hbm_amon command runs an HBM activity monitor in the Vivado hardware<br/>
		/// manager that has been previously configured using the add_hw_hbm_pc command.<br/>
		/// This command returns the file path and name of a CSV file the collected data will be written to,<br/>
		/// or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example runs the HBM activity monitor for the associated HBM core:<br/>
		/// run_hw_hbm_amon [get_hw_hbms *HBM_2]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1549<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_objects">(Required) hardware objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL run_hw_hbm_amon(String hw_objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: run_hw_hbm_amon [-quiet] [-verbose] <hw_objects>
			this.Entry(_builder.run_hw_hbm_amon(hw_objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Arm hardware ILAs.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: run_hw_ila [-trigger_now] [-compile_only] [-file &lt;arg&gt;] [-force] [-quiet] [-verbose] [&lt;hw_ilas&gt;...]
		/// <br/>
		/// <para>
		/// Arm triggers and run the specified hardware ILA debug cores on the current hardware device.<br/>
		/// The Integrated Logic Analyzer (ILA) debug core lets you perform in-system debug of<br/>
		/// implemented designs, or design bitstreams, on a programmed Xilinx FPGA. The ILA core includes<br/>
		/// many advanced features of modern logic analyzers, including boolean trigger equations, and edge<br/>
		/// transition triggers. You can use the ILA core to probe specific signals of the design, to trigger on<br/>
		/// programmed hardware events, and capture data samples from the Xilinx FPGA in real-time. Refer<br/>
		/// to LogiCORE IP Integrated Logic Analyzer (PG172) for details of the ILA core.<br/>
		/// You can add ILA debug cores into the RTL source files of a design, or in the synthesized netlist<br/>
		/// using the create_debug_core command. Refer to the Vivado Design Suite User Guide: Vivado<br/>
		/// Programming and Debugging (UG908) for more information on adding debug cores and signal<br/>
		/// probes to the design.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Debug cores and probes are written to a probes file (.ltx) using the write_debug_probes<br/>
		/// command, and associated with the hardware device along with the bitstream file (.bit) using<br/>
		/// the PROBES.FILE and PROGRAM.FILE properties of the hw_device object. The hardware device<br/>
		/// is programmed using the program_hw_devices command. The ILA debug cores in the design<br/>
		/// are accessible from the Hardware Manager using the get_hw_ilas command. The debug<br/>
		/// probes assigned to the ILA debug cores can be returned with the get_hw_probes command.<br/>
		/// The steps to debug your design in hardware using an ILA debug core are:<br/>
		/// 1. Connect to the hardware server and target using connect_hw_server and<br/>
		/// open_hw_target.<br/>
		/// 2. Program the FPGA with the bitstream (.bit) and probes (.ltx) files using<br/>
		/// program_hw_devices.<br/>
		/// 3. Set up the ILA debug core trigger events and data capture controls using set_property to<br/>
		/// configure properties of the ILA.<br/>
		/// 4. Arm the ILA debug core triggers on the Xilinx FPGA using run_hw_ila. When a trigger<br/>
		/// event occurs, or the capture condition is met, the ILA capture buffer is filled.<br/>
		/// 5. Uploaded sampled data from the hw_device into a Vivado logic analyzer hw_ila_data object<br/>
		/// using upload_hw_ila_data.<br/>
		/// 6. View the captured data in the Waveform window of the Vivado logic analyzer feature using<br/>
		/// display_hw_ila_data.<br/>
		/// You can set up an ILA debug core to trigger on specific events or conditions at the debug probes,<br/>
		/// and to capture data under specific conditions, using CONTROL properties on the hw_ila object.<br/>
		/// You set these properties with the set_property command. Refer to the Vivado Design Suite<br/>
		/// User Guide: Vivado Programming and Debugging (UG908) for more information on setting<br/>
		/// properties to configure debug cores and signal probes to monitor the design.<br/>
		/// RECOMMENDED: The Vivado IDE provides a graphical interface to configure hw_ila and hw_probes for<br/>
		/// trigger and capture. You can use the Vivado IDE to see the properties needed to configure and run the<br/>
		/// hw_ila.<br/>
		/// The specific properties on the hw_ila you can use to configure a debug core include the<br/>
		/// following:<br/>
		/// • CONTROL.DATA_DEPTH - Defaults to the MAX_DATA_DEPTH of the ILA debug core, which<br/>
		/// was set when the debug core was created or inserted into the design. The data depth defines<br/>
		/// the number of data samples the hw_ila object can capture in a data window. Set the data<br/>
		/// depth as an integer which is a power of two, from 1 to the maximum data depth<br/>
		/// (MAX_DATA_DEPTH) of the hw_ila.<br/>
		/// Note: The value of DATA_DEPTH is related to CONTROL.WINDOW_COUNT by the equation:<br/>
		/// DATA_DEPTH * WINDOW_COUNT = MAX_DATA_DEPTH<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// • CONTROL.WINDOW_COUNT - Lets you divide the MAX_DATA_DEPTH of the ILA core into<br/>
		/// a number of data windows to store sample data from multiple trigger events. In the case of 10<br/>
		/// data windows for example, the first window will be filled at the first trigger event, and each<br/>
		/// subsequent window will be filled upon subsequent triggering events or capture conditions.<br/>
		/// • CONTROL.TRIGGER_POSITION - An integer value related to the DATA_DEPTH. Positions the<br/>
		/// trigger event in the sample data buffer. For a DATA_DEPTH of 1024, position 0 refers to the<br/>
		/// first (or left-most) data buffer and 1023 refers to the last (or right-most) data buffer. The<br/>
		/// TRIGGER_POSITION lets you capture sample data ahead of the trigger event. For instance,<br/>
		/// with a DATA_DEPTH of 256, a TRIGGER_POSITION of 100 allows you to capture 100 data<br/>
		/// samples ahead of the trigger, and 155 data samples at and after the trigger event.<br/>
		/// Note: In the case of run_hw_ila -trigger_now 1, the TRIGGER_POSITION merely positions the<br/>
		/// trigger mark in the Vivado logic analyzer waveform window. Because the trigger event is immediate,<br/>
		/// there is no time to capture data samples ahead of the trigger.<br/>
		/// • CONTROL.TRIGGER_MODE - Valid values include:<br/>
		/// ○ BASIC_ONLY - The trigger condition is the result of a Boolean equation using the<br/>
		/// TRIGGER_CONDITION to evaluate the values on each of the associated ILA probes.<br/>
		/// ○ BASIC_OR_TRIG_IN - The ILA core is triggered by a Boolean equation considering probe<br/>
		/// values, or by the TRIG_IN port on the core.<br/>
		/// ○ ADVANCED_ONLY - The ILA core is configured to have advanced trigger capabilities<br/>
		/// defined in a user-defined Trigger State Machine (TSM).<br/>
		/// ○ ADVANCED_OR_TRIG_IN - The ILA core is triggered by the TSM or by the TRIG_IN port<br/>
		/// on the core.<br/>
		/// ○ TRIG_IN_ONLY - The ILA core is triggered only by the TRIG_IN port on the core.<br/>
		/// • CONTROL.TRIGGER_CONDITION - Defines a Boolean equation which evaluates comparators<br/>
		/// on participating probes on the ILA debug core. When the condition evaluates to true, the<br/>
		/// BASIC trigger mode is satisfied. Valid values include:<br/>
		/// ○ AND - Trigger condition is "true" if all participating probe comparators evaluate "true",<br/>
		/// otherwise trigger condition is "false".<br/>
		/// ○ NAND - Trigger condition is "true" if at least one participating probe comparator evaluates<br/>
		/// "false", otherwise trigger condition is "false".<br/>
		/// ○ OR - Trigger condition is "true" if at least one participating probe comparator evaluates<br/>
		/// "true", otherwise trigger condition is "false".<br/>
		/// ○ NOR - Trigger condition is "true" if all participating probe comparators evaluate "false",<br/>
		/// otherwise trigger condition is "false".<br/>
		/// Note: The evaluation of the probes participating in the trigger condition is determined by the<br/>
		/// TRIGGER_COMPARE_VALUE property assigned to the hw_probe object, as returned by<br/>
		/// get_hw_probes. If the TRIGGER_COMPARE_VALUE is 'X' then it is not participating in the trigger<br/>
		/// condition.<br/>
		/// • CONTROL.TSM_FILE - Specify the path to a file defining a Trigger Finite State Machine (TSM)<br/>
		/// to be used for advanced trigger handling.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// • CONTROL.TRIG_OUT_MODE - Used to transition the TRIG_OUT port on the ILA core to be<br/>
		/// used to drive the TRIG_IN port on other ILA cores. Valid values include:<br/>
		/// ○ DISABLED - Disable the TRIG_OUT port on the ILA core.<br/>
		/// ○ TRIGGER_ONLY - Transition the TRIG_OUT port when the trigger conditions have been<br/>
		/// satisfied.<br/>
		/// ○ TRIG_IN_ONLY - Transition the TRIG_OUT when the TRIG_IN signal transitions. Use this to<br/>
		/// pass the trigger event along a chain of ILA cores.<br/>
		/// ○ TRIGGER_OR_TRIG_IN - Transition the TRIG_OUT when either the trigger conditions are<br/>
		/// satisfied, or the TRIG_IN transitions.<br/>
		/// • CONTROL.CAPTURE_MODE - Valid values include ALWAYS or BASIC. Capture and store a<br/>
		/// data sample on the debug core ALWAYS during a given clock cycle, or only if the<br/>
		/// CAPTURE_CONDITION evaluates to "true" (BASIC).<br/>
		/// • CONTROL.CAPTURE_CONDITION - Defines a Boolean equation for participating probe<br/>
		/// comparators on the ILA debug core that must evaluate to TRUE to meet the data capture<br/>
		/// condition. When the capture condition evaluates to true, the BASIC capture mode is satisfied.<br/>
		/// Valid values include:<br/>
		/// ○ AND - Capture condition is "true" if all participating probe comparators evaluate "true",<br/>
		/// otherwise capture condition is "false".<br/>
		/// ○ NAND - Capture condition is "true" if at least one participating probe comparator evaluates<br/>
		/// "false", otherwise capture condition is "false".<br/>
		/// ○ OR - Capture condition is "true" if at least one participating probe comparator evaluates<br/>
		/// "true", otherwise capture condition is "false".<br/>
		/// ○ NOR - Capture condition is "true" if all participating probe comparators evaluate "false",<br/>
		/// otherwise capture condition is "false".<br/>
		/// Note: The evaluation of the probes participating in the capture condition is determined by the<br/>
		/// CAPTURE_COMPARE_VALUE property assigned to the hw_probe object, as returned by<br/>
		/// get_hw_probes. If the CAPTURE_COMPARE_VALUE is 'X' then it is not participating in the trigger<br/>
		/// condition.<br/>
		/// TIP: There are other properties on the ILA core that also determine the operation of the core, but they are<br/>
		/// not user-configurable.<br/>
		/// With the ILA core configured, you can use the run_hw_ila command to arm the ILA cores on<br/>
		/// the target part. When this command is run, the trigger configurations defined in the hw_ila and<br/>
		/// hw_probe objects are written to the target Xilinx FPGA (hw_device) and arms the ILA core or<br/>
		/// cores on the device.<br/>
		/// With the hw_ila armed and running, the wait_on_hw_ila command stops your Tcl script to<br/>
		/// wait for the data sample buffers to be populated with captured data. When the memory of the<br/>
		/// ILA core is full on the physical hw_device, the wait_on_hw_ila command returns, and your Tcl<br/>
		/// script resumes.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// You can use upload_hw_ila_data to upload the captured data from the physical memory of<br/>
		/// the hw_device into a hw_ila_data object in the Vivado logic analyzer. Then view the ILA data in<br/>
		/// the waveform window of the Vivado logic analyzer using display_hw_ila_data, and write<br/>
		/// the data for use in external tools using the write_hw_ila_data command.<br/>
		/// You can also immediately trigger the probes on the hw_device using the -trigger_now option,<br/>
		/// to capture data from the device right away, rather than waiting for trigger events or capture<br/>
		/// conditions to be met over time.<br/>
		/// You can use reset_hw_ila to restore the CONTROL properties of the ILA debug core to their<br/>
		/// default setting, and reset the probe comparator values to 'X'.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1551<br/>
		/// </para>
		/// </summary>
		/// <param name="trigger_now">(Optional) Trigger and capture immediately.</param>
		/// <param name="compile_only">(Optional) Test only compile trigger state machine file but do not upload.</param>
		/// <param name="file">(Optional) Trigger at startup file name. Command will not arm ILA core.</param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_ilas">(Optional) hardware ILAs Default: Current hardware ILA</param>
		public VivadoTCL run_hw_ila(bool? trigger_now = null, bool? compile_only = null, String file = null, bool? force = null, bool? quiet = null, bool? verbose = null, TCLParameterList hw_ilas = null)
		{
			// TCL Syntax: run_hw_ila [-trigger_now] [-compile_only] [-file <arg>] [-force] [-quiet] [-verbose] [<hw_ilas>...]
			this.Entry(_builder.run_hw_ila(trigger_now, compile_only, file, force, quiet, verbose, hw_ilas));
			return this;
		}
		/// <summary>
		/// <para>
		/// Run hardware SIO scans.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: run_hw_sio_scan [-quiet] [-verbose] &lt;hw_sio_scans&gt;
		/// <br/>
		/// <para>
		/// Run the specified serial I/O analyzer link scan.<br/>
		/// To analyze the margin of a given link, it is often helpful to run a scan of the link using the<br/>
		/// specialized Eye Scan hardware of Xilinx UltraScale devices or 7 series FPGAs. The Vivado serial<br/>
		/// I/O analyzer feature lets you to create, run, and save link scans.<br/>
		/// This command creates and returns a link scan object that you can use with the<br/>
		/// run_hw_sio_scan command to run analysis on the specified links, or GT receivers. You can<br/>
		/// also save the scan to disk using the write_hw_sio_scan command.<br/>
		/// This command run analysis on the specified scan objects. If running in a Tcl script, you can<br/>
		/// suspend the script while the scan completes using the wait_on_hw_sio_scan command. You<br/>
		/// can stop a running scan using the stop_hw_sio_scan command.<br/>
		/// You can save the scan to disk using the write_hw_sio_scan command.<br/>
		/// You can remove the created scan object using remove_hw_sio_scan.<br/>
		/// This command returns the hw_sio_scan object, or returns an error if the command fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1557<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_sio_scans">(Required) hardware SIO scans</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL run_hw_sio_scan(String hw_sio_scans, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: run_hw_sio_scan [-quiet] [-verbose] <hw_sio_scans>
			this.Entry(_builder.run_hw_sio_scan(hw_sio_scans, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Run hardware SIO sweeps.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: run_hw_sio_sweep [-quiet] [-verbose] &lt;hw_sio_sweeps&gt;
		/// <br/>
		/// <para>
		/// Run a serial I/O analyzer link sweep scan to run multiple scans across a range of values.<br/>
		/// To analyze the margin of a given link, it is often helpful to run a scan of the link using the<br/>
		/// specialized features of Xilinx UltraScale devices or 7 series FPGAs. It can also be helpful to run<br/>
		/// multiple scans on a the link with different configuration settings for the GTs. This can help you<br/>
		/// determine which settings are best for your design. The Vivado serial I/O analyzer feature enables<br/>
		/// you to define, run, and save link sweeps, or collections of link scans run across a range of values.<br/>
		/// This command run analysis on the specified sweep scan objects. If running in a Tcl script, you can<br/>
		/// suspend the script while the sweep scan completes using the wait_on_hw_sio_sweep<br/>
		/// command. You can stop a running sweep scan using the stop_hw_sio_sweep command.<br/>
		/// You can save the sweep scan to disk using the write_hw_sio_sweep command.<br/>
		/// You can remove the created scan object using remove_hw_sio_sweep.<br/>
		/// This command returns the hw_sio_sweep object, or returns an error if the command fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1559<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_sio_sweeps">(Required) hardware SIO sweeps</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL run_hw_sio_sweep(String hw_sio_sweeps, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: run_hw_sio_sweep [-quiet] [-verbose] <hw_sio_sweeps>
			this.Entry(_builder.run_hw_sio_sweep(hw_sio_sweeps, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// change to a stable state of a specified transition<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: run_state_hw_jtag [-state &lt;args&gt;] [-quiet] [-verbose] &lt;stable_state&gt;
		/// <br/>
		/// <para>
		/// Transition the hw_jtag object of the current hardware target to the specified TAP stable state.<br/>
		/// A hw_jtag object is created by the Hardware Manager feature of the Vivado Design Suite when a<br/>
		/// hardware target is opened in JTAG mode using the open_hw_target -jtag_mode command.<br/>
		/// The run_state_hw_jtag command specifies:<br/>
		/// • An ending or target TAP stable state to transition to.<br/>
		/// • An optional state path list to transition through to get from the current state to the target<br/>
		/// state.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// If an optional -state path list is defined, then the state list must contain all states needed to<br/>
		/// reach the stable state, or the command will return an error. If no state path list is defined, then<br/>
		/// the command will transition from the current state to the target state according to the state<br/>
		/// transition paths defined in the following table:<br/>
		/// Current Target State Transition Path<br/>
		/// State State<br/>
		/// DRPAUSE RESET DRPAUSE -&gt; DREXIT2 -&gt; DRUPDATE -&gt; DRSELECT -&gt;<br/>
		/// IRSELECT-&gt; RESET<br/>
		/// DRPAUSE IDLE DRPAUSE -&gt; DREXIT2 -&gt; DRUPDATE -&gt; IDLE<br/>
		/// DRPAUSE DRPAUSE DRPAUSE -&gt; DREXIT2 -&gt; DRUPDATE -&gt; DRSELECT -&gt;<br/>
		/// DRCAPTURE -&gt; DREXIT1 -&gt; DRPAUSE<br/>
		/// DRPAUSE IRPAUSE DRPAUSE -&gt; DREXIT2 -&gt; DRUPDATE -&gt; DRSELECT -&gt;<br/>
		/// IRSELECT -&gt; IRCAPTURE -&gt; IREXIT12 -&gt; IRPAUSE<br/>
		/// IDLE RESET IDLE -&gt; DRSELECT -&gt; IRSELECT -&gt; RESET<br/>
		/// IDLE IDLE IDLE<br/>
		/// IDLE DRPAUSE IDLE -&gt; DRSELECT -&gt; DRCAPTURE -&gt; DREXIT1 -&gt;<br/>
		/// DRPAUSE<br/>
		/// IDLE IRPAUSE IDLE -&gt; DRPAUSE -&gt; IRSELECT -&gt;IRCAPTURE -&gt;<br/>
		/// IREXIT1 -&gt; IRPAUSE<br/>
		/// IRPAUSE RESET IRPAUSE -&gt; IREXIT2 -&gt; IRUPDATE -&gt; DRSELECT -&gt;<br/>
		/// IRSELECT -&gt; RESET<br/>
		/// IRPAUSE IDLE IRPAUSE -&gt; IREXIT2 -&gt; IRUPDATE -&gt; IDLE<br/>
		/// IRPAUSE DRPAUSE IRPAUSE -&gt; IREXIT2 -&gt; IRUPDATE -&gt; DRSELECT -&gt;<br/>
		/// DRCAPTURE -&gt; DREXIT1 -&gt; DRPAUSE<br/>
		/// IRPAUSE IRPAUSE IRPAUSE -&gt; IREXIT2 -&gt; IRUPDATE -&gt; DRSELECT -&gt;<br/>
		/// IRSELECT -&gt; IRCAPTURE -&gt; IREXIT1 -&gt; IRPAUSE<br/>
		/// RESET RESET RESET<br/>
		/// RESET IDLE RESET -&gt; IDLE<br/>
		/// RESET DRPAUSE RESET -&gt; IDLE -&gt; DRSELECT -&gt; DRCAPTURE -&gt;<br/>
		/// DREXIT1 -&gt; DRPAUSE<br/>
		/// RESET IRPAUSE RESET -&gt; IDLE -&gt; DRSELECT -&gt; IRSELECT -&gt;<br/>
		/// IRCAPTURE -&gt; IREXIT1 -&gt; IRPAUSE<br/>
		/// This command returns the target stable state when successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1561<br/>
		/// </para>
		/// </summary>
		/// <param name="stable_state">
		/// <para>
		/// (Required)<br/>
		/// valid stable_state - valid stable states IDLE, RESET, IRPAUSE,<br/>
		/// and DRPAUSE<br/>
		/// </para>
		/// </param>
		/// <param name="state">(Optional) valid state path sequence to stable_state</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>hardware JTAG</returns>
		public VivadoTCL run_state_hw_jtag(String stable_state, TCLParameterList state = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: run_state_hw_jtag [-state <args>] [-quiet] [-verbose] <stable_state>
			this.Entry(_builder.run_state_hw_jtag(stable_state, state, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Forces IEEE 1149.1 TAP state machine to a stable state for a specified wait period<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: runtest_hw_jtag [-wait_state &lt;arg&gt;] [-end_state &lt;arg&gt;] [-sec &lt;arg&gt;] [-max_wait &lt;arg&gt;] [-tck &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Specify a wait operation for the hw_jtag object state machine which defines:<br/>
		/// • Which TAP stable state to go to perform the wait operation.<br/>
		/// • A wait time expressed as:<br/>
		/// ○ 'n' TCK cycles, where 'n' is a 32-bit unsigned decimal number.<br/>
		/// ○ A minimum and optionally maximum time in seconds to stay in the wait state, with<br/>
		/// min/max times specified as unsigned integers or real numbers.<br/>
		/// • The TAP stable state to go after the wait operation has completed.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The default values for -wait_state and -end_state are IDLE. If a non-IDLE wait_state or<br/>
		/// end_state are defined, then the hw_jtag object will first transition to the specified wait_state<br/>
		/// before starting the wait operation. Once the wait time has elapsed, the hw_jtag object transitions<br/>
		/// to the specified end_state. When the wait_state and/or end_state are specified by the<br/>
		/// runtest_hw_jtag command, subsequent commands will use the same wait_state/end_state<br/>
		/// unless they are changed.<br/>
		/// This command returns the end stable state, or returns an error if it fails.<br/>
		/// Note: If the command cannot meet the wait time specification, then it will raise an exception that can be<br/>
		/// trapped by the Tcl catch command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1564<br/>
		/// </para>
		/// </summary>
		/// <param name="wait_state">
		/// <para>
		/// (Optional)<br/>
		/// valid stable_state - valid stable states IDLE, RESET, IRPAUSE,<br/>
		/// and DRPAUSE<br/>
		/// </para>
		/// </param>
		/// <param name="end_state">
		/// <para>
		/// (Optional)<br/>
		/// valid stable_state - valid stable states IDLE, RESET, IRPAUSE,<br/>
		/// and DRPAUSE<br/>
		/// </para>
		/// </param>
		/// <param name="sec">(Optional) Number of seconds to wait in wait_state</param>
		/// <param name="max_wait">(Optional) Maximum Number of seconds to wait in wait_state - max timeout</param>
		/// <param name="tck">
		/// <para>
		/// (Optional)<br/>
		/// Number of TCK cycles to wait in wait_state Default: Number<br/>
		/// of TCK cycles to wait in wait_state<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL runtest_hw_jtag(String wait_state = null, String end_state = null, Int32? sec = null, Int32? max_wait = null, Int32? tck = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: runtest_hw_jtag [-wait_state <arg>] [-end_state <arg>] [-sec <arg>] [-max_wait <arg>] [-tck <arg>] [-quiet] [-verbose]
			this.Entry(_builder.runtest_hw_jtag(wait_state, end_state, sec, max_wait, tck, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Save an existing IP subsystem design to disk file.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: save_bd_design [-quiet] [-verbose] [&lt;name&gt;]
		/// <br/>
		/// <para>
		/// Saves any changes to the current or specified IP subsystem design in the IP integrator of the<br/>
		/// Vivado Design Suite.<br/>
		/// This command returns TCL_OK if it is successful, or TCL_ERROR if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example saves the current IP subsystem design in the current project:<br/>
		/// save_bd_design<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1567<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="name">(Optional) Name of design to save.</param>
		/// <returns>TCL_OK, TCL_ERROR if failed.</returns>
		public VivadoTCL save_bd_design(bool? quiet = null, bool? verbose = null, String name = null)
		{
			// TCL Syntax: save_bd_design [-quiet] [-verbose] [<name>]
			this.Entry(_builder.save_bd_design(quiet, verbose, name));
			return this;
		}
		/// <summary>
		/// <para>
		/// Save a copy of the existing IP subsystem design to specified disk file with a different name.<br/>
		/// Generated output products will not be saved.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: save_bd_design_as [-dir &lt;arg&gt;] [-ignore_comments] [-force] [-quiet] [-verbose] [&lt;name&gt;]
		/// <br/>
		/// <para>
		/// Save a copy of an existing block design from the IP integrator to a new location, or with a<br/>
		/// different name. The generated output products of the block design will not be saved to the new<br/>
		/// block design.<br/>
		/// Note: You cannot create a copy of a block design that has locked IP. The IP must be unlocked or the<br/>
		/// command will return an error.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example saves the current block design to the specified directory, and renames it<br/>
		/// to the specified name:<br/>
		/// save_bd_design_as -dir C:/Data new_Block<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1569<br/>
		/// </para>
		/// </summary>
		/// <param name="dir">
		/// <para>
		/// (Optional)<br/>
		/// Directory path for remote BD to be created and managed.<br/>
		/// This is required if a name is not specified<br/>
		/// </para>
		/// </param>
		/// <param name="ignore_comments">(Optional) Do not save user comments</param>
		/// <param name="force">(Optional) Overwrite existing file if present</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="name">
		/// <para>
		/// (Optional)<br/>
		/// Name of the design to create. This is required if a directory<br/>
		/// is not specified<br/>
		/// </para>
		/// </param>
		/// <returns>TCL_OK, TCL_ERROR if failed.</returns>
		public VivadoTCL save_bd_design_as(String dir = null, bool? ignore_comments = null, bool? force = null, bool? quiet = null, bool? verbose = null, String name = null)
		{
			// TCL Syntax: save_bd_design_as [-dir <arg>] [-ignore_comments] [-force] [-quiet] [-verbose] [<name>]
			this.Entry(_builder.save_bd_design_as(dir, ignore_comments, force, quiet, verbose, name));
			return this;
		}
		/// <summary>
		/// <para>
		/// Save the current design's constraints<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: save_constraints [-force] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Saves any changes to the constraints files of the active constraints set. This command writes any<br/>
		/// changes to the constraints files to the project data on the hard drive; saving any work in progress<br/>
		/// and committing any changes.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example saves the constraints files for the active constraints set regardless of any<br/>
		/// changes to the files:<br/>
		/// save_constraints -force<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1571<br/>
		/// </para>
		/// </summary>
		/// <param name="force">
		/// <para>
		/// (Optional)<br/>
		/// Force constraints save, overwriting the target and source<br/>
		/// XDC if necessary<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL save_constraints(bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: save_constraints [-force] [-quiet] [-verbose]
			this.Entry(_builder.save_constraints(force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Save current design's constraints as a new set of constraints files<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: save_constraints_as [-dir &lt;arg&gt;] [-target_constrs_file &lt;arg&gt;] [-quiet] [-verbose] &lt;name&gt;
		/// <br/>
		/// <para>
		/// Copies the active constraints set to create a new constraints set, with local copies of any<br/>
		/// constraints files that are part of the constraints set. You can also specify a new constraints file to<br/>
		/// use as the target for the copied constraints set.<br/>
		/// Use this command to save changes to the constraints in a design without affecting the current<br/>
		/// constraints files. This allows you to do some "what-if" type development of design constraints.<br/>
		/// Note: The new constraint set created by the save_constraints_as command will not be active in the<br/>
		/// design, although it will be referenced by the design. To make the constraints set active you must set the<br/>
		/// constrset property to point to the new constraints set for specific runs. See the example below.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example saves the active constraints set into a new constraints set called<br/>
		/// constrs_2, and copies any constraints files into the specified directory, as well as creating a new<br/>
		/// target constraints file for the constraints set:<br/>
		/// save_constraints_as -dir C:/Data/con1 \<br/>
		/// -target_constrs_file rev1.xdc constrs_2<br/>
		/// The following example saves the active constraints set as a new constraints set called newCon2,<br/>
		/// and copies any constraint files into the newCon2 constraint directory under project sources. The<br/>
		/// constrset property for the specified synthesis and implementation runs are then set to point to<br/>
		/// the new constraints set:<br/>
		/// save_constraints_as newCon2<br/>
		/// set_property CONSTRSET newCon2 [get_runs synth_1]<br/>
		/// set_property CONSTRSET newCon2 [get_runs impl_1]<br/>
		/// Note: The constraints set is not active in the design until it has been set to active for the current runs.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1573<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name of the new constraints fileset</param>
		/// <param name="dir">(Optional) Directory to save constraints to</param>
		/// <param name="target_constrs_file">(Optional) Target constraints file for the new fileset</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL save_constraints_as(String name, String dir = null, String target_constrs_file = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: save_constraints_as [-dir <arg>] [-target_constrs_file <arg>] [-quiet] [-verbose] <name>
			this.Entry(_builder.save_constraints_as(name, dir, target_constrs_file, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Save the current project under a new name<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: save_project_as [-scan_for_includes] [-exclude_run_results] [-include_local_ip_cache] [-force] [-quiet] [-verbose] &lt;name&gt; [&lt;dir&gt;]
		/// <br/>
		/// <para>
		/// Saves a currently open project file under a new name in the specified directory, or in the current<br/>
		/// working directory if no other directory is specified.<br/>
		/// This command save a Vivado Design Suite project file (.xpr), or a project file for the Vivado Lab<br/>
		/// Edition (.lpr), in the specified directory.<br/>
		/// The command returns the name of the saved project, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example saves the active project as a new project called myProject in a directory<br/>
		/// called myProjectDir:<br/>
		/// save_project_as myProject myProjectDir<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Note: Because &lt;dir&gt; is specified as the folder name only, the tool will create the project in the current<br/>
		/// working directory, or the directory from which the tool was launched.<br/>
		/// The following example saves the current project to a new project called myProject in a directory<br/>
		/// called C:/Designs/myProjectDir. If you use the -force argument, the tool will overwrite an<br/>
		/// existing project if one is found in the specified location.<br/>
		/// save_project_as myProject C:/Designs/myProjectDir -force<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1575<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) New name for the project to save</param>
		/// <param name="scan_for_includes">(Optional) Scan for include files and add them to the new project</param>
		/// <param name="exclude_run_results">(Optional) Exclude run results in the new project</param>
		/// <param name="include_local_ip_cache">(Optional) Include IP cache results in the new project</param>
		/// <param name="force">(Optional) Overwrite existing project directory</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="dir">(Optional) Directory where the project file is saved Default: .</param>
		/// <returns>saved project object</returns>
		public VivadoTCL save_project_as(String name, bool? scan_for_includes = null, bool? exclude_run_results = null, bool? include_local_ip_cache = null, bool? force = null, bool? quiet = null, bool? verbose = null, String dir = null)
		{
			// TCL Syntax: save_project_as [-scan_for_includes] [-exclude_run_results] [-include_local_ip_cache] [-force] [-quiet] [-verbose] <name> [<dir>]
			this.Entry(_builder.save_project_as(name, scan_for_includes, exclude_run_results, include_local_ip_cache, force, quiet, verbose, dir));
			return this;
		}
		/// <summary>
		/// <para>
		/// Saves the specified or current wave configuration object to the given filename<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: save_wave_config [-object &lt;args&gt;] [-quiet] [-verbose] [&lt;filename&gt;]
		/// <br/>
		/// <para>
		/// Save the current or specified wave configuration object to a specified filename.<br/>
		/// If the wave configuration object has not been saved before, and does not have a FILE_PATH<br/>
		/// property value, the &lt;filename&gt; is required and the NAME of the wave configuration object will<br/>
		/// be changed to match the specified &lt;filename&gt;.<br/>
		/// If the specified wave configuration object has been previously saved, and has a FILE_PATH<br/>
		/// property, the object will be written to its current location, and the &lt;filename&gt; does not need to<br/>
		/// be specified.<br/>
		/// If the wave configuration object has a FILE_PATH property, but a different &lt;filename&gt; is<br/>
		/// specified, the wave configuration object will be saved to the new &lt;filename&gt;, and the object will<br/>
		/// be renamed to match the specified &lt;filename&gt;.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example saves the specified wave configuration object to a new filename:<br/>
		/// save_wave_config -object [get_wave_configs test.wcfg] \<br/>
		/// C:/Data/project/newTest<br/>
		/// Note: The wave config file will be assigned the .wcfg suffix since none is specified.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1578<br/>
		/// </para>
		/// </summary>
		/// <param name="object">
		/// <para>
		/// (Optional)<br/>
		/// The WCFG or wave configuration to save. Default: Current<br/>
		/// wave configuration<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="filename">(Optional) Filename to save the specified or current wave configuration object</param>
		/// <returns>The wave configuration object saved</returns>
		public VivadoTCL save_wave_config(TCLParameterList @object = null, bool? quiet = null, bool? verbose = null, String filename = null)
		{
			// TCL Syntax: save_wave_config [-object <args>] [-quiet] [-verbose] [<filename>]
			this.Entry(_builder.save_wave_config(@object, quiet, verbose, filename));
			return this;
		}
		/// <summary>
		/// <para>
		/// Perform shift DR on 'hw_jtag'.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: scan_dr_hw_jtag [-tdi &lt;arg&gt;] [-tdo &lt;arg&gt;] [-mask &lt;arg&gt;] [-smask &lt;arg&gt;] [-quiet] [-verbose] &lt;length&gt;
		/// <br/>
		/// <para>
		/// The scan_dr_hw_jtag command specifies a scan pattern to be scanned into the JTAG<br/>
		/// interface target data register.<br/>
		/// The command targets a hw_jtag object which is created when the hw_target is opened in JTAG<br/>
		/// mode through the use of the open_hw_target -jtag_mode command.<br/>
		/// When targeting the hw_jtag object prior to shifting the scan pattern specified in the<br/>
		/// scan_dr_hw_jtag command, the last defined header property (HDR) will be pre-pended to the<br/>
		/// beginning of the specified data pattern, and the last defined trailer property (TDR) will be<br/>
		/// appended to the end of the data pattern.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The options can be specified in any order, but can only be specified once. The number of bits<br/>
		/// represented by the hex strings specified for -tdi, -tdo, -mask, or -smask cannot be greater<br/>
		/// than the maximum specified by &lt;length&gt;. Leading zeros are assumed for a hex string if the<br/>
		/// number of bits represented by the hex strings specified is less than the &lt;length&gt;.<br/>
		/// When shifting the data bits to the target data register, the scan_dr_hw_jtag command moves<br/>
		/// the JTAG TAP from the current stable state to the DRSHIFT state according to the state<br/>
		/// transition table below:<br/>
		/// Current State Transitions to get to DRSHIFT state<br/>
		/// RESET IDLE -&gt; DRSELECT -&gt; DRCAPTURE -&gt; DRSHIFT<br/>
		/// IDLE DRSELECT -&gt; DRCAPTURE -&gt;<br/>
		/// DRSHIFT<br/>
		/// IRPAUSE IREXIT2 -&gt; IRUPDATE -&gt; DRSELECT -&gt; DRCAPTURE -&gt;<br/>
		/// DRSHIFT<br/>
		/// DRPAUSE DREXIT2 -&gt;<br/>
		/// DRSHIFT<br/>
		/// DRPAUSE* DREXIT2 -&gt; DRUPDATE -&gt; DRSELECT -&gt; DRCAPTURE -&gt; DRSHIFT<br/>
		/// Note: * With -force_update option set.<br/>
		/// After the last data bit is shifted into the target data register, the scan_dr_hw_jtag command<br/>
		/// moves the JTAG TAP to the IDLE state, or to the stable state defined by the<br/>
		/// run_state_hw_jtag command.<br/>
		/// The scan_dr_hw_jtag command returns a hex array containing captured TDO data from the<br/>
		/// hw_jtag, or returns an error if it fails.<br/>
		/// The command raises an error that can be trapped by the Tcl catch command if TDO data from<br/>
		/// the hw_jtag does not match specified -tdo argument.<br/>
		/// TIP: If -tdo and -mask arguments are specified, then the mask is applied to the -tdo option and the<br/>
		/// hw_jtag TDO data returned before comparing the two.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1580<br/>
		/// </para>
		/// </summary>
		/// <param name="length">(Required) Number of bits to be scanned.</param>
		/// <param name="tdi">(Optional) Hex value to be scanned into the target</param>
		/// <param name="tdo">(Optional) Hex value to be compared against the scanned value</param>
		/// <param name="mask">(Optional) Hex value mask applied when comparing TDO values</param>
		/// <param name="smask">(Optional) Hex value mask applied to TDI value</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>hardware TDO</returns>
		public VivadoTCL scan_dr_hw_jtag(Int32 length, String tdi = null, String tdo = null, String mask = null, String smask = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: scan_dr_hw_jtag [-tdi <arg>] [-tdo <arg>] [-mask <arg>] [-smask <arg>] [-quiet] [-verbose] <length>
			this.Entry(_builder.scan_dr_hw_jtag(length, tdi, tdo, mask, smask, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Perform shift IR on 'hw_jtag'.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: scan_ir_hw_jtag [-tdi &lt;arg&gt;] [-tdo &lt;arg&gt;] [-mask &lt;arg&gt;] [-smask &lt;arg&gt;] [-quiet] [-verbose] &lt;length&gt;
		/// <br/>
		/// <para>
		/// The scan_ir_hw_jtag command specifies a scan pattern to be scanned into the JTAG<br/>
		/// interface target instruction register.<br/>
		/// The command targets a hw_jtag object which is created when the hw_target is opened in JTAG<br/>
		/// mode through the use of the open_hw_target -jtag_mode command.<br/>
		/// When targeting the hw_jtag object prior to shifting the scan pattern specified in the<br/>
		/// scan_ir_hw_jtag command, the last defined header property (HIR) will be pre-pended to the<br/>
		/// beginning of the specified data pattern, and the last defined trailer property (TIR) will be<br/>
		/// appended to the end of the data pattern.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The options can be specified in any order, but can only be specified once. The number of bits<br/>
		/// represented by the hex strings specified for -tdi, -tdo, -mask, or -smask cannot be greater<br/>
		/// than the maximum specified by &lt;length&gt;. Leading zeros are assumed for a hex string if the<br/>
		/// number of bits represented by the hex strings specified is less than the &lt;length&gt;.<br/>
		/// When shifting the bits into the target instruction register, the scan_ir_hw_jtag command<br/>
		/// moves the JTAG TAP from the current stable state to the IRSHIFT state according to the state<br/>
		/// transition table below:<br/>
		/// Current Transitions to get to<br/>
		/// State IRSHIFT state<br/>
		/// RESET IDLE &gt; DRSELECT &gt; IRSELECT &gt; IRCAPTURE &gt; IRSHIFT<br/>
		/// IDLE IRSELECT &gt; IRCAPTURE &gt; IRSHIFT<br/>
		/// DRPAUSE DREXIT2 &gt; DRUPDATE &gt; DRSELECT &gt; IRSELECT &gt; IRCAPTURE &gt; IRSHIFT<br/>
		/// IRPAUSE IREXIT2 &gt; IRSHIFT<br/>
		/// IRPAUSE* IREXIT2 &gt; IRUPDATE &gt; DRSELECT &gt; IRSELECT &gt; IRCAPTURE &gt; IRSHIFT<br/>
		/// Note: * With -force_update option set.<br/>
		/// After the last data bit is shifted into the target data register, the scan_ir_hw_jtag command<br/>
		/// moves the JTAG TAP to the IDLE state, or to the stable state defined by the run_state_hw_jtag<br/>
		/// command.<br/>
		/// The scan_ir_hw_jtag command returns a hex array containing captured TDO data from the<br/>
		/// hw_jtag, or returns an error if it fails.<br/>
		/// The command raises an error that can be trapped by the Tcl catch command if TDO data from<br/>
		/// the hw_jtag does not match specified -tdo argument.<br/>
		/// TIP: If -tdo and -mask arguments are specified, then the mask is applied to the -tdo option and the<br/>
		/// hw_jtag TDO data returned before comparing the two.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1584<br/>
		/// </para>
		/// </summary>
		/// <param name="length">(Required) Number of bits to be scanned.</param>
		/// <param name="tdi">(Optional) Hex value to be scanned into the target</param>
		/// <param name="tdo">(Optional) Hex value to be compared against the scanned value</param>
		/// <param name="mask">(Optional) Hex value mask applied when comparing TDO values</param>
		/// <param name="smask">(Optional) Hex value mask applied to TDI value</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>hardware TDO</returns>
		public VivadoTCL scan_ir_hw_jtag(Int32 length, String tdi = null, String tdo = null, String mask = null, String smask = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: scan_ir_hw_jtag [-tdi <arg>] [-tdo <arg>] [-mask <arg>] [-smask <arg>] [-quiet] [-verbose] <length>
			this.Entry(_builder.scan_ir_hw_jtag(length, tdi, tdo, mask, smask, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Select objects in GUI<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: select_objects [-add] [-quiet] [-verbose] &lt;objects&gt;
		/// <br/>
		/// <para>
		/// Selects the specified object in the appropriate open views in the GUI mode. This command is for<br/>
		/// display purposes only. You must use the get_selected_objects command to return the<br/>
		/// selected objects for use in other commands.<br/>
		/// The select_objects command may select secondary objects in addition to the primary object<br/>
		/// specified. The selection of secondary objects is controlled through the use of Selection Rules<br/>
		/// defined in the Tools → Settings command. Refer to the Vivado Design Suite User Guide: Using the<br/>
		/// IDE (UG893) for more information on Setting Selection Rules.<br/>
		/// Selected objects can be unselected with the unselect_objects command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example selects the specified site on the device:<br/>
		/// select_objects [get_sites SLICE_X56Y214]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1588<br/>
		/// </para>
		/// </summary>
		/// <param name="objects">(Required) Objects to select</param>
		/// <param name="add">(Optional) Add to existing selection list</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL select_objects(String objects, bool? add = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: select_objects [-add] [-quiet] [-verbose] <objects>
			this.Entry(_builder.select_objects(objects, add, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Display help for one or more topics<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: select_wave_objects [-quiet] [-verbose] &lt;items&gt;...
		/// <br/>
		/// <para>
		/// Selects the specified object in the Waveform window of the Vivado IDE. This command is for<br/>
		/// selecting displayed items in the Waveform window only, and is similar to the select_objects<br/>
		/// command in the Vivado IDE.<br/>
		/// Note: Use the get_hdl_objects command to select simulation objects in the open simulation, or<br/>
		/// current_sim.<br/>
		/// Unselect selected objects using the select_wave_objects command with an empty string:<br/>
		/// select_wave_objects ""<br/>
		/// This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example selects the specified site on the device:<br/>
		/// select_wave_objects {sys_clk_p sysc_clk_n}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1590<br/>
		/// </para>
		/// </summary>
		/// <param name="items">(Required) select waveform objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL select_wave_objects(TCLParameterList items, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: select_wave_objects [-quiet] [-verbose] <items>...
			this.Entry(_builder.select_wave_objects(items, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Define bus skew<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_bus_skew [-from &lt;args&gt;] [-rise_from &lt;args&gt;] [-fall_from &lt;args&gt;] [-to &lt;args&gt;] [-rise_to &lt;args&gt;] [-fall_to &lt;args&gt;] [-through &lt;args&gt;] [-rise_through &lt;args&gt;] [-fall_through &lt;args&gt;] [-quiet] [-verbose] &lt;value&gt;
		/// <br/>
		/// <para>
		/// Set the bus skew requirement on bus signals that cross clock domains. The bus skew constraint<br/>
		/// defines the maximum skew spread between the fastest and slowest signals of the bus, and does<br/>
		/// not consider the overall datapath delay. The Vivado router will try to satisfy the set_bus_skew<br/>
		/// constraints. Example uses of the bus skew constraint include clock domain crossing for gray-coded pointers, MUX-controlled and MUX-data holding CDC buses.<br/>
		/// TIP: Bus skew constraints are not overridden by clock groups, max delay, or false path, because<br/>
		/// set_bus_skew is a constraint between the signals of a bus, rather than on a particular path.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The set_bus_skew constraint can be combined with the set_max_delay constraint for good<br/>
		/// results. The set_bus_skew constraint does not care about the absolute datapath delay, but<br/>
		/// only about the relative arrival times of data at the destination, taking into account source and<br/>
		/// destination clock skew. You can help set_bus_skew by also using set_max_delay -<br/>
		/// datapath_only &lt;SRC_CLK&gt;. This constraint helps the Vivado placer to ensure that the<br/>
		/// source and destination registers are not placed too far apart, so that the router can more easily<br/>
		/// satisfy the set_bus_skew constraint. Refer to the Vivado Design Suite User Guide: Using<br/>
		/// Constraints (UG903) for more information.<br/>
		/// In order to not over constrain the skew requirement, the bus skew value should be approximately<br/>
		/// the smallest period of the two clock domains. This will prevent multiple data captures by the<br/>
		/// destination clock domain.<br/>
		/// The set_bus_skew command requires a timing path defined by both -from and -to, or some<br/>
		/// form such as -fall_from or -rise_to. You can optionally specify -through values to<br/>
		/// further refine the path. You should specify explicit signal paths with -from/-to instead of<br/>
		/// specifying entire clock domains:<br/>
		/// • set_bus_skew -from [get_pins &lt;hierarchy/C&gt;] -to [get_pins<br/>
		/// &lt;hierarchy/D&gt;] &lt;value&gt;<br/>
		/// • set_bus_skew -from [get_clocks &lt;clock name&gt;] -to get_clocks &lt;clock<br/>
		/// name&gt;] &lt;value&gt;<br/>
		/// TIP: Do not set bus skew constraints between timed synchronous clock domains.<br/>
		/// You can use the report_bus_skew command to report the calculated skew on paths in the<br/>
		/// current design.<br/>
		/// The set_bus_skew command returns nothing if successful, or an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example defines the bus skew between the gray-coded Read and Write pointers:<br/>
		/// set_bus_skew -from [get_pins gray_coded_read_ptr[*]/C] \<br/>
		/// -to [get_pins gray_coded_write_ptr[*]/D] 2.5<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1592<br/>
		/// </para>
		/// </summary>
		/// <param name="value">(Required) Constraint value</param>
		/// <param name="from">(Optional) List of path startpoints or clocks</param>
		/// <param name="rise_from">(Optional) Apply to paths rising from the list of startpoints or clocks</param>
		/// <param name="fall_from">(Optional) Apply to paths falling from the list of startpoints or clocks</param>
		/// <param name="to">(Optional) List of path endpoints or clocks</param>
		/// <param name="rise_to">(Optional) Apply to paths with rise transition at the list of endpoints or clocks</param>
		/// <param name="fall_to">(Optional) Apply to paths with fall transition at the list of endpoints or clocks</param>
		/// <param name="through">(Optional) List of through pins, cells or nets</param>
		/// <param name="rise_through">(Optional) Apply to paths rising through pins, cells or nets</param>
		/// <param name="fall_through">(Optional) Apply to paths falling through pins, cells or nets</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_bus_skew(String value, TCLParameterList from = null, TCLParameterList rise_from = null, TCLParameterList fall_from = null, TCLParameterList to = null, TCLParameterList rise_to = null, TCLParameterList fall_to = null, TCLParameterList through = null, TCLParameterList rise_through = null, TCLParameterList fall_through = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_bus_skew [-from <args>] [-rise_from <args>] [-fall_from <args>] [-to <args>] [-rise_to <args>] [-fall_to <args>] [-through <args>] [-rise_through <args>] [-fall_through <args>] [-quiet] [-verbose] <value>
			this.Entry(_builder.set_bus_skew(value, from, rise_from, fall_from, to, rise_to, fall_to, through, rise_through, fall_through, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Specify that an input is 1, 0, rising or falling<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_case_analysis [-quiet] [-verbose] &lt;value&gt; &lt;objects&gt;
		/// <br/>
		/// <para>
		/// Specifies that a pin or port is in a steady state of 1, 0, rising or falling.<br/>
		/// This command is usually used to force values onto the ports to help reduce the analysis space,<br/>
		/// runtime and memory consumption. It is important to let the Vivado timing engine know about<br/>
		/// signals that have a constant value. This is also critical to ensure that non-functional and irrelevant<br/>
		/// paths are not reported.<br/>
		/// Setting a case value on a pin results in disabling timing analysis through that pin. This means that<br/>
		/// timing paths through that pin are not reported.<br/>
		/// Note: This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// In the example below, two clocks are created on the input pins of the BUFGMUX, clock_sel, but<br/>
		/// only clk_B is propagated through the output pin after setting the constant value 1 on the<br/>
		/// selection pin S:<br/>
		/// create_clock -name clk_A -period 10.0 [get_pins clock_sel/I0]<br/>
		/// create_clock -name clk_B -period 15.0 [get_pins clock_sel/I1]<br/>
		/// set_case_analysis 1 [get_pins clock_sel/S]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1596<br/>
		/// </para>
		/// </summary>
		/// <param name="value">
		/// <para>
		/// (Required)<br/>
		/// Logic value on the pin: Values: 0, 1, rising, falling, zero, one,<br/>
		/// rise, fall<br/>
		/// </para>
		/// </param>
		/// <param name="objects">(Required) List of ports or pins</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_case_analysis(set_case_analysis_value value, String objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_case_analysis [-quiet] [-verbose] <value> <objects>
			this.Entry(_builder.set_case_analysis(value, objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Set exclusive or asynchronous clock groups<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_clock_groups [-name &lt;arg&gt;] [-logically_exclusive] [-physically_exclusive] [-asynchronous] [-group &lt;args&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// TIP: The XDC &gt; Timing Constraints language templates and the Timing Constraints Wizard in the Vivado<br/>
		/// IDE offer timing diagrams and additional details around defining specific timing constraints. You can refer<br/>
		/// to these sources for additional information.<br/>
		/// Define clocks, or groups of clocks, that are exclusive with or asynchronous to other clocks in the<br/>
		/// design. Exclusive clocks are not active at the same time, and paths between them can be ignored<br/>
		/// during timing analysis. Asynchronous clocks are clocks with no known phase relationship, which<br/>
		/// typically happens when they do not share the same primary clock or do not have a common<br/>
		/// period.<br/>
		/// Using this command is similar to defining false path constraints for data paths moving between<br/>
		/// exclusive or asynchronous clock domains. See the Vivado Design Suite User Guide: Using<br/>
		/// Constraints (UG903) for more information.<br/>
		/// If only one group is specified, the clocks in that group are asynchronous or exclusive to all other<br/>
		/// clocks in the design, but not to each other. If a new clock is created after the<br/>
		/// set_clock_groups command, it is asynchronous to that group as well.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This command can also be used for multiple clocks that are derived from a single BUFGMUX as<br/>
		/// both of the clocks will not be active at the same time.<br/>
		/// Note: This command operates silently and does not return direct feedback of its operation.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// Group all the elements driven by src_clk and sync_clk into separate clock groups. The clock<br/>
		/// groups are asynchronous to each other:<br/>
		/// set_clock_groups -group src_clk -group sync_clk -asynchronous<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example includes the generated clocks of the specified clocks, and adds those to<br/>
		/// the clock group:<br/>
		/// set_clock_groups -group [get_clocks -include_generated_clocks src_clk] \<br/>
		/// -group [get_clocks -include_generated_clocks sync_clk] -asynchronous<br/>
		/// Note: In the preceding example, src_clk and sync_clk, and all their generated clocks, are asynchronous.<br/>
		/// Otherwise the generated clocks would be timed against each other and the other master clock.<br/>
		/// In this example, the specified clocks are grouped together, and are asynchronous to all other<br/>
		/// clocks in the design:<br/>
		/// set_clock_groups -async -group [get_clocks {J_CLK U_CLK}]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1598<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Optional) Name for clock grouping</param>
		/// <param name="logically_exclusive">(Optional) Specify logically exclusive clock groups</param>
		/// <param name="physically_exclusive">(Optional) Specify physically exclusive clock groups</param>
		/// <param name="asynchronous">(Optional) Specify asynchronous clock groups</param>
		/// <param name="group">(Optional) Clocks List</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_clock_groups(String name = null, bool? logically_exclusive = null, bool? physically_exclusive = null, bool? asynchronous = null, TCLParameterList group = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_clock_groups [-name <arg>] [-logically_exclusive] [-physically_exclusive] [-asynchronous] [-group <args>] [-quiet] [-verbose]
			this.Entry(_builder.set_clock_groups(name, logically_exclusive, physically_exclusive, asynchronous, group, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Capture actual or predicted clock latency<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_clock_latency [-clock &lt;args&gt;] [-rise] [-fall] [-min] [-max] [-source] [-late] [-early] [-quiet] [-verbose] &lt;latency&gt; &lt;objects&gt;
		/// <br/>
		/// <para>
		/// This command defines a clock's source or network latency for specified clocks, ports, or pins.<br/>
		/// Note: This command operates silently and does not return direct feedback of its operation.<br/>
		/// Source latency is the time in nanoseconds that a clock signal takes to propagate from its<br/>
		/// waveform origin to the clock definition point in the design. For example, this would be the time<br/>
		/// delay for the clock to propagate from its source (oscillator) on the system board to the FPGA<br/>
		/// input port.<br/>
		/// Network latency is the time a clock signal takes to propagate from its definition point in the<br/>
		/// design to a register clock pin on the timing path. The total clock latency at a register clock pin is<br/>
		/// the sum of a clock's source latency and network latency.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// This example will set an early latency on the rising edge of CLK_A.<br/>
		/// set_clock_latency -source -rise -early 0.4 [get_ports CLK_A]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1601<br/>
		/// </para>
		/// </summary>
		/// <param name="latency">(Required) Latency value</param>
		/// <param name="objects">(Required) List of clocks, ports or pins</param>
		/// <param name="clock">(Optional) List of relative clocks</param>
		/// <param name="rise">(Optional) Specify clock rise latency</param>
		/// <param name="fall">(Optional) Specify clock fall latency</param>
		/// <param name="min">(Optional) Specify clock rise and fall min condition latency</param>
		/// <param name="max">(Optional) Specify clock rise and fall max condition latency</param>
		/// <param name="source">(Optional) Specify clock rise and fall source latency</param>
		/// <param name="late">(Optional) Specify clock rise and fall late source latency</param>
		/// <param name="early">(Optional) Specify clock rise and fall early source latency</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_clock_latency(String latency, String objects, TCLParameterList clock = null, bool? rise = null, bool? fall = null, bool? min = null, bool? max = null, bool? source = null, bool? late = null, bool? early = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_clock_latency [-clock <args>] [-rise] [-fall] [-min] [-max] [-source] [-late] [-early] [-quiet] [-verbose] <latency> <objects>
			this.Entry(_builder.set_clock_latency(latency, objects, clock, rise, fall, min, max, source, late, early, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Set clock sense on ports or pins<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_clock_sense [-positive] [-negative] [-stop_propagation] [-clocks &lt;args&gt;] [-quiet] [-verbose] &lt;pins&gt;
		/// <br/>
		/// <para>
		/// Sets clock sense at specified ports or pins. This is used to define the positive or negative<br/>
		/// unateness at the pin relative to a clock object. However, the specified unateness only applies at a<br/>
		/// non-unate point in the clock network, at a point where the clock signal cannot be determined.<br/>
		/// Since the clock signal is not determined, the defined clock sense propagates forward from the<br/>
		/// given pins.<br/>
		/// Note: This command operates silently and does not return direct feedback of its operation.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example specifies that only the positive unate paths will propagate through the<br/>
		/// output pin of the XOR gate as compared with the original clock.<br/>
		/// set_clock_sense -positive [get_pins xor_a.z]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1604<br/>
		/// </para>
		/// </summary>
		/// <param name="pins">(Required) List of port and/or pins</param>
		/// <param name="positive">(Optional) Specify positive unate (non_inverting) clock sense</param>
		/// <param name="negative">(Optional) Specify negative unate (inverting) clock sense</param>
		/// <param name="stop_propagation">(Optional) Stop clock propagation from specified pins</param>
		/// <param name="clocks">(Optional) List of clocks</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_clock_sense(String pins, bool? positive = null, bool? negative = null, bool? stop_propagation = null, TCLParameterList clocks = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_clock_sense [-positive] [-negative] [-stop_propagation] [-clocks <args>] [-quiet] [-verbose] <pins>
			this.Entry(_builder.set_clock_sense(pins, positive, negative, stop_propagation, clocks, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// set clock uncertainty<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_clock_uncertainty [-setup] [-hold] [-from &lt;args&gt;] [-rise_from &lt;args&gt;] [-fall_from &lt;args&gt;] [-to &lt;args&gt;] [-rise_to &lt;args&gt;] [-fall_to &lt;args&gt;] [-quiet] [-verbose] &lt;uncertainty&gt; [&lt;objects&gt;]
		/// <br/>
		/// <para>
		/// This command is used to add to the uncertainty of a clock in the design, and does not override<br/>
		/// the default jitter calculation. This is referred to as the user clock uncertainty. The<br/>
		/// set_clock_uncertainty command provides a convenient means to over-constrain some<br/>
		/// clocks in the design without changing the clock definitions and relationships. It can constrain<br/>
		/// setup and hold paths separately using the -setup and -hold options.<br/>
		/// Clock uncertainty is the maximum variation, specified in nanoseconds (ns), between two clock<br/>
		/// edges at registers within a single clock domain, or crossing between clock domains.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The clock uncertainty is used during setup and hold analysis, where uncertainty is calculated for<br/>
		/// each timing path based on the clock edges used by the analysis and the clock tree topology. For<br/>
		/// example, for a path where the startpoint and endpoint are connected to the same clock net, the<br/>
		/// clock uncertainty is null because the same clock edge is used for both source and destination,<br/>
		/// unless the set_clock_uncertainty command is used to add uncertainty for the min delay<br/>
		/// analysis. The Vivado timing engine uses clock uncertainty in the slack calculation as determined<br/>
		/// by the following equation:<br/>
		/// • Setup Slack = Setup Path Requirement - Data Delay - Clock Uncertainty + Clock Skew<br/>
		/// Clock Uncertainty is a function of different elements of jitter, as determined by the following<br/>
		/// equation which is returned by the report_timing_summary or report_timing commands:<br/>
		/// • Clock Uncertainty = (√(Tsj2<br/>
		/// + Dj<br/>
		/// 2<br/>
		/// ))/2 + PE + UU<br/>
		/// Where:<br/>
		/// • Tsj = Total System Jitter as calculated using the system jitter. See set_system_jitter.<br/>
		/// • Dj<br/>
		/// = Discrete jitter is the amount of jitter introduced by hardware primitives such as MMCM<br/>
		/// or PLL. Discrete jitter is a feature of clocks generated by the MMCM, which includes the input<br/>
		/// jitter defined on the primary clock. See set_input_jitter.<br/>
		/// • PE = Phase Error, which comes from the MMCM/PLL device model.<br/>
		/// • UU = User Uncertainty, which defines the user clock uncertainty specified by this<br/>
		/// set_clock_uncertainty command.<br/>
		/// TIP: SYSTEM_JITTER is reported as a property of clocks, although it applies to all clocks in the design.<br/>
		/// INPUT_JITTER is also a property of primary clocks. These properties can be returned by the<br/>
		/// get_property or report_property commands. Jitter and clock uncertainty are reported by the<br/>
		/// report_timing_summary and report_timing commands.<br/>
		/// This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example defines the uncertainty between all clock domains:<br/>
		/// set_clock_uncertainty 0.225 -from [get_clocks] -to [get_clocks]<br/>
		/// The following command defines setup and hold uncertainty within the wbClk clock domain:<br/>
		/// set_clock_uncertainty -setup 0.213 [get_clocks wbClk]<br/>
		/// set_clock_uncertainty -hold 0.167 [get_clocks wbClk]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1606<br/>
		/// </para>
		/// </summary>
		/// <param name="uncertainty">(Required) Uncertainty of clock network</param>
		/// <param name="setup">(Optional) Specify clock uncertainty for setup checks</param>
		/// <param name="hold">(Optional) Specify clock uncertainty for hold checks</param>
		/// <param name="from">(Optional) Specify inter-clock uncertainty source clock</param>
		/// <param name="rise_from">(Optional) Specify inter-clock uncertainty source clock with rising edge</param>
		/// <param name="fall_from">(Optional) Specify inter-clock uncertainty source clock with falling edge</param>
		/// <param name="to">(Optional) Specify inter-clock uncertainty destination clock</param>
		/// <param name="rise_to">(Optional) Specify inter-clock uncertainty destination clock with rising edge</param>
		/// <param name="fall_to">(Optional) Specify inter-clock uncertainty destination clock with falling edge</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">(Optional) List of clocks, ports or pins</param>
		public VivadoTCL set_clock_uncertainty(String uncertainty, bool? setup = null, bool? hold = null, TCLParameterList from = null, TCLParameterList rise_from = null, TCLParameterList fall_from = null, TCLParameterList to = null, TCLParameterList rise_to = null, TCLParameterList fall_to = null, bool? quiet = null, bool? verbose = null, String objects = null)
		{
			// TCL Syntax: set_clock_uncertainty [-setup] [-hold] [-from <args>] [-rise_from <args>] [-fall_from <args>] [-to <args>] [-rise_to <args>] [-fall_to <args>] [-quiet] [-verbose] <uncertainty> [<objects>]
			this.Entry(_builder.set_clock_uncertainty(uncertainty, setup, hold, from, rise_from, fall_from, to, rise_to, fall_to, quiet, verbose, objects));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create data to data checks<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_data_check [-from &lt;args&gt;] [-to &lt;args&gt;] [-rise_from &lt;args&gt;] [-fall_from &lt;args&gt;] [-rise_to &lt;args&gt;] [-fall_to &lt;args&gt;] [-setup] [-hold] [-clock &lt;args&gt;] [-quiet] [-verbose] &lt;value&gt;
		/// <br/>
		/// <para>
		/// Performs a setup and hold check for a data pin with respect to another data pin. This is different<br/>
		/// from a conventional setup and hold check that is done with respect to a clock pin.<br/>
		/// This command defines min and max requirements between two endpoints, similar to setup (max)<br/>
		/// and hold (min) timing checks. Setup and hold checks are referenced from the related pin,<br/>
		/// specified by -from, to the constrained pin, specified by -to. The related pin is similar to the<br/>
		/// clock pin in a conventional setup and hold check. The timing analysis compares arrival times<br/>
		/// between the two specified endpoints. The difference must be less than the set_data_check<br/>
		/// &lt;value&gt; requirement in order to meet timing.<br/>
		/// Limitations of the set_data_check command include:<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// • Variations in the destination clock delay are ignored.<br/>
		/// • This command is used for timing purposes only, and is not considered by the Vivado placer or<br/>
		/// router.<br/>
		/// Note: This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example defines a data check for a setup violation from pin A_IN to pin C_IN:<br/>
		/// set_data_check -from A_IN -to C_IN -setup 2.0<br/>
		/// In the above example, A_IN is the related pin and C_IN is the constrained pin. The above<br/>
		/// constraint would do a setup check of C_IN with respect to A_IN. The data at C_IN should arrive<br/>
		/// 2.0 ns prior to the edge of A_IN.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1609<br/>
		/// </para>
		/// </summary>
		/// <param name="value">(Required) Setup or hold time of the defined checks</param>
		/// <param name="from">(Optional) From pin/port of data to data check</param>
		/// <param name="to">(Optional) To pin/port of the data to data check</param>
		/// <param name="rise_from">(Optional) Rise from pin/port of data to data check</param>
		/// <param name="fall_from">(Optional) Fall from pin/port of data to data check</param>
		/// <param name="rise_to">(Optional) Rise to pin/port of data to data check</param>
		/// <param name="fall_to">(Optional) Fall to pin/port of data to data check</param>
		/// <param name="setup">(Optional) Specify data check setup time</param>
		/// <param name="hold">(Optional) Specify data check hold time</param>
		/// <param name="clock">(Optional) Specify the clock domain at related pin/port of the checks</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_data_check(String value, TCLParameterList from = null, TCLParameterList to = null, TCLParameterList rise_from = null, TCLParameterList fall_from = null, TCLParameterList rise_to = null, TCLParameterList fall_to = null, bool? setup = null, bool? hold = null, TCLParameterList clock = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_data_check [-from <args>] [-to <args>] [-rise_from <args>] [-fall_from <args>] [-rise_to <args>] [-fall_to <args>] [-setup] [-hold] [-clock <args>] [-quiet] [-verbose] <value>
			this.Entry(_builder.set_data_check(value, from, to, rise_from, fall_from, rise_to, fall_to, setup, hold, clock, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Sets the interconnect delay model for timing analysis.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_delay_model [-interconnect &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Sets the interconnect delay model for timing analysis. There are three settings for the<br/>
		/// interconnect delay model: "actual", "estimated", or "none".<br/>
		/// • If "actual" is selected, the actual delay from the routed interconnect will be used in timing<br/>
		/// analysis. If the design is only partially routed, then the actual delay from the routed portion<br/>
		/// will be used, along with estimated delay for the unrouted portion. The timing report will<br/>
		/// provide details regarding the source of the calculated delay.<br/>
		/// • If "estimated" delays are selected, the timing analysis will include an estimate of the<br/>
		/// interconnect delays based on the placement and connectivity of the design onto the device<br/>
		/// prior to implementation. Estimated delay can be specified even if the design is fully routed.<br/>
		/// • If "none" is selected, then no interconnect delay is included in the timing analysis, and only the<br/>
		/// logic delay is applied.<br/>
		/// Note: This command operates silently and does not return direct feedback of its operation.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following command will use a timing delay model which is an estimated value.<br/>
		/// set_delay_model -interconnect estimated<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1612<br/>
		/// </para>
		/// </summary>
		/// <param name="interconnect">
		/// <para>
		/// (Optional)<br/>
		/// Interconnect delay model used for timing analysis: Values:<br/>
		/// estimated, actual(default), none<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_delay_model(set_delay_model_interconnect? interconnect = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_delay_model [-interconnect <arg>] [-quiet] [-verbose]
			this.Entry(_builder.set_delay_model(interconnect, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Disable timing arcs<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_disable_timing [-from &lt;arg&gt;] [-to &lt;arg&gt;] [-quiet] [-verbose] &lt;objects&gt;
		/// <br/>
		/// <para>
		/// Disables timing arcs within a specified cell or cells that lead to the output pins of the cell. Only<br/>
		/// the I/O paths between the clock port and the outputs of the cell are disabled.<br/>
		/// The purpose of disabling a timing arc is to prevent timing analysis through the arc.<br/>
		/// If a &lt;cell&gt; is specified, then all timing arcs in that cell are disabled. If the optional -from and -to<br/>
		/// arguments are specified, then the timing arcs are defined by the from/to pins. If only -from is<br/>
		/// speified then all timing arcs from that pin are disabled. If only -to is specified then all timing<br/>
		/// paths to that pin are disabled.<br/>
		/// If a &lt;port&gt; is specified, then all timing paths from a specified input port are disabled, or timing<br/>
		/// paths to a specified output port are disabled.<br/>
		/// Note: This command operates silently and does not return direct feedback of its operation<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example disable the timing arc between the pins I0 and O of the LUT<br/>
		/// div_dec_ff_i/U0/count_i_1 to break a combinational loop:<br/>
		/// set_disable_timing -from I0 -to O [get_cells div_dec_ff_i/U0/count_i_1]<br/>
		/// The following example disables the timing arcs between the specified input pin to the specified<br/>
		/// output pin of a BRAM cell:<br/>
		/// set_disable_timing -from WEBWE[3] -to CLKMEM [get_cells \<br/>
		/// ldpc_dout360_channel/U_AP_FIFO_ldpc_dout360_channel_ram/mem_reg_0]<br/>
		/// The following example disables all timing arcs of the specified cell:<br/>
		/// set arcs [get_timing_arcs -of_objects [get_cells \<br/>
		/// ldpc_dout360_channel/U_AP_FIFO_ldpc_dout360_channel_ram/mem_reg_0]]<br/>
		/// set_disable_timing $arcs<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1614<br/>
		/// </para>
		/// </summary>
		/// <param name="objects">
		/// <para>
		/// (Required)<br/>
		/// List of cells or pins, ports, lib-cells, lib-pins, libcell/cell<br/>
		/// timing-arcs<br/>
		/// </para>
		/// </param>
		/// <param name="from">(Optional) From pin on cell</param>
		/// <param name="to">(Optional) To pin on cell</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_disable_timing(String objects, String from = null, String to = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_disable_timing [-from <arg>] [-to <arg>] [-quiet] [-verbose] <objects>
			this.Entry(_builder.set_disable_timing(objects, from, to, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Set external delay<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_external_delay -from &lt;args&gt; -to &lt;args&gt; [-min] [-max] [-add] [-quiet] [-verbose] &lt;delay_value&gt;
		/// <br/>
		/// <para>
		/// TIP: The XDC &gt; Timing Constraints language templates and the Timing Constraints Wizard in the Vivado<br/>
		/// IDE offer timing diagrams and additional details around defining specific timing constraints. You can refer<br/>
		/// to these sources for additional information.<br/>
		/// Sets the external (feedback) delay in nanoseconds (ns) between an output and input port. The<br/>
		/// external delay is used in the calculation of the PLL/MMCM compensation delay for PLLs/<br/>
		/// MMCMs with external feedback.<br/>
		/// A min or max value can be specified. By default the value specified applies to both min (hold) and<br/>
		/// max (setup) compensation delays.<br/>
		/// The command returns the defined delay.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example sets the external feedback delay to 1.0 ns between the port ClkOut and<br/>
		/// ClkFb:<br/>
		/// set_external_delay -from [get_ports ClkOut] -to [get_ports ClkFb] 1.0<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1616<br/>
		/// </para>
		/// </summary>
		/// <param name="from">(Required) Output port</param>
		/// <param name="to">(Required) Input port</param>
		/// <param name="delay_value">(Required) External (feedback) delay value</param>
		/// <param name="min">(Optional) Specifies minimum delay</param>
		/// <param name="max">(Optional) Specifies maximum delay</param>
		/// <param name="add">(Optional) Add to existing external delay</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_external_delay(TCLParameterList from, TCLParameterList to, String delay_value, bool? min = null, bool? max = null, bool? add = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_external_delay -from <args> -to <args> [-min] [-max] [-add] [-quiet] [-verbose] <delay_value>
			this.Entry(_builder.set_external_delay(from, to, delay_value, min, max, add, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Define false path<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_false_path [-setup] [-hold] [-rise] [-fall] [-reset_path] [-from &lt;args&gt;] [-rise_from &lt;args&gt;] [-fall_from &lt;args&gt;] [-to &lt;args&gt;] [-rise_to &lt;args&gt;] [-fall_to &lt;args&gt;] [-through &lt;args&gt;] [-rise_through &lt;args&gt;] [-fall_through &lt;args&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// TIP: The XDC &gt; Timing Constraints language templates and the Timing Constraints Wizard in the Vivado<br/>
		/// IDE offer timing diagrams and additional details around defining specific timing constraints. You can refer<br/>
		/// to these sources for additional information.<br/>
		/// Sets false timing paths in the design that are ignored during timing analysis.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Note: This command operates silently and does not return direct feedback of its operation<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example eliminates the setup timing for paths from the bftClk:<br/>
		/// set_false_path -setup -from bftClk<br/>
		/// The following example excludes paths between the two clocks from timing analysis:<br/>
		/// set_false_path -from [get_clocks GT0_RXUSRCLK2_OUT] \<br/>
		/// -to [get_clocks DRPCLK_OUT]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1618<br/>
		/// </para>
		/// </summary>
		/// <param name="setup">(Optional) Eliminate setup timing analysis for paths</param>
		/// <param name="hold">(Optional) Eliminate hold timing analysis for paths</param>
		/// <param name="rise">(Optional) Eliminate only rising delays for the defined paths</param>
		/// <param name="fall">(Optional) Eliminate only falling delays for the defined paths</param>
		/// <param name="reset_path">(Optional) Reset this path before setting false path</param>
		/// <param name="from">(Optional) List of path startpoints or clocks</param>
		/// <param name="rise_from">(Optional) Apply to paths rising from the list of startpoints or clocks</param>
		/// <param name="fall_from">(Optional) Apply to paths falling from the list of startpoints or clocks</param>
		/// <param name="to">(Optional) List of path endpoints or clocks</param>
		/// <param name="rise_to">(Optional) Apply to paths with rise transition at the list of endpoints or clocks</param>
		/// <param name="fall_to">(Optional) Apply to paths with fall transition at the list of endpoints or clocks</param>
		/// <param name="through">(Optional) List of through pins, cells or nets</param>
		/// <param name="rise_through">(Optional) Apply to paths rising through pins, cells or nets</param>
		/// <param name="fall_through">(Optional) Apply to paths falling through pins, cells or nets</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_false_path(bool? setup = null, bool? hold = null, bool? rise = null, bool? fall = null, bool? reset_path = null, TCLParameterList from = null, TCLParameterList rise_from = null, TCLParameterList fall_from = null, TCLParameterList to = null, TCLParameterList rise_to = null, TCLParameterList fall_to = null, TCLParameterList through = null, TCLParameterList rise_through = null, TCLParameterList fall_through = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_false_path [-setup] [-hold] [-rise] [-fall] [-reset_path] [-from <args>] [-rise_from <args>] [-fall_from <args>] [-to <args>] [-rise_to <args>] [-fall_to <args>] [-through <args>] [-rise_through <args>] [-fall_through <args>] [-quiet] [-verbose]
			this.Entry(_builder.set_false_path(setup, hold, rise, fall, reset_path, from, rise_from, fall_from, to, rise_to, fall_to, through, rise_through, fall_through, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Set hierarchical separator character<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_hierarchy_separator [-quiet] [-verbose] [&lt;separator&gt;]
		/// <br/>
		/// <para>
		/// Sets the character that will be used for separating levels of hierarchy in the design.<br/>
		/// Note: This command operates silently and does not return direct feedback of its operation<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// This example changes the hierarchy separator to the '|' character:<br/>
		/// set_hierarchy_separator |<br/>
		/// The following example restores the default hierarchy separator, '/':<br/>
		/// set_hierarchy_separator<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1621<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="separator">(Optional) Hierarchy separator character Default: /</param>
		public VivadoTCL set_hierarchy_separator(bool? quiet = null, bool? verbose = null, String separator = null)
		{
			// TCL Syntax: set_hierarchy_separator [-quiet] [-verbose] [<separator>]
			this.Entry(_builder.set_hierarchy_separator(quiet, verbose, separator));
			return this;
		}
		/// <summary>
		/// <para>
		/// Set the system monitor register value<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_hw_sysmon_reg [-quiet] [-verbose] &lt;hw_sysmon&gt; &lt;hexaddress&gt; &lt;hexdata&gt;
		/// <br/>
		/// <para>
		/// Set the system monitor register at the specified address to the hex value specified. This<br/>
		/// command identifies a register on the hw_sysmon on the current device through its hex address<br/>
		/// value, and sets the specified hex data value into that register.<br/>
		/// IMPORTANT! Some of the registers on the system monitor are read-only and cannot be set directly. This<br/>
		/// command has no effect if you try to set the value of a read-only register on the system monitor.<br/>
		/// The System Monitor (SYSMON) Analog-to-Digital Converter (ADC) is used to measure die<br/>
		/// temperature and voltage on the hw_device. The Sysmon monitors the physical environment via<br/>
		/// on-chip temperature and supply sensors. The ADC can access up to 17 external analog input<br/>
		/// channels.<br/>
		/// Data for the system monitor is stored in dedicated registers, called status and control registers,<br/>
		/// accessible through the get_hw_sysmon_reg and set_hw_sysmon_reg commands. Refer to<br/>
		/// the Register Interface in UltraScale Architecture System Monitor User Guide (UG580), or 7 Series<br/>
		/// FPGAs and Zynq-7000 SoC XADC Dual 12-Bit 1 MSPS Analog-to-Digital Converter User Guide<br/>
		/// (UG480) for more information on the addresses of specific system monitor registers.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Although the set_hw_sysmon_reg command lets you directly write the specified hex data<br/>
		/// value into the registers of a system monitor, the recommended procedure is to update the values<br/>
		/// of properties on the hw_sysmon object using the set_property command, and then write the<br/>
		/// property values to the hw_sysmon object using the commit_hw_sysmon command.<br/>
		/// The set_hw_sysmon_reg command writes the specified hex value to the hw_sysmon_reg<br/>
		/// object on the hw_sysmon object at the specified address but returns nothing, or returns an error<br/>
		/// if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1623<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_sysmon">(Required) hw_sysmon object</param>
		/// <param name="hexaddress">(Required) Hex address to write to</param>
		/// <param name="hexdata">(Required) Hex write value</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_hw_sysmon_reg(String hw_sysmon, String hexaddress, String hexdata, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_hw_sysmon_reg [-quiet] [-verbose] <hw_sysmon> <hexaddress> <hexdata>
			this.Entry(_builder.set_hw_sysmon_reg(hw_sysmon, hexaddress, hexdata, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Set input delay on ports<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_input_delay [-clock &lt;args&gt;] [-reference_pin &lt;args&gt;] [-clock_fall] [-rise] [-fall] [-max] [-min] [-add_delay] [-network_latency_included] [-source_latency_included] [-quiet] [-verbose] &lt;delay&gt; &lt;objects&gt;
		/// <br/>
		/// <para>
		/// TIP: The XDC &gt; Timing Constraints language templates and the Timing Constraints Wizard in the Vivado<br/>
		/// IDE offer timing diagrams and additional details around defining specific timing constraints. You can refer<br/>
		/// to these sources for additional information.<br/>
		/// Specifies the external system-level path delay on a primary input port relative to a clock edge at<br/>
		/// the interface of the design. The input delay value is specified in nanoseconds (ns), and can be<br/>
		/// positive or negative, depending on the clock and data relative phase at the interface of the<br/>
		/// device.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// To accurately model the system-level timing of your Xilinx FPGA design, you must assign timing<br/>
		/// delays for objects external to the FPGA onto the primary input or output ports in your design.<br/>
		/// These delays are defined by the set_input_delay and set_output_delay commands.<br/>
		/// IMPORTANT! If the input port also has a set_max_delay constraint assigned, the specified input<br/>
		/// delay value is considered part of the max_delay computation. That is, the input delay consumes a portion<br/>
		/// of the max delay on the timing path that includes the input port.<br/>
		/// This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example specifies the input delay on port DIN. The input delay is 3 and is relative<br/>
		/// to the rising edge of clock clk1:<br/>
		/// set_input_delay -clock clk1 3 DIN<br/>
		/// The following example specifies the input delay on port DIN. The input delay is 2 and is relative<br/>
		/// to the falling edge of the clock clk1:<br/>
		/// set_input_delay -clock_fall -clock clk1 2 DIN<br/>
		/// The following example specifies the input delay on port reset. The input delay is 2 and is relative<br/>
		/// to the rising edge of the clock that appears on the pin wbClk_IBUF_BUFG_inst/O, originating<br/>
		/// from the clock wbClk:<br/>
		/// set_input_delay -clock wbClk 2 -reference_pin \<br/>
		/// [get_pin wbClk_IBUF_BUFG_inst/O] reset<br/>
		/// This example creates a clock named clk_ddr, and defines input delay constraints from data<br/>
		/// launched by both rising and falling edges of the clock outside the device to the data input of the<br/>
		/// internal flip-flop that is sensitive to both rising and falling clock edges:<br/>
		/// create_clock -name clk_ddr -period 6 [get_ports DDR_CLK_IN]<br/>
		/// set_input_delay -clock clk_ddr -max 2.1 [get_ports DDR_IN]<br/>
		/// set_input_delay -clock clk_ddr -max 1.9 [get_ports DDR_IN] -clock_fall -<br/>
		/// add_delay<br/>
		/// set_input_delay -clock clk_ddr -min 0.9 [get_ports DDR_IN]<br/>
		/// set_input_delay -clock clk_ddr -min 1.1 [get_ports DDR_IN] -clock_fall -<br/>
		/// add_delay<br/>
		/// Note: The use of the -add_delay option allows the new min and max delay constraints to exist alongside<br/>
		/// the first delays on the same port.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example specifies the input delay on all non clock input ports of the design.<br/>
		/// Although all_inputs returns all ports of the design, including clock ports, set_input_delay will skip<br/>
		/// setting input delays on the clock ports. The input delay is 1 relative to the rising edge of the clock<br/>
		/// wbClk:<br/>
		/// set_input_delay -clock wbClk 1 [all_inputs]<br/>
		/// The following example sets an input delay of 4 relative to the rising edge of the clock wbClk on<br/>
		/// the ports reset and wbDataForInput:<br/>
		/// set_input_delay -clock wbClk 4 [list reset wbDataForInput]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1626<br/>
		/// </para>
		/// </summary>
		/// <param name="delay">(Required) Delay value</param>
		/// <param name="objects">(Required) List of ports</param>
		/// <param name="clock">(Optional) Relative clock</param>
		/// <param name="reference_pin">(Optional) Relative pin or port</param>
		/// <param name="clock_fall">(Optional) Delay is relative to falling edge of clock</param>
		/// <param name="rise">(Optional) Specifies rising delay</param>
		/// <param name="fall">(Optional) Specifies falling delay</param>
		/// <param name="max">(Optional) Specifies maximum delay</param>
		/// <param name="min">(Optional) Specifies minimum delay</param>
		/// <param name="add_delay">(Optional) Don't remove existing input delay</param>
		/// <param name="network_latency_included">(Optional) Specifies network latency of clock already included</param>
		/// <param name="source_latency_included">(Optional) Specifies source latency of clock already included</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_input_delay(String delay, String objects, TCLParameterList clock = null, TCLParameterList reference_pin = null, bool? clock_fall = null, bool? rise = null, bool? fall = null, bool? max = null, bool? min = null, bool? add_delay = null, bool? network_latency_included = null, bool? source_latency_included = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_input_delay [-clock <args>] [-reference_pin <args>] [-clock_fall] [-rise] [-fall] [-max] [-min] [-add_delay] [-network_latency_included] [-source_latency_included] [-quiet] [-verbose] <delay> <objects>
			this.Entry(_builder.set_input_delay(delay, objects, clock, reference_pin, clock_fall, rise, fall, max, min, add_delay, network_latency_included, source_latency_included, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Set input jitter for a clock object<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_input_jitter [-quiet] [-verbose] &lt;clock&gt; &lt;input_jitter&gt;
		/// <br/>
		/// <para>
		/// Use the set_input_jitter command to specify additional jitter for a specific primary clock.<br/>
		/// Input jitter is the difference between successive clock edges due to variation from the ideal<br/>
		/// arrival times. This command sets the input jitter in nanoseconds (ns) for a specified primary clock,<br/>
		/// defined with the create_clock command. Because the command accepts a single clock, the<br/>
		/// jitter for each primary clock must be set individually.<br/>
		/// You can only use the set_input_jitter command to specify input jitter on primary clocks.<br/>
		/// You cannot use the command to set input jitter on generated or auto derived clocks. Input jitter is<br/>
		/// propagated to generated clocks from the master clock, except for MMCM and PLL.<br/>
		/// The input jitter is used in the calculation of discrete jitter, which is the amount of jitter introduced<br/>
		/// by hardware primitives such as MMCM or PLL. Discrete jitter is a feature of clocks generated by<br/>
		/// the MMCM. See set_clock_uncertainty.<br/>
		/// The set_input_jitter command is ignored during synthesis.<br/>
		/// TIP: INPUT_JITTER is a property of primary clocks that can be returned by the get_property or<br/>
		/// report_property commands.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example sets an input jitter value of 0.3 ns on two clocks, sysClk and procClk.<br/>
		/// Although the jitter values are the same, you must use two set_input_jitter commands<br/>
		/// since the command only takes one clock as an argument:<br/>
		/// set_input_jitter sysClk 0.3<br/>
		/// set_input_jitter procClk 0.3<br/>
		/// The following example defines a primary clock, sysClk, and a generated clock, sysClkDiv2, that is<br/>
		/// a divide by two version of the primary clock. An input jitter of 0.15 ns is specified on the primary<br/>
		/// clock. The input jitter is automatically propagated to the generated clock:<br/>
		/// create_clock -period 10 -name sysClk [get_ports sysClk]<br/>
		/// create_generated_clock -name sysClkDiv2 -source [get_ports sysClk] \<br/>
		/// -divide_by 2 [get_pins clkgen/sysClkDiv/Q]<br/>
		/// set_input_jitter sysClk 0.15<br/>
		/// Note: In this example sysClkDiv2 is generated by a divider implemented with flip-flops, so the input jitter is<br/>
		/// propagated from the primary clock.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1630<br/>
		/// </para>
		/// </summary>
		/// <param name="clock">(Required) Clock</param>
		/// <param name="input_jitter">(Required) Input jitter: Value &gt;= 0</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>clock</returns>
		public VivadoTCL set_input_jitter(String clock, String input_jitter, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_input_jitter [-quiet] [-verbose] <clock> <input_jitter>
			this.Entry(_builder.set_input_jitter(clock, input_jitter, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Set capacitance on output ports and output pins<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_load [-rise] [-fall] [-max] [-min] [-quiet] [-verbose] &lt;capacitance&gt; &lt;objects&gt;
		/// <br/>
		/// <para>
		/// Sets the load capacitance on output ports to the specified value. The load capacitance is used<br/>
		/// during power analysis when running the report_power command, but is not used during<br/>
		/// timing analysis.<br/>
		/// TIP: The default unit of capacitance is picofarads (pF), but can be changed using the set_units<br/>
		/// command.<br/>
		/// This command operates silently and does not return direct feedback of its operation.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example sets the specified load capacitance value for all ports:<br/>
		/// set_load 5.5 [all_outputs]<br/>
		/// The following example sets the rising and falling edge load capacitance for the specified output<br/>
		/// ports:<br/>
		/// set_load -rise -fall 8 [get_ports wbOutput*]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1633<br/>
		/// </para>
		/// </summary>
		/// <param name="capacitance">(Required) Capacitance value</param>
		/// <param name="objects">(Required) List of output ports and output pins</param>
		/// <param name="rise">(Optional) Specify the rise capacitance value (for ports only)</param>
		/// <param name="fall">(Optional) Specify the fall capacitance value (for ports only)</param>
		/// <param name="max">(Optional) Specify the maximum capacitance value</param>
		/// <param name="min">(Optional) Specify the minimum capacitance value</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_load(String capacitance, String objects, bool? rise = null, bool? fall = null, bool? max = null, bool? min = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_load [-rise] [-fall] [-max] [-min] [-quiet] [-verbose] <capacitance> <objects>
			this.Entry(_builder.set_load(capacitance, objects, rise, fall, max, min, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Sets logic dc for input ports and input pins<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_logic_dc [-quiet] [-verbose] &lt;objects&gt;
		/// <br/>
		/// <para>
		/// Sets the specified input ports or input pins to a logic value of 'X', as unknown or don't care. This<br/>
		/// command is NOT supported in Synthesis.<br/>
		/// Note: This command operates silently and does not return direct feedback of its operation.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example sets the specified port to 'X':<br/>
		/// set_logic_dc [get_ports reset]<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1635<br/>
		/// </para>
		/// </summary>
		/// <param name="objects">(Required) List of input ports and input pins</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_logic_dc(String objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_logic_dc [-quiet] [-verbose] <objects>
			this.Entry(_builder.set_logic_dc(objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Sets logic one for input ports and input pins<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_logic_one [-quiet] [-verbose] &lt;objects&gt;
		/// <br/>
		/// <para>
		/// Sets the specified input ports or input pins to a logic one. This command is NOT supported in<br/>
		/// Synthesis.<br/>
		/// Note: This command operates silently and does not return direct feedback of its operation.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example sets the specified input port to a logic one:<br/>
		/// set_logic_one [get_ports reset]<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example sets the input ports reset and wbDataForInput to a logic one:<br/>
		/// set_logic_one [list [get_ports reset] [get_ports wbDataForInput]]<br/>
		/// The following example sets the input pin I on instance reset_IBUF to a logic one:<br/>
		/// set_logic_one [get_pins reset_IBUF_inst/I]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1637<br/>
		/// </para>
		/// </summary>
		/// <param name="objects">(Required) List of input ports and input pins</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_logic_one(String objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_logic_one [-quiet] [-verbose] <objects>
			this.Entry(_builder.set_logic_one(objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Sets logic unconnected for output ports and output pins<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_logic_unconnected [-quiet] [-verbose] &lt;objects&gt;
		/// <br/>
		/// <para>
		/// Defines the specified output ports or pins as unconnected.<br/>
		/// Note: This command operates silently and does not return direct feedback of its operation.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example sets the specified port to unconnected:<br/>
		/// set_logic_unconnected [get_ports OUT1]<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1639<br/>
		/// </para>
		/// </summary>
		/// <param name="objects">(Required) List of output ports and output pins</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_logic_unconnected(String objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_logic_unconnected [-quiet] [-verbose] <objects>
			this.Entry(_builder.set_logic_unconnected(objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Sets logic zero for input ports and input pins<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_logic_zero [-quiet] [-verbose] &lt;objects&gt;
		/// <br/>
		/// <para>
		/// Sets the specified input ports and input pins to a logic zero. This command is NOT supported in<br/>
		/// Synthesis.<br/>
		/// Note: This command operates silently and does not return direct feedback of its operation.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example sets the specified port to logic state 0:<br/>
		/// set_logic_zero [get_ports reset]<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1641<br/>
		/// </para>
		/// </summary>
		/// <param name="objects">(Required) List of input ports and input pins</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_logic_zero(String objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_logic_zero [-quiet] [-verbose] <objects>
			this.Entry(_builder.set_logic_zero(objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Specify maximum delay for timing paths<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_max_delay [-rise] [-fall] [-reset_path] [-from &lt;args&gt;] [-rise_from &lt;args&gt;] [-fall_from &lt;args&gt;] [-to &lt;args&gt;] [-rise_to &lt;args&gt;] [-fall_to &lt;args&gt;] [-through &lt;args&gt;] [-rise_through &lt;args&gt;] [-fall_through &lt;args&gt;] [-datapath_only] [-quiet] [-verbose] &lt;delay&gt;
		/// <br/>
		/// <para>
		/// TIP: The XDC &gt; Timing Constraints language templates and the Timing Constraints Wizard in the Vivado<br/>
		/// IDE offer timing diagrams and additional details around defining specific timing constraints. You can refer<br/>
		/// to these sources for additional information.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Sets the maximum delay allowed on a timing path, specified in nanoseconds (ns). The specified<br/>
		/// delay value is assigned to both the rising and falling edges of the defined timing paths unless the<br/>
		/// -rise or -fall arguments are specified.<br/>
		/// The maximum rising and falling delay cannot be less than the minimum rising and falling delay on<br/>
		/// the same path, as defined by the set_min_delay command. If this happens, the first assigned<br/>
		/// constraint is removed from the timing path as a conflict, and the delay value specified by the<br/>
		/// removed constraint is set to 0.<br/>
		/// The delay value must be assigned to a timing path as defined by at least one -from, -through,<br/>
		/// or -to argument. A general path delay such as -to endpoint will be over written by a more<br/>
		/// specific path definition such as -from/-to, or -from/-through/-to path definition.<br/>
		/// IMPORTANT! When assigned to a primary input or output port, any system-level delay consumes a<br/>
		/// portion of the max delay on the timing path that includes the input or output port. That is, the delay<br/>
		/// specified by set_input_delay or set_output_delay is considered part of the maximum delay.<br/>
		/// This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example defines a maximum delay of 60 ns between all the input and output ports<br/>
		/// (feedthrough paths):<br/>
		/// set_max_delay 60 -from [all_inputs] -to [all_outputs]<br/>
		/// The following example clears the existing max delay and specifies a new &gt; maximum delay for<br/>
		/// paths to endpoints clocked by the specified clock:<br/>
		/// set_max_delay -reset_path 50 -to [get_clocks spi_clk]<br/>
		/// The set_max_delay command is often used with -datapath_only to constrain asynchronous clock<br/>
		/// domains crossing when a simple synchronizer is used on the destination clock domain. In the<br/>
		/// following example, two flops (FF1 and FF2) are clocked by different clocks, and FF1/Q connects<br/>
		/// directly to FF2/D through net1. To limit the delay on this connection to 4.0 ns use the following<br/>
		/// constraints:<br/>
		/// set_max_delay -from FF1/C -to FF2/D -datapath_only 4.0<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1643<br/>
		/// </para>
		/// </summary>
		/// <param name="delay">(Required) Delay value</param>
		/// <param name="rise">(Optional) Delay value applies to rising path delays</param>
		/// <param name="fall">(Optional) Delay value applies to falling path delays</param>
		/// <param name="reset_path">(Optional) Reset this path before setting max delay</param>
		/// <param name="from">(Optional) List of path startpoints or clocks</param>
		/// <param name="rise_from">(Optional) Apply to paths rising from the list of startpoints or clocks</param>
		/// <param name="fall_from">(Optional) Apply to paths falling from the list of startpoints or clocks</param>
		/// <param name="to">(Optional) List of path endpoints or clocks</param>
		/// <param name="rise_to">(Optional) Apply to paths with rise transition at the list of endpoints or clocks</param>
		/// <param name="fall_to">(Optional) Apply to paths with fall transition at the list of endpoints or clocks</param>
		/// <param name="through">(Optional) List of through pins, cells or nets</param>
		/// <param name="rise_through">(Optional) Apply to paths rising through pins, cells or nets</param>
		/// <param name="fall_through">(Optional) Apply to paths falling through pins, cells or nets</param>
		/// <param name="datapath_only">(Optional) Remove clock skew and jitter from calculation</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_max_delay(String delay, bool? rise = null, bool? fall = null, bool? reset_path = null, TCLParameterList from = null, TCLParameterList rise_from = null, TCLParameterList fall_from = null, TCLParameterList to = null, TCLParameterList rise_to = null, TCLParameterList fall_to = null, TCLParameterList through = null, TCLParameterList rise_through = null, TCLParameterList fall_through = null, bool? datapath_only = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_max_delay [-rise] [-fall] [-reset_path] [-from <args>] [-rise_from <args>] [-fall_from <args>] [-to <args>] [-rise_to <args>] [-fall_to <args>] [-through <args>] [-rise_through <args>] [-fall_through <args>] [-datapath_only] [-quiet] [-verbose] <delay>
			this.Entry(_builder.set_max_delay(delay, rise, fall, reset_path, from, rise_from, fall_from, to, rise_to, fall_to, through, rise_through, fall_through, datapath_only, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Limit time borrowing for latches<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_max_time_borrow [-quiet] [-verbose] &lt;delay&gt; &lt;objects&gt;
		/// <br/>
		/// <para>
		/// Sets the maximum amount of time in nanoseconds that can be borrowed between nets when<br/>
		/// analyzing the timing on latches.<br/>
		/// Note: This command operates silently and does not return direct feedback of its operation.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example specifies that the latches attached to "all clocks" will be allowed 0 time<br/>
		/// units of borrowing. Effectively, this disables time borrowing throughout the entire design.<br/>
		/// set_max_time_borrow 0.0 [all_clocks]<br/>
		/// The following example specifies that nets in the top level of hierarchy are allowed 20 time units<br/>
		/// of time borrowing:<br/>
		/// set_max_time_borrow 20 {top/*}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1647<br/>
		/// </para>
		/// </summary>
		/// <param name="delay">(Required) Delay value: Value &gt;= 0</param>
		/// <param name="objects">(Required) List of clocks, cells, data pins or clock pins</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_max_time_borrow(String delay, String objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_max_time_borrow [-quiet] [-verbose] <delay> <objects>
			this.Entry(_builder.set_max_time_borrow(delay, objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Specify minimum delay for timing paths<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_min_delay [-rise] [-fall] [-reset_path] [-from &lt;args&gt;] [-rise_from &lt;args&gt;] [-fall_from &lt;args&gt;] [-to &lt;args&gt;] [-rise_to &lt;args&gt;] [-fall_to &lt;args&gt;] [-through &lt;args&gt;] [-rise_through &lt;args&gt;] [-fall_through &lt;args&gt;] [-quiet] [-verbose] &lt;delay&gt;
		/// <br/>
		/// <para>
		/// Sets the minimum delay allowed on a timing path, specified in nanoseconds (ns). The specified<br/>
		/// delay value is assigned to both the rising and falling edges of the defined timing paths unless the<br/>
		/// -rise or -fall arguments are specified.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// IMPORTANT! The minimum rising and falling delay cannot be greater than the maximum rising and<br/>
		/// falling delay on the same path. If this happens, the first assigned delay value is removed from the timing<br/>
		/// path and reset to 0.<br/>
		/// The delay value must be assigned to a timing path as defined by at least one -from, -through,<br/>
		/// or -to argument. A general path delay such as -to endpoint will be over written by a more<br/>
		/// specific path definition such as -from/-to, or -from/-through/-to path definition.<br/>
		/// This command operates silently and does not return direct feedback of its operation.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example specifies a minimum delay of 20ns between the primary input and output<br/>
		/// ports (combinational/feedthrough paths):<br/>
		/// set_min_delay 20 -from [all_inputs] -to [all_outputs]<br/>
		/// The following example defines a minimum delay of 20ns for timing paths with endpoints at all<br/>
		/// primary output ports:<br/>
		/// set_min_delay 20 -to [get_ports -filter {DIRECTION == out}]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1649<br/>
		/// </para>
		/// </summary>
		/// <param name="delay">(Required) Delay value</param>
		/// <param name="rise">(Optional) Delay value applies to rising path delays</param>
		/// <param name="fall">(Optional) Delay value applies to falling path delays</param>
		/// <param name="reset_path">(Optional) Reset this path before setting min delay</param>
		/// <param name="from">(Optional) List of path startpoints or clocks</param>
		/// <param name="rise_from">(Optional) Apply to paths rising from the list of startpoints or clocks</param>
		/// <param name="fall_from">(Optional) Apply to paths falling from the list of startpoints or clocks</param>
		/// <param name="to">(Optional) List of path endpoints or clocks</param>
		/// <param name="rise_to">(Optional) Apply to paths with rise transition at the list of endpoints or clocks</param>
		/// <param name="fall_to">(Optional) Apply to paths with fall transition at the list of endpoints or clocks</param>
		/// <param name="through">(Optional) List of through pins, cells or nets</param>
		/// <param name="rise_through">(Optional) Apply to paths rising through pins, cells or nets</param>
		/// <param name="fall_through">(Optional) Apply to paths falling through pins, cells or nets</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_min_delay(String delay, bool? rise = null, bool? fall = null, bool? reset_path = null, TCLParameterList from = null, TCLParameterList rise_from = null, TCLParameterList fall_from = null, TCLParameterList to = null, TCLParameterList rise_to = null, TCLParameterList fall_to = null, TCLParameterList through = null, TCLParameterList rise_through = null, TCLParameterList fall_through = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_min_delay [-rise] [-fall] [-reset_path] [-from <args>] [-rise_from <args>] [-fall_from <args>] [-to <args>] [-rise_to <args>] [-fall_to <args>] [-through <args>] [-rise_through <args>] [-fall_through <args>] [-quiet] [-verbose] <delay>
			this.Entry(_builder.set_min_delay(delay, rise, fall, reset_path, from, rise_from, fall_from, to, rise_to, fall_to, through, rise_through, fall_through, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Configure how the Vivado tool will display and manage specific messages, based on message ID,<br/>
		/// string, or severity.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_msg_config [-id &lt;arg&gt;] [-string &lt;args&gt;] [-severity &lt;arg&gt;] [-limit &lt;arg&gt;] [-new_severity &lt;arg&gt;] [-suppress] [-regexp] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// This command lets you configure the messages returned by the Vivado tool in the current<br/>
		/// project. Use this command to change the severity of messages, to limit the number of times a<br/>
		/// message is reported, or to suppress the message altogether. However, you can only perform one<br/>
		/// of these actions at one time with set_msg_config:<br/>
		/// • Customize the severity of messages returned by the tool to specific levels appropriate to your<br/>
		/// usage. For instance, set the severity of a specified message ID from one type, such as<br/>
		/// WARNING, to another type, such as ERROR.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// IMPORTANT! You cannot downgrade a Vivado Design System ERROR message to make it less than an<br/>
		/// error.<br/>
		/// • Define the number of messages that will be returned by the tool during a design session, or<br/>
		/// single invocation. You can specify the limit of a specific message ID, or the limit for a specific<br/>
		/// severity of messages.<br/>
		/// TIP: The default message limit for all message IDs is set to 100, and is defined by the parameter<br/>
		/// messaging.defaultLimit . This is the limit applied to each separate message returned by the<br/>
		/// tool. You can report the current value of this parameter with the get_param command, and change it<br/>
		/// as needed using the set_param command.<br/>
		/// • Suppress a specific message ID from being reported by the tool at all. You can enable<br/>
		/// messages that were previously suppressed using the reset_msg_config command.<br/>
		/// • An error is returned if more than one action is attempted in a single set_msg_config<br/>
		/// command.<br/>
		/// Message qualifiers of string, ID, and severity are used to determine which messages are<br/>
		/// configured by the set_msg_config command. You must supply at least one message qualifier<br/>
		/// to identify a message or group of messages to apply the command to. Multiple qualifiers have an<br/>
		/// AND relationship; the configuration rule will be applied only to messages matching all qualifiers.<br/>
		/// TIP: set_msg_config does not support the use of wildcards in message qualifiers.<br/>
		/// Message configuration rules are project specific, and are persistent with the project when the<br/>
		/// project is closed and reopened.<br/>
		/// IMPORTANT! Message configuration rules apply to the current project and are passed automatically to<br/>
		/// subordinate processes, such as synthesis and implementation runs. Do not use set_msg_config in pre<br/>
		/// and post Tcl scripts.<br/>
		/// Use the get_msg_config command to report the current configuration of a specific message,<br/>
		/// or the configuration rules defined in the current project. Restore messages to their default<br/>
		/// configurations using the reset_msg_config command.<br/>
		/// The set_msg_config command is not supported by report_cdc as that command does not<br/>
		/// generate messages through the message manager.<br/>
		/// This command returns nothing if successful, or returns an error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example elevates a common INFO message to a Critical Warning:<br/>
		/// set_msg_config -id {[Common 17-81]} -new_severity "CRITICAL WARNING"<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// IMPORTANT! In the following example the "Common 17-69" message is an ERROR message, and cannot<br/>
		/// be downgraded from an ERROR. The command in this example appears to work when run from the Tcl<br/>
		/// console, however it will not result in any change.<br/>
		/// set_msg_config -id {[Common 17-69]} -new_severity WARNING<br/>
		/// When the "Common 17-69" message is next thrown by the Vivado tool, a warning message is returned<br/>
		/// stating that an error cannot be downgraded, and the message is thrown as an ERROR:<br/>
		/// WARNING: [Common 17-239] ERROR Messages are prohibited to be<br/>
		/// downgraded.<br/>
		/// Message 'Common 17-69' is not downgraded.<br/>
		/// ERROR: [Common 17-69] Command failed: report_design_analysis<br/>
		/// -critical_paths can be run only after synthesis has successfully<br/>
		/// completed.<br/>
		/// The following example results in warning messages with message ID "17-35", and containing "clk"<br/>
		/// in the message, being redefined as Error messages:<br/>
		/// set_msg_config -severity warning -string "clk" -id "17-35" \<br/>
		/// -new_severity error<br/>
		/// This example changes the severity of messages with the specified message ID, gets the current<br/>
		/// message configuration rules, and then shows two different command forms to reset the specific<br/>
		/// rule and restore the message:<br/>
		/// set_msg_config -id "Common 17-361" -severity INFO -new_severity WARNING<br/>
		/// get_msg_config -rules<br/>
		/// ---------------------<br/>
		/// Message control rules currently in effect are:<br/>
		/// Rule Name Rule Current<br/>
		/// Message Count<br/>
		/// 1 set_msg_config -ruleid {1} -id {Common 17-361} -severity {INFO} -<br/>
		/// new_severity {WARNING} 0<br/>
		/// ---------------------<br/>
		/// reset_msg_config -id "Common 17-361" -default_severity<br/>
		/// reset_msg_config -ruleid {1}<br/>
		/// TIP: In the preceding example, only one of the reset_msg_config commands is needed to reset the<br/>
		/// message.<br/>
		/// This example shows the use of a parameter to change the default message limit, and then defines<br/>
		/// a new limit for the specified message id:<br/>
		/// get_param messaging.defaultLimit<br/>
		/// 100<br/>
		/// set_param messaging.defaultLimit 1000<br/>
		/// set_msg_config -id {[Common 17-81]} -limit 1500<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1652<br/>
		/// </para>
		/// </summary>
		/// <param name="id">
		/// <para>
		/// (Optional)<br/>
		/// A qualifier, apply the selected operation only to messages<br/>
		/// that match given message id. Example: '-id {Common<br/>
		/// 17-35}'. Default: match any id<br/>
		/// </para>
		/// </param>
		/// <param name="string">
		/// <para>
		/// (Optional)<br/>
		/// A qualifier, apply the selected operation only to messages<br/>
		/// that contain the given list of strings. Default: none<br/>
		/// </para>
		/// </param>
		/// <param name="severity">
		/// <para>
		/// (Optional)<br/>
		/// A qualifier, apply the selected operation only to messages at<br/>
		/// the given severity level. Example: '-severity INFO' Default:<br/>
		/// match any severity<br/>
		/// </para>
		/// </param>
		/// <param name="limit">
		/// <para>
		/// (Optional)<br/>
		/// for the messages that match the qualifiers, limit the number<br/>
		/// of messages displayed to the given integer value. Can only<br/>
		/// be used in conjunction with one of -id or -severity.<br/>
		/// </para>
		/// </param>
		/// <param name="new_severity">
		/// <para>
		/// (Optional)<br/>
		/// for the messages that match the qualifiers, change the<br/>
		/// severity to the given value for the current project<br/>
		/// </para>
		/// </param>
		/// <param name="suppress">
		/// <para>
		/// (Optional)<br/>
		/// for the messages that match the qualifiers, suppress (do not<br/>
		/// display) any messages for the current project<br/>
		/// </para>
		/// </param>
		/// <param name="regexp">(Optional) The values used for -string are full regular expressions</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_msg_config(String id = null, TCLParameterList @string = null, String severity = null, Int32? limit = null, String new_severity = null, bool? suppress = null, bool? regexp = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_msg_config [-id <arg>] [-string <args>] [-severity <arg>] [-limit <arg>] [-new_severity <arg>] [-suppress] [-regexp] [-quiet] [-verbose]
			this.Entry(_builder.set_msg_config(id, @string, severity, limit, new_severity, suppress, regexp, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Define multicycle path<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_multicycle_path [-setup] [-hold] [-rise] [-fall] [-start] [-end] [-reset_path] [-from &lt;args&gt;] [-rise_from &lt;args&gt;] [-fall_from &lt;args&gt;] [-to &lt;args&gt;] [-rise_to &lt;args&gt;] [-fall_to &lt;args&gt;] [-through &lt;args&gt;] [-rise_through &lt;args&gt;] [-fall_through &lt;args&gt;] [-quiet] [-verbose] &lt;path_multiplier&gt;
		/// <br/>
		/// <para>
		/// By default, the Vivado timing engine performs a single-cycle analysis, in which the setup check is<br/>
		/// performed at the destination on the capture edge, one clock cycle after the edge of the source<br/>
		/// clock. However, this may not be appropriate for certain timing paths. The most common example<br/>
		/// is a logic path that requires more than one clock cycle for the data to stabilize at the endpoint.<br/>
		/// The set_multicycle_path command lets you choose a path multiplier, N, to establish a<br/>
		/// timing path that takes N clock cycles from the start clock edge to the capture clock edge. The<br/>
		/// path multiplier defines the total number of clock cycles required for propagation of a signal from<br/>
		/// its origin to destination when that propagation is longer than a single clock cycle. For more<br/>
		/// information on the use of this command, refer to the Vivado Design Suite User Guide: Using<br/>
		/// Constraints (UG903).<br/>
		/// The set_multicycle_path command is used to specify path multipliers for setup and hold<br/>
		/// analysis, for rising and/or falling edges, with respect to the source clock or the destination clock.<br/>
		/// This command includes three elements:<br/>
		/// • The specification of the setup and hold analysis affected by the multicycle path.<br/>
		/// • The definition of the timing paths to which the multicycle path applies.<br/>
		/// • The path multiplier defining the number of clock cycles to apply to the timing analysis.<br/>
		/// By default the path multiplier applies to both the setup and hold analysis. The hold analysis is<br/>
		/// derived from the setup analysis, so it is moved along with the setup analysis. If the path multiplier<br/>
		/// moves the setup check N clock cycles, it moves the hold check N-1 clock cycles. However, this<br/>
		/// often results in hold timing failures.<br/>
		/// You can use a second set_multicycle_path command with the -hold option to restore the<br/>
		/// hold analysis to its original location. When the -hold option is specified the &lt;path_multiplier&gt;<br/>
		/// acts on the hold relationship to restore the hold check to its original position. For instance, the<br/>
		/// following command sequence extends the setup check for 3 clock cycles, and consequently<br/>
		/// extends the hold check by two clock cycles (N-1). The second command restores the hold check<br/>
		/// to its original position:<br/>
		/// set_multicycle_path 3 -from {usbEngine1/u4/csr_reg[26]/C} \<br/>
		/// -to {usbEngine1/u1/u2/sizd_c_reg[12]/D}<br/>
		/// set_multicycle_path 2 -from {usbEngine1/u4/csr_reg[26]/C} \<br/>
		/// -to {usbEngine1/u1/u2/sizd_c_reg[12]/D} -hold<br/>
		/// By default, the setup path multiplier is applied with respect to the destination clock, and the hold<br/>
		/// path multiplier is applied with respect to the source clock. Use the -start or -end options to<br/>
		/// change the default setup or hold analysis with respect to the source or destination clocks.<br/>
		/// This command operates silently when successful, or returns an error if the command fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example establishes a path multiplier of 3 clock cycles for the setup check of the<br/>
		/// timing path defined by the -from/-to options. A path multiplier of N-1, or 2 in this example, is<br/>
		/// used to decrement the hold check on the same timing path:<br/>
		/// set_multicycle_path 3 -setup -from [get_pins data0_reg/C] \<br/>
		/// -to [get_pins data1_reg/D]<br/>
		/// set_multicycle_path 2 -hold -from [get_pins data0_reg/C] \<br/>
		/// -to [get_pins data1_reg/D]<br/>
		/// Note: For more information on the relationship between the setup and hold analysis refer to the Vivado<br/>
		/// Design Suite User Guide: Using Constraints (UG903).<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1658<br/>
		/// </para>
		/// </summary>
		/// <param name="path_multiplier">(Required) Number of cycles</param>
		/// <param name="setup">(Optional) Only setup multiplier is set</param>
		/// <param name="hold">(Optional) Only hold multiplier is set</param>
		/// <param name="rise">(Optional) Multiplier valid for rising delays on path endpoint</param>
		/// <param name="fall">(Optional) Multiplier valid for falling delays on path endpoint</param>
		/// <param name="start">(Optional) Multiplier measured against path startpoint</param>
		/// <param name="end">(Optional) Multiplier measured against path endpoint</param>
		/// <param name="reset_path">(Optional) Reset this path before setting multicycle</param>
		/// <param name="from">(Optional) List of path startpoints or clocks</param>
		/// <param name="rise_from">(Optional) Apply to paths rising from the list of startpoints or clocks</param>
		/// <param name="fall_from">(Optional) Apply to paths falling from the list of startpoints or clocks</param>
		/// <param name="to">(Optional) List of path endpoints or clocks</param>
		/// <param name="rise_to">(Optional) Apply to paths with rise transition at the list of endpoints or clocks</param>
		/// <param name="fall_to">(Optional) Apply to paths with fall transition at the list of endpoints or clocks</param>
		/// <param name="through">(Optional) List of through pins, cells or nets</param>
		/// <param name="rise_through">(Optional) Apply to paths rising through pins, cells or nets</param>
		/// <param name="fall_through">(Optional) Apply to paths falling through pins, cells or nets</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_multicycle_path(Int32 path_multiplier, bool? setup = null, bool? hold = null, bool? rise = null, bool? fall = null, bool? start = null, bool? end = null, bool? reset_path = null, TCLParameterList from = null, TCLParameterList rise_from = null, TCLParameterList fall_from = null, TCLParameterList to = null, TCLParameterList rise_to = null, TCLParameterList fall_to = null, TCLParameterList through = null, TCLParameterList rise_through = null, TCLParameterList fall_through = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_multicycle_path [-setup] [-hold] [-rise] [-fall] [-start] [-end] [-reset_path] [-from <args>] [-rise_from <args>] [-fall_from <args>] [-to <args>] [-rise_to <args>] [-fall_to <args>] [-through <args>] [-rise_through <args>] [-fall_through <args>] [-quiet] [-verbose] <path_multiplier>
			this.Entry(_builder.set_multicycle_path(path_multiplier, setup, hold, rise, fall, start, end, reset_path, from, rise_from, fall_from, to, rise_to, fall_to, through, rise_through, fall_through, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Set operating conditions for power estimation<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_operating_conditions [-voltage &lt;args&gt;] [-grade &lt;arg&gt;] [-process &lt;arg&gt;] [-junction_temp &lt;arg&gt;] [-ambient_temp &lt;arg&gt;] [-thetaja &lt;arg&gt;] [-thetasa &lt;arg&gt;] [-airflow &lt;arg&gt;] [-heatsink &lt;arg&gt;] [-thetajb &lt;arg&gt;] [-board &lt;arg&gt;] [-board_temp &lt;arg&gt;] [-board_layers &lt;arg&gt;] [-design_power_budget &lt;arg&gt;] [-supply_current_budget &lt;args&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Sets the real-world operating conditions that are used when performing analysis of the design.<br/>
		/// The environmental operating conditions of the device are used for power analysis when running<br/>
		/// the report_power command.<br/>
		/// Note: This command operates silently and does not return direct feedback of its operation.<br/>
		/// Operating conditions can be restored to their default values with the use of the<br/>
		/// reset_operating_conditions command.<br/>
		/// Current operating conditions can be reported with the report_operating_conditions<br/>
		/// command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example specifies an industrial grade device with an ambient operating<br/>
		/// temperature of 75 degrees C:<br/>
		/// set_operating_conditions -grade industrial -ambient_temp 75<br/>
		/// The following example sets the supply voltage Vccaux to a value of 1.9:<br/>
		/// set_operating_conditions -voltage {Vccaux 1.89}<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example sets the manufacturing process corner to maximum:<br/>
		/// set_operating_conditions -process maximum<br/>
		/// The following example sets the manufacturing process corner to maximum and the voltage<br/>
		/// supply Vccint to 0.875:<br/>
		/// set_operating_conditions -process maximum -voltage {Vccint 0.875}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1663<br/>
		/// </para>
		/// </summary>
		/// <param name="voltage">
		/// <para>
		/// (Optional)<br/>
		/// List of voltage pairs, e.g., {name value}. Supported voltage<br/>
		/// supplies vary by family.<br/>
		/// </para>
		/// </param>
		/// <param name="grade">
		/// <para>
		/// (Optional)<br/>
		/// Temperature grade. Supported values vary by family.<br/>
		/// Default: commercial<br/>
		/// </para>
		/// </param>
		/// <param name="process">(Optional) Process data: typical or maximum Default: typical</param>
		/// <param name="junction_temp">(Optional) Junction Temperature (C): auto|degC Default: auto</param>
		/// <param name="ambient_temp">(Optional) Ambient Temperature (C): default|degC Default: default</param>
		/// <param name="thetaja">(Optional) ThetaJA (C/W): auto|degC/W Default: auto</param>
		/// <param name="thetasa">(Optional) ThetaSA (C/W): auto|degC/W Default: auto</param>
		/// <param name="airflow">(Optional) Airflow (LFM): 0 to 750 Default: varies by family</param>
		/// <param name="heatsink">
		/// <para>
		/// (Optional)<br/>
		/// Dimensions of heatsink: none, low, medium, high, custom<br/>
		/// Default: medium<br/>
		/// </para>
		/// </param>
		/// <param name="thetajb">(Optional) ThetaJB (C/W): auto|degC/W Default: auto</param>
		/// <param name="board">(Optional) Board type: jedec, small, medium, large, custom Default: medium</param>
		/// <param name="board_temp">(Optional) Board Temperature degC</param>
		/// <param name="board_layers">(Optional) Board layers: 4to7, 8to11, 12to15, 16+ Default: 8to11</param>
		/// <param name="design_power_budget">(Optional) Design Power Budget (W) Default: Unspecified</param>
		/// <param name="supply_current_budget">
		/// <para>
		/// (Optional)<br/>
		/// Sets list of supply current budget 'name value' pairs.<br/>
		/// Supported voltage supplies vary by family.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_operating_conditions(TCLParameterList voltage = null, String grade = null, String process = null, String junction_temp = null, String ambient_temp = null, String thetaja = null, String thetasa = null, String airflow = null, String heatsink = null, String thetajb = null, String board = null, String board_temp = null, String board_layers = null, String design_power_budget = null, TCLParameterList supply_current_budget = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_operating_conditions [-voltage <args>] [-grade <arg>] [-process <arg>] [-junction_temp <arg>] [-ambient_temp <arg>] [-thetaja <arg>] [-thetasa <arg>] [-airflow <arg>] [-heatsink <arg>] [-thetajb <arg>] [-board <arg>] [-board_temp <arg>] [-board_layers <arg>] [-design_power_budget <arg>] [-supply_current_budget <args>] [-quiet] [-verbose]
			this.Entry(_builder.set_operating_conditions(voltage, grade, process, junction_temp, ambient_temp, thetaja, thetasa, airflow, heatsink, thetajb, board, board_temp, board_layers, design_power_budget, supply_current_budget, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Set output delay on ports<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_output_delay [-clock &lt;args&gt;] [-reference_pin &lt;args&gt;] [-clock_fall] [-rise] [-fall] [-max] [-min] [-add_delay] [-network_latency_included] [-source_latency_included] [-quiet] [-verbose] &lt;delay&gt; &lt;objects&gt;
		/// <br/>
		/// <para>
		/// TIP: The XDC &gt; Timing Constraints language templates and the Timing Constraints Wizard in the Vivado<br/>
		/// IDE offer timing diagrams and additional details around defining specific timing constraints. You can refer<br/>
		/// to these sources for additional information.<br/>
		/// Specifies the external system-level path delay on a primary output port relative to a clock edge at<br/>
		/// the interface of the design. The output delay value is specified in nanoseconds (ns), and can be<br/>
		/// positive or negative, depending on the clock and data relative phase outside the FPGA device.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// To accurately model the system-level timing of your Xilinx FPGA design, you must assign timing<br/>
		/// delays for objects external to the FPGA onto the primary input or output ports in your design.<br/>
		/// These delays are defined by the set_input_delay and set_output_delay commands.<br/>
		/// IMPORTANT! If the output port also has a set_max_delay constraint assigned, the specified output<br/>
		/// delay value is considered part of the max_delay computation. That is, the output delay consumes a portion<br/>
		/// of the max delay on the timing path that includes the output port.<br/>
		/// This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example sets an output delay on ports relative to the specified clock:<br/>
		/// set_output_delay 5.0 -clock [get_clocks cpuClk] [get_ports]<br/>
		/// The next example is the same as the prior example except that network latency is now included:<br/>
		/// set_output_delay 5.0 -clock [get_clocks cpuClk] \<br/>
		/// -network_latency_included [get_ports]<br/>
		/// This example creates a clock named clk_ddr, and defines output delay constraints from data<br/>
		/// launched by both rising and falling edges of the clock outside the device to the data output of<br/>
		/// the internal flip-flop that is sensitive to both rising and falling clock edges:<br/>
		/// create_clock -name clk_ddr -period 6 [get_ports DDR_CLK_IN]<br/>
		/// set_output_delay -clock clk_ddr -max 2.1 [get_ports DDR_OUT]<br/>
		/// set_output_delay -clock clk_ddr -max 1.9 [get_ports DDR_OUT] -clock_fall -<br/>
		/// add_delay<br/>
		/// set_output_delay -clock clk_ddr -min 0.9 [get_ports DDR_OUT]<br/>
		/// set_output_delay -clock clk_ddr -min 1.1 [get_ports DDR_OUT] -clock_fall -<br/>
		/// add_delay<br/>
		/// Note: The use of the -add_delay option allows the new min and max delay constraints to exist alongside<br/>
		/// the first delays on the same port.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1667<br/>
		/// </para>
		/// </summary>
		/// <param name="delay">(Required) Delay value</param>
		/// <param name="objects">(Required) List of ports</param>
		/// <param name="clock">(Optional) Relative clock</param>
		/// <param name="reference_pin">(Optional) Relative pin or port</param>
		/// <param name="clock_fall">(Optional) Delay is relative to falling edge of clock</param>
		/// <param name="rise">(Optional) Specifies rising delay</param>
		/// <param name="fall">(Optional) Specifies falling delay</param>
		/// <param name="max">(Optional) Specifies maximum delay</param>
		/// <param name="min">(Optional) Specifies minimum delay</param>
		/// <param name="add_delay">(Optional) Don't remove existing input delay</param>
		/// <param name="network_latency_included">(Optional) Specifies network latency of clock already included</param>
		/// <param name="source_latency_included">(Optional) Specifies source latency of clock already included</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_output_delay(String delay, String objects, TCLParameterList clock = null, TCLParameterList reference_pin = null, bool? clock_fall = null, bool? rise = null, bool? fall = null, bool? max = null, bool? min = null, bool? add_delay = null, bool? network_latency_included = null, bool? source_latency_included = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_output_delay [-clock <args>] [-reference_pin <args>] [-clock_fall] [-rise] [-fall] [-max] [-min] [-add_delay] [-network_latency_included] [-source_latency_included] [-quiet] [-verbose] <delay> <objects>
			this.Entry(_builder.set_output_delay(delay, objects, clock, reference_pin, clock_fall, rise, fall, max, min, add_delay, network_latency_included, source_latency_included, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Set user columns on one or more package pins<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_package_pin_val [-quiet] [-verbose] &lt;column&gt; &lt;value&gt; &lt;package_pins&gt;...
		/// <br/>
		/// <para>
		/// Create user-defined package pin attributes and assign values to specific pins on the package.<br/>
		/// User-defined pin attributes can be defined in a CSV file and imported into an I/O Pin Planning<br/>
		/// project using read_csv, or can be edited in the project using this command.<br/>
		/// Note: Use the set_property command to set tool-defined properties of a package pin.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates a new user-defined column in the Package Pins view, and assigns<br/>
		/// the value true to the specified pin:<br/>
		/// set_package_pin_val -column track1 -value true -package_pins AK27<br/>
		/// The following example creates a user-defined column called Test, then assigns the value RED to<br/>
		/// all "AK" package pins, then changes the value to GREEN for the three specified pins:<br/>
		/// set_package_pin_val -column Test -value RED \<br/>
		/// -package_pins [get_package_pins AK*]<br/>
		/// set_package_pin_val -column Test -value GREEN \<br/>
		/// -package_pins {AK1 AK2 AK3}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1670<br/>
		/// </para>
		/// </summary>
		/// <param name="column">(Required) User column name</param>
		/// <param name="value">(Required) Value to set</param>
		/// <param name="package_pins">(Required) Package pin names</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_package_pin_val(String column, String value, TCLParameterList package_pins, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_package_pin_val [-quiet] [-verbose] <column> <value> <package_pins>...
			this.Entry(_builder.set_package_pin_val(column, value, package_pins, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Set a parameter value<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_param [-quiet] [-verbose] &lt;name&gt; &lt;value&gt;
		/// <br/>
		/// <para>
		/// Sets the value of a user-definable configuration parameter. These parameters configure and<br/>
		/// control various behaviors of the tool. Refer to report_param for a description of currently<br/>
		/// defined parameters.<br/>
		/// As an example, a specific param that can be defined is the general.maxThreads parameter<br/>
		/// for the Vivado Design Suite. On multiprocessor systems, the Vivado Design Suite use multi-threading to speed up certain processes, including DRC reporting, static timing analysis,<br/>
		/// placement, and routing. A default limit applies to all tasks and is based on the operating system.<br/>
		/// For Windows systems, the default is 2; for Linux systems the default is 8. The limit can be<br/>
		/// changed as follows:<br/>
		/// set_param general.maxThreads &lt;value&gt;<br/>
		/// Where &lt;value&gt; is an integer from 1 to 8, inclusive.<br/>
		/// The maximum number of simultaneous threads that can be used also varies by the task being<br/>
		/// run. You can change the maxThreads parameter prior to running these processes. The<br/>
		/// maximum number of threads for specific Tcl commands are:<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// • phys_opt_design: 8<br/>
		/// • place_design: 8<br/>
		/// • report_drc: 8<br/>
		/// • report_timing and report_timing_summary: 8<br/>
		/// • route_design: 8<br/>
		/// • synth_design: 4<br/>
		/// You can use the reset_param command to restore any parameter that has been modified back<br/>
		/// to its default setting.<br/>
		/// Note: Setting a specified parameter value to -1 will disable the feature.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example sets the parameter defining how many threads to run for multi-threaded<br/>
		/// processes, including Placement, Routing, and Timing Analysis:<br/>
		/// set_param general.maxThreads 4<br/>
		/// Note: The Vivado tool supports between 1 to 8 threads. Use get_param to determine the current setting.<br/>
		/// The following example sets a new default value for message limit:<br/>
		/// set_param messaging.defaultLimit 1000<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1672<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Parameter name</param>
		/// <param name="value">(Required) Parameter value</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>newly set parameter value</returns>
		public VivadoTCL set_param(String name, String value, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_param [-quiet] [-verbose] <name> <value>
			this.Entry(_builder.set_param(name, value, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Sets the part on the current project. If no project is open, then a diskless project is created.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_part [-quiet] [-verbose] &lt;part&gt;
		/// <br/>
		/// <para>
		/// Change the part used by the current project for subsequent elaboration, synthesis,<br/>
		/// implementation, and analysis.<br/>
		/// TIP: The part is changed for the current project only, and not for the in-memory design. You can change<br/>
		/// the speed grade of the device in the in-memory design for timing analysis using the set_speed_grade<br/>
		/// command. You can change the part used when opening an existing design checkpoint using the -part<br/>
		/// option of the open_checkpoint or read_checkpoint commands.<br/>
		/// This command is provided to let you change the part for the in-memory project of non-project<br/>
		/// based designs, and does not support project-based designs. For a project-based design set the<br/>
		/// PART property on the project as follows:<br/>
		/// set_property PART xc7vx485tffg1158-2 [current_project]<br/>
		/// Use the get_parts command to get a list of the available parts.<br/>
		/// The set_part command creates an in-memory project for a non-project based design, or<br/>
		/// assigns the part to the existing in-memory project.<br/>
		/// Note: For a discussion of Project Mode and Non-Project Mode refer to the Vivado Design Suite User Guide:<br/>
		/// Design Flows Overview (UG892).<br/>
		/// This command returns the part that the in-memory project is set to use, or returns an error if it<br/>
		/// fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1675<br/>
		/// </para>
		/// </summary>
		/// <param name="part">(Required) Set current project's part to this part.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_part(String part, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_part [-quiet] [-verbose] <part>
			this.Entry(_builder.set_part(part, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Set constraints for power optimization<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_power_opt [-include_cells &lt;args&gt;] [-exclude_cells &lt;args&gt;] [-clocks &lt;args&gt;] [-cell_types &lt;args&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Specify cell instances to include or exclude in power optimization. The specified cells are<br/>
		/// optimized using the power_opt_design command.<br/>
		/// TIP: Block RAM optimizations are performed by default with the opt_design command. Some or all<br/>
		/// BRAM cells can be excluded from the opt_design optimization using the set_power_opt command<br/>
		/// as well.<br/>
		/// The effect of multiple set_power_opt commands is cumulative, so that you can specify a<br/>
		/// broad class of cell types to optimize, include specific hierarchical cells, and then exclude cells<br/>
		/// within the included hierarchy to refine the power optimization.<br/>
		/// The power optimizations that have been performed can be reported using the<br/>
		/// report_power_opt command.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example sets power optimization for BRAM cells only, and then runs power<br/>
		/// optimization:<br/>
		/// set_power_opt -cell_types bram<br/>
		/// power_opt_design<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example sets power optimization for BRAM and REG type cells, then adds SRLs,<br/>
		/// and runs power optimization. Then all cells are cleared, and only SRLs are included, and power<br/>
		/// optimization is run again:<br/>
		/// set_power_opt -cell_types { bram reg}<br/>
		/// set_power_opt -cell_types { srl}<br/>
		/// power_opt_design<br/>
		/// set_power_opt -cell_types { none}<br/>
		/// set_power_opt -cell_types { srl}<br/>
		/// power_opt_design<br/>
		/// The following example sets power optimization for BRAM cells only, excludes the cpuEngine<br/>
		/// block from optimization, but then includes the cpuEngine/cpu_dbg_dat_i block, then performs<br/>
		/// power optimization:<br/>
		/// set_power_opt -cell_types bram<br/>
		/// set_power_opt -exclude_cells cpuEngine<br/>
		/// set_power_opt -include_cells cpuEngine/cpu_dbg_dat_i<br/>
		/// power_opt_design<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1677<br/>
		/// </para>
		/// </summary>
		/// <param name="include_cells">(Optional) Include only these instances for clock gating. Default: all</param>
		/// <param name="exclude_cells">(Optional) Exclude these instances from clock gating. Default: none</param>
		/// <param name="clocks">(Optional) Clock gate instances clocked by these clocks only. Default: all clocks</param>
		/// <param name="cell_types">
		/// <para>
		/// (Optional)<br/>
		/// Clock gate these cell types only. Specify either [all|none], or<br/>
		/// one or more of [bram|reg|srl]. Default: all<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_power_opt(TCLParameterList include_cells = null, TCLParameterList exclude_cells = null, TCLParameterList clocks = null, TCLParameterList cell_types = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_power_opt [-include_cells <args>] [-exclude_cells <args>] [-clocks <args>] [-cell_types <args>] [-quiet] [-verbose]
			this.Entry(_builder.set_power_opt(include_cells, exclude_cells, clocks, cell_types, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Specify propagated clock latency<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_propagated_clock [-quiet] [-verbose] &lt;objects&gt;
		/// <br/>
		/// <para>
		/// Propagates clock latency throughout a clock network, resulting in more accurate skew and timing<br/>
		/// results throughout the clock network.<br/>
		/// Note: This command operates silently and does not return direct feedback of its operation.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// This example specifies that the primary system clock from the top-level should be propagated:<br/>
		/// set_propagated_clock [get_clocks top/clk]<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This example specifies that all clocks from "sublevel1" should be propagated:<br/>
		/// set_propagated_clock [get_clocks sublevel1/*]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1680<br/>
		/// </para>
		/// </summary>
		/// <param name="objects">(Required) List of clocks, ports, or pins</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_propagated_clock(String objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_propagated_clock [-quiet] [-verbose] <objects>
			this.Entry(_builder.set_propagated_clock(objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Set property on object(s)<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_property [-dict &lt;args&gt;] [-quiet] [-verbose] &lt;name&gt; &lt;value&gt; &lt;objects&gt;...
		/// <br/>
		/// <para>
		/// Assigns the defined property &lt;name&gt; and &lt;value&gt; to the specified &lt;objects&gt;.<br/>
		/// This command can be used to define any property on an object in the design. Each object has a<br/>
		/// set of predefined properties that have expected values, or a range of values. The set_property<br/>
		/// command can be used to define the values for these properties. To determine the defined set of<br/>
		/// properties on an object, use report_property, list_property, or<br/>
		/// list_property_values.<br/>
		/// You can also define custom properties for an object, by specifying a unique &lt;name&gt; and &lt;value&gt;<br/>
		/// pair for the object. If an object has custom properties, these will also be reported by the<br/>
		/// report_property and list_property commands.<br/>
		/// This command returns nothing if successful, and an error if it fails.<br/>
		/// TIP: You can use the get_property command to validate any properties that have been set on an<br/>
		/// object.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// Create a user-defined boolean property, TRUTH, for cell objects, and set the property on a cell:<br/>
		/// create_property -type bool truth cell<br/>
		/// set_property truth false [lindex [get_cells] 1]<br/>
		/// Use the -dict option to specify multiple properties at one time on the current design:<br/>
		/// set_property -dict "POST_CRC enable POST_CRC_ACTION correct_and_continue"<br/>
		/// \<br/>
		/// [current_design]<br/>
		/// The following example sets the TOP property of the current fileset to define the top module of<br/>
		/// the project:<br/>
		/// set_property top fftTop [current_fileset]<br/>
		/// set_property top_file {C:/Data/sources/fftTop.v} [current_fileset]<br/>
		/// Note: Defining the top module requires the TOP property to be set to the desired hierarchical block in the<br/>
		/// source fileset of the current project. In the preceding example TOP is the property name, fftTop is the<br/>
		/// value, and current_fileset is the object. In addition, the TOP_FILE property should be defined to point to<br/>
		/// the data source for the top module.<br/>
		/// This example shows how to set a property value that includes the dash character, '-'. The dash<br/>
		/// can cause the tool to interpret the value as a new command argument, rather than part of the<br/>
		/// value being specified, and will cause an error as shown. In this case, you must use the explicit<br/>
		/// form of the positional arguments in the set_property command:<br/>
		/// set_property {XELAB.MORE_OPTIONS} {-pulse_e_style ondetect} \<br/>
		/// [get_filesets sim_1]<br/>
		/// ERROR: [Common 17-170] Unknown option '-pulse_e_style ondetect',<br/>
		/// please type 'set_property -help' for usage info.<br/>
		/// set_property -name {XELAB.MORE_OPTIONS} -value {-pulse_e_style ondetect}\<br/>
		/// -objects [get_filesets sim_1]<br/>
		/// The following example sets the internal VREF property value for the specified IO Bank:<br/>
		/// set_property internal_vref {0.75} [get_iobanks 0]<br/>
		/// The following example defines a DCI Cascade by setting the DCI_CASCADE property for the<br/>
		/// specified IO Bank:<br/>
		/// set_property DCI_CASCADE {14} [get_iobanks 0 ]<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example configures the synth_1 run, setting options for Vivado Synthesis 2013,<br/>
		/// and then launches the synthesis run:<br/>
		/// set_property flow {Vivado Synthesis 2016} \<br/>
		/// [get_runs synth_1]<br/>
		/// set_property STEPS.SYNTH_DESIGN.ARGS.GATED_CLOCK_CONVERSION on \<br/>
		/// [get_runs synth_1]<br/>
		/// set_property STEPS.SYNTH_DESIGN.ARGS.FSM_EXTRACTION one_hot \<br/>
		/// [get_runs synth_1]<br/>
		/// launch_runs synth_1<br/>
		/// This example is the same as the prior example, except that it uses the -dict option to set all the<br/>
		/// properties on the synthesis run in a single set_property command:<br/>
		/// set_property -dict [ list flow {Vivado Synthesis 2016} \<br/>
		/// STEPS.SYNTH_DESIGN.ARGS.GATED_CLOCK_CONVERSION on \<br/>
		/// STEPS.SYNTH_DESIGN.ARGS.FSM_EXTRACTION \<br/>
		/// one_hot ] [get_runs synth_1]<br/>
		/// launch_runs synth_1<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1682<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Required) Name of property to set. Not valid with -dict option</param>
		/// <param name="value">(Required) Value of property to set. Not valid with -dict option</param>
		/// <param name="objects">(Required) Objects to set properties on</param>
		/// <param name="dict">(Optional) list of name/value pairs of properties to set</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_property(String name, String value, TCLParameterList objects, TCLParameterList dict = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_property [-dict <args>] [-quiet] [-verbose] <name> <value> <objects>...
			this.Entry(_builder.set_property(name, value, objects, dict, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Set Timing Speed Grade and Temperature Grade<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_speed_grade [-temperature &lt;arg&gt;] [-quiet] [-verbose] [&lt;value&gt;]
		/// <br/>
		/// <para>
		/// Note: After set_speed_grade has been used on a design, it can be used for timing analysis, but it will no<br/>
		/// longer go through implementation. If you want to run implementation on the design, you should save the<br/>
		/// design checkpoint and use read_checkpoint -part to implement the design with the new speed<br/>
		/// grade.<br/>
		/// Sets the speed grade used for timing analysis for the target device in the current design.<br/>
		/// This command is used to change the speed grade of the target device for timing analysis only,<br/>
		/// and does not affect other aspects of the design. It must be run on an opened synthesized or<br/>
		/// implemented design.<br/>
		/// Use the set_speed_grade command prior to the report_timing_summary or<br/>
		/// report_timing command or other timing commands to change the speed grade for analysis. If<br/>
		/// the timing is valid, then you can use the set_property or set_part command to change the<br/>
		/// target part for the project to re-synthesize and implement the design.<br/>
		/// TIP: For UltraScale devices, you can specify either the temperature or the value to define the speed grade<br/>
		/// for the part. For 7 series devices, you can only specify the value.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This command returns a transcript of its process, and the speed grade set, or returns an error if it<br/>
		/// fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example sets the speed grade for the device in the current design to -1:<br/>
		/// set_speed_grade -1<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1686<br/>
		/// </para>
		/// </summary>
		/// <param name="temperature">
		/// <para>
		/// (Optional)<br/>
		/// Temperature grade used for timing analysis (Not available<br/>
		/// for 7 Series and earlier)<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="value">(Optional) Speed grade used for timing analysis</param>
		/// <returns>string result</returns>
		public VivadoTCL set_speed_grade(String temperature = null, bool? quiet = null, bool? verbose = null, String value = null)
		{
			// TCL Syntax: set_speed_grade [-temperature <arg>] [-quiet] [-verbose] [<value>]
			this.Entry(_builder.set_speed_grade(temperature, quiet, verbose, value));
			return this;
		}
		/// <summary>
		/// <para>
		/// Set switching activity on specified objects or default types<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_switching_activity [-toggle_rate &lt;arg&gt;] [-default_toggle_rate &lt;arg&gt;] [-type &lt;args&gt;] [-all] [-static_probability &lt;arg&gt;] [-default_static_probability &lt;arg&gt;] [-signal_rate &lt;arg&gt;] [-hier] [-deassert_resets] [-quiet] [-verbose] [&lt;objects&gt;...]
		/// <br/>
		/// <para>
		/// Sets the signal rate and the switching probability to be used when performing power estimation<br/>
		/// on the current synthesized or implemented design. These include simple signal rate and simple<br/>
		/// static probability on nets, ports, and pins; and state dependent static probabilities on cells.<br/>
		/// Note: This command operates silently and does not return direct feedback of its operation.<br/>
		/// The switching activity of a design affects both the static and dynamic power consumption. The<br/>
		/// static power is often dependent on logic state transitions, and the dynamic power is directly<br/>
		/// proportional to the toggle rate.<br/>
		/// The set_switching_activity command can be used to specify default activity rates for the<br/>
		/// whole design, or to define the activity of one or more signals in the design or on a specified<br/>
		/// module.<br/>
		/// The current switching activity attributes can be found by using the<br/>
		/// report_switching_activity command. The values can be set to their default values by<br/>
		/// using the reset_switching_activity command.<br/>
		/// Note: The reset_switching_activity is used to reset switching activity for specified objects. Use the<br/>
		/// set_switching_activity -default_toggle_rate or -default_static_probability to<br/>
		/// change or reset these values.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example specifies a signal rate and switching probability for all ports, then reports<br/>
		/// the switching attributes for those ports:<br/>
		/// set_switching_activity -signal_rate 55 -static_probability .33 [get_ports]<br/>
		/// report_switching_activity [get_ports]<br/>
		/// The following example specifies the default switching probability for the current design:<br/>
		/// set_switching_activity -default_static_probability .75<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This example sets the specified toggle rate and static probability on all registers in the hierarchy<br/>
		/// of "CPU/MEM":<br/>
		/// set_switching_activity -type register -toggle_rate 0.4 \<br/>
		/// -static_probability 0.5 [get_cells CPU/MEM]<br/>
		/// This example sets the specified toggle rate and static probability on all registers in the hierarchy<br/>
		/// of "CPU/" and underneath hierarchy:<br/>
		/// set_switching_activity -type register -toggle_rate 0.4<br/>
		/// -static_probability 0.5 -hier [get_cells CPU]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1688<br/>
		/// </para>
		/// </summary>
		/// <param name="toggle_rate">
		/// <para>
		/// (Optional)<br/>
		/// Toggle rate (%) is the rate at which the output of<br/>
		/// synchronous logic element switches compared to a given<br/>
		/// clock input. It is modeled as a percentage between 0 - 200%.<br/>
		/// A toggle rate of 100% means that on average the output<br/>
		/// toggles once during every clock cycle, changing on either<br/>
		/// the rising or falling clock edges, and making the effective<br/>
		/// output signal frequency half of the clock frequency. Default:<br/>
		/// 0.0<br/>
		/// </para>
		/// </param>
		/// <param name="default_toggle_rate">
		/// <para>
		/// (Optional)<br/>
		/// The default toggle rate to be used in power analysis on the<br/>
		/// primary inputs of the design. The default toggle rate is set<br/>
		/// on those primary input nets whose switching activity is not<br/>
		/// specified by the user, simulation data or constraints of the<br/>
		/// design. Valid values are: 0 &lt;= value &lt; 200. The default value<br/>
		/// is 12.5. Default: 12.5<br/>
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// (Optional)<br/>
		/// Specify nodes in a specific category. List of valid type values:<br/>
		/// io_output, io_bidir_enable, register, lut_ram, lut, dsp,<br/>
		/// bram_enable, bram_wr_enable, gt_txdata, gt_rxdata.<br/>
		/// </para>
		/// </param>
		/// <param name="all">
		/// <para>
		/// (Optional)<br/>
		/// Used together with -type, set switching activity on -type nets<br/>
		/// within an instance<br/>
		/// </para>
		/// </param>
		/// <param name="static_probability">(Optional) Static probability value: 0 &lt;= Value &lt;= 1 Default: 0.5</param>
		/// <param name="default_static_probability">
		/// <para>
		/// (Optional)<br/>
		/// The default static probability to be used in power analysis<br/>
		/// on the design. The default static probability is set on those<br/>
		/// primary inputs whose switching activity is not specified by<br/>
		/// the user, simulation data or constraints of the design. Valid<br/>
		/// values are: 0 &lt;= Value &lt;= 1. The default value is 0.5. Default:<br/>
		/// 0.5<br/>
		/// </para>
		/// </param>
		/// <param name="signal_rate">
		/// <para>
		/// (Optional)<br/>
		/// The number of times an element changed state (high-to-low<br/>
		/// and low-to-high) per second. Xilinx tools express this as<br/>
		/// millions of transitions per second (Mtr/s). Default: 0.0<br/>
		/// </para>
		/// </param>
		/// <param name="hier">
		/// <para>
		/// (Optional)<br/>
		/// Hierarchically sets the switching activity on a hierarchical<br/>
		/// instance provided via &lt;objects&gt; option. This option should<br/>
		/// be used only with &lt;objects&gt; option<br/>
		/// </para>
		/// </param>
		/// <param name="deassert_resets">
		/// <para>
		/// (Optional)<br/>
		/// A switch to elegantly auto deassert all set,reset,preset and<br/>
		/// clear signals that do not have conflicted polarities<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">
		/// <para>
		/// (Optional)<br/>
		/// Objects to set switching activity on<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// </param>
		public VivadoTCL set_switching_activity(String toggle_rate = null, String default_toggle_rate = null, TCLParameterList type = null, bool? all = null, String static_probability = null, String default_static_probability = null, Int32? signal_rate = null, bool? hier = null, bool? deassert_resets = null, bool? quiet = null, bool? verbose = null, TCLParameterList objects = null)
		{
			// TCL Syntax: set_switching_activity [-toggle_rate <arg>] [-default_toggle_rate <arg>] [-type <args>] [-all] [-static_probability <arg>] [-default_static_probability <arg>] [-signal_rate <arg>] [-hier] [-deassert_resets] [-quiet] [-verbose] [<objects>...]
			this.Entry(_builder.set_switching_activity(toggle_rate, default_toggle_rate, type, all, static_probability, default_static_probability, signal_rate, hier, deassert_resets, quiet, verbose, objects));
			return this;
		}
		/// <summary>
		/// <para>
		/// Set system jitter<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_system_jitter [-quiet] [-verbose] &lt;system_jitter&gt;
		/// <br/>
		/// <para>
		/// Sets the system jitter specified in nanoseconds (ns) for all clocks in the design, including primary<br/>
		/// and generated clocks. System jitter is used to account for excessive noise that affects all the<br/>
		/// clocks within the FPGA, like power supply noise and board noise. The default system jitter is<br/>
		/// technology-dependent and is predefined for each Xilinx FPGA family based on device<br/>
		/// characterization with several power supplies under all supported operating conditions.<br/>
		/// System Jitter is a component of the Total System Jitter (Tsj) used in the calculation of clock<br/>
		/// uncertainty for a path. It is due to the maximum noise (in time) that can be seen on the Vccint rail<br/>
		/// due to simultaneous switching of internal nodes, cross talk and other phenomenon that can<br/>
		/// impact timing on any path in the design.<br/>
		/// IMPORTANT! The jitter calculated by Xilinx takes into consideration the uncertainty introduced by the<br/>
		/// clocking resources, the input jitter and the system jitter. Using the set_system_jitter command<br/>
		/// overrides the default system jitter value calculated by Xilinx, and is not recommended.<br/>
		/// The System Jitter and the Input Jitter are random jitters which typically follow a Gaussian<br/>
		/// distribution and are added in a quadratic manner to represent the worst case combination. When<br/>
		/// the Input Jitter is null, the Total System Jitter (Tsj) for an internal register-to-register path has the<br/>
		/// following equation:<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// • Tsj = √(SourceClockSystemJitter2<br/>
		/// + DestinationClockSystemJitter2<br/>
		/// )<br/>
		/// For example, when using the default value for system jitter of 50ps:<br/>
		/// • Tsj = √(0.0502<br/>
		/// + 0.0502<br/>
		/// ) = 0.071ns = 71ps<br/>
		/// The set_system_jitter command applies to all the clocks in the design. Use the<br/>
		/// set_input_jitter command to specify additional jitter for a specific primary clock.<br/>
		/// TIP: SYSTEM_JITTER is reported as a property of clocks, although it applies to all clocks in the design.<br/>
		/// INPUT_JITTER is also a property of primary clocks. These properties can be returned by the<br/>
		/// get_property or report_property commands.<br/>
		/// This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// This example defines the primary clock, sysClk, and specifies a system wide jitter of 0.1 ns:<br/>
		/// create_clock -period 10 -name sysClk [get_ports sysClk]<br/>
		/// set_system_jitter 0.1<br/>
		/// The following example defines a primary clock, sysClk, and a generated clock, sysClkDiv2, that is<br/>
		/// a divide by two version of the primary clock. A system jitter of 0.2 ns is specified that applies to<br/>
		/// all the clocks in the design. An additional input jitter of 0.09 ns is specified on only the primary<br/>
		/// clock:<br/>
		/// create_clock -period 10 -name sysClk [get_ports sysClk]<br/>
		/// create_generated_clock -name sysClkDiv2 -source [get_ports sysClk] \<br/>
		/// -divide_by 2 [get_pins clkgen/sysClkDiv/Q]<br/>
		/// set_system_jitter 0.2<br/>
		/// set_input_jitter sysClk 0.09<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The follow example defines two primary clocks, sysClk and procClk. A system jitter of 0.2 ns is<br/>
		/// defined for all the clocks in the system. An additional input jitter of 0.05 ns is specified for the<br/>
		/// clock procClk:<br/>
		/// create_clock -period 10 -name sysClk [get_ports sysClk]<br/>
		/// create_clock -period 25 -name procClk [get_ports procClk]<br/>
		/// set_system_jitter 0.2<br/>
		/// set_input_jitter procClk 0.05<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1693<br/>
		/// </para>
		/// </summary>
		/// <param name="system_jitter">(Required) System jitter: Value &gt;= 0</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>system_jitter</returns>
		public VivadoTCL set_system_jitter(String system_jitter, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_system_jitter [-quiet] [-verbose] <system_jitter>
			this.Entry(_builder.set_system_jitter(system_jitter, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Set units for checking<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_units [-capacitance &lt;arg&gt;] [-current &lt;arg&gt;] [-voltage &lt;arg&gt;] [-power &lt;arg&gt;] [-resistance &lt;arg&gt;] [-altitude &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// This command specifies the default units to be assumed when the design is analyzed. Specifically,<br/>
		/// the -current, -voltage, -power, and -resistance options impact the values returned by<br/>
		/// the report_power command.<br/>
		/// The set_units command can be used multiple times to define and redefine units. If<br/>
		/// set_units includes a previously set unit value, the unit is redefined.<br/>
		/// Note: This command operates silently and does not return direct feedback of its operation.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// Specify that voltage should be in millivolts and all values should use three digits<br/>
		/// set_units -voltage mV<br/>
		/// The following example changes the default unit for current to Amperes:<br/>
		/// set_units -voltage kV -current A<br/>
		/// Note: The second example of set_units redefines the Voltage units defined in the first example, as well<br/>
		/// as defining the units for current.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1696<br/>
		/// </para>
		/// </summary>
		/// <param name="capacitance">(Optional) Capacitance unit in farad. Valid values are from kF-fF. Default: pF</param>
		/// <param name="current">(Optional) Current unit in ampere. Valid values are from kA-fA. Default: mA</param>
		/// <param name="voltage">(Optional) Voltage unit in volt. Valid values are from kV-fV. Default: V</param>
		/// <param name="power">(Optional) Wattage unit in watts. Valid values are from kW-fW. Default: mW</param>
		/// <param name="resistance">(Optional) Resistance unit in ohm. Valid values are from kOhm-fOhm. Default: ohm</param>
		/// <param name="altitude">
		/// <para>
		/// (Optional)<br/>
		/// Altitude in metric or standard units. Valid values are meters<br/>
		/// and feet. Default: meters<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_units(String capacitance = null, String current = null, String voltage = null, String power = null, String resistance = null, String altitude = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_units [-capacitance <arg>] [-current <arg>] [-voltage <arg>] [-power <arg>] [-resistance <arg>] [-altitude <arg>] [-quiet] [-verbose]
			this.Entry(_builder.set_units(capacitance, current, voltage, power, resistance, altitude, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Set the current value of an HDL object (variable, signal, wire, or reg) to a specified value<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: set_value [-radix &lt;arg&gt;] [-quiet] [-verbose] &lt;hdl_object&gt; &lt;value&gt;
		/// <br/>
		/// <para>
		/// Specify the value of a single HDL object at the current simulation run time.<br/>
		/// HDL objects include HDL signals, variables, or constants as defined in the Verilog or VHDL test<br/>
		/// bench and source files. An HDL signal includes Verilog wire or reg entities, and VHDL signals.<br/>
		/// Examples of HDL variables include Verilog real, realtime, time, and event.<br/>
		/// HDL constants include Verilog parameters and localparams, and VHDL generic and constants.<br/>
		/// The HDL scope, or scope, is defined by a declarative region in the HDL code such as a module,<br/>
		/// function, task, process, or begin-end blocks in Verilog. VHDL scopes include entity/architecture<br/>
		/// definitions, block, function, procedure, and process blocks.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// HDL constants include Verilog parameters and localparams, and VHDL generic and constants.<br/>
		/// The HDL scope, or scope, is defined by a declarative region in the HDL code such as a module,<br/>
		/// function, task, process, or begin-end blocks in Verilog. VHDL scopes include entity/architecture<br/>
		/// definitions, block, function, procedure, and process blocks.<br/>
		/// Arguments<br/>
		/// -radix &lt;arg&gt; - (Optional) Specifies the radix to use when returning the value of the specified<br/>
		/// object. Allowed values are: default, dec, bin, oct, hex, unsigned, ascii, or smag.<br/>
		/// Note: The radix dec indicates a signed decimal. Specify the radix unsigned when dealing with unsigned<br/>
		/// data.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// -quiet - (Optional) Execute the command quietly, returning no messages from the command.<br/>
		/// The command also returns TCL_OK regardless of any errors encountered during execution.<br/>
		/// Note: Any errors encountered on the command-line, while launching the command, will be returned. Only<br/>
		/// errors occurring inside the command will be trapped.<br/>
		/// -verbose - (Optional) Temporarily override any message limits and return all messages from this<br/>
		/// command.<br/>
		/// Note: Message limits can be defined with the set_msg_config command.<br/>
		/// &lt;hdl_object&gt; - (Required) Specifies a single HDL object to get the value of. The object can be<br/>
		/// specified by name, or can be returned as an object from the get_objects command.<br/>
		/// &lt;value&gt; - (Required) The value to set the specified object to. The specified &lt;value&gt; depends on<br/>
		/// the type of the &lt;hdl_object&gt;. HDL object types include: "logic", floating point, VHDL<br/>
		/// enumerated, and VHDL integral. For all but "logic" the -radix option is ignored.<br/>
		/// • "Logic" does not refer to an actual HDL object type, but means any object whose values are<br/>
		/// similar to those of VHDL std_logic, such as:<br/>
		/// ○ the Verilog implicit 4-state bit type,<br/>
		/// ○ the VHDL bit and std_logic predefined types,<br/>
		/// ○ any VHDL enumeration type which is a subset of std_logic, including the character literals<br/>
		/// '0' and '1'.<br/>
		/// • For logic types the value depends on the radix:<br/>
		/// ○ If the specified value has fewer bits than the logic type expects, the value is zero extended,<br/>
		/// but not sign extended, to match the expected length.<br/>
		/// ○ If the specified value has more bits than the logic type expects, the extra bits on the MSB<br/>
		/// side should all be zeros, or the Vivado simulator will return a "size mismatch" error.<br/>
		/// • Accepted values for floating point objects are floating point values.<br/>
		/// • The accepted value for non-logic VHDL enumerated types is a scalar value from the<br/>
		/// enumerated set of values, without single quotes in the case of characters.<br/>
		/// • Accepted values for VHDL integral types is a signed decimal integer in the range accepted by<br/>
		/// the type.<br/>
		/// Examples<br/>
		/// The following example sets the value of the sysClk signal:<br/>
		/// set_value sysClk Z<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This example uses the bin, dec, and unsigned radix to specify the same value on the given<br/>
		/// bus:<br/>
		/// set_value -radix bin /test/bench_VStatus_pad_0_i[7:0] 10100101<br/>
		/// set_value -radix unsigned /test/bench_VStatus_pad_0_i[7:0] 165<br/>
		/// set_value -radix dec /test/bench_VStatus_pad_0_i[7:0] -91<br/>
		/// The following example shows the bit extension performed when the provided value has fewer<br/>
		/// bits than the logic type expects:<br/>
		/// set_value -radix bin /test/bench_VStatus_pad_0_i[7:0] 101<br/>
		/// get_value -radix bin /test/bench_VStatus_pad_0_i[7:0]<br/>
		/// 00000101<br/>
		/// The following example shows the bit truncation performed when the provided value has more<br/>
		/// bits than the logic type expects:<br/>
		/// set_value -radix bin /test/bench_VStatus_pad_0_i[7:0] 0010100101<br/>
		/// get_value -radix bin /test/bench_VStatus_pad_0_i[7:0]<br/>
		/// 10100101<br/>
		/// set_value -radix bin /test/bench_VStatus_pad_0_i[7:0] 1110100101<br/>
		/// ERROR: [#UNDEF] Object size 8 does not match size of given value 1110100101<br/>
		/// Note: In the second set_value command, the extra bits are not zero, and so an error is returned.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1698<br/>
		/// </para>
		/// </summary>
		/// <param name="hdl_object">(Required) Set the value on the given hdl_object.</param>
		/// <param name="value">(Required) The value to assign to the specified object.</param>
		/// <param name="radix">
		/// <para>
		/// (Optional)<br/>
		/// radix specifies the radix to use for interpreting value.<br/>
		/// Allowed values are: default, dec, bin, oct, hex, unsigned,<br/>
		/// ascii, smag<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL set_value(String hdl_object, String value, String radix = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: set_value [-radix <arg>] [-quiet] [-verbose] <hdl_object> <value>
			this.Entry(_builder.set_value(hdl_object, value, radix, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// (User-written application) Extract IP static files from the project or repository and prepare it for<br/>
		/// compile_simlib<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: setup_ip_static_library [-directory &lt;arg&gt;] [-ip_repo_path &lt;arg&gt;] [-ips &lt;arg&gt;] [-library &lt;arg&gt;] [-project] [-install] [-no_update_catalog] [-force] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Retrieve static simulation files for IP cores used in the current project, or from the Xilinx IP<br/>
		/// catalog, and create a source library for the compile_simlib command to use for compiling the<br/>
		/// IP files for a specified simulator.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following command will build static library for all the IPs in the current project in ./<br/>
		/// static_compiled_lib:<br/>
		/// setup_ip_static_library -project<br/>
		/// The following command will build static library for the current project in /work/simlib. The<br/>
		/// command will create the specified directory if it does not exist:<br/>
		/// setup_ip_static_library -directory /work/simlib -project<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1701<br/>
		/// </para>
		/// </summary>
		/// <param name="directory">(Optional) Extract static files in the specified directory Default: None</param>
		/// <param name="ip_repo_path">
		/// <para>
		/// (Optional)<br/>
		/// Extract static files from the specified IP repository path<br/>
		/// Default: None<br/>
		/// </para>
		/// </param>
		/// <param name="ips">(Optional) Extract static files for the specified IPs only Default: Empty</param>
		/// <param name="library">(Optional) Extract static files for the specified IP library Default: Empty</param>
		/// <param name="project">(Optional) Extract static files for the current project</param>
		/// <param name="install">(Optional) Extract static files for the IP catalog</param>
		/// <param name="no_update_catalog">(Optional) Do no update IP catalog Default: 1</param>
		/// <param name="force">(Optional) Overwrite static files</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>None</returns>
		public VivadoTCL setup_ip_static_library(String directory = null, String ip_repo_path = null, String ips = null, String library = null, bool? project = null, bool? install = null, bool? no_update_catalog = null, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: setup_ip_static_library [-directory <arg>] [-ip_repo_path <arg>] [-ips <arg>] [-library <arg>] [-project] [-install] [-no_update_catalog] [-force] [-quiet] [-verbose]
			this.Entry(_builder.setup_ip_static_library(directory, ip_repo_path, ips, library, project, install, no_update_catalog, force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Creates minimum PR Configurations and Child Impl runs automatically based on the combination<br/>
		/// of Partition Instances and RMs<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: setup_pr_configurations [-partitions &lt;args&gt;] [-use_netlist] [-force] [-run &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Automatically creates the minimum PR configurations and child implementation runs based on<br/>
		/// the combination of Partition Instances and Reconfigurable Modules.<br/>
		/// In the Partial Reconfiguration (PR) design flow, the PR configuration lets you specify a<br/>
		/// reconfigurable module (RM) to assign to a specific instance of a Partition Definition<br/>
		/// (partitionDef). This flow lets you create unique configurations of the design based on the<br/>
		/// combination of the core design and one or more RMs. The PR design flow requires the<br/>
		/// implementation of each PR configuration, resulting in partial bitstreams for the RMs, but<br/>
		/// complete bitstreams for each integrated configuration. Refer to the Vivado Design Suite User<br/>
		/// Guide: Dynamic Function eXchange (UG909) for more information.<br/>
		/// This command is designed to work automatically to create the needed PR configurations and<br/>
		/// implementation runs for those configurations.<br/>
		/// This command returns nothing if successful, or returns an error if the command fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1704<br/>
		/// </para>
		/// </summary>
		/// <param name="partitions">(Optional) List of partition instances and reconfig modules pairs</param>
		/// <param name="use_netlist">
		/// <para>
		/// (Optional)<br/>
		/// Use netlist for getting instances of partition_defs to creating<br/>
		/// PR Configurations<br/>
		/// </para>
		/// </param>
		/// <param name="force">
		/// <para>
		/// (Optional)<br/>
		/// Using force deletes active parent impl run's PR<br/>
		/// Configuration and it's child runs and PR Configurations, and<br/>
		/// then creates new PR Configurations and runs<br/>
		/// </para>
		/// </param>
		/// <param name="run">
		/// <para>
		/// (Optional)<br/>
		/// Parent impl run to which child impl runs and PR<br/>
		/// Configurations need to be created<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL setup_pr_configurations(TCLParameterList partitions = null, bool? use_netlist = null, bool? force = null, String run = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: setup_pr_configurations [-partitions <args>] [-use_netlist] [-force] [-run <arg>] [-quiet] [-verbose]
			this.Entry(_builder.setup_pr_configurations(partitions, use_netlist, force, run, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Show objects in Find Results view<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: show_objects [-name &lt;arg&gt;] [-quiet] [-verbose] &lt;objects&gt;
		/// <br/>
		/// <para>
		/// Populates the specified objects into the Find Results window in the Vivado IDE.<br/>
		/// Note: This command is only useful when run in the Vivado IDE. When run in Tcl or Batch mode the<br/>
		/// command simply returns without error or comment.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example shows all DSP objects in the current design in the Find Results window.<br/>
		/// show_objects -name All_DSPs [all_dsps]<br/>
		/// The following example shows all of the cells in the design hierarchy that are Clock or DSP<br/>
		/// PRIMITIVE_TYPEs:<br/>
		/// show_objects -name find_1 [get_cells -hierarchical \<br/>
		/// -filter { PRIMITIVE_TYPE =~ CLK.*.* || PRIMITIVE_TYPE =~ MULT.dsp.* } ]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1706<br/>
		/// </para>
		/// </summary>
		/// <param name="objects">(Required) Objects to show Find Results view</param>
		/// <param name="name">(Optional) Tab title</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL show_objects(String objects, String name = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: show_objects [-name <arg>] [-quiet] [-verbose] <objects>
			this.Entry(_builder.show_objects(objects, name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Show netlist items in schematic view<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: show_schematic [-add] [-remove] [-regenerate] [-pin_pairs] [-name &lt;arg&gt;] [-quiet] [-verbose] &lt;objects&gt;
		/// <br/>
		/// <para>
		/// Create a schematic view containing the specified design objects when the tool is invoked in GUI<br/>
		/// mode.<br/>
		/// The scope of the schematic that is displayed depends on the objects specified. A schematic<br/>
		/// created with cells, shows the specified cells and any connections between the cells. A schematic<br/>
		/// created with pins, shows the pin objects, or shows them connected as appropriate if -<br/>
		/// pin_pairs is specified. A schematic created with nets shows the nets, as well as the cells and<br/>
		/// ports connected to the nets.<br/>
		/// To display a schematic with multiple levels of hierarchy, use the current_instance command<br/>
		/// to set the top-level of the hierarchy, or the level of interest, and use the -hierarchical option<br/>
		/// when specifying design objects with a get_* command.<br/>
		/// Note: This command is only useful when run in the Vivado IDE. When run in Tcl or Batch mode the<br/>
		/// command simply returns without error or comment.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates a schematic for the top-level of the design, displaying the nets as<br/>
		/// well as the ports and cells they connect to:<br/>
		/// show_schematic [get_nets]<br/>
		/// The following example sets the level of hierarchy of interest, and creates a hierarchical schematic<br/>
		/// from the current level down:<br/>
		/// current_instance A<br/>
		/// show_schematic [get_nets -hier]<br/>
		/// The following example creates a schematic window showing the specified pins, and the wire<br/>
		/// connection between them:<br/>
		/// show_schematic -pin_pairs [get_pins {data0_i/O data_reg/D}]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1708<br/>
		/// </para>
		/// </summary>
		/// <param name="objects">(Required) Netlist items to show in schematic view</param>
		/// <param name="add">(Optional) Add to existing schematic view</param>
		/// <param name="remove">(Optional) Remove from existing schematic view</param>
		/// <param name="regenerate">(Optional) Regenerate layout of schematic view</param>
		/// <param name="pin_pairs">
		/// <para>
		/// (Optional)<br/>
		/// objects are treated as pair of connected pins. This can be<br/>
		/// useful to display paths<br/>
		/// </para>
		/// </param>
		/// <param name="name">(Optional) Schematic window title</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL show_schematic(String objects, bool? add = null, bool? remove = null, bool? regenerate = null, bool? pin_pairs = null, String name = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: show_schematic [-add] [-remove] [-regenerate] [-pin_pairs] [-name <arg>] [-quiet] [-verbose] <objects>
			this.Entry(_builder.show_schematic(objects, add, remove, regenerate, pin_pairs, name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Remove differential pair relationship between 2 ports<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: split_diff_pair_ports [-quiet] [-verbose] &lt;ports&gt;...
		/// <br/>
		/// <para>
		/// Splits an existing differential pair of ports into two single-ended ports.<br/>
		/// Note: This command operates silently and does not return direct feedback of its operation.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example splits the specified diff pair ports to form two single ended ports:<br/>
		/// split_diff_pair_ports PORT_N PORT_P<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1711<br/>
		/// </para>
		/// </summary>
		/// <param name="ports">(Required) Ports to split</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL split_diff_pair_ports(TCLParameterList ports, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: split_diff_pair_ports [-quiet] [-verbose] <ports>...
			this.Entry(_builder.split_diff_pair_ports(ports, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Start GUI<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: start_gui [-verbose]
		/// <br/>
		/// <para>
		/// Launches the GUI when the tool is running in the Vivado Design Suite Tcl shell. The GUI is<br/>
		/// invoked with the current project, design, and run information.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example is executed from the command prompt when the tool is running in Tcl<br/>
		/// mode:<br/>
		/// Vivado% start_gui<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1713<br/>
		/// </para>
		/// </summary>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL start_gui(bool? verbose = null)
		{
			// TCL Syntax: start_gui [-verbose]
			this.Entry(_builder.start_gui(verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Start capturing VCD output (equivalent of $dumpon verilog system task). This can be used after a<br/>
		/// stop_vcd TCL command has stopped VCD generation started by open_vcd<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: start_vcd [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// The start_vcd command specifies that the tool start writing Value Change Dump (VCD)<br/>
		/// information into the specified VCD object. This Tcl command models the behavior of the Verilog<br/>
		/// $dumpon system task.<br/>
		/// IMPORTANT! You must execute the open_vcd command before using the start_vcd command.<br/>
		/// Nothing is returned by this command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example starts the writing of HDL signals into the current VCD file:<br/>
		/// start_vcd<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1714<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL start_vcd(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: start_vcd [-quiet] [-verbose]
			this.Entry(_builder.start_vcd(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Start a set of commands that can be undone/redone as a group<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: startgroup [-try] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Starts a sequence of commands that can be undone or redone as a series. Use endgroup to end<br/>
		/// the sequence of commands.<br/>
		/// You can have multiple command groups to undo or redo, but you cannot nest command groups.<br/>
		/// You must use endgroup to end a command sequence before using startgroup to create a<br/>
		/// new command sequence.<br/>
		/// TIP: The startgroup /endgroup commands are provided to support sequences of related commands<br/>
		/// that can be undone via the undo command, or redone if needed using the redo command. However,<br/>
		/// some commands can trigger an endgroup unexpectedly, and certain commands do not support either<br/>
		/// undo or redo. The limitations are not fully defined.<br/>
		/// The startgroup command returns an integer value of 0 if a group is already started, and<br/>
		/// returns an integer value of 1 if the startgroup command has started a new group.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example defines a startgroup, executes a sequence of related commands, and<br/>
		/// then executes the endgroup. This sequence of commands can be undone or redone as a group:<br/>
		/// startgroup<br/>
		/// create_pblock pblock_wbArbEngine<br/>
		/// create_pblock pblock_usbEngnSRM<br/>
		/// add_cells_to_pblock pblock_wbArbEngine \<br/>
		/// [get_cells [list wbArbEngine]] -clear_locs<br/>
		/// add_cells_to_pblock pblock_usbEngnSRM \<br/>
		/// [get_cells [list usbEngine1/usbEngineSRAM]] -clear_locs<br/>
		/// endgroup<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1716<br/>
		/// </para>
		/// </summary>
		/// <param name="try">(Optional) Don't start a group if one has already been started</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>int</returns>
		public VivadoTCL startgroup(bool? @try = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: startgroup [-try] [-quiet] [-verbose]
			this.Entry(_builder.startgroup(@try, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Step simulation to the next statement<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: step [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Step the current simulation to the next executable statement in the HDL source files.<br/>
		/// The line stepping feature lets you run the simulator stepping through the source code line-by-line. This is helpful if you are interested in observing how each line or feature of your HDL source<br/>
		/// affects the results of simulation.<br/>
		/// The step command returns information related to the next executable line from the HDL source<br/>
		/// file, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example runs the current executable line of the HDL source code, and pauses at<br/>
		/// the next executable line, returning information about that line:<br/>
		/// step<br/>
		/// Stopped at time : 0 fs : File "C:/Data/ug937/sim/testbench.v" Line 17<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1718<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL step(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: step [-quiet] [-verbose]
			this.Entry(_builder.step(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Use within a condition to tell simulation to stop when a condition is true<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: stop [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// The stop command pauses the current simulation. This command can be used within a<br/>
		/// condition, defined by add_condition, to pause the simulation when the condition is true.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example defines a condition named resetLow, that becomes true when the reset<br/>
		/// signal is low, and then puts a message to the standard output, and stops the current simulation:<br/>
		/// add_condition -name resetLow {/testbench/reset == 0 } {<br/>
		/// puts "Condition Reset was encountered at [current_time]. \<br/>
		/// Stopping simulation."<br/>
		/// stop }<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1720<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>A "stop" in simulation is a pause and not a quit</returns>
		public VivadoTCL stop(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: stop [-quiet] [-verbose]
			this.Entry(_builder.stop(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Close GUI<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: stop_gui [-verbose]
		/// <br/>
		/// <para>
		/// Stops GUI mode and places the tool into Tcl mode, running in the Vivado Design Suite Tcl shell. In<br/>
		/// Tcl mode, all commands must be entered as Tcl commands or through Tcl scripts.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example stops and closes the GUI and places the tool into Tcl mode:<br/>
		/// stop_gui<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1722<br/>
		/// </para>
		/// </summary>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL stop_gui(bool? verbose = null)
		{
			// TCL Syntax: stop_gui [-verbose]
			this.Entry(_builder.stop_gui(verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Disable Activity Monitor runs for the specified hardware HBM(s)<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: stop_hw_hbm_amon [-quiet] [-verbose] &lt;hw_objects&gt;
		/// <br/>
		/// <para>
		/// The stop_hw_hbm_amon command stops a running HBM activity monitor in the Vivado<br/>
		/// hardware manager that has been previously started using the run_hw_hbm_amon command.<br/>
		/// This command returns nothing when successful, or returns an error when it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example stops the HBM activity monitor for the associated HBM core:<br/>
		/// stop_hw_hbm_amon [get_hw_hbms *HBM_2]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1723<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_objects">(Required) hardware objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL stop_hw_hbm_amon(String hw_objects, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: stop_hw_hbm_amon [-quiet] [-verbose] <hw_objects>
			this.Entry(_builder.stop_hw_hbm_amon(hw_objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Stop hardware SIO scans.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: stop_hw_sio_scan [-quiet] [-verbose] &lt;hw_sio_scans&gt;
		/// <br/>
		/// <para>
		/// Stop the specified scan running in the Vivado serial I/O analyzer.<br/>
		/// To analyze the margin of a given link, it is often helpful to run a scan of the link using the<br/>
		/// specialized Eye Scan hardware of Xilinx UltraScale devices or 7 series FPGAs. The Vivado serial<br/>
		/// I/O analyzer feature lets you to create, run, and save link scans.<br/>
		/// This command lets you stop a scan that is in progress as started with the run_hw_sio_scan<br/>
		/// command.<br/>
		/// You can remove the created scan object using remove_hw_sio_scan.<br/>
		/// This command returns a message if successful, or returns an error if the command fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1725<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_sio_scans">(Required) hardware SIO scans</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL stop_hw_sio_scan(String hw_sio_scans, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: stop_hw_sio_scan [-quiet] [-verbose] <hw_sio_scans>
			this.Entry(_builder.stop_hw_sio_scan(hw_sio_scans, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Stop hardware SIO sweeps.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: stop_hw_sio_sweep [-quiet] [-verbose] &lt;hw_sio_sweeps&gt;
		/// <br/>
		/// <para>
		/// Stop the specified sweep scan.<br/>
		/// To analyze the margin of a given link, it is often helpful to run a scan of the link using the<br/>
		/// specialized features of Xilinx UltraScale devices or 7 series FPGAs. It can also be helpful to run<br/>
		/// multiple scans on a the link with different configuration settings for the GTs. This can help you<br/>
		/// determine which settings are best for your design. The Vivado serial I/O analyzer feature enables<br/>
		/// you to define, run, and save link sweeps, or collections of link scans run across a range of values.<br/>
		/// This command lets you stop a sweep scan that is in progress as started with the<br/>
		/// run_hw_sio_sweep command.<br/>
		/// You can remove the created sweep scan object using remove_hw_sio_sweep.<br/>
		/// This command returns nothing if successful, or returns an error if the command fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1727<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_sio_sweeps">(Required) hardware SIO sweeps</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL stop_hw_sio_sweep(String hw_sio_sweeps, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: stop_hw_sio_sweep [-quiet] [-verbose] <hw_sio_sweeps>
			this.Entry(_builder.stop_hw_sio_sweep(hw_sio_sweeps, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Stop capturing VCD output (equivalent of $dumpoff verilog system task). The start_vcd TCL<br/>
		/// command can be used to resume capturing VCD<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: stop_vcd [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Stop writing the simulation values to the current Value Change Dump (VCD) file. This suspends<br/>
		/// the output of simulation information to the file until the process is resumed using the<br/>
		/// start_vcd command.<br/>
		/// This Tcl command models the behavior of the Verilog $dumpoff system task.<br/>
		/// IMPORTANT! You must execute the open_vcd command before using the stop_vcd command.<br/>
		/// Nothing is returned by the command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example stops writing simulation values to the current VCD file:<br/>
		/// stop_vcd<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1729<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL stop_vcd(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: stop_vcd [-quiet] [-verbose]
			this.Entry(_builder.stop_vcd(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Swap two locations<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: swap_locs [-quiet] [-verbose] &lt;aloc&gt; &lt;bloc&gt;
		/// <br/>
		/// <para>
		/// Swaps the LOC constraints assigned to two similar logic elements. A logic element is an element<br/>
		/// that can be placed onto a device resource on the FPGA.<br/>
		/// Some DRC checking is performed when the swap_locs command is executed to ensure that<br/>
		/// the two selected elements can in fact be assigned to their new locations. If the location of either<br/>
		/// element is invalid for any reason, the swap_locs command will fail and an error will be<br/>
		/// returned.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example swaps the instances assigned to the two specified device sites:<br/>
		/// swap_locs [get_sites {OLOGIC_X2Y1}] [get_sites {OLOGIC_X2Y0}]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1731<br/>
		/// </para>
		/// </summary>
		/// <param name="aloc">(Required) First location (port/cell/site - should be of same type as 'bloc')</param>
		/// <param name="bloc">(Required) Second location (port/cell/site - should be of same type as 'aloc')</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL swap_locs(String aloc, String bloc, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: swap_locs [-quiet] [-verbose] <aloc> <bloc>
			this.Entry(_builder.swap_locs(aloc, bloc, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Synthesize a design using Vivado Synthesis and open that design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: synth_design [-name &lt;arg&gt;] [-part &lt;arg&gt;] [-constrset &lt;arg&gt;] [-top &lt;arg&gt;] [-include_dirs &lt;args&gt;] [-generic &lt;args&gt;] [-verilog_define &lt;args&gt;] [-flatten_hierarchy &lt;arg&gt;] [-gated_clock_conversion &lt;arg&gt;] [-directive &lt;arg&gt;] [-rtl] [-bufg &lt;arg&gt;] [-no_lc] [-shreg_min_size &lt;arg&gt;] [-mode &lt;arg&gt;] [-fsm_extraction &lt;arg&gt;] [-rtl_skip_mlo] [-rtl_skip_ip] [-rtl_skip_constraints] [-srl_style &lt;arg&gt;] [-keep_equivalent_registers] [-resource_sharing &lt;arg&gt;] [-cascade_dsp &lt;arg&gt;] [-control_set_opt_threshold &lt;arg&gt;] [-incremental &lt;arg&gt;] [-max_bram &lt;arg&gt;] [-max_uram &lt;arg&gt;] [-max_dsp &lt;arg&gt;] [-max_bram_cascade_height &lt;arg&gt;] [-max_uram_cascade_height &lt;arg&gt;] [-retiming] [-no_srlextract] [-assert] [-no_timing_driven] [-sfcu] [-debug_log] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Directly launches the Vivado synthesis engine to compile and synthesize a design in either<br/>
		/// Project Mode or Non-Project Mode in the Vivado Design Suite. Refer to the Vivado Design Suite<br/>
		/// User Guide: Design Flows Overview (UG892) for a complete description of Project Mode and Non-Project Mode.<br/>
		/// Vivado synthesis can be launched directly with the synth_design command in the Non-Project Mode of the Vivado Design Suite.<br/>
		/// TIP: The synth_design can be multi-threaded to speed the process. Refer to the set_param<br/>
		/// command for more information on setting the general.maxThreads parameter.<br/>
		/// In Project Mode, synthesis should be launched from an existing synthesis run created with the<br/>
		/// create_run command. The run is launched using the launch_runs command, and this in turn<br/>
		/// calls synth_design for Vivado synthesis.<br/>
		/// You can also use the synth_design command to elaborate RTL source files, and open an<br/>
		/// elaborated design:<br/>
		/// synth_design -rtl -name rtl_1<br/>
		/// This command returns a transcript of the synthesis process, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example uses the set_property command to define the target part for the<br/>
		/// active project, then elaborates the source files and opens an RTL design:<br/>
		/// set_property part xc7vx485tffg1158-1 [current_project]<br/>
		/// synth_design -rtl -name rtl_1<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Note: The default source set, constraint set, and part will be used in this example.<br/>
		/// The following example uses the find_top command to define the top of the current design for<br/>
		/// synthesis:<br/>
		/// synth_design -top [lindex [find_top] 0]<br/>
		/// Note: Since find_top returns multiple possible candidates, choosing index 0 chooses the best top<br/>
		/// candidate for synthesis.<br/>
		/// The following example runs synthesis on the current design, defining the top module and the<br/>
		/// target part, and specifying no flattening of the hierarchy. The results of the synthesis run are then<br/>
		/// opened in a netlist design:<br/>
		/// synth_design -top top -part xc7k70tfbg676-2 -flatten_hierarchy none<br/>
		/// open_run synth_1 -name netlist_1<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1733<br/>
		/// </para>
		/// </summary>
		/// <param name="name">(Optional) Design name</param>
		/// <param name="part">(Optional) Target part</param>
		/// <param name="constrset">(Optional) Constraint fileset to use</param>
		/// <param name="top">(Optional) Specify the top module name</param>
		/// <param name="include_dirs">(Optional) Specify verilog search directories</param>
		/// <param name="generic">
		/// <para>
		/// (Optional)<br/>
		/// Specify generic parameters. Syntax: -generic<br/>
		/// &lt;name&gt;=&lt;value&gt; -generic &lt;name&gt;=&lt;value&gt; ...<br/>
		/// </para>
		/// </param>
		/// <param name="verilog_define">
		/// <para>
		/// (Optional)<br/>
		/// Specify verilog defines. Syntax: -verilog_define<br/>
		/// &lt;macro_name&gt;[=&lt;macro_text&gt;] -verilog_define<br/>
		/// &lt;macro_name&gt;[=&lt;macro_text&gt;] ...<br/>
		/// </para>
		/// </param>
		/// <param name="flatten_hierarchy">
		/// <para>
		/// (Optional)<br/>
		/// Flatten hierarchy during LUT mapping. Values: full, none,<br/>
		/// rebuilt Default: rebuilt<br/>
		/// </para>
		/// </param>
		/// <param name="gated_clock_conversion">
		/// <para>
		/// (Optional)<br/>
		/// Convert clock gating logic to flop enable. Values: off, on,<br/>
		/// auto Default: off<br/>
		/// </para>
		/// </param>
		/// <param name="directive">
		/// <para>
		/// (Optional)<br/>
		/// Synthesis directive. Values: default, RuntimeOptimized,<br/>
		/// AreaOptimized_high,<br/>
		/// AreaOptimized_medium,AlternateRoutability,<br/>
		/// AreaMapLargeShiftRegToBRAM, AreaMultThresholdDSP,<br/>
		/// FewerCarryChains,Perfor manceOptimized,<br/>
		/// LogicCompaction Default: default<br/>
		/// </para>
		/// </param>
		/// <param name="rtl">(Optional) Elaborate and open an rtl design</param>
		/// <param name="bufg">
		/// <para>
		/// (Optional)<br/>
		/// Max number of global clock buffers used by synthesis<br/>
		/// Default: 12<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Name Description<br/>
		/// </para>
		/// </param>
		/// <param name="no_lc">
		/// <para>
		/// (Optional)<br/>
		/// Disable LUT combining. Do not allow combining LUT pairs<br/>
		/// into single dual output LUTs.<br/>
		/// </para>
		/// </param>
		/// <param name="shreg_min_size">(Optional) Minimum length for chain of registers to be mapped onto SRL Default: 3</param>
		/// <param name="mode">(Optional) The design mode. Values: default, out_of_context Default: default</param>
		/// <param name="fsm_extraction">
		/// <para>
		/// (Optional)<br/>
		/// FSM Extraction Encoding. Values: off, one_hot, sequential,<br/>
		/// johnson, gray, user_encoding, auto Default: auto<br/>
		/// </para>
		/// </param>
		/// <param name="rtl_skip_mlo">
		/// <para>
		/// (Optional)<br/>
		/// Skip mandatory logic optimization for RTL elaboration of the<br/>
		/// design; requires -rtl option.<br/>
		/// </para>
		/// </param>
		/// <param name="rtl_skip_ip">
		/// <para>
		/// (Optional)<br/>
		/// Exclude subdesign checkpoints in the RTL elaboration of the<br/>
		/// design; requires -rtl option.<br/>
		/// </para>
		/// </param>
		/// <param name="rtl_skip_constraints">
		/// <para>
		/// (Optional)<br/>
		/// Do not load and validate constraints against elaborated<br/>
		/// design; requires -rtl option.<br/>
		/// </para>
		/// </param>
		/// <param name="srl_style">
		/// <para>
		/// (Optional)<br/>
		/// Static SRL Implementation Style. Values: register, srl, srl_reg,<br/>
		/// reg_srl, reg_srl_reg<br/>
		/// </para>
		/// </param>
		/// <param name="keep_equivalent_registers">
		/// <para>
		/// (Optional)<br/>
		/// Prevents registers sourced by the same logic from being<br/>
		/// merged. (Note that the merging can otherwise be<br/>
		/// prevented using the synthesis KEEP attribute)<br/>
		/// </para>
		/// </param>
		/// <param name="resource_sharing">(Optional) Sharing arithmetic operators. Value: auto, on, off Default: auto</param>
		/// <param name="cascade_dsp">
		/// <para>
		/// (Optional)<br/>
		/// Controls how adders summing DSP block outputs will be<br/>
		/// implemented. Value: auto, tree, force Default: auto<br/>
		/// </para>
		/// </param>
		/// <param name="control_set_opt_threshold">
		/// <para>
		/// (Optional)<br/>
		/// Threshold for synchronous control set optimization to lower<br/>
		/// number of control sets. Valid values are 'auto' and non-negative integers. The higher the number, the more control<br/>
		/// set optimization will be performed and fewer control sets<br/>
		/// will result. To disable control set optimization completely,<br/>
		/// set to 0. Default: auto<br/>
		/// </para>
		/// </param>
		/// <param name="incremental">(Optional) dcp file for incremental flowvalue of this is the file name</param>
		/// <param name="max_bram">
		/// <para>
		/// (Optional)<br/>
		/// Maximum number of block RAM allowed in design. (Note -1<br/>
		/// means that the tool will choose the max number allowed for<br/>
		/// the part in question) Default: -1<br/>
		/// </para>
		/// </param>
		/// <param name="max_uram">
		/// <para>
		/// (Optional)<br/>
		/// Maximum number of Ultra RAM blocks allowed in design.<br/>
		/// (Note -1 means that the tool will choose the max number<br/>
		/// allowed for the part in question) Default: -1<br/>
		/// </para>
		/// </param>
		/// <param name="max_dsp">
		/// <para>
		/// (Optional)<br/>
		/// Maximum number of block DSP allowed in design. (Note -1<br/>
		/// means that the tool will choose the max number allowed for<br/>
		/// the part in question) Default: -1<br/>
		/// </para>
		/// </param>
		/// <param name="max_bram_cascade_height">
		/// <para>
		/// (Optional)<br/>
		/// Controls the maximum number of BRAM that can be<br/>
		/// cascaded by the tool. (Note -1 means that the tool will<br/>
		/// choose the max number allowed for the part in question)<br/>
		/// Default: -1<br/>
		/// </para>
		/// </param>
		/// <param name="max_uram_cascade_height">
		/// <para>
		/// (Optional)<br/>
		/// Controls the maximum number of URAM that can be<br/>
		/// cascaded by the tool. (Note -1 means that the tool will<br/>
		/// choose the max number allowed for the part in question)<br/>
		/// Default: -1<br/>
		/// </para>
		/// </param>
		/// <param name="retiming">
		/// <para>
		/// (Optional)<br/>
		/// Seeks to improve circuit performance for intra-clock<br/>
		/// sequential paths by automatically moving registers (register<br/>
		/// balancing) across combinatorial gates or LUTs. It maintains<br/>
		/// the original behavior and latency of the circuit and does not<br/>
		/// require changes to the RTL sources.<br/>
		/// </para>
		/// </param>
		/// <param name="no_srlextract">
		/// <para>
		/// (Optional)<br/>
		/// Prevents the extraction of shift registers so that they get<br/>
		/// implemented as simple registers<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Name Description<br/>
		/// </para>
		/// </param>
		/// <param name="assert">
		/// <para>
		/// (Optional)<br/>
		/// Enable VHDL assert statements to be evaluated. A severity<br/>
		/// level of failure will stop the synthesis flow and produce an<br/>
		/// error.<br/>
		/// </para>
		/// </param>
		/// <param name="no_timing_driven">(Optional) Do not run in timing driven mode</param>
		/// <param name="sfcu">(Optional) Run in single-file compilation unit mode</param>
		/// <param name="debug_log">(Optional) Print detailed log files for debugging</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>design object</returns>
		public VivadoTCL synth_design(String name = null, String part = null, String constrset = null, String top = null, TCLParameterList include_dirs = null, TCLParameterList generic = null, TCLParameterList verilog_define = null, synth_design_flatten_hierarchy? flatten_hierarchy = null, synth_design_gated_clock_conversion? gated_clock_conversion = null, synth_design_directive? directive = null, bool? rtl = null, Int32? bufg = null, bool? no_lc = null, String shreg_min_size = null, synth_design_mode? mode = null, synth_design_fsm_extraction? fsm_extraction = null, bool? rtl_skip_mlo = null, bool? rtl_skip_ip = null, bool? rtl_skip_constraints = null, synth_design_srl_style? srl_style = null, bool? keep_equivalent_registers = null, String resource_sharing = null, String cascade_dsp = null, Int32? control_set_opt_threshold = null, String incremental = null, Int32? max_bram = null, Int32? max_uram = null, Int32? max_dsp = null, Int32? max_bram_cascade_height = null, Int32? max_uram_cascade_height = null, bool? retiming = null, bool? no_srlextract = null, bool? assert = null, bool? no_timing_driven = null, bool? sfcu = null, bool? debug_log = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: synth_design [-name <arg>] [-part <arg>] [-constrset <arg>] [-top <arg>] [-include_dirs <args>] [-generic <args>] [-verilog_define <args>] [-flatten_hierarchy <arg>] [-gated_clock_conversion <arg>] [-directive <arg>] [-rtl] [-bufg <arg>] [-no_lc] [-shreg_min_size <arg>] [-mode <arg>] [-fsm_extraction <arg>] [-rtl_skip_mlo] [-rtl_skip_ip] [-rtl_skip_constraints] [-srl_style <arg>] [-keep_equivalent_registers] [-resource_sharing <arg>] [-cascade_dsp <arg>] [-control_set_opt_threshold <arg>] [-incremental <arg>] [-max_bram <arg>] [-max_uram <arg>] [-max_dsp <arg>] [-max_bram_cascade_height <arg>] [-max_uram_cascade_height <arg>] [-retiming] [-no_srlextract] [-assert] [-no_timing_driven] [-sfcu] [-debug_log] [-quiet] [-verbose]
			this.Entry(_builder.synth_design(name, part, constrset, top, include_dirs, generic, verilog_define, flatten_hierarchy, gated_clock_conversion, directive, rtl, bufg, no_lc, shreg_min_size, mode, fsm_extraction, rtl_skip_mlo, rtl_skip_ip, rtl_skip_constraints, srl_style, keep_equivalent_registers, resource_sharing, cascade_dsp, control_set_opt_threshold, incremental, max_bram, max_uram, max_dsp, max_bram_cascade_height, max_uram_cascade_height, retiming, no_srlextract, assert, no_timing_driven, sfcu, debug_log, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Generate a synthesis netlist for an IP<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: synth_ip [-force] [-quiet] [-verbose] &lt;objects&gt;
		/// <br/>
		/// <para>
		/// This command is used in the non-project flow to create a synthesized design checkpoint file<br/>
		/// (DCP) to support the out-of-context (OOC) IP flow, or to synthesize and implement an IP module<br/>
		/// in the OOC hierarchical design flow. IP objects are specified by the get_ips command, or for<br/>
		/// the specified IP core file (XCI) as specified by the get_files command.<br/>
		/// IMPORTANT! To enable this functionality, the IP core must be marked for OOC generation by setting the<br/>
		/// GENERATE_SYNTH_CHECKPOINT property to true (or 1) using the set_property command on the<br/>
		/// XCI file.<br/>
		/// For project-based designs you would use the create_ip_run and launch_runs commands.<br/>
		/// Refer to the Vivado Design Suite User Guide: Design Flows Overview (UG892) for more information<br/>
		/// on Project and Non-Project Modes in Vivado.<br/>
		/// The synth_ip command will automatically generate any required target files prior to<br/>
		/// synthesizing the IP core. The source files required to synthesize the IP are copied into the IP run<br/>
		/// directory. Upon completion, any newly generated OOC target files (dcp, stub files, funcsim<br/>
		/// netlists...) are registered with the associated IP core.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example synthesizes the specified IP object, regenerating the netlist if the<br/>
		/// synthesized core is up-to-date:<br/>
		/// synth_ip [get_ips char_fifo] -force<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1742<br/>
		/// </para>
		/// </summary>
		/// <param name="objects">(Required) All the objects for which a netlist needs to be generated for.</param>
		/// <param name="force">(Optional) Force regeneration of the netlist.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL synth_ip(String objects, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: synth_ip [-force] [-quiet] [-verbose] <objects>
			this.Entry(_builder.synth_ip(objects, force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Tie off unused cell pins<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: tie_unused_pins [-of_objects &lt;args&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Tie up or down the unconnected pins of cells in the open synthesized or implemented design.<br/>
		/// The command uses an internal process to identify whether a pin should be tied up or down.<br/>
		/// This command is intended to tie up or down the unconnected pins of cells added to the netlist<br/>
		/// with the create_cell command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1744<br/>
		/// </para>
		/// </summary>
		/// <param name="of_objects">(Optional) tie unused pins of specified cell(s)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL tie_unused_pins(TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: tie_unused_pins [-of_objects <args>] [-quiet] [-verbose]
			this.Entry(_builder.tie_unused_pins(of_objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Un-do previous command<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: undo [-list] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// IMPORTANT! The undo and redo commands are intended for use in the Vivado IDE, and are not<br/>
		/// recommended for use in Tcl scripts to restore designs to a former state. To restore a design to a specific<br/>
		/// condition, you must write a design checkpoint using the write_checkpoint command, to be restored<br/>
		/// using read_checkpoint.<br/>
		/// Undo a prior command. This command can be used repeatedly to undo a series of commands.<br/>
		/// If a group of commands has been created using the startgroup and endgroup commands,<br/>
		/// this command will undo that group as a sequence. The undo command will start at the<br/>
		/// endgroup command and continue to undo until it hits the startgroup command.<br/>
		/// If you undo a command, and then change your mind, you can redo the command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns a list of commands that you can undo:<br/>
		/// undo -list<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1746<br/>
		/// </para>
		/// </summary>
		/// <param name="list">(Optional) Show a list of undoable tasks</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>with -list, the list of undoable tasks</returns>
		public VivadoTCL undo(bool? list = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: undo [-list] [-quiet] [-verbose]
			this.Entry(_builder.undo(list, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Move the group of cells inside a hierarchy cell to its parent cell, and then remove the hierarchical<br/>
		/// cell. The connections between these cells are maintained; the connections between these cells<br/>
		/// and other cells are maintained through crossing hierarchy cell.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: ungroup_bd_cells [-prefix &lt;arg&gt;] [-quiet] [-verbose] [&lt;cells&gt;...]
		/// <br/>
		/// <para>
		/// This command is intended to undo the grouping of IP integrator cells into a hierarchical module,<br/>
		/// by either the group_bd_cells or the move_bd_cells commands. The command moves the<br/>
		/// cells inside a selected hierarchical module up one level to the parent cell, and then removes the<br/>
		/// hierarchical module.<br/>
		/// The connections between the selected cells are maintained. The connections between these cells<br/>
		/// and other cells are maintained automatically by removing unneeded subsystem ports and pins.<br/>
		/// This command returns 0 if successful, or an error message if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1748<br/>
		/// </para>
		/// </summary>
		/// <param name="cells">(Required) Match engine names against cell names Default: *</param>
		/// <param name="prefix">(Optional) Prefix name to add to cells</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>0 if success.</returns>
		public VivadoTCL ungroup_bd_cells(TCLParameterList cells, String prefix = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: ungroup_bd_cells [-prefix <arg>] [-quiet] [-verbose] [<cells>...]
			this.Entry(_builder.ungroup_bd_cells(cells, prefix, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Unhighlight objects that are currently highlighted<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: unhighlight_objects [-color_index &lt;arg&gt;] [-rgb &lt;args&gt;] [-color &lt;arg&gt;] [-leaf_cells] [-quiet] [-verbose] [&lt;objects&gt;]
		/// <br/>
		/// <para>
		/// This command is for use in GUI mode. This command unhighlights the specified object or objects<br/>
		/// that were previously highlighted by the highlight_objects command.<br/>
		/// This command supports the color options as specified below. These options can be used to<br/>
		/// unhighlight all objects currently highlighted in the specified color. See the example below.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example unhighlights the specified cell objects:<br/>
		/// unhighlight_objects -leaf_cells [get_cells cpuEngine/*]<br/>
		/// The following example unhighlights all objects currently highlighted in the color yellow:<br/>
		/// unhighlight_objects -color yellow<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1750<br/>
		/// </para>
		/// </summary>
		/// <param name="color_index">(Optional) Color index</param>
		/// <param name="rgb">(Optional) RGB color index list</param>
		/// <param name="color">(Optional) Valid values are red green blue magenta yellow cyan and orange</param>
		/// <param name="leaf_cells">(Optional) Leaf cells</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">(Optional) Objects to unhighlight</param>
		public VivadoTCL unhighlight_objects(String color_index = null, TCLParameterList rgb = null, String color = null, bool? leaf_cells = null, bool? quiet = null, bool? verbose = null, String objects = null)
		{
			// TCL Syntax: unhighlight_objects [-color_index <arg>] [-rgb <args>] [-color <arg>] [-leaf_cells] [-quiet] [-verbose] [<objects>]
			this.Entry(_builder.unhighlight_objects(color_index, rgb, color, leaf_cells, quiet, verbose, objects));
			return this;
		}
		/// <summary>
		/// <para>
		/// Unmark items that are currently marked<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: unmark_objects [-rgb &lt;args&gt;] [-color &lt;arg&gt;] [-quiet] [-verbose] [&lt;objects&gt;]
		/// <br/>
		/// <para>
		/// Unmarks the specified object or objects that were previously marked by the mark_objects<br/>
		/// command. This command is for use in GUI mode.<br/>
		/// This command supports the color options as specified below. However, these options are not<br/>
		/// necessary to unmark a specific object, but can be used to unmark all objects currently marked in<br/>
		/// the specified color. See the example below.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example unmarks the selected objects:<br/>
		/// unmark_objects [get_selected_objects]<br/>
		/// The following example unmarks all objects currently marked in the color yellow:<br/>
		/// unmark_objects -color yellow<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1752<br/>
		/// </para>
		/// </summary>
		/// <param name="rgb">(Optional) RGB color index list</param>
		/// <param name="color">(Optional) Valid values are red green blue magenta yellow cyan and orange</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">(Optional) Objects to unmark</param>
		public VivadoTCL unmark_objects(TCLParameterList rgb = null, String color = null, bool? quiet = null, bool? verbose = null, String objects = null)
		{
			// TCL Syntax: unmark_objects [-rgb <args>] [-color <arg>] [-quiet] [-verbose] [<objects>]
			this.Entry(_builder.unmark_objects(rgb, color, quiet, verbose, objects));
			return this;
		}
		/// <summary>
		/// <para>
		/// Unplace one or more instances.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: unplace_cell [-quiet] [-verbose] &lt;cell_list&gt;...
		/// <br/>
		/// <para>
		/// Unplace the specified cells from their current placement site.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example unplaces the specified cell:<br/>
		/// unplace_cell {fftEngine/fftInst/ingressLoop[6].ingressFifo/buffer_fifo/<br/>
		/// i_4773_12897}<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example unplaces multiple cells:<br/>
		/// unplace_cell {div_cntr_reg_inferredi_4810_15889 div_cntr_reg[0]<br/>
		/// div_cntr_reg[1]}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1754<br/>
		/// </para>
		/// </summary>
		/// <param name="cell_list">(Required) a list of cells to be unplaced</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL unplace_cell(TCLParameterList cell_list, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: unplace_cell [-quiet] [-verbose] <cell_list>...
			this.Entry(_builder.unplace_cell(cell_list, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Unregister a previously registered Tcl proc.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: unregister_proc [-quiet] [-verbose] &lt;tasknm&gt;
		/// <br/>
		/// <para>
		/// Unregister the Tcl command, or &lt;tasknm&gt;, from the Vivado Design Suite Tcl interpretor.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1756<br/>
		/// </para>
		/// </summary>
		/// <param name="tasknm">(Required) Name of Tcl task to unregister. The task must be wrapping a proc.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Nothing</returns>
		public VivadoTCL unregister_proc(String tasknm, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: unregister_proc [-quiet] [-verbose] <tasknm>
			this.Entry(_builder.unregister_proc(tasknm, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Unselect items that are currently selected<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: unselect_objects [-quiet] [-verbose] [&lt;objects&gt;]
		/// <br/>
		/// <para>
		/// Unselects the specified object or objects that were previously selected by the<br/>
		/// select_objects command.<br/>
		/// This command will unselect both primary and secondary selected objects. The selection of<br/>
		/// secondary objects is controlled through the use of Selection Rules defined in the Tools → Settings<br/>
		/// command. Refer to the Vivado Design Suite User Guide: Using the IDE (UG893) for more<br/>
		/// information on Setting Selection Rules.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example unselects the specified site on the device:<br/>
		/// unselect_objects [get_sites SLICE_X56Y214]<br/>
		/// The following example unselects all currently selected objects:<br/>
		/// unselect_objects<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1758<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">(Optional) Objects to unselect</param>
		public VivadoTCL unselect_objects(bool? quiet = null, bool? verbose = null, String objects = null)
		{
			// TCL Syntax: unselect_objects [-quiet] [-verbose] [<objects>]
			this.Entry(_builder.unselect_objects(quiet, verbose, objects));
			return this;
		}
		/// <summary>
		/// <para>
		/// update the boundary of source designs of a specified block design container cell from its active<br/>
		/// variant source design or a specified design. Otherwise, update the boundary of a block design<br/>
		/// from another block design provided<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: update_bd_boundaries [-from_bd &lt;arg&gt;] [-check_only] [-quiet] [-verbose] [&lt;of_objects&gt;...]
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1760<br/>
		/// </para>
		/// </summary>
		/// <param name="from_bd">(Optional) block design to copy the boundary from</param>
		/// <param name="check_only">
		/// <para>
		/// (Optional)<br/>
		/// report only the changes made when the boundary is copied,<br/>
		/// do not save the changes to disk<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="of_objects">
		/// <para>
		/// (Optional)<br/>
		/// One or a list of block design container cells enabled for<br/>
		/// Dynamic Function Exchange or block desing names. List<br/>
		/// must be of one object type.<br/>
		/// </para>
		/// </param>
		/// <returns>TCL_OK on success, TCL_ERROR on failure.</returns>
		public VivadoTCL update_bd_boundaries(String from_bd = null, bool? check_only = null, bool? quiet = null, bool? verbose = null, TCLParameterList of_objects = null)
		{
			// TCL Syntax: update_bd_boundaries [-from_bd <arg>] [-check_only] [-quiet] [-verbose] [<of_objects>...]
			this.Entry(_builder.update_bd_boundaries(from_bd, check_only, quiet, verbose, of_objects));
			return this;
		}
		/// <summary>
		/// <para>
		/// Update clock routing on global clocks if they are modified after placement<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: update_clock_routing [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// The update_clock_routing command is an advanced command used for manually updating<br/>
		/// the routing structures of all global clocks in designs targeting the UltraScale architecture. The<br/>
		/// command operates on all global clocks in a design, not individual clocks.<br/>
		/// Due to a more flexible clocking architecture, UltraScale and UltraScale+ designs require a two-step process for routing global clocks. First the Vivado placer assigns the routing resources<br/>
		/// required to route the global clocks from the clock source to the destination clock regions<br/>
		/// (CLOCK_ROOT or USER_CLOCK_ROOT). Next the Vivado router fills in the routing gaps on the<br/>
		/// clock nets. In between these two steps the resulting structures are called gap trees: each global<br/>
		/// clock net has its base routing resources assigned but with large routing gaps where no routing<br/>
		/// resources have been assigned.<br/>
		/// After gap trees are constructed, the router optimally routes the remaining clock network to all<br/>
		/// leaf-level primitives to fill in the routing gaps. During an implementation run the global clock<br/>
		/// routing is handled automatically. However in cases where the clock tree has been changed after<br/>
		/// implementation, by modifying the USER_CLOCK_ROOT property on a clock net for instance, the<br/>
		/// Vivado tool may need the update_clock_routing command to properly rebuild the gap trees<br/>
		/// and fill in the routing gaps.<br/>
		/// Examples of this include:<br/>
		/// • Moving the clock root of a global clock.<br/>
		/// • Adding or moving loads of a global clock into a clock region not yet occupied by the global<br/>
		/// clock, then running timing analysis on the updated design.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// • Moving the clock root of a global clock.<br/>
		/// • Adding or moving loads of a global clock into a clock region not yet occupied by the global<br/>
		/// clock, then running timing analysis on the updated design.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Arguments<br/>
		/// -quiet - (Optional) Execute the command quietly, returning no messages from the command.<br/>
		/// The command also returns TCL_OK regardless of any errors encountered during execution.<br/>
		/// Note: Any errors encountered on the command-line, while launching the command, will be returned. Only<br/>
		/// errors occurring inside the command will be trapped.<br/>
		/// -verbose - (Optional) Temporarily override any message limits and return all messages from this<br/>
		/// command.<br/>
		/// Note: Message limits can be defined with the set_msg_config command.<br/>
		/// Examples<br/>
		/// The following example updates the USER_CLOCK_ROOT property on the specified clock nets,<br/>
		/// unroutes the nets, and then updates the clock routing:<br/>
		/// set_property USER_CLOCK_ROOT X1Y0 [get_nets {clk1 clk2}]<br/>
		/// route_design -unroute -nets [get_nets {clk1 clk2}]<br/>
		/// update_clock_routing<br/>
		/// IMPORTANT! The unroute command is needed to clean out existing clock routing on the clock nets<br/>
		/// before updating the clock routing.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1761<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL update_clock_routing(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: update_clock_routing [-quiet] [-verbose]
			this.Entry(_builder.update_clock_routing(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Updates a fileset compile order and possibly top based on a design graph.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: update_compile_order [-force_gui] [-fileset &lt;arg&gt;] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Update the compile order of the design sources in the current project, or in the specified fileset.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example updates the compile order of the source files in the simulation fileset:<br/>
		/// update_compile_order -fileset sim_1<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1763<br/>
		/// </para>
		/// </summary>
		/// <param name="force_gui">(Optional) Execute this command, even when run interactively in the GUI.</param>
		/// <param name="fileset">(Optional) Fileset to update based on a design graph</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL update_compile_order(bool? force_gui = null, String fileset = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: update_compile_order [-force_gui] [-fileset <arg>] [-quiet] [-verbose]
			this.Entry(_builder.update_compile_order(force_gui, fileset, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// update the netlist of the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: update_design -cells &lt;args&gt; [-strict] [-from_file &lt;arg&gt;] [-from_design &lt;arg&gt;] [-from_cell &lt;arg&gt;] [-black_box] [-buffer_ports] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// This command updates the in-memory design, replacing the current netlist in the specified cell<br/>
		/// with a netlist from a specified file, from another open design, from a specified cell of a design, or<br/>
		/// converts the cell to a black box cell.<br/>
		/// The update_design command can update a single instance, or can update all instances of a<br/>
		/// master cell.<br/>
		/// Only the in-memory view of the design is changed by the new netlist. You must save the design<br/>
		/// using the write_checkpoint command, or any updates will be lost when you close the project<br/>
		/// or exit the tool.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// This example replaces a black box cell with the netlist from the specified file:<br/>
		/// update_design -from_file C:/Data/cell_contents.v -cell black_box_cell<br/>
		/// The following example updates the netlist in the arnd4 cell with the specified Verilog netlist:<br/>
		/// update_design -cell arnd4 -from_file C:/Data/round_4.v<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example updates the arnd4 cell in the current design with the netlist from the<br/>
		/// same cell in the specified design:<br/>
		/// update_design -cell arnd4 -from_design netlist_2 -from_cell arnd4<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1765<br/>
		/// </para>
		/// </summary>
		/// <param name="cells">(Required) List of cells to update with a new sub-netlist.</param>
		/// <param name="strict">
		/// <para>
		/// (Optional)<br/>
		/// Require exact ports match for replacing cell (otherwise extra<br/>
		/// ports are allowed).<br/>
		/// </para>
		/// </param>
		/// <param name="from_file">(Optional) Name of the file containing the new sub-netlist.</param>
		/// <param name="from_design">(Optional) Name of the an open netlist design containing the new sub-netlist.</param>
		/// <param name="from_cell">(Optional) Name of cell in the from_design which defines the new sub-netlist.</param>
		/// <param name="black_box">(Optional) Update the cell to a black_box.</param>
		/// <param name="buffer_ports">(Optional) buffer all the ports of black box</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL update_design(TCLParameterList cells, bool? strict = null, String from_file = null, String from_design = null, String from_cell = null, bool? black_box = null, bool? buffer_ports = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: update_design -cells <args> [-strict] [-from_file <arg>] [-from_design <arg>] [-from_cell <arg>] [-black_box] [-buffer_ports] [-quiet] [-verbose]
			this.Entry(_builder.update_design(cells, strict, from_file, from_design, from_cell, black_box, buffer_ports, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Update file(s) in the project based on the file(s) or directory(ies) specified<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: update_files [-from_files &lt;args&gt;] [-norecurse] [-to_files &lt;args&gt;] [-filesets &lt;args&gt;] [-force] [-report_only] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Updates the specified files with the contents of specified remote files. Use this command to<br/>
		/// update a local file with the contents of its original remote file, or replace it with the contents of a<br/>
		/// different remote file.<br/>
		/// This command returns a list of updated files, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example updates the various project source IP core files with the specified -<br/>
		/// from_files, reporting the results without making any updates:<br/>
		/// update_files -from_files C:/Data/IP/*.xci \<br/>
		/// -to_file [get_files *.xci} -report_only<br/>
		/// Note: No warnings will be issued for newer local files that will be overwritten.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1768<br/>
		/// </para>
		/// </summary>
		/// <param name="from_files">(Optional) New files and directories to use for updating</param>
		/// <param name="norecurse">(Optional) Recursively search in specified directories</param>
		/// <param name="to_files">(Optional) Existing project files and directories to limit updates to</param>
		/// <param name="filesets">(Optional) Fileset name</param>
		/// <param name="force">
		/// <para>
		/// (Optional)<br/>
		/// Overwrite imported files in the project, even if read-only, if<br/>
		/// possible<br/>
		/// </para>
		/// </param>
		/// <param name="report_only">
		/// <para>
		/// (Optional)<br/>
		/// Do no actual file updates, but report on updates that<br/>
		/// otherwise would have been made<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>list of the files updated</returns>
		public VivadoTCL update_files(TCLParameterList from_files = null, bool? norecurse = null, TCLParameterList to_files = null, TCLParameterList filesets = null, bool? force = null, bool? report_only = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: update_files [-from_files <args>] [-norecurse] [-to_files <args>] [-filesets <args>] [-force] [-report_only] [-quiet] [-verbose]
			this.Entry(_builder.update_files(from_files, norecurse, to_files, filesets, force, report_only, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Update the SmartLynq firmware image<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: update_hw_firmware [-file_path &lt;arg&gt;] [-config_path &lt;arg&gt;] [-skip_update] [-reset] [-format] [-flash] [-quiet] [-verbose] [&lt;hw_server&gt;]
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1770<br/>
		/// </para>
		/// </summary>
		/// <param name="file_path">(Optional) Optional path to BOOT.BIN file Default: Use default BOOT.BIN</param>
		/// <param name="config_path">(Optional) Optional path to config.ini file Default: No config.ini updated</param>
		/// <param name="skip_update">(Optional) Skip writing the BOOT.BIN to the SmartLynq</param>
		/// <param name="reset">
		/// <para>
		/// (Optional)<br/>
		/// Reset the SmartLynq cable after any other operations to<br/>
		/// complete the update and disconnects the hw_server<br/>
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// (Optional)<br/>
		/// Format the SmartLynq cable EMMC prior to any other<br/>
		/// operations. Any files on SmartLynq cable will be lost.<br/>
		/// </para>
		/// </param>
		/// <param name="flash">
		/// <para>
		/// (Optional)<br/>
		/// Flash the SmartLynq cable QSPI. This updates the primary<br/>
		/// FSBL and Safe Mode images.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_server">(Optional) hardware server Default: current hardware server</param>
		public VivadoTCL update_hw_firmware(String file_path = null, String config_path = null, bool? skip_update = null, bool? reset = null, bool? format = null, bool? flash = null, bool? quiet = null, bool? verbose = null, String hw_server = null)
		{
			// TCL Syntax: update_hw_firmware [-file_path <arg>] [-config_path <arg>] [-skip_update] [-reset] [-format] [-flash] [-quiet] [-verbose] [<hw_server>]
			this.Entry(_builder.update_hw_firmware(file_path, config_path, skip_update, reset, format, flash, quiet, verbose, hw_server));
			return this;
		}
		/// <summary>
		/// <para>
		/// Update the SmartLynq GPIO PMOD pin values<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: update_hw_gpio [-quiet] [-verbose] [&lt;output_enable_mask&gt;] [&lt;output_pin_values&gt;] [&lt;hw_server&gt;]
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1771<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="output_enable_mask">
		/// <para>
		/// (Optional)<br/>
		/// 8 bit hex mask to enable output pins on GPIO Default: All<br/>
		/// output pins disabled<br/>
		/// </para>
		/// </param>
		/// <param name="output_pin_values">(Optional) 8 bit hex value of output pins Default: All output pins driven low</param>
		/// <param name="hw_server">(Optional) hardware server Default: current hardware server</param>
		/// <returns>All GPIO PMOD pin values</returns>
		public VivadoTCL update_hw_gpio(bool? quiet = null, bool? verbose = null, String output_enable_mask = null, String output_pin_values = null, String hw_server = null)
		{
			// TCL Syntax: update_hw_gpio [-quiet] [-verbose] [<output_enable_mask>] [<output_pin_values>] [<hw_server>]
			this.Entry(_builder.update_hw_gpio(quiet, verbose, output_enable_mask, output_pin_values, hw_server));
			return this;
		}
		/// <summary>
		/// <para>
		/// Update the IP Catalog. Before executing this command optionally use the following to set<br/>
		/// repository paths:'set_property ip_repo_paths &lt;repo_path_list&gt; [current_fileset]'<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: update_ip_catalog [-rebuild] [-add_ip &lt;arg&gt;] [-delete_ip &lt;arg&gt;] [-delete_mult_ip &lt;args&gt;] [-disable_ip &lt;arg&gt;] [-enable_ip &lt;arg&gt;] [-add_interface &lt;arg&gt;] [-create_index] [-repo_path &lt;arg&gt;] [-update_module_ref] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Update the IP catalog associated with the current design.<br/>
		/// The Xilinx® IP catalog, or repository, is located in the installation hierarchy of the Vivado Design<br/>
		/// Suite software release being used. You can also add custom IP to the repository by using the<br/>
		/// set_property command to set the IP_REPO_PATHS property on the source fileset to point to<br/>
		/// the locations of custom IP, as shown in the example below.<br/>
		/// The update_ip_catalog command lets you add, delete, disable, or enable individual IP cores<br/>
		/// in the catalog. When referring to individual cores, you can reference them by the path to the<br/>
		/// component.xml file, or by referencing the VLNV property of the IP.<br/>
		/// TIP: The VLNV property refers to the Vendor:Library:Name:Version string which uniquely identifies the IP<br/>
		/// in the catalog.<br/>
		/// This command returns a transcript of its process if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example sets the IP_REPO_PATHS property of the current Source fileset, to add an<br/>
		/// IP repository, then rebuilds the IP catalog index for the whole IP catalog:<br/>
		/// set_property IP_REPO_PATHS C:/Data/IP_LIB [current_fileset]<br/>
		/// update_ip_catalog -rebuild<br/>
		/// This example disables the IP specified by its VLNV property from the specified IP repository:<br/>
		/// update_ip_catalog -disable_ip {myCo.com:ip:custom_decoder:1.0} \<br/>
		/// -repo_path C:/Data/ip<br/>
		/// This example disables the IP specified by the path to the component.xml file, from the IP<br/>
		/// repository:<br/>
		/// update_ip_catalog -disable_ip C:/Data/ip/custom_encoder_1/component.xml \<br/>
		/// -repo_path C:/Xilinx/Vivado/data/ip<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1772<br/>
		/// </para>
		/// </summary>
		/// <param name="rebuild">
		/// <para>
		/// (Optional)<br/>
		/// Trigger a rebuild of the specified repository's index file or<br/>
		/// rebuild all repositories if none specified<br/>
		/// </para>
		/// </param>
		/// <param name="add_ip">
		/// <para>
		/// (Optional)<br/>
		/// Add the specified IP into the specified repository Values:<br/>
		/// Either a path to the IP's component.xml or to a zip file<br/>
		/// containing the IP<br/>
		/// </para>
		/// </param>
		/// <param name="delete_ip">
		/// <para>
		/// (Optional)<br/>
		/// Remove the specified IP from the specified repository<br/>
		/// Values: Either a path to the IP's component.xml or its VLNV<br/>
		/// </para>
		/// </param>
		/// <param name="delete_mult_ip">
		/// <para>
		/// (Optional)<br/>
		/// Remove the specified IPs from the specified repository<br/>
		/// Values: A list of IPs; either paths to the component.xml files<br/>
		/// or their VLNVs<br/>
		/// </para>
		/// </param>
		/// <param name="disable_ip">
		/// <para>
		/// (Optional)<br/>
		/// Disable the specified IP from the specified repository<br/>
		/// Values: Either a path to the IP's component.xml or its VLNV<br/>
		/// </para>
		/// </param>
		/// <param name="enable_ip">
		/// <para>
		/// (Optional)<br/>
		/// Enable the specified disabled IP from the specified<br/>
		/// repository Values: Either a path to the IP's component.xml<br/>
		/// or its VLNV<br/>
		/// </para>
		/// </param>
		/// <param name="add_interface">
		/// <para>
		/// (Optional)<br/>
		/// Add the specified interface into the specified repository<br/>
		/// Values: A path to the interface's xml file<br/>
		/// </para>
		/// </param>
		/// <param name="create_index">(Optional) Cache the specified repository's data on disk, to improve load time.</param>
		/// <param name="repo_path">
		/// <para>
		/// (Optional)<br/>
		/// Used in conjunction with rebuild, add_ip, delete_ip,<br/>
		/// delete_mult_ip, disable_ip or create_index to specify the path<br/>
		/// of the repository on which to operate<br/>
		/// </para>
		/// </param>
		/// <param name="update_module_ref">(Optional) Update module reference from their source (e.g. HDL file)</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>True for success</returns>
		public VivadoTCL update_ip_catalog(bool? rebuild = null, String add_ip = null, String delete_ip = null, TCLParameterList delete_mult_ip = null, String disable_ip = null, String enable_ip = null, String add_interface = null, bool? create_index = null, String repo_path = null, bool? update_module_ref = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: update_ip_catalog [-rebuild] [-add_ip <arg>] [-delete_ip <arg>] [-delete_mult_ip <args>] [-disable_ip <arg>] [-enable_ip <arg>] [-add_interface <arg>] [-create_index] [-repo_path <arg>] [-update_module_ref] [-quiet] [-verbose]
			this.Entry(_builder.update_ip_catalog(rebuild, add_ip, delete_ip, delete_mult_ip, disable_ip, enable_ip, add_interface, create_index, repo_path, update_module_ref, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Update a macro<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: update_macro [-absolute_grid] [-quiet] [-verbose] &lt;macro&gt; &lt;rlocs&gt;
		/// <br/>
		/// <para>
		/// Populate a previously created macro with leaf cells and relative placements.<br/>
		/// A macro is made up of primitive, or leaf-level logic cells, and their associated connections,<br/>
		/// positioned in a placement grid. The specified relative locations, or &lt;rlocs&gt;, can be based on a<br/>
		/// relative grid, or on an absolute grid, called an RPM_GRID. Refer to the Vivado Design Suite User<br/>
		/// Guide: Implementation (UG904) for more information on absolute and relative placement grids<br/>
		/// A cell can only belong to a one macro. If you attempt to assign a leaf-level cell to multiple macros,<br/>
		/// the Vivado tool will return an error. If you attempt to assign a non-primitive cell to a macro, the<br/>
		/// tool will return an error.<br/>
		/// To change the contents of an existing macro, you must delete the macro with delete_macro,<br/>
		/// recreate it with create_macro, and update it with new contents. You cannot simply overwrite<br/>
		/// or modify an existing macro.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates a macro named usbMacro0, sets the current instance to the<br/>
		/// usbEngine0/u0 module, assigns three cells to the macro, with a relative placement for each cell<br/>
		/// to have two of them placed inside the same Slice, and the third placed in a vertically adjacent<br/>
		/// Slice:<br/>
		/// create_macro usbMacro0<br/>
		/// current_instance usbEngine0/u0<br/>
		/// update_macro usbMacro0 {rx_active_reg X0Y0 \<br/>
		/// rx_err_reg X0Y0 rx_valid_reg X0Y1}<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example creates a macro named usbMacro1, assigns three cells to the macro using<br/>
		/// the hierarchical path to the leaf-cell, with absolute coordinates specified for the cells in the<br/>
		/// macro:<br/>
		/// create_macro usbMacro1<br/>
		/// set Site1 [get_sites SLICE_X8Y77]<br/>
		/// set Site2 [get_sites SLICE_X9Y77]<br/>
		/// set Site3 [get_sites SLICE_X8Y78]<br/>
		/// set RPM1 X[get_property RPM_X $Site1]Y[get_property RPM_Y $Site1]<br/>
		/// set RPM2 X[get_property RPM_X $Site2]Y[get_property RPM_Y $Site2]<br/>
		/// set RPM3 X[get_property RPM_X $Site3]Y[get_property RPM_Y $Site3]<br/>
		/// update_macro usbMacro1 -absolute_grid "usbEngine1/u0/rx_active_reg $RPM1 \<br/>
		/// usbEngine1/u0/rx_err_reg $RPM2 usbEngine1/u0/rx_valid_reg $RPM3"<br/>
		/// Note: In the prior example, notice the use of Tcl variables to capture the Sites of interest, and extract the<br/>
		/// RPM_X and RPM_Y properties of those sites for use in the update_macro command. Also notice the use<br/>
		/// of quotes ("") instead of curly braces ({}) in the update_macro command. This is to allow the Tcl shell to<br/>
		/// perform variable substitution of the command. Refer to the Vivado Design Suite User Guide: Using Tcl<br/>
		/// Scripting (UG894) for more information on variables and variable substitution.<br/>
		/// This command reports the properties on the usbMacro1 macro to see the absolute grid<br/>
		/// coordinates assigned to the cells in the macro:<br/>
		/// report_property -all [get_macros usbMacro1]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1776<br/>
		/// </para>
		/// </summary>
		/// <param name="macro">(Required) Macro to update</param>
		/// <param name="rlocs">(Required) a list interleaved instances and site names</param>
		/// <param name="absolute_grid">(Optional) Use absolute grid for relative locations</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL update_macro(String macro, String rlocs, bool? absolute_grid = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: update_macro [-absolute_grid] [-quiet] [-verbose] <macro> <rlocs>
			this.Entry(_builder.update_macro(macro, rlocs, absolute_grid, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Refresh module reference definition and instance(s)<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: update_module_reference [-quiet] [-verbose] [&lt;ips&gt;...]
		/// <br/>
		/// <para>
		/// Refresh the block design cell or cells that reference module definitions from RTL source files by<br/>
		/// rereading the module definition from the source file.<br/>
		/// Note: This command does not cause the Vivado tool to reread the source file. If changes have been made<br/>
		/// to the source file it must be separately updated.<br/>
		/// This command returns a transcript of the update process as well as any warnings related to<br/>
		/// design changes, or returns nothing if the command fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example updates the specified module references in the current design:<br/>
		/// update_module_reference {rtlRam_0 uart_0}<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1779<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="ips">
		/// <para>
		/// (Optional)<br/>
		/// module reference to be upgraded Values: IP instance<br/>
		/// name(s) within the design<br/>
		/// </para>
		/// </param>
		/// <returns>A return code indicating success or failure.</returns>
		public VivadoTCL update_module_reference(bool? quiet = null, bool? verbose = null, TCLParameterList ips = null)
		{
			// TCL Syntax: update_module_reference [-quiet] [-verbose] [<ips>...]
			this.Entry(_builder.update_module_reference(quiet, verbose, ips));
			return this;
		}
		/// <summary>
		/// <para>
		/// Update the NoC solution<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: update_noc_qos [-force] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1781<br/>
		/// </para>
		/// </summary>
		/// <param name="force">(Optional) Force update even if the existing solution is invalid</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL update_noc_qos(bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: update_noc_qos [-force] [-quiet] [-verbose]
			this.Entry(_builder.update_noc_qos(force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Update the dcp by adding the generated sw param info files to it<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: update_sw_parameters [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Updates the design check-points (DCPs) with the latest hardware def. This hardware def will<br/>
		/// have the updated sw parameters information.<br/>
		/// Whenever a software parameter of an IP is modified, the runs need not to go stale. But already<br/>
		/// generated design checkpoints need to be updated with the modified parameter information. This<br/>
		/// information is captured in the hwdef file. With update_sw_parameters command, the<br/>
		/// hwdef file is added to already generated design checkpoints.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example modifies a software parameter for the CIPS IP, generates the hw_handoff<br/>
		/// target and then updates the DCPs with the modified values:<br/>
		/// set_property -dict [list CONFIG.PS_I2C0_PERIPHERAL_ENABLE {1}]<br/>
		/// [get_bd_cells versal_cips_0]<br/>
		/// generate_target hw_handoff [get_files top.bd]<br/>
		/// update_sw_parameters<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1782<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL update_sw_parameters(bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: update_sw_parameters [-quiet] [-verbose]
			this.Entry(_builder.update_sw_parameters(quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// update timing<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: update_timing [-full] [-skip_delay_calc] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Updates timing for the current design.<br/>
		/// Update the timing data to reflect any timing constraints that were added to the design since the<br/>
		/// timing engine was last run. This command updates the in-memory view of the timing database,<br/>
		/// without incurring the time of a full timing analysis.<br/>
		/// Timing is automatically updated by commands that change timing or need updated timing<br/>
		/// information, such as the report_timing command. The update_timing command lets you<br/>
		/// manually trigger the timing update to insure the latest constraints are applied to the timing<br/>
		/// engine.<br/>
		/// The update_timing command uses an incremental analysis approach by default, which<br/>
		/// updates only out-of-date information, to reduce process and analysis time. You can also specify a<br/>
		/// complete or full update to insure a comprehensive review of timing data in the design. However,<br/>
		/// to avoid long timing analysis run times, you should use the -full option only when you need to.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example performs a full update of the in-memory timing data:<br/>
		/// update_timing -full<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1784<br/>
		/// </para>
		/// </summary>
		/// <param name="full">(Optional) Perform a full timing update instead of an incremental one</param>
		/// <param name="skip_delay_calc">(Optional) Skip delay calculation</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL update_timing(bool? full = null, bool? skip_delay_calc = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: update_timing [-full] [-skip_delay_calc] [-quiet] [-verbose]
			this.Entry(_builder.update_timing(full, skip_delay_calc, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Upgrade configurable IPIntegrator cell(s) to later version<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: upgrade_bd_cells [-latest &lt;arg&gt;] [-quiet] [-verbose] &lt;objects&gt;...
		/// <br/>
		/// <para>
		/// Upgrade IP integrator cells to the latest version available in the IP integrator catalog.<br/>
		/// This command lets you update IP integrator subsystem designs from an earlier release to use the<br/>
		/// IP cores from the latest catalog.<br/>
		/// This command returns the list of IP integrator cells that were upgraded, or returns an error if it<br/>
		/// fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1786<br/>
		/// </para>
		/// </summary>
		/// <param name="objects">(Required) IPIntegrator cells to be upgraded</param>
		/// <param name="latest">(Optional) Upgrade the IPIntegrator block to the latest version</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>List of IPIntegrator cell names those were upgraded, "" if failed.</returns>
		public VivadoTCL upgrade_bd_cells(TCLParameterList objects, String latest = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: upgrade_bd_cells [-latest <arg>] [-quiet] [-verbose] <objects>...
			this.Entry(_builder.upgrade_bd_cells(objects, latest, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Upgrade a configurable IP to a later version<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: upgrade_ip [-srcset &lt;arg&gt;] [-vlnv &lt;arg&gt;] [-log &lt;arg&gt;] [-quiet] [-verbose] &lt;objects&gt;...
		/// <br/>
		/// <para>
		/// This command upgrades the specified IP cores from an older version to the latest version in the<br/>
		/// IP catalog.<br/>
		/// You can only upgrade IP that explicitly supports upgrading. The UPGRADE_VERSIONS property<br/>
		/// on the ipdef object indicates if there are upgrade versions for an IP core.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// TIP: The upgrade_ip command also accepts Block Design cell IP instances as bd_cell objects. The<br/>
		/// command upgrades the bd_cell objects within the Block Design, and does not require the diagram to be<br/>
		/// open in the Vivado IP integrator .<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example upgrades all IP cores in the current project to the latest version:<br/>
		/// upgrade_ip [get_ips]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1788<br/>
		/// </para>
		/// </summary>
		/// <param name="objects">
		/// <para>
		/// (Required)<br/>
		/// IP to be upgraded Values: IP instance(s) within the design,<br/>
		/// as returned by 'get_ips &lt;instance name&gt;' or 'get_bd_cells<br/>
		/// &lt;cell name&gt;'<br/>
		/// </para>
		/// </param>
		/// <param name="srcset">
		/// <para>
		/// (Optional)<br/>
		/// (Optional) Specifies the source file set containing the IP to<br/>
		/// be upgraded Default: The current source fileset Values:<br/>
		/// Source set name<br/>
		/// </para>
		/// </param>
		/// <param name="vlnv">
		/// <para>
		/// (Optional)<br/>
		/// (Optional) Identifies the Catalog IP to which the IP will be<br/>
		/// upgraded. The VLNV string maps to the IPDEF property on<br/>
		/// the IP core. This is a strict comparison, and the upgrade will<br/>
		/// fail if the identified IP does not exist in the Catalog. Default:<br/>
		/// Latest version of the current IP Values: A string of the form<br/>
		/// '&lt;vendor&gt;:&lt;library&gt;:&lt;name&gt;:&lt;versio n&gt;'<br/>
		/// </para>
		/// </param>
		/// <param name="log">
		/// <para>
		/// (Optional)<br/>
		/// (Optional) Identifies the log file to which the IP upgrade<br/>
		/// report will be concatenated. Default: An empty string,<br/>
		/// indicating that no log will be written Values: A file path to an<br/>
		/// existing writable file, or a non-existent file location in a<br/>
		/// writable directory<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>A return code indicating success or failure.</returns>
		public VivadoTCL upgrade_ip(TCLParameterList objects, String srcset = null, String vlnv = null, String log = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: upgrade_ip [-srcset <arg>] [-vlnv <arg>] [-log <arg>] [-quiet] [-verbose] <objects>...
			this.Entry(_builder.upgrade_ip(objects, srcset, vlnv, log, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Stop capturing. Upload any captured hardware ILA data.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: upload_hw_ila_data [-quiet] [-verbose] [&lt;hw_ilas&gt;...]
		/// <br/>
		/// <para>
		/// Upload the captured data from the memory buffers of the specified ILA debug cores on the Xilinx<br/>
		/// FPGA hardware device, and move it into a hw_ila_data object in the Vivado logic analyzer.<br/>
		/// You can upload captured data from the ILA debug core at any time during the capture process<br/>
		/// triggered by the run_hw_ila command. However, you may want to use the wait_on_hw_ila<br/>
		/// command in any Tcl scripts, to wait until the sample data buffers of the ILA core are fully<br/>
		/// populated with data. If you run the upload_hw_ila_data command prior to this, you may see<br/>
		/// a message as follows:<br/>
		/// INFO: [Labtools 27-1965] The ILA core 'hw_ila_1' trigger was stopped by<br/>
		/// user \<br/>
		/// at 2014-Mar-06 08:59:30<br/>
		/// INFO: [Labtools 27-2212] The ILA core 'hw_ila_1' captured '6' windows with<br/>
		/// \<br/>
		/// '64' samples each, and a last partial window with '0' samples.<br/>
		/// The upload process creates a hw_ila_data object in the process of moving the captured data from<br/>
		/// the ILA debug core, hw_ila, on the physical FPGA device, hw_device. The hw_ila_data object is<br/>
		/// named after the hw_ila core it is uploaded from.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// TIP: Each hw_ila object has only one matching hw_ila_data object associated with it. Each time<br/>
		/// upload_hw_ila_data is run for a specific hw_ila core, the hw_ila_data object is overwritten if it already<br/>
		/// exists.<br/>
		/// The data object, hw_ila_data can be viewed in the waveform viewer of the Vivado logic analyzer<br/>
		/// by using the display_hw_ila_data command, and can be written to disk using the<br/>
		/// write_hw_ila_data command.<br/>
		/// This command returns a hw_ila_data object, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1791<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_ilas">(Optional) List of hardware ILA objects. Default: Current hardware ILA</param>
		/// <returns>hardware ILA data objects</returns>
		public VivadoTCL upload_hw_ila_data(bool? quiet = null, bool? verbose = null, TCLParameterList hw_ilas = null)
		{
			// TCL Syntax: upload_hw_ila_data [-quiet] [-verbose] [<hw_ilas>...]
			this.Entry(_builder.upload_hw_ila_data(quiet, verbose, hw_ilas));
			return this;
		}
		/// <summary>
		/// <para>
		/// Run Parameter Propagation for specified design or for a specific cell.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: validate_bd_design [-force] [-design &lt;arg&gt;] [-include_pfm] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Validate an IP integrator subsystem design, or IP cell or hierarchical module.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example validates the current IP integrator subsystem design, forcing re-validation<br/>
		/// if needed:<br/>
		/// validate_bd_design -force<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1794<br/>
		/// </para>
		/// </summary>
		/// <param name="force">(Optional) Force re-run validation on the design</param>
		/// <param name="design">
		/// <para>
		/// (Optional)<br/>
		/// Design name. If not specified, run parameter propagation<br/>
		/// on current design<br/>
		/// </para>
		/// </param>
		/// <param name="include_pfm">(Optional) including validate pfm attributes on the design</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>TCL_OK, TCL_ERROR if failed.</returns>
		public VivadoTCL validate_bd_design(bool? force = null, String design = null, bool? include_pfm = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: validate_bd_design [-force] [-design <arg>] [-include_pfm] [-quiet] [-verbose]
			this.Entry(_builder.validate_bd_design(force, design, include_pfm, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Check whether the XML files describing a board in the given directory are valid. Only supported<br/>
		/// for board XML files with schema_version&gt;=2.0. The XML files must contain an appropriate<br/>
		/// DOCTYPE declaration to be fully validated. Examples: &lt;!DOCTYPE board SYSTEM "board.dtd"&gt;<br/>
		/// &lt;!-- for board.xml --&gt; &lt;!DOCTYPE ip_presets SYSTEM "preset.dtd"&gt; &lt;!-- for preset.xml --&gt; &lt;!<br/>
		/// DOCTYPE part_info SYSTEM "part0_pins.dtd"&gt; &lt;!-- for part0_pins.xml --&gt;<br/>
		/// Note that if a project is open and an IP repository loaded, this command will also validate certain<br/>
		/// IP and Interface attributes used in the board definition against the current IP repository.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: validate_board_files [-quiet] [-verbose] [&lt;dir&gt;...]
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1796<br/>
		/// </para>
		/// </summary>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="dir">
		/// <para>
		/// (Optional)<br/>
		/// The name of a directory containing the board files<br/>
		/// (board.xml, part0_pins.xml, preset.xml) to be checked<br/>
		/// </para>
		/// </param>
		/// <returns>ok if all board files are valid</returns>
		public VivadoTCL validate_board_files(bool? quiet = null, bool? verbose = null, TCLParameterList dir = null)
		{
			// TCL Syntax: validate_board_files [-quiet] [-verbose] [<dir>...]
			this.Entry(_builder.validate_board_files(quiet, verbose, dir));
			return this;
		}
		/// <summary>
		/// <para>
		/// Validate list of cluster configurations<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: validate_cluster_configurations [-quiet] [-verbose] &lt;cluster_configurations&gt;
		/// <br/>
		/// <para>
		/// Validates the list of cluster configurations provided as an input. Use the<br/>
		/// get_cluster_configurations command to get a list of cluster configurations.<br/>
		/// validate_cluster_configurations validates the submit and kill command of the cluster<br/>
		/// configuration objects to ensure if a job can be submitted using a particular cluster configuration<br/>
		/// or not.<br/>
		/// Currently, Vivado supports following clusters management tools.<br/>
		/// • Load Sharing Facility (LSF)<br/>
		/// • Sun Grid Engine (SGE)<br/>
		/// • Simple Linux Utility For Resource Management (SLURM)<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example validates all the user defined cluster configurations.<br/>
		/// validate_cluster_configurations [get_cluster_configurations -filter<br/>
		/// {IS_DEFAULT == 0}]<br/>
		/// The following example validates a cluster configuration named lsf_medium.<br/>
		/// validate_cluster_configurations [get_cluster_configurations lsf_medium]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1797<br/>
		/// </para>
		/// </summary>
		/// <param name="cluster_configurations">(Required) List of cluster configurations</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL validate_cluster_configurations(String cluster_configurations, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: validate_cluster_configurations [-quiet] [-verbose] <cluster_configurations>
			this.Entry(_builder.validate_cluster_configurations(cluster_configurations, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Validate the specified harware platform<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: validate_hw_platform [-verbose] [-quiet] [&lt;file&gt;]
		/// <br/>
		/// <para>
		/// Validate a Xilinx support archive (XSA) file to ensure it has the required content for the platform.<br/>
		/// This command returns information related to the validation of the XSA, or returns an error if it<br/>
		/// fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example validates the specified XSA, returning verbose information related to the<br/>
		/// platform contents:<br/>
		/// validate_hw_platform C:/Data/zc706.xsa -verbose<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1799<br/>
		/// </para>
		/// </summary>
		/// <param name="verbose">(Optional) Dump verbose information</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="file">(Optional) Xilinx Shell Archive file Values: Path to shell file.</param>
		/// <returns>The name of the shell file</returns>
		public VivadoTCL validate_hw_platform(bool? verbose = null, bool? quiet = null, String file = null)
		{
			// TCL Syntax: validate_hw_platform [-verbose] [-quiet] [<file>]
			this.Entry(_builder.validate_hw_platform(verbose, quiet, file));
			return this;
		}
		/// <summary>
		/// <para>
		/// This command applies any pending set_property commands and returns parameter validation<br/>
		/// messages, if any exist<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: validate_ip [-save_ip] [-quiet] [-verbose] [&lt;ips&gt;]
		/// <br/>
		/// <para>
		/// Perform DRC check on IP to ensure that it is properly constructed. This command returns 1<br/>
		/// when all IPs have been validated, or 0 when there is a problem.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example validates the IPs in the current project, and updates the persistent<br/>
		/// representation of the IP.<br/>
		/// validate_ip -save_ip [get_ips]<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1801<br/>
		/// </para>
		/// </summary>
		/// <param name="save_ip">(Optional) Write IP files on the disk</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="ips">(Optional) IPs to be validated</param>
		public VivadoTCL validate_ip(bool? save_ip = null, bool? quiet = null, bool? verbose = null, String ips = null)
		{
			// TCL Syntax: validate_ip [-save_ip] [-quiet] [-verbose] [<ips>]
			this.Entry(_builder.validate_ip(save_ip, quiet, verbose, ips));
			return this;
		}
		/// <summary>
		/// <para>
		/// Verify hardware devices<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: verify_hw_devices [-key &lt;arg&gt;] [-user_efuse &lt;arg&gt;] [-control_efuse &lt;arg&gt;] [-security_efuse &lt;arg&gt;] [-verbose] [-quiet] [&lt;hw_device&gt;...]
		/// <br/>
		/// <para>
		/// For EFUSE encrypted devices, this command compares the bitstream assigned to the<br/>
		/// PROGRAM.FILE property on the specified hw_device with the bitstream programmed into the<br/>
		/// device with the program_hw_devices command.<br/>
		/// Filtered through a required mask file, associated with the hw_device, the verify_hw_devices<br/>
		/// command uses both the bitstream and mask file to compare only the bits that are marked as<br/>
		/// important in the mask file. A mask file can be created along with the bitstream using the<br/>
		/// write_bitstream command, and is associated with the hw_device using the<br/>
		/// create_hw_bitstream command.<br/>
		/// IMPORTANT! Verification cannot be performed on devices programmed with encrypted bitstreams, other<br/>
		/// than to verify that the -key has been programmed.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The verify_hw_devices command reports that the readback data matches the programmed<br/>
		/// bitstream if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1803<br/>
		/// </para>
		/// </summary>
		/// <param name="key">(Optional) option value for key verification: efuse</param>
		/// <param name="user_efuse">(Optional) hex user fuse value for verification</param>
		/// <param name="control_efuse">(Optional) hex control fuse value for verification</param>
		/// <param name="security_efuse">(Optional) hex security fuse value for verification</param>
		/// <param name="verbose">(Optional) Shows fuse values during verification</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="hw_device">(Optional) list of hardware devices Default: current hardware device</param>
		/// <returns>hardware devices</returns>
		public VivadoTCL verify_hw_devices(String key = null, String user_efuse = null, String control_efuse = null, String security_efuse = null, bool? verbose = null, bool? quiet = null, TCLParameterList hw_device = null)
		{
			// TCL Syntax: verify_hw_devices [-key <arg>] [-user_efuse <arg>] [-control_efuse <arg>] [-security_efuse <arg>] [-verbose] [-quiet] [<hw_device>...]
			this.Entry(_builder.verify_hw_devices(key, user_efuse, control_efuse, security_efuse, verbose, quiet, hw_device));
			return this;
		}
		/// <summary>
		/// <para>
		/// Returns the build for Vivado and the build date<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: version [-short] [-quiet] [-verbose]
		/// <br/>
		/// <para>
		/// Returns the version number of the Xilinx® tool. This includes the software version number, build<br/>
		/// number and date, and copyright information.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example returns only the version number for the software:<br/>
		/// version -short<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1806<br/>
		/// </para>
		/// </summary>
		/// <param name="short">(Optional) Return only the numeric version number</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>
		/// </returns>
		public VivadoTCL version(bool? @short = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: version [-short] [-quiet] [-verbose]
			this.Entry(_builder.version(@short, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Wait until all hardware ILA data has been captured.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: wait_on_hw_ila [-timeout &lt;arg&gt;] [-quiet] [-verbose] [&lt;hw_ilas&gt;...]
		/// <br/>
		/// <para>
		/// Suspend Tcl script or Tcl command processing until the ILA debug core memory is filled by<br/>
		/// captured data samples.<br/>
		/// This command is used after the run_hw_ila command to pause Tcl processing to wait for the<br/>
		/// data buffers to fill up. When the wait_on_hw_ila command returns, the Tcl command or script<br/>
		/// processing can continue.<br/>
		/// With the ILA debug core memory filed with sample data, when Tcl processing resumes, you can<br/>
		/// upload the captured data samples into an ILA debug core data object, or hw_ila_data object. Use<br/>
		/// the upload_ila_data command to perform this action.<br/>
		/// This command operates silently, returning nothing if successful, or returning an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1808<br/>
		/// </para>
		/// </summary>
		/// <param name="timeout">(Optional) Timeout in minutes. Decimal value allowed Default: No timeout</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_ilas">(Optional) hardware ILA objects. Default: Current hardware ILA</param>
		public VivadoTCL wait_on_hw_ila(String timeout = null, bool? quiet = null, bool? verbose = null, TCLParameterList hw_ilas = null)
		{
			// TCL Syntax: wait_on_hw_ila [-timeout <arg>] [-quiet] [-verbose] [<hw_ilas>...]
			this.Entry(_builder.wait_on_hw_ila(timeout, quiet, verbose, hw_ilas));
			return this;
		}
		/// <summary>
		/// <para>
		/// Wait until hardware SIO scan has completed.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: wait_on_hw_sio_scan [-timeout &lt;arg&gt;] [-quiet] [-verbose] &lt;hw_sio_scans&gt;...
		/// <br/>
		/// <para>
		/// Suspend a Tcl script or Tcl command processing until the specified serial I/O analyzer scan is<br/>
		/// complete.<br/>
		/// This command is used after the run_hw_sio_scan command to pause Tcl processing to wait<br/>
		/// for the scan to complete. When the wait_on_sio_scan command returns, the Tcl command<br/>
		/// or script processing can continue.<br/>
		/// This command operates silently, returning nothing if successful, or returning an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1810<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_sio_scans">(Required) List of hardware SIO scan objects.</param>
		/// <param name="timeout">(Optional) Timeout in minutes. Decimal value allowed Default: No timeout</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL wait_on_hw_sio_scan(TCLParameterList hw_sio_scans, String timeout = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: wait_on_hw_sio_scan [-timeout <arg>] [-quiet] [-verbose] <hw_sio_scans>...
			this.Entry(_builder.wait_on_hw_sio_scan(hw_sio_scans, timeout, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Wait until hardware SIO sweep has completed.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: wait_on_hw_sio_sweep [-timeout &lt;arg&gt;] [-quiet] [-verbose] &lt;hw_sio_sweeps&gt;...
		/// <br/>
		/// <para>
		/// Suspend a Tcl script or Tcl command processing until the serial I/O analyzer sweep scan is<br/>
		/// complete.<br/>
		/// This command is used after the run_hw_sio_sweep command to pause Tcl processing to wait<br/>
		/// for the sweep scan to complete. When the wait_on_sio_sweep command returns, the Tcl<br/>
		/// command or script processing can continue.<br/>
		/// This command operates silently, returning nothing if successful, or returning an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1812<br/>
		/// </para>
		/// </summary>
		/// <param name="hw_sio_sweeps">(Required) List of hardware SIO sweep objects.</param>
		/// <param name="timeout">(Optional) Timeout in minutes. Decimal value allowed Default: No timeout</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL wait_on_hw_sio_sweep(TCLParameterList hw_sio_sweeps, String timeout = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: wait_on_hw_sio_sweep [-timeout <arg>] [-quiet] [-verbose] <hw_sio_sweeps>...
			this.Entry(_builder.wait_on_hw_sio_sweep(hw_sio_sweeps, timeout, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Block execution of further Tcl commands until the specified run completes.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: wait_on_run [-timeout &lt;arg&gt;] [-quiet] [-verbose] &lt;run&gt;
		/// <br/>
		/// <para>
		/// Blocks the execution of Tcl commands until the specified run has completed either successfully<br/>
		/// or in error, or until the specified amount of time has elapsed.<br/>
		/// This command will tell you when the run has terminated, but not the results of the run. To<br/>
		/// determine if the run has completed successfully, you could query the value of the PROGRESS<br/>
		/// property of the run:<br/>
		/// launch_runs synth_1<br/>
		/// wait_on_run synth_1<br/>
		/// if {[get_property PROGRESS [get_runs synth_1]] != "100%"} {<br/>
		/// error "ERROR: synth_1 failed"<br/>
		/// }<br/>
		/// The wait_on_run command can be used for runs that have been launched. If the specified run<br/>
		/// has not been launched when the wait_on_run command is used, you will get an error. Runs<br/>
		/// that have already completed do not return an error.<br/>
		/// Note: This command is used for running the tool in batch mode or from Tcl scripts. It is ignored when<br/>
		/// running interactively from the GUI.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example launches the impl_1 run, and then waits for the specified run to complete,<br/>
		/// or to wait for one hour, whichever occurs first:<br/>
		/// launch_runs impl_1<br/>
		/// wait_on_run -timeout 60 impl_1<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1814<br/>
		/// </para>
		/// </summary>
		/// <param name="run">(Required) Run to wait on</param>
		/// <param name="timeout">(Optional) Maximum time to wait for the run to complete (in minutes) Default: -1</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL wait_on_run(String run, String timeout = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: wait_on_run [-timeout <arg>] [-quiet] [-verbose] <run>
			this.Entry(_builder.wait_on_run(run, timeout, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Write an abstract shell checkpoint of the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_abstract_shell -cell &lt;arg&gt; [-force] [-quiet] [-verbose] &lt;file&gt;
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1816<br/>
		/// </para>
		/// </summary>
		/// <param name="cell">(Required) Create an abstract shell for this reconfigurable cell</param>
		/// <param name="file">
		/// <para>
		/// (Required)<br/>
		/// Design checkpoint file Values: A filename with alphanumeric<br/>
		/// characters and .dcp extension.<br/>
		/// </para>
		/// </param>
		/// <param name="force">(Optional) Overwrite existing checkpoint file</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The name of the checkpoint file</returns>
		public VivadoTCL write_abstract_shell(String cell, String file, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_abstract_shell -cell <arg> [-force] [-quiet] [-verbose] <file>
			this.Entry(_builder.write_abstract_shell(cell, file, force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Export layout in native, pdf or svg<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_bd_layout [-force] [-format &lt;arg&gt;] [-orientation &lt;arg&gt;] [-scope &lt;arg&gt;] [-hierarchy &lt;arg&gt;] [-quiet] [-verbose] &lt;file&gt;
		/// <br/>
		/// <para>
		/// Write the current open block design in the Vivado IP integrator to the specified file format.<br/>
		/// This command lets you print the block design, output it as a vector graphic file for use in<br/>
		/// documentation related to the design project, or recreate the block design layout in the Vivado IP<br/>
		/// integrator design canvas using the regenerate_bd_layout command.<br/>
		/// This command returns the name of the file written, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example prints the current block design to the specified PDF file:<br/>
		/// write_bd_layout -format pdf -orientation landscape C:/Data/microblaze.pdf<br/>
		/// The following example prints the specified hierarchical cell of the block design to the specified<br/>
		/// SVG file:<br/>
		/// write_bd_layout -format svg -orientation landscape C:/Data/microblaze.svg<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1817<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) Output file</param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="format">
		/// <para>
		/// (Optional)<br/>
		/// Values: native, pdf or svg. regenerate_bd_layout -layout_file<br/>
		/// can be used with native layout. Default: native<br/>
		/// </para>
		/// </param>
		/// <param name="orientation">(Optional) Values: landscape or portrait</param>
		/// <param name="scope">(Optional) Values: visible or all Default: all</param>
		/// <param name="hierarchy">(Optional) Hierarchy block</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>name of the output file</returns>
		public VivadoTCL write_bd_layout(String file, bool? force = null, write_bd_layout_format? format = null, write_bd_layout_orientation? orientation = null, write_bd_layout_scope? scope = null, String hierarchy = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_bd_layout [-force] [-format <arg>] [-orientation <arg>] [-scope <arg>] [-hierarchy <arg>] [-quiet] [-verbose] <file>
			this.Entry(_builder.write_bd_layout(file, force, format, orientation, scope, hierarchy, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Export the current design to a Tcl file on disk.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_bd_tcl [-force] [-bd_name &lt;arg&gt;] [-no_mig_contents] [-no_ip_version] [-ignore_minor_versions] [-bd_folder &lt;arg&gt;] [-check_ips &lt;arg&gt;] [-hier_blks &lt;arg&gt;] [-include_layout] [-exclude_layout] [-make_local] [-no_project_wrapper] [-exclude_pfm] [-updated_pfm_attrs] [-quiet] [-verbose] &lt;tcl_filename&gt;
		/// <br/>
		/// <para>
		/// Export the current IP integrator subsystem design as a Tcl script file to the disk.<br/>
		/// IMPORTANT! Any directory in the path specified by the &lt;name&gt; option must already exist, or the script<br/>
		/// will not be created.<br/>
		/// The Tcl script file lets you recreate, reuse, and customize IP integrator subsystem designs without<br/>
		/// having to archive the original subsystem design.<br/>
		/// When working with a new software release, you must use the output script from the<br/>
		/// write_bd_tcl command to create a block design in the same software release as the Tcl script<br/>
		/// was generated. This ensures the availability of the needed versions of any IP used in the script.<br/>
		/// You can then migrate the created block design into a new software release.<br/>
		/// This command returns TCL_OK if it is successful, or TCL_ERROR if it fails, unless -quiet is<br/>
		/// specified.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1820<br/>
		/// </para>
		/// </summary>
		/// <param name="tcl_filename">(Required) Name of exported Tcl file</param>
		/// <param name="force">(Optional) Flag to overwrite existing file.</param>
		/// <param name="bd_name">
		/// <para>
		/// (Optional)<br/>
		/// Name for block diagram. By default will use current block<br/>
		/// diagram's name.<br/>
		/// </para>
		/// </param>
		/// <param name="no_mig_contents">
		/// <para>
		/// (Optional)<br/>
		/// Flag to not include MIG PRJ contents into generated Tcl<br/>
		/// script, but instead will load PRJ from working directory.<br/>
		/// Default is to include MIG PRJ contents in Tcl script.<br/>
		/// </para>
		/// </param>
		/// <param name="no_ip_version">
		/// <para>
		/// (Optional)<br/>
		/// Flag to not include the IP version as part of the IP VLNV in<br/>
		/// create_bd_cell commands. NOTE - this may have<br/>
		/// implications if there are major IP version changes.<br/>
		/// </para>
		/// </param>
		/// <param name="ignore_minor_versions">
		/// <para>
		/// (Optional)<br/>
		/// Use this flag to create the cells in the design using their<br/>
		/// latest minor version. For example, a project contains<br/>
		/// versions of blk_mem_gen IP like 7.3, 7.4, 8.3, 8.4. In the<br/>
		/// design there is a blk_mem_gen_v7.4. With this flag,<br/>
		/// write_bd_tcl will generate the line: create_bd_cell -type ip -<br/>
		/// vlnv xilinx.com:ip:blk_mem_gen:7.* bmg_0_v7. When the<br/>
		/// generated Tcl script is sourced, the cell bmg_0_v7 will use<br/>
		/// the latest blk_mem_gen_v7.<br/>
		/// </para>
		/// </param>
		/// <param name="bd_folder">
		/// <para>
		/// (Optional)<br/>
		/// Remote BD feature - Specify the folder where the design will<br/>
		/// be generated when Tcl script is sourced.<br/>
		/// </para>
		/// </param>
		/// <param name="check_ips">
		/// <para>
		/// (Optional)<br/>
		/// By default value = true, therefore, will check if IPs/modules<br/>
		/// exist in the IP catalog or project before continuing to<br/>
		/// reconstruct the design. Valid values are (true/false), (yes/<br/>
		/// no), or (1/0).<br/>
		/// </para>
		/// </param>
		/// <param name="hier_blks">
		/// <para>
		/// (Optional)<br/>
		/// Comma separated list of hierarchical blocks in the design<br/>
		/// that will be generated by the Tcl script. Will include any sub-hierachical blocks within the specified blocks too. This<br/>
		/// option will not create the top-level design portion.<br/>
		/// </para>
		/// </param>
		/// <param name="include_layout">
		/// <para>
		/// (Optional)<br/>
		/// By default will NOT include the GUI layout of the design. Use<br/>
		/// this argument to include the layout information in the<br/>
		/// generated Tcl script.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Name Description<br/>
		/// </para>
		/// </param>
		/// <param name="exclude_layout">
		/// <para>
		/// (Optional)<br/>
		/// NOTE - This flag will be obsolete in a near future release, but<br/>
		/// is currently supported for backwards compatibility. Use this<br/>
		/// argument to not include the layout information in the<br/>
		/// generated Tcl script.<br/>
		/// </para>
		/// </param>
		/// <param name="make_local">(Optional) Use this flag when you want to write your remote BD out as a local BD.</param>
		/// <param name="no_project_wrapper">
		/// <para>
		/// (Optional)<br/>
		/// This option is used to write the BD create TCL procs without<br/>
		/// any project wrapper.<br/>
		/// </para>
		/// </param>
		/// <param name="exclude_pfm">(Optional) Use this flag to exclude pfm attributes for this design</param>
		/// <param name="updated_pfm_attrs">
		/// <para>
		/// (Optional)<br/>
		/// Use this flag to update the pfms to remove connected<br/>
		/// ports/interfaces from the values.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>TCL_OK, TCL_ERROR if failed.</returns>
		public VivadoTCL write_bd_tcl(String tcl_filename, bool? force = null, String bd_name = null, bool? no_mig_contents = null, bool? no_ip_version = null, bool? ignore_minor_versions = null, String bd_folder = null, String check_ips = null, String hier_blks = null, bool? include_layout = null, bool? exclude_layout = null, bool? make_local = null, bool? no_project_wrapper = null, bool? exclude_pfm = null, bool? updated_pfm_attrs = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_bd_tcl [-force] [-bd_name <arg>] [-no_mig_contents] [-no_ip_version] [-ignore_minor_versions] [-bd_folder <arg>] [-check_ips <arg>] [-hier_blks <arg>] [-include_layout] [-exclude_layout] [-make_local] [-no_project_wrapper] [-exclude_pfm] [-updated_pfm_attrs] [-quiet] [-verbose] <tcl_filename>
			this.Entry(_builder.write_bd_tcl(tcl_filename, force, bd_name, no_mig_contents, no_ip_version, ignore_minor_versions, bd_folder, check_ips, hier_blks, include_layout, exclude_layout, make_local, no_project_wrapper, exclude_pfm, updated_pfm_attrs, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Write a bitstream for the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_bitstream [-force] [-verbose] [-raw_bitfile] [-no_binary_bitfile] [-mask_file] [-readback_file] [-logic_location_file] [-bin_file] [-reference_bitfile &lt;arg&gt;] [-cell &lt;arg&gt;] [-no_partial_bitfile] [-quiet] &lt;file&gt;
		/// <br/>
		/// <para>
		/// Writes a bitstream file for the current project. This command must be run on an Implemented<br/>
		/// Design. The bitstream written will be based on the open Implemented Design.<br/>
		/// The files that can be generated by the write_bitstream command include the following:<br/>
		/// • Bit file: The binary bitstream file (.bit).<br/>
		/// • Raw (ASCII) Bit file: A raw bit file (.rbt) that contains the same information as the binary<br/>
		/// bitstream file, but is in ASCII format.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// • Mask file: A mask file (.msk) that has mask data in place of the configuration data in the<br/>
		/// bitstream file.<br/>
		/// • Logic Location file: An ASCII logic location file (.ll) that shows the bitstream position of<br/>
		/// latches, flip-flops, LUTs, Block RAMs, and I/O block inputs and outputs.<br/>
		/// • Bin file: A binary file (.bin) containing only the device programming data, without the header<br/>
		/// information found in the standard binary Bit file.<br/>
		/// • Reference Bit file: An incremental bitstream file containing only the differences from the<br/>
		/// current bitstream and a specified reference bitstream.<br/>
		/// The Vivado tool can write a compressed bitstream, if you have enabled compression by setting<br/>
		/// the BITSTREAM.GENERAL.COMPRESS property on the implemented design. Refer to the Vivado<br/>
		/// Design Suite User Guide: Programming and Debugging (UG908) for more information on Device<br/>
		/// Configuration Properties. To enable compression use the following Tcl command:<br/>
		/// set_property BITSTREAM.GENERAL.COMPRESS TRUE [current_design]<br/>
		/// The Vivado Design Suite can also write an encrypted bitstream to protect the intellectual<br/>
		/// property of the design in the bitstream. To create an encrypted bitstream you must first define<br/>
		/// the type of encryption to be used, and the encryption key. You can accomplish this most easily<br/>
		/// using the Encryption page of the Edit Device Properties dialog box in the Vivado IDE. Refer to<br/>
		/// the Vivado Design Suite User Guide: Programming and Debugging (UG908) for more information on<br/>
		/// the Edit Device Properties dialog box.<br/>
		/// You can also enable encryption by manually defining the appropriate properties on the<br/>
		/// implemented design as follows:<br/>
		/// set_property BITSTREAM.ENCRYPTION.ENCRYPT YES [get_designs impl_1]<br/>
		/// set_property BITSTREAM.ENCRYPTION.ENCRYPTKEYSELECT EFUSE [get_designs<br/>
		/// impl_1]<br/>
		/// set_property BITSTREAM.ENCRYPTION.KEY0 8675309 [get_designs impl_1]<br/>
		/// The properties associated with encryption include:<br/>
		/// • BITSTREAM.ENCRYPTION.ENCRYPT - Enables encryption when generating the bitstream<br/>
		/// with write_bitstream. This property accepts a value of YES or NO.<br/>
		/// • BITSTREAM.ENCRYPTION.ENCRYPTKEYSELECT - Specifies the method for storing the<br/>
		/// encryption key on the hardware device. The accepted values are BBRAM and EFUSE, referring<br/>
		/// to battery-backed SRAM or the eFUSE registers on the device.<br/>
		/// CAUTION! eFUSEs are one-time programmable cells on the hardware device, used to store the<br/>
		/// factory-programmed Device DNA, AES-GCM encryption key, and user specified values. Refer to the<br/>
		/// UltraScale Architecture Configuration User Guide (UG570) or 7 Series FPGAs Configuration User Guide<br/>
		/// (UG470) for more information on eFUSE registers.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// • BITSTREAM.ENCRYPTION.KEY0 - Specifies the encryption key to apply to the BBRAM, or<br/>
		/// the eFUSE FUSE_KEY registers on the device. The key can be specified as a 256 bit value, and<br/>
		/// will be required when accessing an encrypted bitstream to program, verify, or readback the<br/>
		/// hw_device.<br/>
		/// TIP: The write_bitstream command will write an NKY file of the same name as the bitstream file<br/>
		/// (with the .nky extension) when the BITSTREAM.ENCRYPTION.KEY0 property is specified. This<br/>
		/// encryption file can then be used in other designs by setting the BITSTREAM.ENCRYPTION.KEYFILE<br/>
		/// property.<br/>
		/// • BITSTREAM.ENCRYPTION.KEYFILE - Specifies an encryption key file (NKY or NKZ) as an<br/>
		/// alternative to setting the ENCRYPTION.KEY0 property. The specified encryption key file will<br/>
		/// be used during bitstream encryption.<br/>
		/// IMPORTANT! If both the BITSTREAM.ENCRYPTION.KEY0 and BITSTREAM.ENCRYPTION.KEYFILE<br/>
		/// properties are defined, the tool will use the encryption key specified by the<br/>
		/// BITSTREAM.ENCRYPTION.KEY0 property and return a message to that effect.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example enables compression and writes a bitstream file of the specified name:<br/>
		/// set_property BITSTREAM.GENERAL.COMPRESS TRUE [current_design]<br/>
		/// write_bitstream design1.bit<br/>
		/// The following example writes both the binary and ASCII forms of the bitstream:<br/>
		/// write_bitstream -raw_bitfile C:/Data/design1<br/>
		/// Note: The appropriate file extension will be added by the tool.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1824<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) The name of the .bit file to generate</param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="verbose">(Optional) Print write_bitstream options</param>
		/// <param name="raw_bitfile">(Optional) Write raw bit file (.rbt)</param>
		/// <param name="no_binary_bitfile">(Optional) Do not write binary bit file (.bit)</param>
		/// <param name="mask_file">(Optional) Write mask file (.msk)</param>
		/// <param name="readback_file">(Optional) Write readback files (.rbd, .msd)</param>
		/// <param name="logic_location_file">(Optional) Write logic location file (.ll)</param>
		/// <param name="bin_file">(Optional) Write binary bit file without header (.bin)</param>
		/// <param name="reference_bitfile">(Optional) Reference bitfile to be used for generating partial bitstream</param>
		/// <param name="cell">(Optional) Create only partial bitstream for named cell</param>
		/// <param name="no_partial_bitfile">(Optional) Do not write partial bit files for a Dynamic Function eXchange design</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		public VivadoTCL write_bitstream(String file, bool? force = null, bool? verbose = null, bool? raw_bitfile = null, bool? no_binary_bitfile = null, bool? mask_file = null, bool? readback_file = null, bool? logic_location_file = null, bool? bin_file = null, String reference_bitfile = null, String cell = null, bool? no_partial_bitfile = null, bool? quiet = null)
		{
			// TCL Syntax: write_bitstream [-force] [-verbose] [-raw_bitfile] [-no_binary_bitfile] [-mask_file] [-readback_file] [-logic_location_file] [-bin_file] [-reference_bitfile <arg>] [-cell <arg>] [-no_partial_bitfile] [-quiet] <file>
			this.Entry(_builder.write_bitstream(file, force, verbose, raw_bitfile, no_binary_bitfile, mask_file, readback_file, logic_location_file, bin_file, reference_bitfile, cell, no_partial_bitfile, quiet));
			return this;
		}
		/// <summary>
		/// <para>
		/// Write a bmm file<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_bmm [-force] [-quiet] [-verbose] &lt;file&gt;
		/// <br/>
		/// <para>
		/// The Block RAM Memory Map (BMM) file is a text file that describes how individual block RAMs<br/>
		/// on an FPGA are grouped together into a contiguous address space called an Address Block.<br/>
		/// The write_bmm command exports BMM information from the current design to the specified<br/>
		/// file. For implemented designs the BMM file will be include placement information. The<br/>
		/// data2mem command uses the BMM file as input to direct the translation of programming data<br/>
		/// into the proper form for use in simulation, device programming, or software development in SDK.<br/>
		/// The command returns the name of the output file, or an error.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1829<br/>
		/// </para>
		/// </summary>
		/// <param name="file">
		/// <para>
		/// (Required)<br/>
		/// Design bmm file Values: A filename with alphanumeric<br/>
		/// characters and .bmm extension.<br/>
		/// </para>
		/// </param>
		/// <param name="force">(Optional) Overwrite existing BMM file.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The name of the bmm file</returns>
		public VivadoTCL write_bmm(String file, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_bmm [-force] [-quiet] [-verbose] <file>
			this.Entry(_builder.write_bmm(file, force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Generate a design specific post-configuration BSDL file (.bsd).<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_bsdl [-force] [-bsd &lt;arg&gt;] [-quiet] [-verbose] &lt;file&gt;
		/// <br/>
		/// <para>
		/// Generate a Boundary Scan Description Language (BSDL) file (.bsd) for the current design that<br/>
		/// reflects the post-configuration boundary scan architecture of the target device.<br/>
		/// The boundary scan architecture for the device is changed when the device is configured because<br/>
		/// certain connections between the boundary scan registers and pad may change. These changes<br/>
		/// must be communicated to the boundary scan tester through a post-configuration BSDL file.<br/>
		/// Refer to the Vivado Design Suite User Guide: Programming and Debugging (UG908) for more<br/>
		/// information on the available configuration modes.<br/>
		/// The write_bsdl command reads a pre-configuration BSDL file for the target part from the<br/>
		/// Vivado Design Suite installation area, and combines that with post-configuration data from the<br/>
		/// current design.<br/>
		/// This command returns the name of the output BSDL file, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1831<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) Output file name. The .bsd extension is optional.</param>
		/// <param name="force">(Optional) Overwrite existing .bsd file</param>
		/// <param name="bsd">(Optional) Specify an updated generic BSDL file.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>name of the output file</returns>
		public VivadoTCL write_bsdl(String file, bool? force = null, String bsd = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_bsdl [-force] [-bsd <arg>] [-quiet] [-verbose] <file>
			this.Entry(_builder.write_bsdl(file, force, bsd, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Create file(s) for programming flash memory.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_cfgmem [-force] -format &lt;arg&gt; -size &lt;arg&gt; [-interface &lt;arg&gt;] [-checksum] [-disablebitswap] [-loadbit &lt;arg&gt;] [-loaddata &lt;arg&gt;] [-quiet] [-verbose] &lt;file&gt;
		/// <br/>
		/// <para>
		/// This command formats a design specific configuration bitstream (.bit) file, and any specified<br/>
		/// data files, into a specified memory configuration file format to program into a flash memory<br/>
		/// device using the program_hw_cfgmem command. Supported memory configuration file formats<br/>
		/// are MCS, BIN, and HEX.<br/>
		/// TIP: When you generate a cfgmem file with write_cfgmem , by default the bits within a byte are bit-swapped, or mirrored, compared to bytes in the original input bitstream. You can disable bitswap using the<br/>
		/// -disablebitswap option as described below.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The process whereby the design specific data is loaded or programmed into the Xilinx® FPGA is<br/>
		/// called configuration. The create_hw_cfgmem command defines a flash memory device used<br/>
		/// for configuring and booting the hardware device.<br/>
		/// After the hw_cfgmem object is created, and associated with the hw_device, the configuration<br/>
		/// memory can be programmed with the bitstream and other data from a memory configuration file<br/>
		/// created with the write_cfgmem command. The hw_cfgmem object is programmed using the<br/>
		/// program_hw_cfgmem command.<br/>
		/// The write_cfgmem -loadbit command loads one or more specified bitstream files into the<br/>
		/// memory configuration file, filling the available memory of the device in an upward or downward<br/>
		/// direction from a specified starting address. You can also add data files to the memory<br/>
		/// configuration file, by specifying the starting address to load the file with -loaddata.<br/>
		/// TIP: When using -loadbit and -loaddata to fill the memory of the device, you must exercise care to<br/>
		/// insure that the bitstream and data files fit into the available memory and do not overwrite each other. Any<br/>
		/// data collisions will cause the write_cfgmem command to fail with an error.<br/>
		/// The write_cfgmem command returns a transcript of its process when successful, or returns an<br/>
		/// error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1833<br/>
		/// </para>
		/// </summary>
		/// <param name="format">(Required) Format of the file to generate</param>
		/// <param name="size">(Required) Size of memory that is being targeted in M Bytes (must be power of 2).</param>
		/// <param name="file">(Required) The name of the file to generate</param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="interface">(Optional) Interface used to program device. Default: SMAPx8</param>
		/// <param name="checksum">
		/// <para>
		/// (Optional)<br/>
		/// Calculate a 32-bit checksum for each file. Memory will be<br/>
		/// filed with value of 0xFF unless a different byte value is<br/>
		/// specified. Default: 0xFF<br/>
		/// </para>
		/// </param>
		/// <param name="disablebitswap">(Optional) Disable bit swapping in a byte for bitfiles.</param>
		/// <param name="loadbit">(Optional) Load bit files into memory from given address.</param>
		/// <param name="loaddata">(Optional) Load data into memory from given address.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL write_cfgmem(String format, String size, String file, bool? force = null, String @interface = null, bool? checksum = null, bool? disablebitswap = null, String loadbit = null, String loaddata = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_cfgmem [-force] -format <arg> -size <arg> [-interface <arg>] [-checksum] [-disablebitswap] [-loadbit <arg>] [-loaddata <arg>] [-quiet] [-verbose] <file>
			this.Entry(_builder.write_cfgmem(format, size, file, force, @interface, checksum, disablebitswap, loadbit, loaddata, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Write a checkpoint of the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_checkpoint [-force] [-cell &lt;arg&gt;] [-logic_function_stripped] [-encrypt] [-key &lt;arg&gt;] [-incremental_synth] [-quiet] [-verbose] [&lt;file&gt;]
		/// <br/>
		/// <para>
		/// Saves the design at any point in the design process so that you can quickly import it back into the<br/>
		/// tool as needed. A design checkpoint (DCP) can contain the netlist, the constraints, and any<br/>
		/// placement and routing information from the implemented design.<br/>
		/// TIP: In the Project mode, a DCP will not have timing constraints after synthesis. The timing constraints are<br/>
		/// annotated against the design during open_run or link_design commands, or when launching an<br/>
		/// implementation run. To create a DCP with timing constraints, create the design checkpoint after<br/>
		/// opt_design, or after the implementation run completes.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Use the read_checkpoint command to import a checkpoint file.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates the specified checkpoint file, overwriting a file of the same name<br/>
		/// if one already exists:<br/>
		/// write_checkpoint C:/Data/checkpoint1 -force<br/>
		/// Note: The tool will add the .dcp extension to the specified file name, and will overwrite an existing<br/>
		/// checkpoint1.dcp file.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1837<br/>
		/// </para>
		/// </summary>
		/// <param name="file">
		/// <para>
		/// (Required)<br/>
		/// Design checkpoint file Values: A filename with alphanumeric<br/>
		/// characters and .dcp extension.<br/>
		/// </para>
		/// </param>
		/// <param name="force">(Optional) Overwrite existing checkpoint file</param>
		/// <param name="cell">(Optional) Write a checkpoint of this cell</param>
		/// <param name="logic_function_stripped">
		/// <para>
		/// (Optional)<br/>
		/// Convert INIT strings on LUTs &amp; RAMBs to fixed values. Note<br/>
		/// that the resulting netlist will be nonfunctional.<br/>
		/// </para>
		/// </param>
		/// <param name="encrypt">(Optional) Encrypt unprotected modules using IEEE 1735 IP security version 2</param>
		/// <param name="key">
		/// <para>
		/// (Optional)<br/>
		/// Key file to be used with -encrypt option; Otherwise, use<br/>
		/// Xilinx public key<br/>
		/// </para>
		/// </param>
		/// <param name="incremental_synth">(Optional) export synthesis archive file to be used for re-using implementation.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The name of the checkpoint file</returns>
		public VivadoTCL write_checkpoint(String file, bool? force = null, String cell = null, bool? logic_function_stripped = null, bool? encrypt = null, String key = null, bool? incremental_synth = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_checkpoint [-force] [-cell <arg>] [-logic_function_stripped] [-encrypt] [-key <arg>] [-incremental_synth] [-quiet] [-verbose] [<file>]
			this.Entry(_builder.write_checkpoint(file, force, cell, logic_function_stripped, encrypt, key, incremental_synth, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Export package pin and port placement information<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_csv [-force] [-quiet] [-verbose] &lt;file&gt;
		/// <br/>
		/// <para>
		/// Writes package pin and port placement information into a comma separated value (CSV) file.<br/>
		/// The specific format and requirements of the CSV file are described in the Vivado Design Suite User<br/>
		/// Guide: I/O and Clock Planning (UG899).<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example exports a CSV file from the current project:<br/>
		/// write_csv C:/Data/pinList.csv<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1840<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) Pin Planning CSV file</param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>name of the output file</returns>
		public VivadoTCL write_csv(String file, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_csv [-force] [-quiet] [-verbose] <file>
			this.Entry(_builder.write_csv(file, force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Write debug probes to a file<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_debug_probes [-cell &lt;arg&gt;] [-no_partial_ltxfile] [-force] [-quiet] [-verbose] &lt;file&gt;
		/// <br/>
		/// <para>
		/// Writes a Vivado Design Suite logic analyzer probes file containing ILA debug cores and signal<br/>
		/// probes added to the current design. The debug probes data file typically has a .ltx file<br/>
		/// extension.<br/>
		/// ILA cores are added to the design using the create_debug_core command. ILA probes are<br/>
		/// added to the design using the create_debug_port command, and connected to nets in your<br/>
		/// design using the connect_debug_port command.<br/>
		/// The specific information and use of the debug probes file is described in the Vivado Design Suite<br/>
		/// User Guide: Vivado Programming and Debugging (UG908).<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example write a debug probe file from the current design:<br/>
		/// write_debug_probes C:/Data/designProbes.ltx<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1842<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) Debug probes file name (default extension is .ltx)</param>
		/// <param name="cell">(Optional) Hierarchical name of the Reconfigurable Partition Cell</param>
		/// <param name="no_partial_ltxfile">(Optional) Do not generate partial LTX files</param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>name of the output file</returns>
		public VivadoTCL write_debug_probes(String file, String cell = null, bool? no_partial_ltxfile = null, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_debug_probes [-cell <arg>] [-no_partial_ltxfile] [-force] [-quiet] [-verbose] <file>
			this.Entry(_builder.write_debug_probes(file, cell, no_partial_ltxfile, force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Write programmable device image<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_device_image [-force] [-verbose] [-raw_partitions] [-mask_file] [-logic_location_file] [-cell &lt;arg&gt;] [-no_pdi] [-no_partial_pdifile] [-quiet] &lt;file&gt;
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1844<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) The name of the .rcfi and .rnpi files to generate</param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="verbose">(Optional) Print write_device_image options</param>
		/// <param name="raw_partitions">(Optional) Write raw CFI and NPI partition files (.rcfi and .rnpi)</param>
		/// <param name="mask_file">(Optional) Write mask file (.msk_cfi)</param>
		/// <param name="logic_location_file">(Optional) Write logic location file (.ll)</param>
		/// <param name="cell">(Optional) Create only partial device image for named cell</param>
		/// <param name="no_pdi">(Optional) Do not generate pdi file</param>
		/// <param name="no_partial_pdifile">(Optional) Do not write partial pdi files for a Dynamic Function eXchange design</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		public VivadoTCL write_device_image(String file, bool? force = null, bool? verbose = null, bool? raw_partitions = null, bool? mask_file = null, bool? logic_location_file = null, String cell = null, bool? no_pdi = null, bool? no_partial_pdifile = null, bool? quiet = null)
		{
			// TCL Syntax: write_device_image [-force] [-verbose] [-raw_partitions] [-mask_file] [-logic_location_file] [-cell <arg>] [-no_pdi] [-no_partial_pdifile] [-quiet] <file>
			this.Entry(_builder.write_device_image(file, force, verbose, raw_partitions, mask_file, logic_location_file, cell, no_pdi, no_partial_pdifile, quiet));
			return this;
		}
		/// <summary>
		/// <para>
		/// Export the current netlist as an EDIF file<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_edif [-pblocks &lt;args&gt;] [-cell &lt;arg&gt;] [-force] [-security_mode &lt;arg&gt;] [-logic_function_stripped] [-quiet] [-verbose] &lt;file&gt;
		/// <br/>
		/// <para>
		/// Writes the current netlist as an EDIF file, or outputs the contents of specific Pblocks or<br/>
		/// hierarchical cells as EDIF netlist files.<br/>
		/// In the case of either the -pblocks or -cell option being used, this argument specifies a<br/>
		/// directory name where the EDIF netlist files for each Pblock or cell will be written. The EDIF<br/>
		/// netlist file will be named after the Pblock or cell. If the directory specified does not exist, the tool<br/>
		/// will return an error.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example writes an EDIF netlist file for the whole design to the specified file name:<br/>
		/// write_edif C:/Data/edifOut.edn<br/>
		/// The following example outputs an EDIF netlist for all Pblocks in the design. The files will be<br/>
		/// written to the specified directory.<br/>
		/// write_edif -pblocks [get_pblocks] C:/Data/FPGA_Design/<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1845<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) Output file (directory with -pblocks or -cell)</param>
		/// <param name="pblocks">(Optional) Export netlist for these pblocks (not valid with -cell)</param>
		/// <param name="cell">(Optional) Export netlist for this cell (not valid with -pblocks)</param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="security_mode">
		/// <para>
		/// (Optional)<br/>
		/// If set to 'all', and some of design needs encryption then<br/>
		/// whole of design will be written to a single encrypted file<br/>
		/// Default: multifile<br/>
		/// </para>
		/// </param>
		/// <param name="logic_function_stripped">(Optional) Convert INIT strings on LUTs &amp; RAMBs to fixed values</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>the name of the output file or directory</returns>
		public VivadoTCL write_edif(String file, TCLParameterList pblocks = null, String cell = null, bool? force = null, String security_mode = null, bool? logic_function_stripped = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_edif [-pblocks <args>] [-cell <arg>] [-force] [-security_mode <arg>] [-logic_function_stripped] [-quiet] [-verbose] <file>
			this.Entry(_builder.write_edif(file, pblocks, cell, force, security_mode, logic_function_stripped, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Write hardware ILA data to a file<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_hw_ila_data [-force] [-csv_file] [-vcd_file] [-legacy_csv_file] [-quiet] [-verbose] &lt;file&gt; [&lt;hw_ila_data&gt;] [&lt;hw_ila_data&gt;]
		/// <br/>
		/// <para>
		/// Write the ILA debug core sample data, stored in the specified hw_ila_data object, to a binary file<br/>
		/// on the disk.<br/>
		/// A hw_ila_data object is created when the hw_ila is triggered on the hw_device, or by the<br/>
		/// upload_hw_ila_data command when moving the captured data from the physical FPGA<br/>
		/// device, hw_device.<br/>
		/// The write_hw_ila_data lets you write the data of the hw_ila_data object to a binary file on<br/>
		/// the disk for later review. You can read the ILA debug core data back into the Vivado logic<br/>
		/// analyzer using the read_hw_ila_data command, which creates a new hw_ila_data object.<br/>
		/// This command returns the name of the file written, or returns an error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1848<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) hardware ILA data file name</param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="csv_file">(Optional) Export CSV format file only</param>
		/// <param name="vcd_file">(Optional) Export VCD format file only</param>
		/// <param name="legacy_csv_file">(Optional) Export csv file without radix information.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="hw_ila_data">(Optional) hardware ILA data object Default: Current hardware ILA data</param>
		/// <returns>Name of the output file</returns>
		public VivadoTCL write_hw_ila_data(String file, bool? force = null, bool? csv_file = null, bool? vcd_file = null, bool? legacy_csv_file = null, bool? quiet = null, bool? verbose = null, String hw_ila_data = null)
		{
			// TCL Syntax: write_hw_ila_data [-force] [-csv_file] [-vcd_file] [-legacy_csv_file] [-quiet] [-verbose] <file> [<hw_ila_data>] [<hw_ila_data>]
			this.Entry(_builder.write_hw_ila_data(file, force, csv_file, vcd_file, legacy_csv_file, quiet, verbose, hw_ila_data));
			return this;
		}
		/// <summary>
		/// <para>
		/// Write the Xilinx Shell Archive for the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_hw_platform [-fixed] [-force] [-include_bit] [-include_sim_content] [-minimal] [-hw] [-hw_emu] [-quiet] [-verbose] [&lt;file&gt;]
		/// <br/>
		/// <para>
		/// Writes a Xilinx support archive (XSA) of the current design for use as a hardware platform.<br/>
		/// All platforms are dynamically implemented during compilation, meaning that the accelerator logic<br/>
		/// coming is implemented along with some or all of the logic contained in the hardware platform<br/>
		/// design. The XSA represents the required portion of the hardware platform. The hardware<br/>
		/// platform design used to create a XSA consists of a Vivado IP integrator subsystem design with all<br/>
		/// the required board interface IP cores configured and connected to the device I/Os. The Vivado<br/>
		/// project must also include several required XSA and PFM properties needed to define the XSA.<br/>
		/// This command reports the name of the XSA file written, or returns an error if it fails.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example writes the XSA for the current project, overwriting a XSA file of the same<br/>
		/// name if one exists:<br/>
		/// write_hw_platform -force C:/Data/zc702.xsa<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1851<br/>
		/// </para>
		/// </summary>
		/// <param name="file">
		/// <para>
		/// (Required)<br/>
		/// Device Support Archive file Values: A filename with<br/>
		/// alphanumeric characters and .xsa extension.<br/>
		/// </para>
		/// </param>
		/// <param name="fixed">(Optional) Write fixed Shell.</param>
		/// <param name="force">(Optional) Overwrite existing Xilinx Shell Archive file</param>
		/// <param name="include_bit">(Optional) Include bit file(s) in the Shell.</param>
		/// <param name="include_sim_content">(Optional) Include simulaton files in the Shell.</param>
		/// <param name="minimal">(Optional) Add only minimal files in the Shell.</param>
		/// <param name="hw">(Optional) Write shell for use in hardware only.</param>
		/// <param name="hw_emu">(Optional) Write shell for use in hardware emulation only.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The name of the Shell file</returns>
		public VivadoTCL write_hw_platform(String file, bool? @fixed = null, bool? force = null, bool? include_bit = null, bool? include_sim_content = null, bool? minimal = null, bool? hw = null, bool? hw_emu = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_hw_platform [-fixed] [-force] [-include_bit] [-include_sim_content] [-minimal] [-hw] [-hw_emu] [-quiet] [-verbose] [<file>]
			this.Entry(_builder.write_hw_platform(file, @fixed, force, include_bit, include_sim_content, minimal, hw, hw_emu, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Write the unified JSON metadata file for the current design<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_hw_platform_metadata [-quiet] [-verbose] [&lt;file&gt;]
		/// <br/>
		/// <para>
		/// Writes a JSON metadata file for the platform represented by the current design.<br/>
		/// This command returns the name of the JSON file written, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example writes the JSON file for the current project:<br/>
		/// write_hw_platform_metadata C:/Data/zc102_platform.json<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1853<br/>
		/// </para>
		/// </summary>
		/// <param name="file">
		/// <para>
		/// (Required)<br/>
		/// Unified JSON metadata file Values: A filename with<br/>
		/// alphanumeric characters and .json extension.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The name of the unified JSON metadata file</returns>
		public VivadoTCL write_hw_platform_metadata(String file, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_hw_platform_metadata [-quiet] [-verbose] [<file>]
			this.Entry(_builder.write_hw_platform_metadata(file, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Write scan data to a file.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_hw_sio_scan [-force] [-quiet] [-verbose] &lt;file&gt; &lt;hw_sio_scan&gt;
		/// <br/>
		/// <para>
		/// Write the populated hw_sio_scan object after run_hw_sio_scan completes.<br/>
		/// To analyze the margin of a given link, it is often helpful to run a scan of the link using the<br/>
		/// specialized Eye Scan hardware of Xilinx UltraScale devices or 7 series FPGAs. The Vivado serial<br/>
		/// I/O analyzer feature lets you to create, run, and save link scans.<br/>
		/// This command saves the scan to disk after completing the scan run. The format of the file is a<br/>
		/// CSV file of values observed while running the scan.<br/>
		/// This command returns the filename of the file output, or returns an error if the command fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1855<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) hardware SIO_scan file name</param>
		/// <param name="hw_sio_scan">(Required) hardware SIO scan data object</param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Name of the output file</returns>
		public VivadoTCL write_hw_sio_scan(String file, String hw_sio_scan, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_hw_sio_scan [-force] [-quiet] [-verbose] <file> <hw_sio_scan>
			this.Entry(_builder.write_hw_sio_scan(file, hw_sio_scan, force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Write sweep data to a directory.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_hw_sio_sweep [-force] [-quiet] [-verbose] &lt;directory&gt; &lt;hw_sio_sweep&gt;
		/// <br/>
		/// <para>
		/// Write the populated hw_sio_sweep object after run_hw_sio_sweep completes.<br/>
		/// To analyze the margin of a given link, it is often helpful to run a scan of the link using the<br/>
		/// specialized features of Xilinx UltraScale devices or 7 series FPGAs. It can also be helpful to run<br/>
		/// multiple scans on a the link with different configuration settings for the GTs. This can help you<br/>
		/// determine which settings are best for your design. The Vivado serial I/O analyzer feature enables<br/>
		/// you to define, run, and save link sweeps, or collections of link scans run across a range of values.<br/>
		/// This command saves the specified link sweep object to disk after it has been populated by the<br/>
		/// run_hw_sio_sweep command.<br/>
		/// This command returns the name of the directory created, or returns an error if the command<br/>
		/// fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1857<br/>
		/// </para>
		/// </summary>
		/// <param name="directory">(Required) hardware SIO_sweep directory path</param>
		/// <param name="hw_sio_sweep">(Required) hardware SIO sweep data object</param>
		/// <param name="force">(Optional) Overwrite existing directory</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Name of the output directory</returns>
		public VivadoTCL write_hw_sio_sweep(String directory, String hw_sio_sweep, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_hw_sio_sweep [-force] [-quiet] [-verbose] <directory> <hw_sio_sweep>
			this.Entry(_builder.write_hw_sio_sweep(directory, hw_sio_sweep, force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Generate SVF file for current_hw_target<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_hw_svf [-force] [-quiet] [-verbose] &lt;file_name&gt;
		/// <br/>
		/// <para>
		/// The Vivado hardware manager supports programming of hardware devices through the use of<br/>
		/// Serial Vector Format (SVF) files. SVF files are ASCII files that contain both programming<br/>
		/// instructions and configuration data. These files are used by ATE machines and embedded<br/>
		/// controllers to perform boundary-scan operations. The SVF file captures the JTAG commands<br/>
		/// needed to program the bitstream directly into a Xilinx device, or indirectly into a flash memory<br/>
		/// device. The SVF file can be written using the write_hw_svf command, or applied to an open<br/>
		/// hw_target through the execute_hw_svf command. Refer to the Vivado Design Suite User Guide:<br/>
		/// Programming and Debugging (UG908) for more information.<br/>
		/// The specific process for creating the hw_svf file is:<br/>
		/// 1. Create an SVF target using create_hw_target.<br/>
		/// 2. Open the SVF target.<br/>
		/// 3. Create one or more devices on the SVF target using create_hw_device.<br/>
		/// 4. Program the devices using commands like program_hw_devices.<br/>
		/// 5. Write the SVF file of operation commands using write_hw_svf.<br/>
		/// In programming the hw_devices in Step 4 above, the SVF commands for the operations are<br/>
		/// cached to a temporary file. The write_hw_svf command saves the cache by giving it a file<br/>
		/// name and moving it to the specified file path.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Note: Because this command is essentially flushing the cached SVF commands, after you use the<br/>
		/// write_hw_svf command, the cache is cleared, and restarted to capture any new device commands.<br/>
		/// This command returns a message indicating success, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example writes an SVF file to specified location:<br/>
		/// program_hw_devices [lindex [get_hw_devices] 0]<br/>
		/// write_hw_svf C:/Data/k7_design.svf<br/>
		/// This example demonstrates the correct order of creating multiple devices on an SVF target. An<br/>
		/// SVF target is created and opened, then a Xilinx device, a user part, and a second Xilinx device are<br/>
		/// created on the current target. The bitstream properties are defined for the two Xilinx devices, the<br/>
		/// devices are programmed, and an SVF file is written:<br/>
		/// open_hw<br/>
		/// connect_hw_server<br/>
		/// create_hw_target my_svf_target<br/>
		/// open_hw_target<br/>
		/// create_hw_device -part xc7k325t<br/>
		/// create_hw_device -idcode 01234567 -irlength 8 -mask ffffffff -part<br/>
		/// userPart1<br/>
		/// create_hw_device -part xcku9p<br/>
		/// set_property PROGRAM.FILE {C:/Data/k7_design.bit} [lindex [get_hw_devices]<br/>
		/// 0]<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// set_property PROGRAM.FILE {C:/Data/ku_design.bit} [lindex [get_hw_devices]<br/>
		/// 2]<br/>
		/// program_hw_devices [lindex [get_hw_devices] 0]<br/>
		/// program_hw_devices [lindex [get_hw_devices] 2]<br/>
		/// write_hw_svf C:/Data/myDesign.svf<br/>
		/// The following example demonstrates creating a device on an SVF target, creating a configuration<br/>
		/// memory object (hw_cfgmem) associated with that device, programming the device and<br/>
		/// configuration memory, and saving that command sequence to an SVF file:<br/>
		/// create_hw_target my_svf_target<br/>
		/// open_hw_target<br/>
		/// set device [create_hw_device -part xc7k325t]<br/>
		/// set_property PROGRAM.FILE {C:/Data/k7_design.bit} $device<br/>
		/// create_hw_cfgmem -hw_device $device -mem_dev [lindex \<br/>
		/// [get_cfgmem_parts {28f00am29ew-bpi-x16}] 0]<br/>
		/// set cfgMem [current_hw_cfgmem]<br/>
		/// set_property PROGRAM.ADDRESS_RANGE {use_file} $cfgMem<br/>
		/// set_property PROGRAM.BLANK_CHECK 0 $cfgMem<br/>
		/// set_property PROGRAM.BPI_RS_PINS {none} $cfgMem<br/>
		/// set_property PROGRAM.CFG_PROGRAM 1 $cfgMem<br/>
		/// set_property PROGRAM.CHECKSUM 0 $cfgMem<br/>
		/// set_property PROGRAM.ERASE 1 $cfgMem<br/>
		/// set_property PROGRAM.UNUSED_PIN_TERMINATION {pull-none} $cfgMem<br/>
		/// set_property PROGRAM.VERIFY 1 $cfgMem<br/>
		/// set_property PROGRAM.FILES [list {C:/data/flash.mcs} ] $cfgMem<br/>
		/// create_hw_bitstream -hw_device $device [get_property \<br/>
		/// PROGRAM.HW_CFGMEM_BITFILE $device]<br/>
		/// program_hw_devices $device<br/>
		/// program_hw_cfgmem -hw_cfgmem $cfgMem<br/>
		/// write_hw_svf C:/Data/myDesign.svf<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1859<br/>
		/// </para>
		/// </summary>
		/// <param name="file_name">(Required) SVF filename</param>
		/// <param name="force">(Optional) overwrite svf file if it exists</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL write_hw_svf(String file_name, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_hw_svf [-force] [-quiet] [-verbose] <file_name>
			this.Entry(_builder.write_hw_svf(file_name, force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Writes hardware definition for use in the software development<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_hwdef [-force] [-quiet] [-verbose] &lt;file&gt;
		/// <br/>
		/// <para>
		/// Writes a hardware definition (.hwdef) file for use in the software development tools (SDK).<br/>
		/// Each BD and HIP generates a .hwdef file. Write_hwdef merges all the files into a single<br/>
		/// container. This command is run automatically by the Vivado Design Suite when generating the<br/>
		/// output products for a top-level design that includes a block design with an embedded processor<br/>
		/// like MicroBlaze, or Zynq-7000 SoC. Block designs are created in the IP integrator of the Vivado<br/>
		/// Design Suite with the create_bd_design command.<br/>
		/// The write_hwdef command is run after place_design and creates a hardware container file<br/>
		/// with .hwdef extension. The container file includes device metadata and hardware design files.<br/>
		/// The write_hwdef command returns nothing if successful, or an error if the command fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example creates the specified hardware definition file:<br/>
		/// write_hwdef -force C:/Data/ug940/lab1/zynq_design.hdf<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1862<br/>
		/// </para>
		/// </summary>
		/// <param name="file">
		/// <para>
		/// (Required)<br/>
		/// Hardware definition file (Values: A filename with<br/>
		/// alphanumeric characters and .hwdef extention.)<br/>
		/// </para>
		/// </param>
		/// <param name="force">(Optional) Overwrites the existing hardware definition file</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>success/failure status of applied action.</returns>
		public VivadoTCL write_hwdef(String file, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_hwdef [-force] [-quiet] [-verbose] <file>
			this.Entry(_builder.write_hwdef(file, force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Write IBIS models for current floorplan<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_ibis [-force] [-allmodels] [-nopin] [-no_pin_mapping] [-truncate &lt;arg&gt;] [-component_name &lt;arg&gt;] [-ibs &lt;arg&gt;] [-pkg &lt;arg&gt;] [-quiet] [-verbose] &lt;file&gt;
		/// <br/>
		/// <para>
		/// Writes the IBIS models for the target device in the current design. The netlist and<br/>
		/// implementation details from the design are combined with the per-pin parasitic package<br/>
		/// information to create a custom IBIS model for the design.<br/>
		/// Because the write_ibis command incorporates design information into the IBIS Model, you<br/>
		/// must have an RTL, Netlist, or Implemented Design open when running this command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example exports all buffer models for the target device, eliminates truncation of<br/>
		/// signal names, and specifies the file name and path to write:<br/>
		/// write_ibis -allmodels -truncate 0 C:/Data/FPGA_Design/ibisOut.txt<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1864<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) Output file name. The .ibs extension is optional.</param>
		/// <param name="force">(Optional) Overwrite existing .ibs file</param>
		/// <param name="allmodels">
		/// <para>
		/// (Optional)<br/>
		/// Include all available buffer models for this architecture. By<br/>
		/// default, only buffer models used by the floorplan are<br/>
		/// included.<br/>
		/// </para>
		/// </param>
		/// <param name="nopin">
		/// <para>
		/// (Optional)<br/>
		/// Disable inclusion of the per-pin modeling of the package<br/>
		/// (path from the die pad to the package pin). Package is<br/>
		/// reduced to a single RLC transmission line model applied to<br/>
		/// all pins and defined in the [Package] section. Default: This<br/>
		/// option is not set. IBISWriter includes per-pin modeling of<br/>
		/// the package as RLC matrices in the [Define Package Model]<br/>
		/// section if this data is available.<br/>
		/// </para>
		/// </param>
		/// <param name="no_pin_mapping">
		/// <para>
		/// (Optional)<br/>
		/// Do not output the [Pin Mapping] section for ultrascale,<br/>
		/// ultrascale plus, and versal.<br/>
		/// </para>
		/// </param>
		/// <param name="truncate">
		/// <para>
		/// (Optional)<br/>
		/// Maximum length for a signal name in the output file. Names<br/>
		/// longer than this will be truncated. This property can be set<br/>
		/// to truncate signal name length to 20, 40, or 0 (unlimited).<br/>
		/// Default: Truncate signal name length to 40 characters in<br/>
		/// accordance with the IBIS version 4.2 specification. Default:<br/>
		/// 40<br/>
		/// </para>
		/// </param>
		/// <param name="component_name">
		/// <para>
		/// (Optional)<br/>
		/// Specify a new component name for use in multiple FPGA<br/>
		/// designs to replace the default.<br/>
		/// </para>
		/// </param>
		/// <param name="ibs">(Optional) Specify an updated generic IBIS models file.</param>
		/// <param name="pkg">(Optional) Specify an updated per pin parasitic package data file.</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>name of the output file</returns>
		public VivadoTCL write_ibis(String file, bool? force = null, bool? allmodels = null, bool? nopin = null, bool? no_pin_mapping = null, String truncate = null, String component_name = null, String ibs = null, String pkg = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_ibis [-force] [-allmodels] [-nopin] [-no_pin_mapping] [-truncate <arg>] [-component_name <arg>] [-ibs <arg>] [-pkg <arg>] [-quiet] [-verbose] <file>
			this.Entry(_builder.write_ibis(file, force, allmodels, nopin, no_pin_mapping, truncate, component_name, ibs, pkg, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Write file with inferred xdc timing constraints<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_inferred_xdc [-force] [-all] [-append] [-async_clocks] [-all_async_reg] [-clock_groups] [-clocks] [-excl_clocks] [-exceptions] [-io_constraints] [-merge_existing_constraints] [-name &lt;arg&gt;] [-quiet] [-verbose] [&lt;file&gt;]
		/// <br/>
		/// <para>
		/// You can use the write_inferred_xdc to find constraints that should be defined in the open<br/>
		/// synthesized or implemented design. Write timing constraints that are automatically generated by<br/>
		/// the Vivado timing engine, rather than defined in an existing XDC file and added to the design.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Run write_inferred_xdc -clocks first to define suggested clock and generated clock<br/>
		/// constraints. The suggested clock constraints will be defined with a period of 1 ns. You can edit<br/>
		/// the recommended constraints to create clocks and generated clocks with the required clock<br/>
		/// period to meet the needs of your design.<br/>
		/// You can add the edited constraints file into the design using read_xdc, or add_files, and<br/>
		/// update_timing.<br/>
		/// You may need to run the write_inferred_xdc command multiple times, using various<br/>
		/// options like -clock_groups or -async_clocks, to capture all inferred timing constraints<br/>
		/// from the fully clocked design. You can use an iterative process of writing and sourcing the<br/>
		/// inferred clocked constraints, and then writing and sourcing additional constraint files to capture<br/>
		/// all inferred constraints. See the example below for more information.<br/>
		/// This command returns a transcript of the process when successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example writes the inferred clock constraints in the current design:<br/>
		/// write_inferred_xdc -clocks C:/Data/design1_inferred_clocks.xdc<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The write_inferred_xdc command may need to be run multiple times to capture all the<br/>
		/// inferred constraints, as is shown in this example:<br/>
		/// write_inferred_xdc -clocks clocks.xdc<br/>
		/// source clocks.xdc<br/>
		/// write_inferred_xdc -all all.xdc<br/>
		/// source all.xdc<br/>
		/// write_inferred_xdc -async_clocks async.xdc<br/>
		/// source async.xdc<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1867<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) Filename to write constraints into</param>
		/// <param name="force">(Optional) Overwrite existing file.</param>
		/// <param name="all">
		/// <para>
		/// (Optional)<br/>
		/// Generate all constraints except missing clocks which are<br/>
		/// generated with the -clocks option<br/>
		/// </para>
		/// </param>
		/// <param name="append">(Optional) Append the constraints to file, don't overwrite the constraints file</param>
		/// <param name="async_clocks">(Optional) Find asynchronous clock groups</param>
		/// <param name="all_async_reg">
		/// <para>
		/// (Optional)<br/>
		/// Find the missing ASYNC_REG property for safe and unsafe<br/>
		/// Clock Domain Crossing<br/>
		/// </para>
		/// </param>
		/// <param name="clock_groups">
		/// <para>
		/// (Optional)<br/>
		/// Find asynchronous and exclusive clock groups, equivalent to<br/>
		/// options -async_clocks -excl_clocks<br/>
		/// </para>
		/// </param>
		/// <param name="clocks">(Optional) Find missing clock definitions</param>
		/// <param name="excl_clocks">(Optional) Find logically and physically exclusive clock groups</param>
		/// <param name="exceptions">(Optional) Find missing exceptions</param>
		/// <param name="io_constraints">(Optional) Find missing input and output delays</param>
		/// <param name="merge_existing_constraints">(Optional) Add existing user defined constraints to the generated constraints</param>
		/// <param name="name">
		/// <para>
		/// (Optional)<br/>
		/// Start constraints wizard in a GUI panel with this name. Do<br/>
		/// other command options can be combined with -name.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL write_inferred_xdc(String file, bool? force = null, bool? all = null, bool? append = null, bool? async_clocks = null, bool? all_async_reg = null, bool? clock_groups = null, bool? clocks = null, bool? excl_clocks = null, bool? exceptions = null, bool? io_constraints = null, bool? merge_existing_constraints = null, String name = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_inferred_xdc [-force] [-all] [-append] [-async_clocks] [-all_async_reg] [-clock_groups] [-clocks] [-excl_clocks] [-exceptions] [-io_constraints] [-merge_existing_constraints] [-name <arg>] [-quiet] [-verbose] [<file>]
			this.Entry(_builder.write_inferred_xdc(file, force, all, append, async_clocks, all_async_reg, clock_groups, clocks, excl_clocks, exceptions, io_constraints, merge_existing_constraints, name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Write a tcl script on disk that will recreate a given IP.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_ip_tcl [-force] [-no_ip_version] [-ip_name &lt;arg&gt;] [-show_defaults] [-multiple_files] [-quiet] [-verbose] [&lt;objects&gt;] [&lt;tcl_filename&gt;...]
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1871<br/>
		/// </para>
		/// </summary>
		/// <param name="force">(Optional) Flag to overwrite existing file.</param>
		/// <param name="no_ip_version">
		/// <para>
		/// (Optional)<br/>
		/// Flag to not include the IP version in the IP VLNV in create_ip<br/>
		/// commands. NOTE - this may have implications if there are<br/>
		/// major IP version changes.<br/>
		/// </para>
		/// </param>
		/// <param name="ip_name">
		/// <para>
		/// (Optional)<br/>
		/// Set the name of the IP. This argument is not supported for<br/>
		/// multiple IP.<br/>
		/// </para>
		/// </param>
		/// <param name="show_defaults">(Optional) Add a comment containing the default parameter values of the IP.</param>
		/// <param name="multiple_files">(Optional) Flag to create a .tcl file for each IP supplied as an argument</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <param name="objects">
		/// <para>
		/// (Optional)<br/>
		/// IP(s) to be written to disk Values: IP instance(s) as returned<br/>
		/// by 'get_ips &lt;instance name&gt;'<br/>
		/// </para>
		/// </param>
		/// <param name="tcl_filename">
		/// <para>
		/// (Optional)<br/>
		/// File path to the exported tcl file. If the path is a directory and<br/>
		/// multiple IP are given as an argument, a file for each IP will<br/>
		/// be created. Default: ./<br/>
		/// </para>
		/// </param>
		/// <returns>IP TCL file</returns>
		public VivadoTCL write_ip_tcl(bool? force = null, bool? no_ip_version = null, String ip_name = null, bool? show_defaults = null, bool? multiple_files = null, bool? quiet = null, bool? verbose = null, String objects = null, TCLParameterList tcl_filename = null)
		{
			// TCL Syntax: write_ip_tcl [-force] [-no_ip_version] [-ip_name <arg>] [-show_defaults] [-multiple_files] [-quiet] [-verbose] [<objects>] [<tcl_filename>...]
			this.Entry(_builder.write_ip_tcl(force, no_ip_version, ip_name, show_defaults, multiple_files, quiet, verbose, objects, tcl_filename));
			return this;
		}
		/// <summary>
		/// <para>
		/// Write iPhysOpt script.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_iphys_opt_tcl [-place] [-binary] [-quiet] [-verbose] [&lt;output&gt;]
		/// <br/>
		/// <para>
		/// Because physical optimization requires timing data that is only available after placement, the<br/>
		/// phys_opt_design command cannot be run prior to placement. However, the interactive<br/>
		/// physical optimization feature, or iphys_opt_design, lets you write out the physical<br/>
		/// optimizations performed on the post-placed design, and then apply those optimizations to the<br/>
		/// design netlist prior to placement. Refer to the Vivado Design Suite User Guide: Implementation<br/>
		/// (UG904) for more information on interactive physical optimization.<br/>
		/// Interactive physical optimization can be used in two ways:<br/>
		/// • Applying post-placement physical optimizations to the pre-placement netlist to improve the<br/>
		/// overall placement result and improve design performance.<br/>
		/// • Saving the physical optimizations in a Tcl script to be repeated as needed.<br/>
		/// The write_iphys_opt_tcl command can only be run after placement, on a design that has<br/>
		/// had actual physical optimizations performed.<br/>
		/// TIP: You can use the report_phys_opt command to report the physical optimizations that have been<br/>
		/// performed on the design.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The output is a Tcl script file with a sequence of iphys_opt_design commands listing the<br/>
		/// specific optimizations performed by the phys_opt_design command. The iphys_opt Tcl<br/>
		/// script can be edited to change the specific optimizations performed. The Tcl script provides a<br/>
		/// history of the physical optimizations performed on the design after placement, marked by date<br/>
		/// and history.<br/>
		/// IMPORTANT! The iphys_opt Tcl script contains the specific optimizations performed by the<br/>
		/// phys_opt_design command, but does not include placement and routing changes or results.<br/>
		/// This command returns nothing if successful, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example writes the physical optimizations that have been performed in the current<br/>
		/// design to the specified Tcl script:<br/>
		/// write_iphys_opt_tcl C:/Data/myDesign_physopt.tcl<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1872<br/>
		/// </para>
		/// </summary>
		/// <param name="output">(Required) tcl file containing iPhysOpt script</param>
		/// <param name="place">(Optional) write out placement information</param>
		/// <param name="binary">(Optional) write out in binary format</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL write_iphys_opt_tcl(String output, bool? place = null, bool? binary = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_iphys_opt_tcl [-place] [-binary] [-quiet] [-verbose] [<output>]
			this.Entry(_builder.write_iphys_opt_tcl(output, place, binary, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Write the Memory Map Info of the design to a .mmi file.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_mem_info [-cell &lt;arg&gt;] [-no_partial_mmi] [-force_detect_xpm] [-force] [-quiet] [-verbose] &lt;file&gt;
		/// <br/>
		/// <para>
		/// This command writes a memory information (MMI) file defining the BRAM placement and<br/>
		/// address ranges to create a memory map of the design.<br/>
		/// IMPORTANT! write_mem_info requires an open implemented design so that the memory<br/>
		/// information includes the BRAM placement data, as well as the address ranges, required for proper<br/>
		/// programming.<br/>
		/// The memory map information (MMI) file, written by the write_mem_info command, is a text<br/>
		/// file that describes how individual Block RAMs on the Xilinx device are grouped together to form<br/>
		/// a contiguous address space called an Address Block.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The mem info file (MMI) contains memory mapping information similar to the Block Memory<br/>
		/// Map (BMM) file, but in a format that can be read by the updatemem command to merge with a<br/>
		/// bitstream (BIT) file. The updatemem command uses the MMI file to identify the physical BRAM<br/>
		/// resource that maps to a specific address range. Refer to the Vivado Design Suite User Guide:<br/>
		/// Embedded Processor Hardware Design (UG898) for more information on running updatemem.<br/>
		/// This command returns the name of the file created, or returns an error if it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1874<br/>
		/// </para>
		/// </summary>
		/// <param name="file">
		/// <para>
		/// (Required)<br/>
		/// Design mem info file Values: A filename with alphanumeric<br/>
		/// characters and .mmi extension.<br/>
		/// </para>
		/// </param>
		/// <param name="cell">(Optional) Create only partial .mmi for named cell</param>
		/// <param name="no_partial_mmi">(Optional) Do not write partial bit files for a Dynamic Function eXchange design</param>
		/// <param name="force_detect_xpm">(Optional) Traverse netlist and check for XPM</param>
		/// <param name="force">(Optional) Overwrite existing mem info xml file</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>The name of the .mmi file</returns>
		public VivadoTCL write_mem_info(String file, String cell = null, bool? no_partial_mmi = null, bool? force_detect_xpm = null, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_mem_info [-cell <arg>] [-no_partial_mmi] [-force_detect_xpm] [-force] [-quiet] [-verbose] <file>
			this.Entry(_builder.write_mem_info(file, cell, no_partial_mmi, force_detect_xpm, force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Save peripheral component to the disk.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_peripheral [-quiet] [-verbose] &lt;peripheral&gt;
		/// <br/>
		/// <para>
		/// Write the specified AXI peripheral object to disk in the form of the component.xml file. The<br/>
		/// peripheral is written to the repository location specified by the create_peripheral<br/>
		/// command, under the name specified at creation.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1876<br/>
		/// </para>
		/// </summary>
		/// <param name="peripheral">(Required) Peripheral object</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL write_peripheral(String peripheral, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_peripheral [-quiet] [-verbose] <peripheral>
			this.Entry(_builder.write_peripheral(peripheral, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// (User-written application) Export Tcl script for re-creating the current project<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_project_tcl [-paths_relative_to &lt;arg&gt;] [-origin_dir_override &lt;arg&gt;] [-target_proj_dir &lt;arg&gt;] [-force] [-all_properties] [-no_copy_sources] [-no_ip_version] [-absolute_path] [-dump_project_info] [-use_bd_files] [-internal] [-validate] [-quiet] [-verbose] &lt;file&gt;
		/// <br/>
		/// <para>
		/// Creates a Tcl script to recreate the current project.<br/>
		/// The generated script will contain the Tcl commands for creating the project, setting the project<br/>
		/// type, creating filesets, adding/importing source files, defining runs and run properties.<br/>
		/// IMPORTANT! The new project will be created in the current working directory (CWD) where the<br/>
		/// generated Tcl script is sourced from. The script written out by write_project_tcl should be sourced<br/>
		/// in the same directory from which it was created. If you source the script from a different directory, you<br/>
		/// should first set the &lt;origin_dir_loc&gt; variable in Tcl shell to this alternate directory, or edit the script to<br/>
		/// define the &lt;origin_dir&gt; variable in the script in order to maintain the relative path between the CWD and<br/>
		/// the source files referenced in the script.<br/>
		/// This Tcl project script and the various design sources can be stored in a version control system<br/>
		/// for source file management and project archival.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example exports Tcl script named recreate.tcl for the current project:<br/>
		/// write_project_tcl recreate.tcl<br/>
		/// The following example exports a Tcl script named recreate.tcl for the current project in<br/>
		/// the ./script directory and specifies the /tmp/test directory for the create_project<br/>
		/// command. When the recreate.tcl script is run in the Vivado Tcl shell, the project will be re-created in /tmp/test directory:<br/>
		/// write_project_tcl -target_proj_dir "/tmp/test" ./script/recreate.tcl<br/>
		/// The following command exports Tcl script for the current project and writes all the properties,<br/>
		/// both default or non-default values:<br/>
		/// write_project_tcl -all_properties recreate.tcl<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following command exports Tcl script for the current project and adds files that are local in<br/>
		/// this project. The recreated project will reference these files:<br/>
		/// write_project_tcl -no_copy_sources -use_bd_files recreate.tcl<br/>
		/// IMPORTANT! The -use_bd_files switch is required for use with -no_copy_sources in designs<br/>
		/// with block diagrams.<br/>
		/// The following command exports recreate.tcl script for the current project in the current<br/>
		/// working directory, creates a new project in ./my_test directory, prints the list of files in the<br/>
		/// new project, prints the current project settings and then closes the newly created project:<br/>
		/// open_project ./test/test.xpr<br/>
		/// write_project_tcl -force recreate.tcl<br/>
		/// close_project<br/>
		/// file mkdir my_test<br/>
		/// cd my_test<br/>
		/// source ../recreate.tcl<br/>
		/// get_files -of_objects [get_filesets sources_1]<br/>
		/// report_property [current_project]<br/>
		/// close_project<br/>
		/// The following command creates a new project named bft_test, adds files to the project, sets the<br/>
		/// fileset property, exports a tcl script named bft.tcl in the current working directory, creates a<br/>
		/// new project in ./my_bft directory, prints the list of files in the new project (test_1.v and<br/>
		/// test_2.v), prints the "verilog_define" property value and then closes the newly created project:<br/>
		/// create_project bft_test ./bft_test<br/>
		/// add_files test_1.v<br/>
		/// add_files test_2.v<br/>
		/// set_property verilog_define {a=10} [get_filesets sources_1]<br/>
		/// write_project_tcl -force bft.tcl<br/>
		/// close_project<br/>
		/// file mkdir my_bft<br/>
		/// cd my_bft<br/>
		/// source ../bft.tcl<br/>
		/// get_files -of_objects [get_filesets sources_1]<br/>
		/// get_property verilog_define [get_filesets sources_1]<br/>
		/// close_project<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1878<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) Name of the tcl script file to generate</param>
		/// <param name="paths_relative_to">
		/// <para>
		/// (Optional)<br/>
		/// Override the reference directory variable for source file<br/>
		/// relative paths Default: Script output directory path<br/>
		/// </para>
		/// </param>
		/// <param name="origin_dir_override">
		/// <para>
		/// (Optional)<br/>
		/// Set 'origin_dir' directory variable to the specified value<br/>
		/// (Default is value specified with the -paths_relative_to switch)<br/>
		/// Default: None<br/>
		/// </para>
		/// </param>
		/// <param name="target_proj_dir">
		/// <para>
		/// (Optional)<br/>
		/// Directory where the project needs to be restored Default:<br/>
		/// Current project directory path<br/>
		/// </para>
		/// </param>
		/// <param name="force">(Optional) Overwrite existing tcl script file</param>
		/// <param name="all_properties">(Optional) Write all properties (default &amp; non-default) for the project object(s)</param>
		/// <param name="no_copy_sources">
		/// <para>
		/// (Optional)<br/>
		/// Do not import sources even if they were local in the original<br/>
		/// project Default: 1<br/>
		/// </para>
		/// </param>
		/// <param name="no_ip_version">
		/// <para>
		/// (Optional)<br/>
		/// Flag to not include the IP version as part of the IP VLNV in<br/>
		/// create_bd_cell commands. Default: 1<br/>
		/// </para>
		/// </param>
		/// <param name="absolute_path">(Optional) Make all file paths absolute wrt the original project directory</param>
		/// <param name="dump_project_info">(Optional) Write object values</param>
		/// <param name="use_bd_files">(Optional) Use BD sources directly instead of writing out procs to create them</param>
		/// <param name="internal">(Optional) Print basic header information in the generated tcl script</param>
		/// <param name="validate">
		/// <para>
		/// (Optional)<br/>
		/// Runs a validate script before recreating the project. To test if<br/>
		/// the files and paths refrenced in the tcl file exists or not.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Execute the command quietly, returning no messages from the command.</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>true (0) if success, false (1) otherwise</returns>
		public VivadoTCL write_project_tcl(String file, String paths_relative_to = null, String origin_dir_override = null, String target_proj_dir = null, bool? force = null, bool? all_properties = null, bool? no_copy_sources = null, bool? no_ip_version = null, bool? absolute_path = null, bool? dump_project_info = null, bool? use_bd_files = null, bool? @internal = null, bool? validate = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_project_tcl [-paths_relative_to <arg>] [-origin_dir_override <arg>] [-target_proj_dir <arg>] [-force] [-all_properties] [-no_copy_sources] [-no_ip_version] [-absolute_path] [-dump_project_info] [-use_bd_files] [-internal] [-validate] [-quiet] [-verbose] <file>
			this.Entry(_builder.write_project_tcl(file, paths_relative_to, origin_dir_override, target_proj_dir, force, all_properties, no_copy_sources, no_ip_version, absolute_path, dump_project_info, use_bd_files, @internal, validate, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Write QoR Suggestions to the given file<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_qor_suggestions [-strategy_dir &lt;arg&gt;] [-tcl_output_dir &lt;arg&gt;] [-force] [-of_objects &lt;args&gt;] [-quiet] [-verbose] &lt;file&gt;
		/// <br/>
		/// <para>
		/// Write the QoR suggestions generated by the report_qor_suggestions command. You can<br/>
		/// combine the suggestions from the latest report with suggestions read into the design with<br/>
		/// read_qor_suggestions so that you can manage all suggestions in a single RQS file.<br/>
		/// To write out specific QoR suggestions, use the -of_objects option. When this is not specified,<br/>
		/// all suggestions will be written.<br/>
		/// The recommended way to manage suggestions is using RQS objects. However, it is possible to<br/>
		/// view and execute the commands using Tcl. Specifying the -tcl_output_dir option writes Tcl<br/>
		/// scripts for the automated suggestions that are property based.<br/>
		/// Implementation strategies that use machine learning to analyze the design can be generated<br/>
		/// running report_qor_suggestions. If you specify the -strategy_dir option, multiple Tcl<br/>
		/// files and one RQS file will be written for each strategy. The Tcl files aid integration into project or<br/>
		/// non project flows. The main RQS file should not be used as the suggestions are contained in the<br/>
		/// run specific files along with strategy information.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// This command returns the name of the output file created when successful, or returns an error if<br/>
		/// it fails.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example reports QoR suggestions, then writes non-strategy suggestions to the<br/>
		/// specified file.<br/>
		/// report_qor_suggestions<br/>
		/// write_qor_suggestions C:/Data/qor_results.rqs<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The following example reports QoR suggestions, then writes both strategy and non-strategy<br/>
		/// suggestions. It will create one RQS file for each strategy suggestion that exists, generating up to<br/>
		/// three by default. Into each RQS file, it writes one strategy suggestion and all non-strategy<br/>
		/// suggestions. This behavior means that for subsequent runs one RQS file per run is required.<br/>
		/// report_qor_suggestions<br/>
		/// write_qor_suggestions -strategy_dir C:/Data/strategy_dir C:/Data/<br/>
		/// qor_suggestions.rqs<br/>
		/// To make use of strategy suggestions, the directive for each implementation command<br/>
		/// (opt_design, place_design, phys_opt_design, and route_design) must be set to RQS.<br/>
		/// This can be configured automatically in project mode by sourcing the project mode Tcl script<br/>
		/// generated for each RQS file in the strategy_dir. There is also a non-project example Tcl script<br/>
		/// that demonstrates this requirement.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1883<br/>
		/// </para>
		/// </summary>
		/// <param name="file">
		/// <para>
		/// (Required)<br/>
		/// QoR suggestions file Values: A filename with alphanumeric<br/>
		/// characters and .rqs extension.<br/>
		/// </para>
		/// </param>
		/// <param name="strategy_dir">
		/// <para>
		/// (Optional)<br/>
		/// Directory to create Strategy RQS &amp; TCL files Values: If<br/>
		/// passed a directory path, for each strategy suggested one set<br/>
		/// of RQS and TCL files will be generated.<br/>
		/// </para>
		/// </param>
		/// <param name="tcl_output_dir">
		/// <para>
		/// (Optional)<br/>
		/// Directory to create TCL files Values: TCL files for the QoR<br/>
		/// suggestions will be generated in the provided directory.<br/>
		/// </para>
		/// </param>
		/// <param name="force">(Optional) Overwrite existing suggestions file</param>
		/// <param name="of_objects">(Optional) List of QoR suggestion objects</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL write_qor_suggestions(String file, String strategy_dir = null, String tcl_output_dir = null, bool? force = null, TCLParameterList of_objects = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_qor_suggestions [-strategy_dir <arg>] [-tcl_output_dir <arg>] [-force] [-of_objects <args>] [-quiet] [-verbose] <file>
			this.Entry(_builder.write_qor_suggestions(file, strategy_dir, tcl_output_dir, force, of_objects, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Export schematic<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_schematic [-force] [-format &lt;arg&gt;] [-orientation &lt;arg&gt;] [-scope &lt;arg&gt;] [-name &lt;arg&gt;] [-quiet] [-verbose] &lt;file&gt;
		/// <br/>
		/// <para>
		/// Output the currently opened, or specified Schematic window in the Vivado IDE to a file.<br/>
		/// The file can be written as a native ASCII file that can be read back into the Vivado IDE using the<br/>
		/// read_schematic command, or can be written as a PDF or SVG file for use outside of the Vivado<br/>
		/// Design Suite. This can be useful when documenting IP cores from the IP packager flow, or from<br/>
		/// the Vivado IP integrator.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1886<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) Output file</param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="format">
		/// <para>
		/// (Optional)<br/>
		/// Values: native or pdf. read_schematic can be used to view<br/>
		/// native format. Default: native<br/>
		/// </para>
		/// </param>
		/// <param name="orientation">(Optional) Values: landscape or portrait</param>
		/// <param name="scope">(Optional) Values: current_page, visible or all Default: current_page</param>
		/// <param name="name">(Optional) Schematic window title</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>name of the output file</returns>
		public VivadoTCL write_schematic(String file, bool? force = null, write_schematic_format? format = null, write_schematic_orientation? orientation = null, write_schematic_scope? scope = null, String name = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_schematic [-force] [-format <arg>] [-orientation <arg>] [-scope <arg>] [-name <arg>] [-quiet] [-verbose] <file>
			this.Entry(_builder.write_schematic(file, force, format, orientation, scope, name, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// write_sdf command generates flat sdf delay files for event simulation<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_sdf [-process_corner &lt;arg&gt;] [-cell &lt;arg&gt;] [-rename_top &lt;arg&gt;] [-force] [-mode &lt;arg&gt;] [-gzip] [-multithread &lt;arg&gt;] [-quiet] [-verbose] &lt;file&gt;
		/// <br/>
		/// <para>
		/// Writes the timing delays for cells in the design to a Standard Delay Format (SDF) file.<br/>
		/// The output SDF file can be used by the write_verilog command to create Verilog netlists for<br/>
		/// static timing analysis and timing simulation.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example writes an SDF file to the specified directory:<br/>
		/// write_sdf C:/Data/FPGA_Design/designOut.sdf<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1889<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) File name</param>
		/// <param name="process_corner">
		/// <para>
		/// (Optional)<br/>
		/// Specify process corner for which SDF delays are required;<br/>
		/// Values: slow, fast Default: slow<br/>
		/// </para>
		/// </param>
		/// <param name="cell">(Optional) Root of the design to write, e.g. des.subblk.cpu Default: whole design</param>
		/// <param name="rename_top">
		/// <para>
		/// (Optional)<br/>
		/// Replace name of top module with custom name e.g. netlist<br/>
		/// Default: new top module name<br/>
		/// </para>
		/// </param>
		/// <param name="force">(Optional) Overwrite existing SDF file</param>
		/// <param name="mode">
		/// <para>
		/// (Optional)<br/>
		/// Specify sta (Static Timing Analysis) or timesim (Timing<br/>
		/// Simulation) mode for SDF Default: timesim<br/>
		/// </para>
		/// </param>
		/// <param name="gzip">(Optional) write gzipped SDF</param>
		/// <param name="multithread">(Optional) Run in multithread mode with specified number of threads Default: -1</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL write_sdf(String file, write_sdf_process_corner? process_corner = null, String cell = null, String rename_top = null, bool? force = null, String mode = null, bool? gzip = null, Int32? multithread = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_sdf [-process_corner <arg>] [-cell <arg>] [-rename_top <arg>] [-force] [-mode <arg>] [-gzip] [-multithread <arg>] [-quiet] [-verbose] <file>
			this.Entry(_builder.write_sdf(file, process_corner, cell, rename_top, force, mode, gzip, multithread, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Export the current netlist in Verilog format<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_verilog [-cell &lt;arg&gt;] [-mode &lt;arg&gt;] [-lib] [-port_diff_buffers] [-write_all_overrides] [-keep_vcc_gnd] [-rename_top &lt;arg&gt;] [-sdf_anno &lt;arg&gt;] [-sdf_file &lt;arg&gt;] [-force] [-include_xilinx_libs] [-logic_function_stripped] [-quiet] [-verbose] &lt;file&gt;
		/// <br/>
		/// <para>
		/// Write a Verilog netlist of the current design or from a specific cell of the design to the specified<br/>
		/// file or directory. The output is a IEEE 1364-2001 compliant Verilog HDL file that contains netlist<br/>
		/// information obtained from the input design files.<br/>
		/// You can output a complete netlist of the design or specific cell, or output a port list for the<br/>
		/// design, or a Verilog netlist for simulation or static timing analysis.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example writes a Verilog simulation netlist file for the whole design to the specified<br/>
		/// file and path:<br/>
		/// write_verilog C:/Data/my_verilog.v<br/>
		/// In the following example, because the -mode timesim and -sdf_anno options are specified,<br/>
		/// the $sdf_annotate statement will be added to the Verilog netlist. However, since the -<br/>
		/// sdf_file option is not specified, the SDF file is assumed to have the same name as the Verilog<br/>
		/// output file, with an .sdf file extension:<br/>
		/// write_verilog C:/Data/my_verilog.net -mode timesim -sdf_anno true<br/>
		/// Note: The SDF filename written to the $sdf_annotate statement will be my_verilog.sdf.<br/>
		/// In the following example, the functional simulation mode is specified, the option to keep VCC<br/>
		/// and GND primitives in the output simulation netlist is enabled, and the output file is specified:<br/>
		/// write_verilog -mode funcsim -keep_vcc_gnd out.v<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1891<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) Which file to write</param>
		/// <param name="cell">(Optional) Root of the design to write, e.g. des.subblk.cpu Default: whole design</param>
		/// <param name="mode">
		/// <para>
		/// (Optional)<br/>
		/// Values: design, pin_planning, synth_stub, sta, funcsim,<br/>
		/// timesim Default: design<br/>
		/// </para>
		/// </param>
		/// <param name="lib">(Optional) Write each library into a separate file</param>
		/// <param name="port_diff_buffers">(Optional) Output differential buffers when writing in -port mode</param>
		/// <param name="write_all_overrides">
		/// <para>
		/// (Optional)<br/>
		/// Write parameter overrides on Xilinx primitives even if the<br/>
		/// override value is the same as the default value<br/>
		/// </para>
		/// </param>
		/// <param name="keep_vcc_gnd">
		/// <para>
		/// (Optional)<br/>
		/// Don't replace VCC/GND instances by literal constants on<br/>
		/// load terminals. For simulation modes only.<br/>
		/// </para>
		/// </param>
		/// <param name="rename_top">
		/// <para>
		/// (Optional)<br/>
		/// Replace top module name with custom name e.g. netlist<br/>
		/// Default: new top module name<br/>
		/// </para>
		/// </param>
		/// <param name="sdf_anno">(Optional) Specify if sdf_annotate system task statement is generated</param>
		/// <param name="sdf_file">(Optional) Full path to sdf file location Default: &lt;file&gt;.sdf</param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="include_xilinx_libs">
		/// <para>
		/// (Optional)<br/>
		/// Include simulation models directly in netlist instead of<br/>
		/// linking to library<br/>
		/// </para>
		/// </param>
		/// <param name="logic_function_stripped">
		/// <para>
		/// (Optional)<br/>
		/// Convert INIT strings on LUTs &amp; RAMBs to fixed values.<br/>
		/// Resulting netlist will not behave correctly.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>the name of the output file or directory</returns>
		public VivadoTCL write_verilog(String file, String cell = null, write_verilog_mode? mode = null, bool? lib = null, bool? port_diff_buffers = null, bool? write_all_overrides = null, bool? keep_vcc_gnd = null, String rename_top = null, String sdf_anno = null, String sdf_file = null, bool? force = null, bool? include_xilinx_libs = null, bool? logic_function_stripped = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_verilog [-cell <arg>] [-mode <arg>] [-lib] [-port_diff_buffers] [-write_all_overrides] [-keep_vcc_gnd] [-rename_top <arg>] [-sdf_anno <arg>] [-sdf_file <arg>] [-force] [-include_xilinx_libs] [-logic_function_stripped] [-quiet] [-verbose] <file>
			this.Entry(_builder.write_verilog(file, cell, mode, lib, port_diff_buffers, write_all_overrides, keep_vcc_gnd, rename_top, sdf_anno, sdf_file, force, include_xilinx_libs, logic_function_stripped, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Export the current netlist in VHDL format<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_vhdl [-cell &lt;arg&gt;] [-mode &lt;arg&gt;] [-lib] [-port_diff_buffers] [-write_all_overrides] [-keep_vcc_gnd] [-rename_top &lt;arg&gt;] [-arch_only] [-force] [-include_xilinx_libs] [-quiet] [-verbose] &lt;file&gt;
		/// <br/>
		/// <para>
		/// Write a VHDL netlist of the current design or from a specific cell of the design to the specified<br/>
		/// file or directory.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// The output of this command is a VHDL IEEE 1076.4 VITAL-2000 compliant VHDL file that<br/>
		/// contains netlist information obtained from the input design files. You can output a complete<br/>
		/// netlist of the design or specific cell, or output a port list for the design.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example writes a VHDL simulation netlist file for the whole design to the specified<br/>
		/// file and path:<br/>
		/// write_vhdl C:/Data/bft_top.vhd<br/>
		/// In the following example the entity definition of the top-level module is not output to the VHDL<br/>
		/// netlist:<br/>
		/// write_vhdl C:/Data/vhdl_arch_only.vhd -arch_only<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1895<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) Which file to write</param>
		/// <param name="cell">(Optional) Root of the design to write, e.g. des.subblk.cpu Default: whole design</param>
		/// <param name="mode">
		/// <para>
		/// (Optional)<br/>
		/// Output mode. Valid values: funcsim, pin_planning,<br/>
		/// synth_stub Default: funcsim<br/>
		/// </para>
		/// </param>
		/// <param name="lib">(Optional) Write each library into a separate file</param>
		/// <param name="port_diff_buffers">(Optional) Output differential buffers when writing in -port mode</param>
		/// <param name="write_all_overrides">
		/// <para>
		/// (Optional)<br/>
		/// Write parameter overrides on Xilinx primitives even if the<br/>
		/// same as the default value<br/>
		/// </para>
		/// </param>
		/// <param name="keep_vcc_gnd">
		/// <para>
		/// (Optional)<br/>
		/// Don't replace VCC/GND instances by literal constants on<br/>
		/// load terminals. For simulation modes only.<br/>
		/// </para>
		/// </param>
		/// <param name="rename_top">
		/// <para>
		/// (Optional)<br/>
		/// Replace top module name with custom name e.g. netlist<br/>
		/// Default: new top module name<br/>
		/// </para>
		/// </param>
		/// <param name="arch_only">
		/// <para>
		/// (Optional)<br/>
		/// Write only the architecture, not the entity declaration for the<br/>
		/// top cell<br/>
		/// </para>
		/// </param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="include_xilinx_libs">
		/// <para>
		/// (Optional)<br/>
		/// Include simulation models directly in netlist instead of<br/>
		/// linking to library<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>the name of the output file or directory</returns>
		public VivadoTCL write_vhdl(String file, String cell = null, String mode = null, bool? lib = null, bool? port_diff_buffers = null, bool? write_all_overrides = null, bool? keep_vcc_gnd = null, String rename_top = null, bool? arch_only = null, bool? force = null, bool? include_xilinx_libs = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_vhdl [-cell <arg>] [-mode <arg>] [-lib] [-port_diff_buffers] [-write_all_overrides] [-keep_vcc_gnd] [-rename_top <arg>] [-arch_only] [-force] [-include_xilinx_libs] [-quiet] [-verbose] <file>
			this.Entry(_builder.write_vhdl(file, cell, mode, lib, port_diff_buffers, write_all_overrides, keep_vcc_gnd, rename_top, arch_only, force, include_xilinx_libs, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Write out one or more DRC/METHODOLOGY/CDC message waivers in command form<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_waivers [-type &lt;arg&gt;] [-objects &lt;args&gt;] [-return_string] [-force] [-quiet] [-verbose] [&lt;file&gt;]
		/// <br/>
		/// <para>
		/// To save waivers from one design session to the next, you must use write_waivers to create<br/>
		/// an XDC file of the waiver commands, and read_xdc to read those waivers back into the design<br/>
		/// when it is reopened.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// This example writes all waivers in the current design:<br/>
		/// write_waivers C:/Data/design_waivers.xdc<br/>
		/// The following example writes only DRC type waivers:<br/>
		/// write_waivers -type DRC C:/Data/drc_waivers.xdc<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1898<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) Name of file to write waivers</param>
		/// <param name="type">(Optional) Type of waiver(s) - ALL, DRC, METHODOLOGY, CDC to write</param>
		/// <param name="objects">(Optional) List of DRC/METHODOLOGY/CDC waiver objects to be written</param>
		/// <param name="return_string">(Optional) Return report results as a string object</param>
		/// <param name="force">(Optional) Overwrite existing file</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL write_waivers(String file, String type = null, TCLParameterList objects = null, bool? return_string = null, bool? force = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_waivers [-type <arg>] [-objects <args>] [-return_string] [-force] [-quiet] [-verbose] [<file>]
			this.Entry(_builder.write_waivers(file, type, objects, return_string, force, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Writes constraints to a Xilinx Design Constraints (XDC) file. The default file extension for a XDC<br/>
		/// file is .xdc.<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: write_xdc [-no_fixed_only] [-constraints &lt;arg&gt;] [-cell &lt;arg&gt;] [-sdc] [-no_tool_comments] [-force] [-exclude_timing] [-exclude_physical] [-add_netlist_placement] [-logic_function_stripped] [-type &lt;args&gt;] [-write_id] [-quiet] [-verbose] [&lt;file&gt;]
		/// <br/>
		/// <para>
		/// Writes constraints to a Xilinx® Design Constraints file (XDC). The XDC can be exported from the<br/>
		/// top-level, which is the default, or from a specific hierarchical cell.<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// IMPORTANT! The write_xdc command writes the constraints to the specified file in the same order<br/>
		/// they are added to or executed in the design.<br/>
		/// The write_xdc command lets you write invalid XDC constraints so that you can quickly report<br/>
		/// constraints that have been ignored by the Vivado Design Suite due to a problem with the way<br/>
		/// the constraint is written or applied. This is useful for debugging constraint files applied in specific<br/>
		/// designs.<br/>
		/// This command can be used to create an XDC file from a design with UCF files. All constraints<br/>
		/// from the active constraint fileset will be exported to the XDC, even if they come from multiple<br/>
		/// files.<br/>
		/// TIP: The write_xdc command will not convert all UCF constraints into XDC format, and is not intended<br/>
		/// to automatically convert UCF based designs to XDC. Refer to the Vivado Design Suite Migration<br/>
		/// Methodology Guide (UG911) for more information on migrating UCF constraints to XDC.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example writes the valid and invalid constraints, including both fixed and unfixed<br/>
		/// cells, to the specified file:<br/>
		/// write_xdc -no_fixed_only -constraints all C:/Data/design.xdc<br/>
		/// This example writes only the invalid constraints, including both fixed and unfixed cells, to the<br/>
		/// specified file:<br/>
		/// write_xdc -constraints invalid C:/Data/bad_constraints.xdc<br/>
		/// The following example writes the physical constraints only, including any placement constraints<br/>
		/// defined in any netlist source files:<br/>
		/// write_xdc -exclude_timing -add_netlist_placement C:/Data/physical.xdc<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1900<br/>
		/// </para>
		/// </summary>
		/// <param name="file">(Required) Output constraints to the specified XDC file.</param>
		/// <param name="no_fixed_only">
		/// <para>
		/// (Optional)<br/>
		/// Export fixed and non-fixed placement (by default only fixed<br/>
		/// placement is exported)<br/>
		/// </para>
		/// </param>
		/// <param name="constraints">
		/// <para>
		/// (Optional)<br/>
		/// Include constraints that are flagged invalid Values: valid,<br/>
		/// invalid, all Default: valid<br/>
		/// </para>
		/// </param>
		/// <param name="cell">(Optional) Hierarchical cell for which constraints are exported.</param>
		/// <param name="sdc">(Optional) Export all timing constriants in SDC compatible format.</param>
		/// <param name="no_tool_comments">
		/// <para>
		/// (Optional)<br/>
		/// Don't write verbose tool generated comments to the xdc<br/>
		/// when translating from ucf.<br/>
		/// </para>
		/// </param>
		/// <param name="force">(Optional) Overwrite existing file.</param>
		/// <param name="exclude_timing">(Optional) Don't export timing constraints.</param>
		/// <param name="exclude_physical">(Optional) Don't export physical constraints.</param>
		/// <param name="add_netlist_placement">(Optional) Export netlist placement constraints.</param>
		/// <param name="logic_function_stripped">
		/// <para>
		/// (Optional)<br/>
		/// Write disable_timing constraints which are associated with<br/>
		/// having previously run write_edif with its -<br/>
		/// logic_function_stripped option.<br/>
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// (Optional)<br/>
		/// Types of constraint to export. Values: timing, io, misc, waiver<br/>
		/// and physical. If not specified, all constraints will be<br/>
		/// exported.<br/>
		/// </para>
		/// </param>
		/// <param name="write_id">(Optional) Write position number for timing constraints</param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		public VivadoTCL write_xdc(String file, bool? no_fixed_only = null, write_xdc_constraints? constraints = null, String cell = null, bool? sdc = null, bool? no_tool_comments = null, bool? force = null, bool? exclude_timing = null, bool? exclude_physical = null, bool? add_netlist_placement = null, bool? logic_function_stripped = null, TCLParameterList type = null, bool? write_id = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: write_xdc [-no_fixed_only] [-constraints <arg>] [-cell <arg>] [-sdc] [-no_tool_comments] [-force] [-exclude_timing] [-exclude_physical] [-add_netlist_placement] [-logic_function_stripped] [-type <args>] [-write_id] [-quiet] [-verbose] [<file>]
			this.Entry(_builder.write_xdc(file, no_fixed_only, constraints, cell, sdc, no_tool_comments, force, exclude_timing, exclude_physical, add_netlist_placement, logic_function_stripped, type, write_id, quiet, verbose));
			return this;
		}
		/// <summary>
		/// <para>
		/// Load a simulation snapshot for simulation and return a simulation object<br/>
		/// </para>
		/// <br/>
		/// <br/>
		/// TCL Syntax: xsim [-view &lt;args&gt;] [-autoloadwcfg] [-runall] [-R] [-maxdeltaid &lt;arg&gt;] [-nolog] [-maxlogsize &lt;arg&gt;] [-onfinish &lt;arg&gt;] [-onerror &lt;arg&gt;] [-tclbatch &lt;args&gt;] [-t &lt;args&gt;] [-testplusarg &lt;args&gt;] [-vcdfile &lt;arg&gt;] [-vcdunit &lt;arg&gt;] [-wdb &lt;arg&gt;] [-tp] [-tl] [-nosignalhandlers] [-ieeewarnings] [-stats] [-scNoLogFile] [-sv_seed &lt;arg&gt;] [-protoinst &lt;args&gt;] [-cov_db_dir &lt;arg&gt;] [-cov_db_name &lt;arg&gt;] [-ignore_assertions] [-ignore_coverage] [-downgrade_error2info] [-downgrade_error2warning] [-downgrade_fatal2info] [-downgrade_fatal2warning] [-ignore_feature &lt;args&gt;] [-downgrade_severity &lt;args&gt;] [-quiet] [-verbose] &lt;snapshot&gt;
		/// <br/>
		/// <para>
		/// The xsim command loads a simulation snapshot to run a batch mode simulation, or to provide a<br/>
		/// GUI and/or Tcl-based interactive simulation environment. The snapshot must be generated using<br/>
		/// the xelab command.<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// The following example launches xsim on the specified simulation snapshot:<br/>
		/// xsim C:/Data/project_xsim/project_xsim.sim/sim_1/behav/testbench_behav<br/>
		/// </para>
		/// <br/>
		/// <para>
		/// See ug835-vivado-tcl-commands.pdf, page 1903<br/>
		/// </para>
		/// </summary>
		/// <param name="snapshot">(Required) The name of design snapshot or WDB file</param>
		/// <param name="view">
		/// <para>
		/// (Optional)<br/>
		/// Open a wave configuration file. This switch may be repeated<br/>
		/// to open multiple files.<br/>
		/// </para>
		/// </param>
		/// <param name="autoloadwcfg">
		/// <para>
		/// (Optional)<br/>
		/// For a WDB file named &lt;name&gt;.wdb, automatically open all<br/>
		/// WCFG files named &lt;name&gt;#.wcfg. Ignored if -view is<br/>
		/// present.<br/>
		/// </para>
		/// </param>
		/// <param name="runall">(Optional) Run simulation until completion, then quit (does 'run -all; exit')</param>
		/// <param name="R">(Optional) Run simulation until completion, then quit (does 'run -all; exit')</param>
		/// <param name="maxdeltaid">
		/// <para>
		/// (Optional)<br/>
		/// Specify the maximum delta number. Will report error if it<br/>
		/// exceeds maximum simulation loops at the same time<br/>
		/// Default: 10000<br/>
		/// </para>
		/// </param>
		/// <param name="nolog">(Optional) Ignored (for compatibility with xsim command-line tool)</param>
		/// <param name="maxlogsize">
		/// <para>
		/// (Optional)<br/>
		/// Set the maximum size a log file can reach in MB. The default<br/>
		/// setting is unlimited Default: -1<br/>
		/// </para>
		/// </param>
		/// <param name="onfinish">(Optional) Specify behavior at end of simulation: quit|stop Default: stop</param>
		/// <param name="onerror">
		/// <para>
		/// (Optional)<br/>
		/// Specify behavior upon simulation run-time error: quit|stop<br/>
		/// Default: stop<br/>
		/// </para>
		/// </param>
		/// <param name="tclbatch">(Optional) Specify the TCL file for batch mode execution</param>
		/// <param name="t">(Optional) Specify the TCL file for batch mode execution</param>
		/// <param name="testplusarg">
		/// <para>
		/// (Optional)<br/>
		/// Specify plusargs to be used by $test$plusargs and $value<br/>
		/// $plusargs system functions<br/>
		/// </para>
		/// </param>
		/// <param name="vcdfile">
		/// <para>
		/// (Optional)<br/>
		/// Specify the vcd output file<br/>
		/// UG835 (v2020.2) November 18, 2020 www.xilinx.com<br/>
		/// Name Description<br/>
		/// </para>
		/// </param>
		/// <param name="vcdunit">
		/// <para>
		/// (Optional)<br/>
		/// Specify the vcd output unit. Default is the same as the<br/>
		/// engine precision unit<br/>
		/// </para>
		/// </param>
		/// <param name="wdb">(Optional) Specify the waveform database output file</param>
		/// <param name="tp">(Optional) Enable printing of hierarchical names of process being executed</param>
		/// <param name="tl">
		/// <para>
		/// (Optional)<br/>
		/// Enable printing of file name and line number of statements<br/>
		/// being executed.<br/>
		/// </para>
		/// </param>
		/// <param name="nosignalhandlers">(Optional) Run with no signal handlers to avoid conflict with security software</param>
		/// <param name="ieeewarnings">(Optional) Enable warnings from VHDL IEEE functions</param>
		/// <param name="stats">(Optional) Display memory and cpu stats upon exiting</param>
		/// <param name="scNoLogFile">(Optional) Keep the SystemC output separate from XSim output</param>
		/// <param name="sv_seed">(Optional) Seed for constraint random stimulus Default: 1</param>
		/// <param name="protoinst">(Optional) Specify a .protoinst file for protocol analysis</param>
		/// <param name="cov_db_dir">
		/// <para>
		/// (Optional)<br/>
		/// System Verilog Coverage Run Directory. The coverage data<br/>
		/// will be present under &lt;cov_db_dir&gt;/xsim.covdb/<br/>
		/// &lt;cov_db_name&gt; directory.Default is ./ or inherits value set in<br/>
		/// similar xelab option.<br/>
		/// </para>
		/// </param>
		/// <param name="cov_db_name">
		/// <para>
		/// (Optional)<br/>
		/// System Verilog Coverage Run Name. The coverage data will<br/>
		/// be present under &lt;cov_db_dir&gt;/xsim.covdb/&lt;cov_db_name&gt;<br/>
		/// directory.Default is snapshot name or inherits value set in<br/>
		/// similar xelab option.<br/>
		/// </para>
		/// </param>
		/// <param name="ignore_assertions">(Optional) Ignore System Verilog concurrent assertion constructs at runtime.</param>
		/// <param name="ignore_coverage">(Optional) Ignore System Verilog Functional Coverage at runtime.</param>
		/// <param name="downgrade_error2info">(Optional) Downgrade System verilog message severity from error to info level.</param>
		/// <param name="downgrade_error2warning">(Optional) Downgrade System verilog message severity from error to warning level.</param>
		/// <param name="downgrade_fatal2info">(Optional) Downgrade System verilog message severity from fatal to info level.</param>
		/// <param name="downgrade_fatal2warning">(Optional) Downgrade System verilog message severity from fatal to warning level.</param>
		/// <param name="ignore_feature">
		/// <para>
		/// (Optional)<br/>
		/// Specify System Verilog feature to be ignored at runtime.<br/>
		/// Choices are: assertion : Ignore concurrent assertions.<br/>
		/// </para>
		/// </param>
		/// <param name="downgrade_severity">
		/// <para>
		/// (Optional)<br/>
		/// Downgrade severity level of System Verilog HDL<br/>
		/// messages.Choices are: error2warning|error2info|<br/>
		/// fatal2warning|fatal2info.<br/>
		/// </para>
		/// </param>
		/// <param name="quiet">(Optional) Ignore command errors</param>
		/// <param name="verbose">(Optional) Suspend message limits during command execution</param>
		/// <returns>Current simulation object</returns>
		public VivadoTCL xsim(String snapshot, TCLParameterList view = null, bool? autoloadwcfg = null, bool? runall = null, bool? R = null, String maxdeltaid = null, bool? nolog = null, String maxlogsize = null, String onfinish = null, String onerror = null, TCLParameterList tclbatch = null, TCLParameterList t = null, TCLParameterList testplusarg = null, String vcdfile = null, String vcdunit = null, String wdb = null, bool? tp = null, bool? tl = null, bool? nosignalhandlers = null, bool? ieeewarnings = null, bool? stats = null, bool? scNoLogFile = null, String sv_seed = null, TCLParameterList protoinst = null, String cov_db_dir = null, String cov_db_name = null, bool? ignore_assertions = null, bool? ignore_coverage = null, bool? downgrade_error2info = null, bool? downgrade_error2warning = null, bool? downgrade_fatal2info = null, bool? downgrade_fatal2warning = null, TCLParameterList ignore_feature = null, TCLParameterList downgrade_severity = null, bool? quiet = null, bool? verbose = null)
		{
			// TCL Syntax: xsim [-view <args>] [-autoloadwcfg] [-runall] [-R] [-maxdeltaid <arg>] [-nolog] [-maxlogsize <arg>] [-onfinish <arg>] [-onerror <arg>] [-tclbatch <args>] [-t <args>] [-testplusarg <args>] [-vcdfile <arg>] [-vcdunit <arg>] [-wdb <arg>] [-tp] [-tl] [-nosignalhandlers] [-ieeewarnings] [-stats] [-scNoLogFile] [-sv_seed <arg>] [-protoinst <args>] [-cov_db_dir <arg>] [-cov_db_name <arg>] [-ignore_assertions] [-ignore_coverage] [-downgrade_error2info] [-downgrade_error2warning] [-downgrade_fatal2info] [-downgrade_fatal2warning] [-ignore_feature <args>] [-downgrade_severity <args>] [-quiet] [-verbose] <snapshot>
			this.Entry(_builder.xsim(snapshot, view, autoloadwcfg, runall, R, maxdeltaid, nolog, maxlogsize, onfinish, onerror, tclbatch, t, testplusarg, vcdfile, vcdunit, wdb, tp, tl, nosignalhandlers, ieeewarnings, stats, scNoLogFile, sv_seed, protoinst, cov_db_dir, cov_db_name, ignore_assertions, ignore_coverage, downgrade_error2info, downgrade_error2warning, downgrade_fatal2info, downgrade_fatal2warning, ignore_feature, downgrade_severity, quiet, verbose));
			return this;
		}
	}
}
#pragma warning restore IDE1006 // Naming Styles
